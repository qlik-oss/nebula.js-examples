/*
* @nebula.js/sn-line-chart v1.30.8
* Copyright (c) 2023 QlikTech International AB
* Released under the MIT license.
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@nebula.js/stardust')) :
  typeof define === 'function' && define.amd ? define(['@nebula.js/stardust'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global["sn-line-chart"] = factory(global.stardust));
})(this, (function (stardust) { 'use strict';

  var properties_dataPoints_labelmode_share = {
    id: "properties.dataPoints.labelmode.share",
    locale: {
      "en-US": "Share",
      "zh-TW": "佔有率",
      "zh-CN": "份额",
      "tr-TR": "Pay",
      "sv-SE": "Andel",
      "it-IT": "Percentuale",
      "es-ES": "Cuota",
      "de-DE": "Anteil",
      "pl-PL": "Udział",
      "nl-NL": "Aandeel",
      "ko-KR": "공유",
      "pt-BR": "Percentual",
      "fr-FR": "Part",
      "ja-JP": "割合",
      "ru-RU": "Доля"
    }
  };
  var Tooltip_selections_locked = {
    id: "Tooltip.selections.locked",
    locale: {
      "en-US": "Selections on this dimension are locked",
      "zh-TW": "已鎖定此維度上的選項",
      "zh-CN": "相关维度的选择已锁定",
      "tr-TR": "Bu boyuttaki seçimler kilitli",
      "sv-SE": "Urval i den här dimensionen är låsta",
      "it-IT": "Le selezioni in questa dimensione sono bloccate",
      "es-ES": "Las selecciones de esta dimensión están bloqueadas.",
      "de-DE": "Auswahlen sind für diese Dimension gesperrt",
      "pl-PL": "Selekcje dotyczące tego wymiaru są zablokowane",
      "nl-NL": "Selecties voor deze dimensie zijn vergrendeld",
      "ko-KR": "이 차원의 선택은 잠겨 있습니다.",
      "pt-BR": "Seleções estão bloqueadas nesta dimensão",
      "fr-FR": "Sélections verrouillées pour cette dimension",
      "ja-JP": "この軸での選択はロックされています",
      "ru-RU": "Выборки для данного измерения заблокированы"
    }
  };
  var Tooltip_dimensions_drilldown = {
    id: "Tooltip.dimensions.drilldown",
    locale: {
      "en-US": "Drill-down dimension",
      "zh-TW": "向下探查維度",
      "zh-CN": "下钻维度",
      "tr-TR": "Detaya inme boyutu",
      "sv-SE": "Hierarkisk dimension",
      "it-IT": "Dimensione di drill-down",
      "es-ES": "Dimensión jerárquica",
      "de-DE": "Drilldown-Dimension:",
      "pl-PL": "Wymiar hierarchiczny",
      "nl-NL": "Drill-downdimensie",
      "ko-KR": "드릴다운 차원",
      "pt-BR": "Dimensão da hierarquia",
      "fr-FR": "Descendre dans la hiérarchie de la dimension",
      "ja-JP": "軸のドリルダウン",
      "ru-RU": "Измерение с детализацией"
    }
  };
  var Object_ErrorMessage_MissingDimension = {
    id: "Object.ErrorMessage.MissingDimension",
    locale: {
      "en-US": "Dimension not found",
      "zh-TW": "找不到維度",
      "zh-CN": "未找到维度",
      "tr-TR": "Boyut bulunamadı",
      "sv-SE": "Dimensionen hittades inte",
      "it-IT": "Dimensione non trovata",
      "es-ES": "No se ha encontrado la dimensión",
      "de-DE": "Dimension nicht gefunden",
      "pl-PL": "Wymiar nie został znaleziony",
      "nl-NL": "Dimensie niet gevonden",
      "ko-KR": "차원을 찾지 못했습니다.",
      "pt-BR": "Dimensão não encontrada",
      "fr-FR": "Dimension introuvable",
      "ja-JP": "軸が見つかりません",
      "ru-RU": "Измерение не найдено"
    }
  };
  var Object_ErrorMessage_MissingMeasure = {
    id: "Object.ErrorMessage.MissingMeasure",
    locale: {
      "en-US": "Measure not found",
      "zh-TW": "找不到量值",
      "zh-CN": "未找到度量",
      "tr-TR": "Hesaplama bulunamadı",
      "sv-SE": "Måttet hittades inte",
      "it-IT": "Misura non trovata",
      "es-ES": "No se ha encontrado la medida",
      "de-DE": "Kennzahl nicht gefunden",
      "pl-PL": "Miara nie została znaleziona",
      "nl-NL": "Meting niet gevonden",
      "ko-KR": "측정값을 찾지 못했습니다.",
      "pt-BR": "Medida não encontrada",
      "fr-FR": "Mesure introuvable",
      "ja-JP": "メジャーが見つかりません",
      "ru-RU": "Мера не найдена"
    }
  };
  var Object_Disclaimer_LimitedData = {
    id: "Object.Disclaimer.LimitedData",
    locale: {
      "en-US": "Currently showing a limited data set.",
      "zh-TW": "目前顯示的是有限的資料集。",
      "zh-CN": "当前正显示有限的数据集。",
      "tr-TR": "Şu anda sınırlı bir veri kümesi gösteriliyor.",
      "sv-SE": "Just nu visas en begränsad uppsättning data.",
      "it-IT": "Attualmente viene visualizzata una serie di dati limitata.",
      "es-ES": "Mostrando actualmente un conjunto limitado de datos.",
      "de-DE": "Zurzeit wird nur ein beschränkter Datensatz angezeigt.",
      "pl-PL": "Aktualnie przedstawiany jest ograniczony zestaw danych.",
      "nl-NL": "Momenteel wordt een beperkte gegevensverzameling getoond.",
      "ko-KR": "현재 제한된 데이터 집합을 표시하고 있습니다.",
      "pt-BR": "Mostrando um conjunto de dados limitado.",
      "fr-FR": "Affichage d'un ensemble de données limité pour l'instant.",
      "ja-JP": "現在、限定的なデータ セットを表示しています。",
      "ru-RU": "В настоящее время отображается ограниченный набор данных."
    }
  };
  var Object_Disclaimer_OnlyNegativeOrZeroValues = {
    id: "Object.Disclaimer.OnlyNegativeOrZeroValues",
    locale: {
      "en-US": "The chart is not displayed because it contains only negative or zero values.",
      "zh-TW": "系統不會顯示圖表，因為該圖表僅包含負值或零值。",
      "zh-CN": "未显示图表，因为它仅包含负值或零值。",
      "tr-TR": "Yalnızca negatif veya sıfır değerlerini içermesi nedeniyle grafik görüntülenmiyor.",
      "sv-SE": "Diagrammet visas inte eftersom det enbart innehåller negativa eller nollvärden",
      "it-IT": "Il grafico non viene visualizzato poiché contiene solo valori negativi o uguali a zero.",
      "es-ES": "El gráfico no se muestra porque sólo contiene valores negativos o valores cero.",
      "de-DE": "Das Diagramm wird nicht angezeigt, da es nur negative oder 0-Werte enthält.",
      "pl-PL": "Wykres nie jest wyświetlany, ponieważ zawiera wartości ujemne lub zerowe.",
      "nl-NL": "De grafiek wordt niet weergegeven omdat het alleen negatieve waarden of nulwaarden bevat.",
      "ko-KR": "음수 또는 zero 값만 포함되어 있으므로 차트가 표시되지 않습니다.",
      "pt-BR": "O gráfico não foi exibido, porque contém apenas valores negativos ou zero.",
      "fr-FR": "Le graphique n'est pas affiché, car il contient uniquement des valeurs négatives ou égales à zéro.",
      "ja-JP": "チャートは負の値またはゼロ値しか含まれていないため、表示されていません。",
      "ru-RU": "Диаграмма не отображается, поскольку она содержит только отрицательные или нулевые значения."
    }
  };
  var Object_Disclaimer_NegativeOrZeroValues = {
    id: "Object.Disclaimer.NegativeOrZeroValues",
    locale: {
      "en-US": "The data set contains negative or zero values that cannot be shown in this chart.",
      "zh-TW": "資料集包含無法在此圖表中顯示的負值或零值。",
      "zh-CN": "数据集中包含无法在此图表中显示的负值或零值。",
      "tr-TR": "Veri kümesi, bu grafikte gösterilemeyen negatif veya sıfır değerlerini içeriyor.",
      "sv-SE": "Datauppsättningen innehåller negativa värden eller nollvärden som inte kan visas i detta diagram.",
      "it-IT": "La serie di dati contiene valori negativi o uguali a zero che non possono essere visualizzati in questo grafico.",
      "es-ES": "El conjunto de datos contiene valores negativos o cero que no se pueden mostrar en este gráfico.",
      "de-DE": "Die in den Datensätzen enthaltenen negativen oder 0-Werte können nicht in diesem Diagramm dargestellt werden.",
      "pl-PL": "Zestaw danych zawiera wartości ujemne lub zerowe, których nie można przedstawić w tym wykresie.",
      "nl-NL": "De gegevensverzameling bevat negatieve waarden of nulwaarden die niet kunnen worden weergegeven in deze grafiek.",
      "ko-KR": "데이터 집합에 해당 차트에 표시할 수 없는 음수 값 또는 zero 값이 포함되어 있습니다.",
      "pt-BR": "O conjunto de dados contém valores negativos ou iguais a zero que não podem ser mostrados neste gráfico.",
      "fr-FR": "L'ensemble de données contient des valeurs négatives ou égales à zéro impossibles à afficher dans ce graphique.",
      "ja-JP": "データ セットには、本チャートに表示できない負の値またはゼロ値が含まれています。",
      "ru-RU": "Набор данных содержит отрицательные или нулевые значения, которые невозможно показать в этой диаграмме."
    }
  };
  var Object_Disclaimer_DataRangeIncludingZero = {
    id: "Object.Disclaimer.DataRangeIncludingZero",
    locale: {
      "en-US": "The logarithmic scale has been replaced by a linear scale because the data range includes zero.",
      "zh-TW": "對數刻度已遭線性刻度取代，因為資料範圍包含零。",
      "zh-CN": "对数刻度已替换为线性刻度，因为该数据范围包括零。",
      "tr-TR": "Veri aralığı sıfır değerini içerdiğinden, logaritmik ölçek yerine doğrusal ölçek kullanıldı.",
      "sv-SE": "Den logaritmiska skalan har ersatts av en linjär skala eftersom dataintervallet innehåller värdet noll.",
      "it-IT": "La scala logaritmica è stata sostituita da una scala lineare perché l'intervallo di dati include zero.",
      "es-ES": "La escala logarítmica ha sido reemplazada por una escala lineal porque el rango de datos incluye cero.",
      "de-DE": "Die logarithmische Skala wurde durch die lineare Skala ersetzt, weil der Datenbereich NULL enthält.",
      "pl-PL": "Skala logarytmiczna została zastąpiona liniową, ponieważ zakres danych zawiera zero.",
      "nl-NL": "De logaritmische schaal is vervangen door een lineaire schaal omdat het gegevensbereik nullen bevat.",
      "ko-KR": "데이터 범위에 0이 포함되어 있으므로 로그 눈금이 선형 눈금으로 바뀌었습니다.",
      "pt-BR": "A escala logarítmica foi substituída por uma escala linear, pois o intervalo de dados inclui zero.",
      "fr-FR": "L'échelle logarithmique a été remplacée par une échelle linéaire, car la plage de données comprend la valeur zéro.",
      "ja-JP": "データ範囲にゼロが含まれるため、Log スケールは Linear スケールで置換されています。",
      "ru-RU": "Логарифмический масштаб заменен линейным масштабом, поскольку диапазон данных включает ноль."
    }
  };
  var Object_Disclaimer_NoDataExist = {
    id: "Object.Disclaimer.NoDataExist",
    locale: {
      "en-US": "The selections generated no data for this chart.",
      "zh-TW": "此選項無法產生任何適用於此圖表的資料。",
      "zh-CN": "选择未生成此图表的数据。",
      "tr-TR": "Seçimler bu grafik için hiç veri oluşturmadı.",
      "sv-SE": "Urvalen genererade inga data för detta diagram.",
      "it-IT": "Le selezioni non hanno generato dati per questo grafico.",
      "es-ES": "Las selecciones no han generado datos para este gráfico.",
      "de-DE": "Die Auswahlen haben für dieses Diagramm keine Daten generiert.",
      "pl-PL": "Selekcje nie spowodowały wygenerowania danych dla tego wykresu.",
      "nl-NL": "De selecties hebben geen gegevens voor de grafiek gegenereerd.",
      "ko-KR": "선택 내용으로 해당 차트에 대한 데이터가 생성되지 않았습니다.",
      "pt-BR": "As seleções não geraram dados para este gráfico.",
      "fr-FR": "Les sélections n'ont pas généré de données pour ce graphique.",
      "ja-JP": "このチャートには選択からデータが生成されませんでした。",
      "ru-RU": "В результате выборок данные для этой диаграммы не созданы."
    }
  };
  var Object_Disclaimer_OnlyNanData = {
    id: "Object.Disclaimer.OnlyNanData",
    locale: {
      "en-US": "The chart is not displayed because it contains only undefined values.",
      "zh-TW": "系統不會顯示圖表，因為該圖表僅包含未定義的值。",
      "zh-CN": "未显示图表，因为它仅包含未定义的值。",
      "tr-TR": "Yalnızca tanımsız değerleri içermesi nedeniyle grafik görüntülenmiyor.",
      "sv-SE": "Diagrammet visas inte eftersom det enbart innehåller odefinierade värden.",
      "it-IT": "Il grafico non è visualizzato poiché contiene solo valori non definiti.",
      "es-ES": "El gráfico no se muestra porque solo contiene valores indefinidos.",
      "de-DE": "Das Diagramm wird nicht angezeigt, da es nur nicht definierte Werte enthält.",
      "pl-PL": "Wykres nie jest wyświetlany, ponieważ zawiera wartości niezdefiniowane.",
      "nl-NL": "De grafiek wordt niet weergegeven omdat deze alleen ongedefinieerde waarden bevat.",
      "ko-KR": "정의되지 않은 값만 포함되어 있으므로 차트가 표시되지 않습니다.",
      "pt-BR": "O gráfico não foi exibido, porque contém apenas valores não definidos.",
      "fr-FR": "Le graphique n'est pas affiché, car il contient uniquement des valeurs non définies.",
      "ja-JP": "未定義の値しか含まれていないため、チャートは表示されていません。",
      "ru-RU": "Диаграмма не отображается, поскольку она содержит только неопределенные значения."
    }
  };
  var Object_ChartTooltip_NMore = {
    id: "Object.ChartTooltip.NMore",
    locale: {
      "en-US": "+{0} more",
      "zh-TW": "再加 {0} 個",
      "zh-CN": "+{0} 个",
      "tr-TR": "+{0} öğe daha",
      "sv-SE": "+{0} till",
      "it-IT": "Altre +{0}",
      "es-ES": "+{0} más",
      "de-DE": "+{0} mehr",
      "pl-PL": "+ {0} więcej",
      "nl-NL": "+ {0} meer",
      "ko-KR": "+추가 {0}개",
      "pt-BR": "+{0} mais",
      "fr-FR": "+ {0} de plus",
      "ja-JP": "さらに {0}",
      "ru-RU": "+ дополнительно: {0}"
    }
  };
  var Object_ChartTooltip_sumOfPositives = {
    id: "Object.ChartTooltip.sumOfPositives",
    locale: {
      "en-US": "Sum of positives",
      "zh-TW": "正數總和",
      "zh-CN": "正值总和",
      "tr-TR": "Pozitif değerlerin toplamı",
      "sv-SE": "Summan av positiva",
      "it-IT": "Somma valori positivi",
      "es-ES": "Suma de positivos",
      "de-DE": "Summe positiver Werte",
      "pl-PL": "Suma dodatnich",
      "nl-NL": "Som positieven",
      "ko-KR": "양수 합계",
      "pt-BR": "Soma de positivos",
      "fr-FR": "Sommes des valeurs positives",
      "ja-JP": "正の合計",
      "ru-RU": "Сумма положительных значений"
    }
  };
  var Object_ChartTooltip_sumOfNegatives = {
    id: "Object.ChartTooltip.sumOfNegatives",
    locale: {
      "en-US": "Sum of negatives",
      "zh-TW": "負數總和",
      "zh-CN": "负值总和",
      "tr-TR": "Negatif değerlerin toplamı",
      "sv-SE": "Summan av negativa",
      "it-IT": "Somma valori negativi",
      "es-ES": "Suma de negativos",
      "de-DE": "Summe negativer Werte",
      "pl-PL": "Suma ujemnych",
      "nl-NL": "Som negatieven",
      "ko-KR": "음수 합계",
      "pt-BR": "Soma de negativos",
      "fr-FR": "Somme des valeurs négatives",
      "ja-JP": "負の合計",
      "ru-RU": "Сумма отрицательных значений"
    }
  };
  var Object_ChartTooltip_ColorExpression = {
    id: "Object.ChartTooltip.ColorExpression",
    locale: {
      "en-US": "Color expression",
      "zh-TW": "色彩運算式",
      "zh-CN": "颜色表达式",
      "tr-TR": "Renk ifadesi",
      "sv-SE": "Färguttryck",
      "it-IT": "Espressione colore",
      "es-ES": "Expresión de color",
      "de-DE": "Farbformel",
      "pl-PL": "Wyrażenie koloru",
      "nl-NL": "Kleuruitdrukking",
      "ko-KR": "색상 표현식",
      "pt-BR": "Expressão de cor",
      "fr-FR": "Expression de couleur",
      "ja-JP": "カラー表現",
      "ru-RU": "Выражение для цвета"
    }
  };
  var Object_Disclaimer_OnlyNanColor = {
    id: "Object.Disclaimer.OnlyNanColor",
    locale: {
      "en-US": "The data used to color this visualization only contains undefined values.",
      "zh-TW": "用以定義此視覺化的色彩的資料只包含未定義的值。",
      "zh-CN": "用于将该可视化着色的数据仅包含未定义的值。",
      "tr-TR": "Bu görselleştirmeyi renklendirmek için kullanılan veriler yalnızca tanımlanmamış değerler içeriyor.",
      "sv-SE": "Data som används för att färgsätta denna visualisering innehåller enbart odefinierade värden.",
      "it-IT": "I dati utilizzati per colorare questa visualizzazione contengono solo valori non definiti.",
      "es-ES": "Los datos utilizados para colorear esta visualización solo contienen valores indefinidos.",
      "de-DE": "Die verwendeten Daten für die Farbgebung dieser Visualisierung enthalten undefinierte Werte.",
      "pl-PL": "Dane używane do kolorowania tej wizualizacji zawierają wyłącznie niezdefiniowane wartości.",
      "nl-NL": "De gegevens die worden gebruikt om deze visualisatie kleur te geven bevatten uitsluitend ongedefinieerde waarden.",
      "ko-KR": "이 시각화에 색을 지정하는 데 사용된 데이터에는 정의되지 않은 값만 포함되어 있습니다.",
      "pt-BR": "Os dados usados para colorir esse visualização contém somente valores indefinidos.",
      "fr-FR": "Les données utilisées pour colorer cette visualisation ne comportent que des valeurs non définies.",
      "ja-JP": "このビジュアライゼーションの色の割り当てに使用したデータには、未定義の値が含まれています。",
      "ru-RU": "Данные, используемые для выбора цвета визуализации, содержат только неопределенные значения."
    }
  };
  var properties_trendlines_types_average = {
    id: "properties.trendlines.types.average",
    locale: {
      "en-US": "Average",
      "zh-TW": "平均值",
      "zh-CN": "平均值",
      "tr-TR": "Ortalama",
      "sv-SE": "Medel",
      "it-IT": "Media",
      "es-ES": "Media",
      "de-DE": "Durchschnitt",
      "pl-PL": "Średnia",
      "nl-NL": "Gemiddelde",
      "ko-KR": "평균",
      "pt-BR": "Média",
      "fr-FR": "Moyenne",
      "ja-JP": "平均値",
      "ru-RU": "Среднее"
    }
  };
  var properties_trendlines_types_linear = {
    id: "properties.trendlines.types.linear",
    locale: {
      "en-US": "Linear",
      "zh-TW": "線性",
      "zh-CN": "线性",
      "tr-TR": "Doğrusal",
      "sv-SE": "Linjär",
      "it-IT": "Lineare",
      "es-ES": "Lineal",
      "de-DE": "Linear",
      "pl-PL": "Liniowa",
      "nl-NL": "Lineair",
      "ko-KR": "선형",
      "pt-BR": "Linear",
      "fr-FR": "Linéaire",
      "ja-JP": "線形",
      "ru-RU": "Линейный"
    }
  };
  var properties_trendlines_types_polynomial2 = {
    id: "properties.trendlines.types.polynomial2",
    locale: {
      "en-US": "Second degree polynomial",
      "zh-TW": "第二度多項式",
      "zh-CN": "二次多项式",
      "tr-TR": "İkinci derece polinom",
      "sv-SE": "Polynomial, andra graden",
      "it-IT": "Polinomio di secondo grado",
      "es-ES": "Polinómica de segundo grado",
      "de-DE": "Polynom zweiten Grades",
      "pl-PL": "Wielomianowa drugiego stopnia",
      "nl-NL": "Tweedegraadspolynoom",
      "ko-KR": "2차 다항식",
      "pt-BR": "Polinômio de segundo grau",
      "fr-FR": "Polynomial du 2ème degré",
      "ja-JP": "2 番目の角度の多項式近似",
      "ru-RU": "Полиномиальный второй степени"
    }
  };
  var properties_trendlines_types_polynomial3 = {
    id: "properties.trendlines.types.polynomial3",
    locale: {
      "en-US": "Third degree polynomial",
      "zh-TW": "第三度多項式",
      "zh-CN": "三次多项式",
      "tr-TR": "Üçüncü derece polinom",
      "sv-SE": "Polynomial, tredje graden",
      "it-IT": "Polinomio di terzo grado",
      "es-ES": "Polinómica de tercer grado",
      "de-DE": "Polynom dritten Grades",
      "pl-PL": "Wielomianowa trzeciego stopnia",
      "nl-NL": "Derdegraadspolynoom",
      "ko-KR": "3차 다항식",
      "pt-BR": "Polinômio de terceiro grau",
      "fr-FR": "Polynomial du 3ème degré",
      "ja-JP": "3 番目の角度の多項式近似",
      "ru-RU": "Полиномиальный третьей степени"
    }
  };
  var properties_trendlines_types_polynomial4 = {
    id: "properties.trendlines.types.polynomial4",
    locale: {
      "en-US": "Fourth degree polynomial",
      "zh-TW": "第四度多項式",
      "zh-CN": "四次多项式",
      "tr-TR": "Dördüncü derece polinom",
      "sv-SE": "Polynomial, fjärde graden",
      "it-IT": "Polinomio di quarto grado",
      "es-ES": "Polinómica de cuarto grado",
      "de-DE": "Polynom vierten Grades",
      "pl-PL": "Wielomianowa czwartego stopnia",
      "nl-NL": "Vierdegraadspolynoom",
      "ko-KR": "4차 다항식",
      "pt-BR": "Polinômio de quarto grau",
      "fr-FR": "Polynomial du 4ème degré",
      "ja-JP": "4 番目の角度の多項式近似",
      "ru-RU": "Полиномиальный четвертой степени"
    }
  };
  var properties_trendlines_types_exponential = {
    id: "properties.trendlines.types.exponential",
    locale: {
      "en-US": "Exponential",
      "zh-TW": "指數",
      "zh-CN": "指数",
      "tr-TR": "Üstel",
      "sv-SE": "Exponentiell",
      "it-IT": "Esponenziale",
      "es-ES": "Exponencial",
      "de-DE": "Exponentiell",
      "pl-PL": "Wykładnicze",
      "nl-NL": "Exponentieel",
      "ko-KR": "지수",
      "pt-BR": "Exponencial",
      "fr-FR": "Exponentiel",
      "ja-JP": "指数",
      "ru-RU": "Экспоненциальный"
    }
  };
  var properties_trendlines_types_logarithmic = {
    id: "properties.trendlines.types.logarithmic",
    locale: {
      "en-US": "Logarithmic",
      "zh-TW": "對數",
      "zh-CN": "对数",
      "tr-TR": "Logaritmik",
      "sv-SE": "Logaritmisk",
      "it-IT": "Logaritmica",
      "es-ES": "Logarítmica",
      "de-DE": "Logarithmisch",
      "pl-PL": "Logarytmiczna",
      "nl-NL": "Logaritmisch",
      "ko-KR": "로그",
      "pt-BR": "Logarítmico",
      "fr-FR": "Logarithmique",
      "ja-JP": "対数",
      "ru-RU": "Логарифмический"
    }
  };
  var properties_trendlines_types_power = {
    id: "properties.trendlines.types.power",
    locale: {
      "en-US": "Power",
      "zh-TW": "乘冪",
      "zh-CN": "幂",
      "tr-TR": "Üs",
      "sv-SE": "Potens",
      "it-IT": "Potenza",
      "es-ES": "Potencia",
      "de-DE": "Potenz",
      "pl-PL": "Potęgowa",
      "nl-NL": "Macht",
      "ko-KR": "거듭제곱",
      "pt-BR": "Potência",
      "fr-FR": "Puissance",
      "ja-JP": "累乗",
      "ru-RU": "Силовой"
    }
  };
  var Common_Measures = {
    id: "Common.Measures",
    locale: {
      "en-US": "Measures",
      "de-DE": "Kennzahlen",
      "fr-FR": "Mesures",
      "it-IT": "Misure",
      "ja-JP": "メジャー",
      "ko-KR": "측정값",
      "es-ES": "Medidas",
      "nl-NL": "Metingen",
      "pl-PL": "Miary",
      "pt-BR": "Medidas",
      "sv-SE": "Mått",
      "tr-TR": "Hesaplamalar",
      "zh-CN": "度量",
      "zh-TW": "量值",
      "ru-RU": "Меры"
    }
  };
  var Tooltip_ToggleOnLassoSelection = {
    id: "Tooltip.ToggleOnLassoSelection",
    locale: {
      "en-US": "Turn on lasso selection",
      "de-DE": "Lasso-Auswahl aktivieren",
      "fr-FR": "Activer la sélection au lasso",
      "it-IT": "Attiva selezione lazo",
      "ja-JP": "囲み選択をオンにする",
      "ko-KR": "올가미 선택 켜기",
      "es-ES": "Activar la selección de contorno",
      "nl-NL": "Lassoselectie inschakelen",
      "pl-PL": "Włącz zaznaczenie lasso",
      "pt-BR": "Ativar seleção de laço",
      "sv-SE": "Slå på lassourval",
      "tr-TR": "Serbest seçimi aç",
      "zh-CN": "开启套索选择方法",
      "zh-TW": "開啟套索選取",
      "ru-RU": "Включить выбор лассо"
    }
  };
  var Tooltip_ToggleOffLassoSelection = {
    id: "Tooltip.ToggleOffLassoSelection",
    locale: {
      "en-US": "Turn off lasso selection",
      "de-DE": "Lasso-Auswahl deaktivieren",
      "fr-FR": "Désactiver la sélection au lasso",
      "it-IT": "Disattiva selezione lazo",
      "ja-JP": "囲み選択をオフにする",
      "ko-KR": "올가미 선택 끄기",
      "es-ES": "Desactivar la selección de contorno",
      "nl-NL": "Lassoselectie uitschakelen",
      "pl-PL": "Wyłącz zaznaczenie lasso",
      "pt-BR": "Desativar seleção de laço",
      "sv-SE": "Stäng av lassourval",
      "tr-TR": "Serbest seçimi kapat",
      "zh-CN": "关闭套索选择方法",
      "zh-TW": "關閉套索選取",
      "ru-RU": "Выключить выбор лассо"
    }
  };
  var all = {
    properties_dataPoints_labelmode_share: properties_dataPoints_labelmode_share,
    Tooltip_selections_locked: Tooltip_selections_locked,
    Tooltip_dimensions_drilldown: Tooltip_dimensions_drilldown,
    Object_ErrorMessage_MissingDimension: Object_ErrorMessage_MissingDimension,
    Object_ErrorMessage_MissingMeasure: Object_ErrorMessage_MissingMeasure,
    Object_Disclaimer_LimitedData: Object_Disclaimer_LimitedData,
    Object_Disclaimer_OnlyNegativeOrZeroValues: Object_Disclaimer_OnlyNegativeOrZeroValues,
    Object_Disclaimer_NegativeOrZeroValues: Object_Disclaimer_NegativeOrZeroValues,
    Object_Disclaimer_DataRangeIncludingZero: Object_Disclaimer_DataRangeIncludingZero,
    Object_Disclaimer_NoDataExist: Object_Disclaimer_NoDataExist,
    Object_Disclaimer_OnlyNanData: Object_Disclaimer_OnlyNanData,
    Object_ChartTooltip_NMore: Object_ChartTooltip_NMore,
    Object_ChartTooltip_sumOfPositives: Object_ChartTooltip_sumOfPositives,
    Object_ChartTooltip_sumOfNegatives: Object_ChartTooltip_sumOfNegatives,
    Object_ChartTooltip_ColorExpression: Object_ChartTooltip_ColorExpression,
    Object_Disclaimer_OnlyNanColor: Object_Disclaimer_OnlyNanColor,
    properties_trendlines_types_average: properties_trendlines_types_average,
    properties_trendlines_types_linear: properties_trendlines_types_linear,
    properties_trendlines_types_polynomial2: properties_trendlines_types_polynomial2,
    properties_trendlines_types_polynomial3: properties_trendlines_types_polynomial3,
    properties_trendlines_types_polynomial4: properties_trendlines_types_polynomial4,
    properties_trendlines_types_exponential: properties_trendlines_types_exponential,
    properties_trendlines_types_logarithmic: properties_trendlines_types_logarithmic,
    properties_trendlines_types_power: properties_trendlines_types_power,
    Common_Measures: Common_Measures,
    Tooltip_ToggleOnLassoSelection: Tooltip_ToggleOnLassoSelection,
    Tooltip_ToggleOffLassoSelection: Tooltip_ToggleOffLassoSelection
  };

  function autoRegister(translator) {
    if (translator && translator.get && translator.add) {
      const t = 'Object.Disclaimer.LimitedData';
      const g = translator.get(t);
      // if translated string is different from its id
      // assume translations already exists for current locale
      if (g !== t) {
        return;
      }
      Object.keys(all).forEach(key => {
        translator.add(all[key]);
      });
    }
  }

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var hasOwn$2 = Object.prototype.hasOwnProperty;
  var toStr$2 = Object.prototype.toString;
  var defineProperty$3 = Object.defineProperty;
  var gOPD$2 = Object.getOwnPropertyDescriptor;
  var isArray$3 = function isArray(arr) {
    if (typeof Array.isArray === 'function') {
      return Array.isArray(arr);
    }
    return toStr$2.call(arr) === '[object Array]';
  };
  var isPlainObject$3 = function isPlainObject(obj) {
    if (!obj || toStr$2.call(obj) !== '[object Object]') {
      return false;
    }
    var hasOwnConstructor = hasOwn$2.call(obj, 'constructor');
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn$2.call(obj.constructor.prototype, 'isPrototypeOf');
    // Not own constructor property must be Object
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }

    // Own properties are enumerated firstly, so to speed up,
    // if last one is own, then all properties are own.
    var key;
    for (key in obj) {/**/}
    return typeof key === 'undefined' || hasOwn$2.call(obj, key);
  };

  // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
  var setProperty$3 = function setProperty(target, options) {
    if (defineProperty$3 && options.name === '__proto__') {
      defineProperty$3(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
      });
    } else {
      target[options.name] = options.newValue;
    }
  };

  // Return undefined instead of __proto__ if '__proto__' is not an own property
  var getProperty$2 = function getProperty(obj, name) {
    if (name === '__proto__') {
      if (!hasOwn$2.call(obj, name)) {
        return void 0;
      } else if (gOPD$2) {
        // In early versions of node, obj['__proto__'] is buggy when obj has
        // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
        return gOPD$2(obj, name).value;
      }
    }
    return obj[name];
  };
  var extend$6 = function extend() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;

    // Handle a deep copy situation
    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[1] || {};
      // skip the boolean and the target
      i = 2;
    }
    if (target == null || typeof target !== 'object' && typeof target !== 'function') {
      target = {};
    }
    for (; i < length; ++i) {
      options = arguments[i];
      // Only deal with non-null/undefined values
      if (options != null) {
        // Extend the base object
        for (name in options) {
          src = getProperty$2(target, name);
          copy = getProperty$2(options, name);

          // Prevent never-ending loop
          if (target !== copy) {
            // Recurse if we're merging plain objects or arrays
            if (deep && copy && (isPlainObject$3(copy) || (copyIsArray = isArray$3(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray$3(src) ? src : [];
              } else {
                clone = src && isPlainObject$3(src) ? src : {};
              }

              // Never move original objects, clone them
              setProperty$3(target, {
                name: name,
                newValue: extend(deep, clone, copy)
              });

              // Don't bring in undefined values
            } else if (typeof copy !== 'undefined') {
              setProperty$3(target, {
                name: name,
                newValue: copy
              });
            }
          }
        }
      }
    }

    // Return the modified object
    return target;
  };
  var extend$7 = /*@__PURE__*/getDefaultExportFromCjs(extend$6);

  const modesArray = [['FULL', {
    width: 550,
    height: 450
  }], ['MEDIUM', {
    width: 400,
    height: 220
  }], ['SMALL', {
    width: 300,
    height: 150
  }], ['XSMALL', {
    width: 150,
    height: 75
  }], ['SPARK', {
    width: 0,
    height: 0
  }]];
  const modesObject = {};
  modesArray.forEach(([size, {
    width,
    height
  }]) => {
    modesObject[size] = {
      width,
      height
    };
  });
  const layoutModes = {
    getLayoutModes() {
      return modesObject;
    },
    getLayoutMode(width, height) {
      let i;
      for (i = 0; i < modesArray.length; ++i) {
        if (width >= modesArray[i][1].width && height >= modesArray[i][1].height) {
          return modesArray[i][0];
        }
      }
      return 'SPARK';
    }
  };

  function dockLayout$1(layout, opts) {
    return {
      layoutModes: layoutModes.getLayoutModes(),
      center: opts.minCenterRatio !== undefined ? {
        minWidthRatio: opts.minCenterRatio,
        minHeightRatio: opts.minCenterRatio
      } : undefined,
      logicalSize: opts.logicalSize ? {
        align: 0.5,
        preserveAspectRatio: true,
        ...opts.logicalSize
      } : undefined
    };
  }

  const TIME_TAGS = ['$date', '$timestamp', '$time'];
  const TIME_FORMAT = ['D', 'TS', 'T'];
  const ERROR_CODE$1 = 7005;
  const timeUtils = {
    hasTimeTag(dimensionInfo) {
      return !!(dimensionInfo && dimensionInfo.qTags && dimensionInfo.qTags.some(tag => TIME_TAGS.some(tt => tt === tag)));
    },
    hasUnknownFormat(dimensionInfo) {
      return !!(dimensionInfo && dimensionInfo.qNumFormat && dimensionInfo.qNumFormat.qType === 'U');
    },
    hasTimeFormat(dimensionInfo) {
      return !!(dimensionInfo && dimensionInfo.qNumFormat && TIME_FORMAT.some(tt => tt === dimensionInfo.qNumFormat.qType));
    },
    isTimeDimension(isContinuous, dimensionInfo) {
      return !!(isContinuous && dimensionInfo && (timeUtils.hasTimeTag(dimensionInfo) && timeUtils.hasUnknownFormat(dimensionInfo) || timeUtils.hasTimeFormat(dimensionInfo)));
    },
    isTime(isContinuous, layout) {
      if (!layout || !layout.qHyperCube.qDimensionInfo || !layout.qHyperCube.qDimensionInfo.length) {
        return false;
      }
      return isContinuous && timeUtils.isTimeDimension(isContinuous, layout.qHyperCube.qDimensionInfo.filter(d => {
        var _d$qError;
        return ((_d$qError = d.qError) === null || _d$qError === void 0 ? void 0 : _d$qError.qErrorCode) !== ERROR_CODE$1;
      })[0]);
    },
    canBeContinuousDimension(dimensionInfo) {
      if (!dimensionInfo) {
        return false;
      }
      const tags = dimensionInfo.qTags || [];
      return !!(dimensionInfo.qContinuousAxes && tags.some(tag => tag === '$numeric'));
    },
    canBeContinuous(layout) {
      var _layout$qHyperCube, _qDimensionInfo$lengt;
      const qDimensionInfo = layout === null || layout === void 0 || (_layout$qHyperCube = layout.qHyperCube) === null || _layout$qHyperCube === void 0 || (_layout$qHyperCube = _layout$qHyperCube.qDimensionInfo) === null || _layout$qHyperCube === void 0 ? void 0 : _layout$qHyperCube.filter(d => {
        var _d$qError2;
        return ((_d$qError2 = d.qError) === null || _d$qError2 === void 0 ? void 0 : _d$qError2.qErrorCode) !== ERROR_CODE$1;
      });
      return ((_qDimensionInfo$lengt = qDimensionInfo === null || qDimensionInfo === void 0 ? void 0 : qDimensionInfo.length) !== null && _qDimensionInfo$lengt !== void 0 ? _qDimensionInfo$lengt : 0) < 1 ? false : timeUtils.canBeContinuousDimension(qDimensionInfo[0]);
    },
    maxNumberOfLines: 12
  };

  const AlphaDigit = /^[A-Z][A-z0-9_]*$/i;
  const util$2 = {
    /**
     * Sets a value in a data object using a dot notated reference to point out the path.
     *
     * Example:
     * If data is an empty object, reference is "my.value" and value the is "x", then
     * the resulting data object will be: { my: { value: "x" } }
     *
     * @param data The data object. Must be an object.
     * @param reference Reference to the value.
     * @param value Arbitrary value to set. If the value is set to undefined, the value property will be removed.
     */
    setValue: (data, reference, value) => {
      if (!reference) {
        return false;
      }
      const steps = reference.split('.');
      const dataName = steps[steps.length - 1];
      let dataContainer = data;
      let i;
      for (i = 0; i < steps.length - 1; ++i) {
        if (typeof dataContainer[steps[i]] === 'undefined') {
          dataContainer[steps[i]] = Number.isNaN(+steps[i + 1]) ? {} : [];
        }
        dataContainer = dataContainer[steps[i]];
      }
      if (typeof value !== 'undefined') {
        const previous = dataContainer[dataName];
        dataContainer[dataName] = value;
        return {
          updated: value,
          previous
        };
      }
      delete dataContainer[dataName];
      return false;
    },
    /**
     * Gets a value from a data object structure.
     *
     * @param data The data object.
     * @param reference Reference to the value.
     * @param defaultValue Default value to return if no value was found.
     * @returns {*} The default value if specified, otherwise undefined.
     */
    getValue: (data, reference, defaultValue) => {
      const steps = reference.split('.');
      let dataContainer = data;
      let i;
      if (dataContainer === undefined) {
        return defaultValue;
      }
      for (i = 0; i < steps.length; ++i) {
        if (typeof dataContainer[steps[i]] === 'undefined') {
          return defaultValue;
        }
        dataContainer = dataContainer[steps[i]];
      }
      return dataContainer;
    },
    /**
     * Move an element from position old_index to position new_index in
     * the array.
     *
     * The method was nicked from this thread on StackOverflow:
     * http://stackoverflow.com/a/5306832
     *
     * @ignore
     *
     * @param array
     * @param oldIndex
     * @param newIndex
     */
    moveArrayElement: (array, oldIndex, newIndex) => {
      if (newIndex >= array.length) {
        let k = newIndex - array.length;
        while (k-- + 1) {
          array.push(undefined);
        }
      }
      array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);
    },
    escapeField: field => {
      let newField;
      if (!field || field === ']' || AlphaDigit.test(field)) {
        newField = field;
      } else {
        newField = `[${field.replace(/\]/g, ']]')}]`;
      }
      return newField;
    },
    deleteUndefinedProperties: obj => {
      Object.keys(obj).forEach(key => {
        if (typeof obj[key] === 'undefined') {
          // eslint-disable-next-line no-param-reassign
          delete obj[key];
        }
      });
    },
    shouldUseFormat: measureInfo => !measureInfo.isCustomFormatted && (measureInfo.qIsAutoFormat || measureInfo.qNumFormat.qType === 'U')
  };

  const getDimensionInfo = layout => util$2.getValue(layout, 'qHyperCube.qDimensionInfo', []);
  const getMeasureInfo = layout => util$2.getValue(layout, 'qHyperCube.qMeasureInfo', []);
  const getBarGrouping = layout => util$2.getValue(layout, 'barGrouping.grouping');
  const isType = {
    continuous(layout, auto = false) {
      if (!timeUtils.canBeContinuous(layout)) {
        return false;
      }
      if (util$2.getValue(layout, 'dimensionAxis.continuousAuto')) {
        return typeof auto === 'function' ? auto() : auto;
      }
      return !!layout.preferContinuousAxis;
    },
    dimensionless(layout) {
      return !getDimensionInfo(layout).length;
    },
    grouped(layout) {
      return !this.dimensionless(layout) && getBarGrouping(layout) === 'grouped' && (getDimensionInfo(layout).length > 1 || getMeasureInfo(layout).length > 1) && !this.continuous(layout);
    },
    groupedByDimension(layout) {
      return this.grouped(layout) && getDimensionInfo(layout).length > 1 && getMeasureInfo(layout).length === 1;
    },
    groupedByMeasure(layout) {
      return this.grouped(layout) && getDimensionInfo(layout).length === 1 && getMeasureInfo(layout).length > 1;
    },
    stacked(layout) {
      return (!this.dimensionless(layout) && getBarGrouping(layout) !== 'grouped' || this.continuous(layout)) && (getDimensionInfo(layout).length > 1 || getMeasureInfo(layout).length > 1);
    },
    stackedByDimension(layout) {
      return this.stacked(layout) && getDimensionInfo(layout).length > 1 && getMeasureInfo(layout).length === 1;
    },
    stackedByMeasure(layout) {
      return this.stacked(layout) && getDimensionInfo(layout).length === 1 && getMeasureInfo(layout).length > 1;
    },
    simple(layout) {
      return getDimensionInfo(layout).length === 0 || getDimensionInfo(layout).length === 1 && getMeasureInfo(layout).length === 1;
    },
    snapshot(layout) {
      return !!util$2.getValue(layout, 'snapshotData');
    }
  };

  /* eslint-disable no-underscore-dangle */
  function getLegendScrollOffset (chart, key) {
    const legend = chart.component(key);
    return legend && legend._DO_NOT_USE_getInfo && legend._DO_NOT_USE_getInfo().offset;
  }

  const handleError = error => {
    // error caused by an update of the object after getLayout should not show any error dialog
    error.isHandled = true; // eslint-disable-line no-param-reassign
    throw error;
  };
  function getReducedData(model, layoutService, settings) {
    return model.getHyperCubeReducedData(settings.path, [settings.rect], settings.zoomLevel, settings.filter).catch(handleError).then(dataPages => {
      var _dataPages$;
      const qMode = layoutService.getHyperCubeValue('qMode');
      const qDimensionInfo = layoutService.getHyperCubeValue('qDimensionInfo');
      const isReducedStackedDims = qMode === 'K' && qDimensionInfo.length > 1 && ((_dataPages$ = dataPages[0]) === null || _dataPages$ === void 0 ? void 0 : _dataPages$.qIsReduced);
      const reducedPages = dataPages.slice();
      const qMeasureInfo = layoutService.getHyperCubeValue('qMeasureInfo');
      const qColumnOrder = isReducedStackedDims ? [] : layoutService.getHyperCubeValue('qColumnOrder');
      const reducedCube = {
        qDataPages: reducedPages,
        qDimensionInfo: qDimensionInfo.slice(),
        qEffectiveInterColumnSortOrder: [1, 0],
        // For stacked, 2 dim 1 mea case, the format of data pages can be perceived as containing 1 dim and 2 mea.
        // The two measures are inserted to ease extraction for the component using it.
        qMeasureInfo: isReducedStackedDims ? [qMeasureInfo[0], qMeasureInfo[0]] : qMeasureInfo.slice(),
        qStackedDataPages: [],
        qMode: 'S',
        qHasOtherValues: layoutService.getHyperCubeValue('qHasOtherValues'),
        qSize: layoutService.getHyperCubeValue('qSize'),
        qColumnOrder
      };
      return {
        reducedCube
      };
    });
  }

  /**
   * Gets the default value for a property definition.
   *
   * @param type
   * @param definition
   * @returns {*} Default value in property definition if specified. Otherwise the type default.
   */
  const getDefaultValue = (type, definition) => {
    if (typeof definition.defaultValue === 'function') {
      return definition.defaultValue();
    }
    if (typeof definition.defaultValue !== 'undefined') {
      return definition.defaultValue;
    }
    if (Array.isArray(definition.options)) {
      return definition.options[0].value;
    }
    switch (type) {
      case 'array':
        return [];
      case 'string':
        return '';
      case 'integer':
        return 0;
      case 'number':
        return 0;
      case 'boolean':
        return false;
      default:
        return null;
    }
  };
  var propertyResolver = {
    getDefaultValue
  };

  /**
   * Sets the displayOrder on each component in the array components.
   * The displayOrder is specified by the index for the component in the array.
   * @param {array} components - Array of picasso component
   */
  function setDisplayOrder(components) {
    if (!components || components.length === 0) {
      return;
    }
    for (let i = 0; i < components.length; i++) {
      components[i].layout = components[i].layout || {}; // eslint-disable-line no-param-reassign
      components[i].layout.displayOrder = i; // eslint-disable-line no-param-reassign
    }
  }

  const CHARACTER_AVERAGE_WIDTH = 166 / 26;
  const CHARACTER_MAX_WIDTH = 12;
  const M_WIDTH = 11;
  const CJK_AVERAGE_WIDTH = 12;
  const CJK_OVER_LATIN_WIDTH_RATIO = CJK_AVERAGE_WIDTH / M_WIDTH;
  const stringUtils = {
    stringWidthOverMWidth(len) {
      const n = 3; // For short strings with wide letters or numbers
      return (Math.min(len, n) * CHARACTER_MAX_WIDTH + Math.max(len - n, 0) * CHARACTER_AVERAGE_WIDTH) / M_WIDTH;
    },
    getCharacterRatios(s) {
      if (!s) {
        return {
          latin: 0,
          cjk: 0
        };
      }
      let CJK = s.match(/[\u4E00-\u9FFF]/g);
      let hiragana = s.match(/[\u3040-\u309F]/g);
      let katakana = s.match(/[\u30A0-\u30FF]/g);
      CJK = CJK ? CJK.length : 0;
      hiragana = hiragana ? hiragana.length : 0;
      katakana = katakana ? katakana.length : 0;
      const t = CJK + hiragana + katakana;
      return {
        latin: s.length - t,
        cjk: t
      };
    },
    getTotalCharacterRatios(data, columnIndex, attr = 'qText') {
      if (!data) {
        return {
          latinRatio: 1,
          cjkRatio: 0
        };
      }
      const total = {
        latin: 0,
        cjk: 0
      };
      let res;
      if (columnIndex === undefined) {
        data.forEach(row => {
          res = stringUtils.getCharacterRatios(row[attr]);
          total.latin += res.latin;
          total.cjk += res.cjk;
        });
      } else {
        data.forEach(row => {
          res = stringUtils.getCharacterRatios(row[columnIndex][attr]);
          total.latin += res.latin;
          total.cjk += res.cjk;
        });
      }
      const t = Math.max(1, total.latin + total.cjk);
      total.latinRatio = total.latin / t;
      total.cjkRatio = total.cjk / t;
      return total;
    },
    getAdjustedMaxGlyphCount(maxGlyphCount, data, columnIndex, attr = 'qText') {
      const totalCharacterRatios = stringUtils.getTotalCharacterRatios(data, columnIndex, attr);
      const latinGlyphCount = totalCharacterRatios.latinRatio * maxGlyphCount;
      const cjkGlyphCount = totalCharacterRatios.cjkRatio * maxGlyphCount;
      const adjustedMaxGlyphCount = Math.ceil(stringUtils.stringWidthOverMWidth(latinGlyphCount) + cjkGlyphCount * CJK_OVER_LATIN_WIDTH_RATIO);
      return adjustedMaxGlyphCount;
    }
  };

  /* eslint no-underscore-dangle: 0 */
  const TOOLTIP_CONTAINER_SELECTOR = '#la-vie-tooltip';
  function appendTooltipContainer() {
    if (!document.querySelector(TOOLTIP_CONTAINER_SELECTOR)) {
      const container = document.createElement('div');
      container.id = 'la-vie-tooltip';
      container.style.overflow = 'hidden';
      container.style.position = 'fixed';
      container.style.pointerEvents = 'none';
      container.style.left = '0px';
      container.style.top = '0px';
      container.style.width = '100%';
      container.style.height = '100%';
      container.style.zIndex = 1020;
      document.body.appendChild(container);
    }
  }
  function destroyTooltipContainer() {
    const elm = document.querySelector(TOOLTIP_CONTAINER_SELECTOR);
    if (elm && elm.parentElement && elm.childElementCount < 1) {
      elm.parentElement.removeChild(elm);
    }
  }
  function rowContent(inputRow, {
    h,
    style
  }) {
    return inputRow.map(cell => {
      const attributes = {
        style: {
          ...(style.cell || {}),
          ...(cell.style || {})
        },
        class: cell.class
      };
      if (cell.colspan) {
        attributes.colspan = cell.colspan;
      }
      return h('td', attributes, cell.content);
    });
  }

  /**
   * Base tooltip definition
   */
  function tooltip({
    key = 'tooltip',
    rtl
  }) {
    return {
      show: true,
      key,
      type: 'tooltip',
      layout: {
        displayOrder: 3
      },
      beforeMount() {
        appendTooltipContainer();
      },
      beforeUpdate() {
        appendTooltipContainer();
      },
      destroyed() {
        destroyTooltipContainer();
      },
      settings: {
        appendTo: () => document.querySelector(TOOLTIP_CONTAINER_SELECTOR),
        content: ({
          h,
          data,
          style
        }) => data[0].map(row => h('tr', {}, rowContent(row, {
          h,
          style
        }))),
        direction: rtl ? 'rtl' : 'ltr'
      },
      style: {
        arrow: {
          color: '#404040'
        },
        content: {
          display: 'table',
          'border-spacing': '4px',
          background: 'rgba(64, 64, 64, 0.9)',
          opacity: '1',
          fontSize: '13px',
          fontFamily: '"Source Sans Pro", "Arial", "sans-serif"',
          'empty-cells': 'show'
        },
        cell: {
          'max-width': '180px',
          'word-break': 'break-word',
          'word-wrap': 'break-word',
          'overflow-wrap': 'break-word',
          hyphens: 'auto'
        }
      }
    };
  }

  // Source: https://en.wikipedia.org/wiki/Bi-directional_text and http://www.unicode.org/Public/6.0.0/ucd/UnicodeData.txt
  // 3 types of strong direction characters: L (strong left-to-right), R(strong right-to-left, Hebrew) and AL(strong right-to-left, Arabic language)
  const rangesOfLChars$1 = '[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02B8\u02BB-\u02C1\u02D0-\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376-\u037D\u0386\u0388-\u03F5\u03F7-\u0482\u048A-\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u097F\u0982-\u09B9\u09BD-\u09C0\u09C7-\u09CC\u09CE-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u0A03-\u0A39\u0A3E-\u0A40\u0A59-\u0A6F\u0A72-\u0A74\u0A83-\u0AB9\u0ABD-\u0AC0\u0AC9-\u0ACC\u0AD0-\u0AE1\u0AE6-\u0AEF\u0B02-\u0B39\u0B3D-\u0B3E\u0B40\u0B47-\u0B4C\u0B57-\u0B61\u0B66-\u0B77\u0B83-\u0BBF\u0BC1-\u0BCC\u0BD0-\u0BF2\u0C01-\u0C3D\u0C41-\u0C44\u0C58-\u0C61\u0C66-\u0C6F\u0C7F-\u0CB9\u0CBD-\u0CCB\u0CD5-\u0CE1\u0CE6-\u0D40\u0D46-\u0D4C\u0D4E-\u0D61\u0D66-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0E30\u0E32-\u0E33\u0E40-\u0E46\u0E4F-\u0EB0\u0EB2-\u0EB3\u0EBD-\u0EC6\u0ED0-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u102C\u1031\u1038\u103B-\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083-\u1084\u1087-\u108C\u108E-\u109C\u109E-\u135A\u1360-\u138F\u13A0-\u13F4\u1401-\u167F\u1681-\u169A\u16A0-\u1711\u1720-\u1731\u1735-\u1751\u1760-\u1770\u1780-\u17B6\u17BE-\u17C5\u17C7-\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u18A8\u18AA-\u191C\u1923-\u1926\u1929-\u1931\u1933-\u1938\u1946-\u19DA\u1A00-\u1A16\u1A19-\u1A55\u1A57\u1A61\u1A63-\u1A64\u1A6D-\u1A72\u1A80-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B6A\u1B74-\u1B7C\u1B82-\u1BA1\u1BA6-\u1BA7\u1BAA-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2-\u1C2B\u1C34-\u1C35\u1C3B-\u1C7F\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1DBF\u1E00-\u1FBC\u1FBE\u1FC2-\u1FCC\u1FD0-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E-\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2D00-\u2D70\u2D80-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u31BA\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DB5\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA66E\uA680-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA925\uA92E-\uA946\uA952-\uA97C\uA983-\uA9B2\uA9B4-\uA9B5\uA9BA-\uA9BB\uA9BD-\uAA28\uAA2F-\uAA30\uAA33-\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D-\uAAAF\uAAB1\uAAB5-\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2-\uABE4\uABE6-\uABE7\uABE9-\uABEC\uABF0-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFDC]';
  const rangesOfRChars$1 = '[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u07C0-\u07EA\u07F4-\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB4F]';
  const rangesOfALChars$1 = '[\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5-\u06E6\u06EE-\u06EF\u06FA-\u070D\u0710\u0712-\u072F\u074D-\u07A5\u07B1\uFB50-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]';
  const rangesOfLRgExp$1 = new RegExp(rangesOfLChars$1); // eslint-disable-line
  const rangesOfRRgExp$1 = new RegExp(rangesOfRChars$1);
  const rangesOfALRgExp$1 = new RegExp(rangesOfALChars$1);
  const rtlUtils = {
    lrm: String.fromCharCode(8206),
    // left-to-right marker
    rlm: String.fromCharCode(8207),
    // right-to-left marker

    isLtrChar(c) {
      return rangesOfLRgExp$1.test(c);
    },
    isRtlChar(c) {
      return rangesOfRRgExp$1.test(c) || rangesOfALRgExp$1.test(c);
    },
    detectTextDirection(s) {
      const n = s ? s.length : 0;
      let i;
      let c;
      for (i = 0; i < n; i++) {
        c = s[i];
        if (rtlUtils.isLtrChar(c)) {
          return 'ltr';
        }
        if (rtlUtils.isRtlChar(c)) {
          return 'rtl';
        }
      }
      return 'ltr';
    }
  };

  /**
   * TODO: Split up and refactor.
   */

  /* eslint no-underscore-dangle: 0 */
  const tooltipHelper = {
    getColorSymbol(ctx, data) {
      return ctx.h('div', {
        style: {
          display: 'inline-block',
          width: '10px',
          height: '10px',
          'background-color': data.color.fill,
          margin: '0 8px'
        }
      });
    },
    getNodeFillColor(node) {
      if (node.attrs && typeof node.attrs.fill !== 'undefined') {
        return node.attrs.fill;
      }
      if (node.children && node.children[0] && node.children[0].attrs && typeof node.children[0].attrs.fill !== 'undefined') {
        return node.children[0].attrs.fill;
      }
      return undefined;
    },
    getColor(ctx, node, opts) {
      const nodeData = node.data;
      const f = ctx.resources.formatter;
      const ds = ctx.resources.dataset;
      const color = {};
      if (opts.coloring.label) {
        color.label = `${opts.coloring.label}`;
      }
      if (opts.coloring.type !== 'color' && nodeData.fillTooltip) {
        const formatter = f('fill');
        const colorByMeasure = opts.coloring.fieldType === 'measure';
        if (colorByMeasure && formatter) {
          color.value = formatter(nodeData.fillTooltip.value);
        } else {
          color.value = nodeData.fillTooltip.label ? nodeData.fillTooltip.label : nodeData.fillTooltip.value;
        }
        if (!opts.coloring.label) {
          const colorField = ds(nodeData.fillTooltip.source.key).field(nodeData.fillTooltip.source.field).title();
          color.label = `${colorField}`;
        }
      }
      color.fill = typeof nodeData._fillColor === 'undefined' ? tooltipHelper.getNodeFillColor(node) : nodeData._fillColor;
      return color;
    },
    getMeasure(dataset, prop) {
      const measureField = dataset(prop.source.key).field(prop.source.field);
      const measureLabel = measureField.title();
      return {
        label: `${measureLabel}`,
        value: prop.label === '' || prop.label === 'NaN' ? '-' : prop.label,
        field: prop.source.field
      };
    },
    hideColorRow(data, opts) {
      return typeof data.color.value === 'undefined' || data.measures.some(m => m.field === opts.coloring.field);
    },
    getTitleRow(data, rtl) {
      const contentDir = rtlUtils.detectTextDirection(data.title);
      return [{
        content: data.title,
        style: {
          'font-weight': 'bold',
          'text-align': rtl ? 'right' : 'left',
          direction: contentDir
        },
        colspan: 2
      }, {}];
    },
    getDescriptionRow(data, rtl) {
      const contentDir = rtlUtils.detectTextDirection(data.value);
      return [{
        content: data.value,
        style: {
          'text-align': rtl ? 'right' : 'left',
          direction: contentDir
        },
        colspan: 2
      }, {}];
    },
    getNMoreRow(n, translator, rtl) {
      const content = translator ? translator.get('Object.ChartTooltip.NMore', n) : `+${n} more`;
      const contentDir = rtlUtils.detectTextDirection(content);
      return [{
        content,
        style: {
          'font-weight': 'bold',
          'text-align': rtl ? 'right' : 'left',
          direction: contentDir
        },
        colspan: 2
      }, {}];
    },
    getSeparatorRow() {
      const content = '';
      return [{
        content,
        style: {
          'background-image': 'linear-gradient(transparent 8px, rgba(255, 255, 255, 0.4) 8px, rgba(255, 255, 255, 0.4) 9.2px, transparent 9.2px)',
          height: '17px'
        },
        colspan: 2
      }, {}];
    },
    getColorRow(ctx, data, rtl) {
      const labelDir = rtlUtils.detectTextDirection(data.color.label);
      const labelContent = rtl ? [':', data.color.label] : [data.color.label, ':'];
      const valueDir = rtlUtils.detectTextDirection(data.color.value);
      const colorContent = rtl ? [data.color.value, tooltipHelper.getColorSymbol(ctx, data)] : [tooltipHelper.getColorSymbol(ctx, data), data.color.value];
      return [{
        content: labelContent,
        style: {
          'text-align': rtl ? 'right' : 'left',
          direction: labelDir
        }
      }, {
        content: colorContent,
        style: {
          'text-align': rtl ? 'left' : 'right',
          direction: valueDir,
          'vertical-align': 'middle'
        }
      }];
    },
    getMeasureRow(measure, ctx, data, rtl, showColorSymbol = false) {
      const labelDir = rtlUtils.detectTextDirection(measure.label);
      const labelContent = rtl ? [':', measure.label] : [measure.label, ':'];
      const valueDir = rtlUtils.detectTextDirection(measure.value);
      let valueContent;
      if (showColorSymbol) {
        valueContent = rtl ? [measure.value, tooltipHelper.getColorSymbol(ctx, data)] : [tooltipHelper.getColorSymbol(ctx, data), measure.value];
      } else {
        valueContent = [measure.value];
      }
      return [{
        content: labelContent,
        style: {
          'text-align': rtl ? 'right' : 'left',
          direction: labelDir
        }
      }, {
        content: valueContent,
        style: {
          'text-align': rtl ? 'left' : 'right',
          direction: valueDir,
          'vertical-align': 'middle'
        }
      }];
    }
  };

  function define$2 (constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend$5(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  function Color$2() {}
  var darker$2 = 0.7;
  var brighter$2 = 1 / darker$2;
  var reI$2 = "\\s*([+-]?\\d+)\\s*",
    reN$2 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP$2 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex$1 = /^#([0-9a-f]{3,8})$/,
    reRgbInteger$2 = new RegExp(`^rgb\\(${reI$2},${reI$2},${reI$2}\\)$`),
    reRgbPercent$2 = new RegExp(`^rgb\\(${reP$2},${reP$2},${reP$2}\\)$`),
    reRgbaInteger$2 = new RegExp(`^rgba\\(${reI$2},${reI$2},${reI$2},${reN$2}\\)$`),
    reRgbaPercent$2 = new RegExp(`^rgba\\(${reP$2},${reP$2},${reP$2},${reN$2}\\)$`),
    reHslPercent$2 = new RegExp(`^hsl\\(${reN$2},${reP$2},${reP$2}\\)$`),
    reHslaPercent$2 = new RegExp(`^hsla\\(${reN$2},${reP$2},${reP$2},${reN$2}\\)$`);
  var named$2 = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
  };
  define$2(Color$2, color$2, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex$1,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex$1,
    formatHex8: color_formatHex8$1,
    formatHsl: color_formatHsl$1,
    formatRgb: color_formatRgb$1,
    toString: color_formatRgb$1
  });
  function color_formatHex$1() {
    return this.rgb().formatHex();
  }
  function color_formatHex8$1() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl$1() {
    return hslConvert$2(this).formatHsl();
  }
  function color_formatRgb$1() {
    return this.rgb().formatRgb();
  }
  function color$2(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex$1.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn$2(m) // #ff0000
    : l === 3 ? new Rgb$2(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
    : l === 8 ? rgba$2(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
    : l === 4 ? rgba$2(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
    : null // invalid hex
    ) : (m = reRgbInteger$2.exec(format)) ? new Rgb$2(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
    : (m = reRgbPercent$2.exec(format)) ? new Rgb$2(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
    : (m = reRgbaInteger$2.exec(format)) ? rgba$2(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
    : (m = reRgbaPercent$2.exec(format)) ? rgba$2(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
    : (m = reHslPercent$2.exec(format)) ? hsla$2(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
    : (m = reHslaPercent$2.exec(format)) ? hsla$2(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
    : named$2.hasOwnProperty(format) ? rgbn$2(named$2[format]) // eslint-disable-line no-prototype-builtins
    : format === "transparent" ? new Rgb$2(NaN, NaN, NaN, 0) : null;
  }
  function rgbn$2(n) {
    return new Rgb$2(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
  }
  function rgba$2(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb$2(r, g, b, a);
  }
  function rgbConvert$2(o) {
    if (!(o instanceof Color$2)) o = color$2(o);
    if (!o) return new Rgb$2();
    o = o.rgb();
    return new Rgb$2(o.r, o.g, o.b, o.opacity);
  }
  function rgb$4(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert$2(r) : new Rgb$2(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb$2(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define$2(Rgb$2, rgb$4, extend$5(Color$2, {
    brighter(k) {
      k = k == null ? brighter$2 : Math.pow(brighter$2, k);
      return new Rgb$2(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker$2 : Math.pow(darker$2, k);
      return new Rgb$2(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb$2(clampi$1(this.r), clampi$1(this.g), clampi$1(this.b), clampa$1(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: rgb_formatHex$1,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex$1,
    formatHex8: rgb_formatHex8$1,
    formatRgb: rgb_formatRgb$1,
    toString: rgb_formatRgb$1
  }));
  function rgb_formatHex$1() {
    return `#${hex$3(this.r)}${hex$3(this.g)}${hex$3(this.b)}`;
  }
  function rgb_formatHex8$1() {
    return `#${hex$3(this.r)}${hex$3(this.g)}${hex$3(this.b)}${hex$3((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb$1() {
    const a = clampa$1(this.opacity);
    return `${a === 1 ? "rgb(" : "rgba("}${clampi$1(this.r)}, ${clampi$1(this.g)}, ${clampi$1(this.b)}${a === 1 ? ")" : `, ${a})`}`;
  }
  function clampa$1(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi$1(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex$3(value) {
    value = clampi$1(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla$2(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
    return new Hsl$2(h, s, l, a);
  }
  function hslConvert$2(o) {
    if (o instanceof Hsl$2) return new Hsl$2(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color$2)) o = color$2(o);
    if (!o) return new Hsl$2();
    if (o instanceof Hsl$2) return o;
    o = o.rgb();
    var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
    if (s) {
      if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
      s /= l < 0.5 ? max + min : 2 - max - min;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl$2(h, s, l, o.opacity);
  }
  function hsl$2(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert$2(h) : new Hsl$2(h, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl$2(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define$2(Hsl$2, hsl$2, extend$5(Color$2, {
    brighter(k) {
      k = k == null ? brighter$2 : Math.pow(brighter$2, k);
      return new Hsl$2(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker$2 : Math.pow(darker$2, k);
      return new Hsl$2(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
      return new Rgb$2(hsl2rgb$2(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb$2(h, m1, m2), hsl2rgb$2(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
    },
    clamp() {
      return new Hsl$2(clamph$1(this.h), clampt$1(this.s), clampt$1(this.l), clampa$1(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl() {
      const a = clampa$1(this.opacity);
      return `${a === 1 ? "hsl(" : "hsla("}${clamph$1(this.h)}, ${clampt$1(this.s) * 100}%, ${clampt$1(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }
  }));
  function clamph$1(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt$1(value) {
    return Math.max(0, Math.min(1, value || 0));
  }

  /* From FvD 13.37, CSS Color Module Level 3 */
  function hsl2rgb$2(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }

  const radians = Math.PI / 180;
  const degrees = 180 / Math.PI;

  // https://observablehq.com/@mbostock/lab-and-rgb
  const K$2 = 18,
    Xn$2 = 0.96422,
    Yn$2 = 1,
    Zn$2 = 0.82521,
    t0$4 = 4 / 29,
    t1$4 = 6 / 29,
    t2$1 = 3 * t1$4 * t1$4,
    t3$1 = t1$4 * t1$4 * t1$4;
  function labConvert$1(o) {
    if (o instanceof Lab$1) return new Lab$1(o.l, o.a, o.b, o.opacity);
    if (o instanceof Hcl$1) return hcl2lab(o);
    if (!(o instanceof Rgb$2)) o = rgbConvert$2(o);
    var r = rgb2lrgb$1(o.r),
      g = rgb2lrgb$1(o.g),
      b = rgb2lrgb$1(o.b),
      y = xyz2lab$1((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn$2),
      x,
      z;
    if (r === g && g === b) x = z = y;else {
      x = xyz2lab$1((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn$2);
      z = xyz2lab$1((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn$2);
    }
    return new Lab$1(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
  }
  function lab$1(l, a, b, opacity) {
    return arguments.length === 1 ? labConvert$1(l) : new Lab$1(l, a, b, opacity == null ? 1 : opacity);
  }
  function Lab$1(l, a, b, opacity) {
    this.l = +l;
    this.a = +a;
    this.b = +b;
    this.opacity = +opacity;
  }
  define$2(Lab$1, lab$1, extend$5(Color$2, {
    brighter(k) {
      return new Lab$1(this.l + K$2 * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    darker(k) {
      return new Lab$1(this.l - K$2 * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    rgb() {
      var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
      x = Xn$2 * lab2xyz$1(x);
      y = Yn$2 * lab2xyz$1(y);
      z = Zn$2 * lab2xyz$1(z);
      return new Rgb$2(lrgb2rgb$1(3.1338561 * x - 1.6168667 * y - 0.4906146 * z), lrgb2rgb$1(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z), lrgb2rgb$1(0.0719453 * x - 0.2289914 * y + 1.4052427 * z), this.opacity);
    }
  }));
  function xyz2lab$1(t) {
    return t > t3$1 ? Math.pow(t, 1 / 3) : t / t2$1 + t0$4;
  }
  function lab2xyz$1(t) {
    return t > t1$4 ? t * t * t : t2$1 * (t - t0$4);
  }
  function lrgb2rgb$1(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
  }
  function rgb2lrgb$1(x) {
    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
  }
  function hclConvert$1(o) {
    if (o instanceof Hcl$1) return new Hcl$1(o.h, o.c, o.l, o.opacity);
    if (!(o instanceof Lab$1)) o = labConvert$1(o);
    if (o.a === 0 && o.b === 0) return new Hcl$1(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
    var h = Math.atan2(o.b, o.a) * degrees;
    return new Hcl$1(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
  }
  function hcl$1(h, c, l, opacity) {
    return arguments.length === 1 ? hclConvert$1(h) : new Hcl$1(h, c, l, opacity == null ? 1 : opacity);
  }
  function Hcl$1(h, c, l, opacity) {
    this.h = +h;
    this.c = +c;
    this.l = +l;
    this.opacity = +opacity;
  }
  function hcl2lab(o) {
    if (isNaN(o.h)) return new Lab$1(o.l, 0, 0, o.opacity);
    var h = o.h * radians;
    return new Lab$1(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  define$2(Hcl$1, hcl$1, extend$5(Color$2, {
    brighter(k) {
      return new Hcl$1(this.h, this.c, this.l + K$2 * (k == null ? 1 : k), this.opacity);
    },
    darker(k) {
      return new Hcl$1(this.h, this.c, this.l - K$2 * (k == null ? 1 : k), this.opacity);
    },
    rgb() {
      return hcl2lab(this).rgb();
    }
  }));

  function isDark$1(color) {
    return hcl$1(color).l < 70;
  }

  var commonColor = {
    isDark: isDark$1
  };

  function autoSortDimension(dimension) {
    const def = dimension.qDef;
    if (def.autoSort === true) {
      def.qSortCriterias.forEach(sortCriteria => {
        // eslint-disable-next-line no-param-reassign
        sortCriteria.qSortByNumeric = 1;
        // eslint-disable-next-line no-param-reassign
        sortCriteria.qSortByAscii = 1;
      });
    }
  }

  function autoSortAdapter(properties) {
    var _properties$qHyperCub;
    properties.qHyperCubeDef.qDimensions.forEach(autoSortDimension);
    if ((_properties$qHyperCub = properties.qHyperCubeDef.qLayoutExclude) !== null && _properties$qHyperCub !== void 0 && (_properties$qHyperCub = _properties$qHyperCub.qHyperCubeDef) !== null && _properties$qHyperCub !== void 0 && _properties$qHyperCub.qDimensions) {
      properties.qHyperCubeDef.qLayoutExclude.qHyperCubeDef.qDimensions.forEach(autoSortDimension);
    }
  }

  function ascending$1 (a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function bisector$1 (compare) {
    if (compare.length === 1) compare = ascendingComparator(compare);
    return {
      left: function (a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
        }
        return lo;
      },
      right: function (a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  function ascendingComparator(f) {
    return function (d, x) {
      return ascending$1(f(d), x);
    };
  }

  var ascendingBisect$1 = bisector$1(ascending$1);
  var bisectRight$1 = ascendingBisect$1.right;

  var e10$1 = Math.sqrt(50),
    e5$1 = Math.sqrt(10),
    e2$1 = Math.sqrt(2);
  function ticks$1 (start, stop, count) {
    var reverse,
      i = -1,
      n,
      ticks,
      step;
    stop = +stop, start = +start, count = +count;
    if (start === stop && count > 0) return [start];
    if (reverse = stop < start) n = start, start = stop, stop = n;
    if ((step = tickIncrement$1(start, stop, count)) === 0 || !isFinite(step)) return [];
    if (step > 0) {
      start = Math.ceil(start / step);
      stop = Math.floor(stop / step);
      ticks = new Array(n = Math.ceil(stop - start + 1));
      while (++i < n) ticks[i] = (start + i) * step;
    } else {
      start = Math.floor(start * step);
      stop = Math.ceil(stop * step);
      ticks = new Array(n = Math.ceil(start - stop + 1));
      while (++i < n) ticks[i] = (start - i) / step;
    }
    if (reverse) ticks.reverse();
    return ticks;
  }
  function tickIncrement$1(start, stop, count) {
    var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
    return power >= 0 ? (error >= e10$1 ? 10 : error >= e5$1 ? 5 : error >= e2$1 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10$1 ? 10 : error >= e5$1 ? 5 : error >= e2$1 ? 2 : 1);
  }
  function tickStep$1(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
    if (error >= e10$1) step1 *= 10;else if (error >= e5$1) step1 *= 5;else if (error >= e2$1) step1 *= 2;
    return stop < start ? -step1 : step1;
  }

  function initRange$1(domain, range) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(domain);
        break;
      default:
        this.range(range).domain(domain);
        break;
    }
    return this;
  }

  var prefix$1 = "$";
  function Map$1() {}
  Map$1.prototype = map$2.prototype = {
    constructor: Map$1,
    has: function (key) {
      return prefix$1 + key in this;
    },
    get: function (key) {
      return this[prefix$1 + key];
    },
    set: function (key, value) {
      this[prefix$1 + key] = value;
      return this;
    },
    remove: function (key) {
      var property = prefix$1 + key;
      return property in this && delete this[property];
    },
    clear: function () {
      for (var property in this) if (property[0] === prefix$1) delete this[property];
    },
    keys: function () {
      var keys = [];
      for (var property in this) if (property[0] === prefix$1) keys.push(property.slice(1));
      return keys;
    },
    values: function () {
      var values = [];
      for (var property in this) if (property[0] === prefix$1) values.push(this[property]);
      return values;
    },
    entries: function () {
      var entries = [];
      for (var property in this) if (property[0] === prefix$1) entries.push({
        key: property.slice(1),
        value: this[property]
      });
      return entries;
    },
    size: function () {
      var size = 0;
      for (var property in this) if (property[0] === prefix$1) ++size;
      return size;
    },
    empty: function () {
      for (var property in this) if (property[0] === prefix$1) return false;
      return true;
    },
    each: function (f) {
      for (var property in this) if (property[0] === prefix$1) f(this[property], property.slice(1), this);
    }
  };
  function map$2(object, f) {
    var map = new Map$1();

    // Copy constructor.
    if (object instanceof Map$1) object.each(function (value, key) {
      map.set(key, value);
    });

    // Index array by numeric index or specified key function.
    else if (Array.isArray(object)) {
      var i = -1,
        n = object.length,
        o;
      if (f == null) while (++i < n) map.set(i, object[i]);else while (++i < n) map.set(f(o = object[i], i, object), o);
    }

    // Convert object to map.
    else if (object) for (var key in object) map.set(key, object[key]);
    return map;
  }

  function Set$1() {}
  var proto = map$2.prototype;
  Set$1.prototype = {
    constructor: Set$1,
    has: proto.has,
    add: function (value) {
      value += "";
      this[prefix$1 + value] = value;
      return this;
    },
    remove: proto.remove,
    clear: proto.clear,
    values: proto.keys,
    size: proto.size,
    empty: proto.empty,
    each: proto.each
  };

  var array$1 = Array.prototype;
  var map$1 = array$1.map;
  var slice$1 = array$1.slice;

  function define$1 (constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend$4(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  function Color$1() {}
  var darker$1 = 0.7;
  var brighter$1 = 1 / darker$1;
  var reI$1 = "\\s*([+-]?\\d+)\\s*",
    reN$1 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP$1 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger$1 = new RegExp("^rgb\\(" + [reI$1, reI$1, reI$1] + "\\)$"),
    reRgbPercent$1 = new RegExp("^rgb\\(" + [reP$1, reP$1, reP$1] + "\\)$"),
    reRgbaInteger$1 = new RegExp("^rgba\\(" + [reI$1, reI$1, reI$1, reN$1] + "\\)$"),
    reRgbaPercent$1 = new RegExp("^rgba\\(" + [reP$1, reP$1, reP$1, reN$1] + "\\)$"),
    reHslPercent$1 = new RegExp("^hsl\\(" + [reN$1, reP$1, reP$1] + "\\)$"),
    reHslaPercent$1 = new RegExp("^hsla\\(" + [reN$1, reP$1, reP$1, reN$1] + "\\)$");
  var named$1 = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
  };
  define$1(Color$1, color$1, {
    displayable: function () {
      return this.rgb().displayable();
    },
    hex: function () {
      return this.rgb().hex();
    },
    toString: function () {
      return this.rgb() + "";
    }
  });
  function color$1(format) {
    var m;
    format = (format + "").trim().toLowerCase();
    return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb$1(m >> 8 & 0xf | m >> 4 & 0x0f0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
    ) : (m = reHex6.exec(format)) ? rgbn$1(parseInt(m[1], 16)) // #ff0000
    : (m = reRgbInteger$1.exec(format)) ? new Rgb$1(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
    : (m = reRgbPercent$1.exec(format)) ? new Rgb$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
    : (m = reRgbaInteger$1.exec(format)) ? rgba$1(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
    : (m = reRgbaPercent$1.exec(format)) ? rgba$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
    : (m = reHslPercent$1.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
    : (m = reHslaPercent$1.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
    : named$1.hasOwnProperty(format) ? rgbn$1(named$1[format]) : format === "transparent" ? new Rgb$1(NaN, NaN, NaN, 0) : null;
  }
  function rgbn$1(n) {
    return new Rgb$1(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
  }
  function rgba$1(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb$1(r, g, b, a);
  }
  function rgbConvert$1(o) {
    if (!(o instanceof Color$1)) o = color$1(o);
    if (!o) return new Rgb$1();
    o = o.rgb();
    return new Rgb$1(o.r, o.g, o.b, o.opacity);
  }
  function rgb$3(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert$1(r) : new Rgb$1(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb$1(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define$1(Rgb$1, rgb$3, extend$4(Color$1, {
    brighter: function (k) {
      k = k == null ? brighter$1 : Math.pow(brighter$1, k);
      return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function (k) {
      k = k == null ? darker$1 : Math.pow(darker$1, k);
      return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function () {
      return this;
    },
    displayable: function () {
      return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: function () {
      return "#" + hex$2(this.r) + hex$2(this.g) + hex$2(this.b);
    },
    toString: function () {
      var a = this.opacity;
      a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
    }
  }));
  function hex$2(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla$1(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
    return new Hsl$1(h, s, l, a);
  }
  function hslConvert$1(o) {
    if (o instanceof Hsl$1) return new Hsl$1(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color$1)) o = color$1(o);
    if (!o) return new Hsl$1();
    if (o instanceof Hsl$1) return o;
    o = o.rgb();
    var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
    if (s) {
      if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
      s /= l < 0.5 ? max + min : 2 - max - min;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl$1(h, s, l, o.opacity);
  }
  function hsl$1(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert$1(h) : new Hsl$1(h, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl$1(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define$1(Hsl$1, hsl$1, extend$4(Color$1, {
    brighter: function (k) {
      k = k == null ? brighter$1 : Math.pow(brighter$1, k);
      return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function (k) {
      k = k == null ? darker$1 : Math.pow(darker$1, k);
      return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function () {
      var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
      return new Rgb$1(hsl2rgb$1(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb$1(h, m1, m2), hsl2rgb$1(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
    },
    displayable: function () {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    }
  }));

  /* From FvD 13.37, CSS Color Module Level 3 */
  function hsl2rgb$1(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }

  var deg2rad = Math.PI / 180;
  var rad2deg = 180 / Math.PI;

  // https://beta.observablehq.com/@mbostock/lab-and-rgb
  var K$1 = 18,
    Xn$1 = 0.96422,
    Yn$1 = 1,
    Zn$1 = 0.82521,
    t0$3 = 4 / 29,
    t1$3 = 6 / 29,
    t2 = 3 * t1$3 * t1$3,
    t3 = t1$3 * t1$3 * t1$3;
  function labConvert(o) {
    if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
    if (o instanceof Hcl) {
      if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
      var h = o.h * deg2rad;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }
    if (!(o instanceof Rgb$1)) o = rgbConvert$1(o);
    var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn$1),
      x,
      z;
    if (r === g && g === b) x = z = y;else {
      x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn$1);
      z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn$1);
    }
    return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
  }
  function lab(l, a, b, opacity) {
    return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
  }
  function Lab(l, a, b, opacity) {
    this.l = +l;
    this.a = +a;
    this.b = +b;
    this.opacity = +opacity;
  }
  define$1(Lab, lab, extend$4(Color$1, {
    brighter: function (k) {
      return new Lab(this.l + K$1 * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    darker: function (k) {
      return new Lab(this.l - K$1 * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    rgb: function () {
      var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
      x = Xn$1 * lab2xyz(x);
      y = Yn$1 * lab2xyz(y);
      z = Zn$1 * lab2xyz(z);
      return new Rgb$1(lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z), lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z), lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z), this.opacity);
    }
  }));
  function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$3;
  }
  function lab2xyz(t) {
    return t > t1$3 ? t * t * t : t2 * (t - t0$3);
  }
  function lrgb2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
  }
  function rgb2lrgb(x) {
    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
  }
  function hclConvert(o) {
    if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
    if (!(o instanceof Lab)) o = labConvert(o);
    if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0, o.l, o.opacity);
    var h = Math.atan2(o.b, o.a) * rad2deg;
    return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
  }
  function hcl(h, c, l, opacity) {
    return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
  }
  function Hcl(h, c, l, opacity) {
    this.h = +h;
    this.c = +c;
    this.l = +l;
    this.opacity = +opacity;
  }
  define$1(Hcl, hcl, extend$4(Color$1, {
    brighter: function (k) {
      return new Hcl(this.h, this.c, this.l + K$1 * (k == null ? 1 : k), this.opacity);
    },
    darker: function (k) {
      return new Hcl(this.h, this.c, this.l - K$1 * (k == null ? 1 : k), this.opacity);
    },
    rgb: function () {
      return labConvert(this).rgb();
    }
  }));

  var A$2 = -0.14861,
    B$2 = +1.78277,
    C$2 = -0.29227,
    D$1 = -0.90649,
    E$1 = +1.97294,
    ED = E$1 * D$1,
    EB = E$1 * B$2,
    BC_DA = B$2 * C$2 - D$1 * A$2;
  function cubehelixConvert(o) {
    if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Rgb$1)) o = rgbConvert$1(o);
    var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E$1 * (g - l) - C$2 * bl) / D$1,
      s = Math.sqrt(k * k + bl * bl) / (E$1 * l * (1 - l)),
      // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
    return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
  }
  function cubehelix$1(h, s, l, opacity) {
    return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
  }
  function Cubehelix(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define$1(Cubehelix, cubehelix$1, extend$4(Color$1, {
    brighter: function (k) {
      k = k == null ? brighter$1 : Math.pow(brighter$1, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function (k) {
      k = k == null ? darker$1 : Math.pow(darker$1, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function () {
      var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
      return new Rgb$1(255 * (l + a * (A$2 * cosh + B$2 * sinh)), 255 * (l + a * (C$2 * cosh + D$1 * sinh)), 255 * (l + a * (E$1 * cosh)), this.opacity);
    }
  }));

  function constant$4 (x) {
    return function () {
      return x;
    };
  }

  function linear$4(a, d) {
    return function (t) {
      return a + t * d;
    };
  }
  function exponential$2(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
      return Math.pow(a + t * b, y);
    };
  }
  function hue(a, b) {
    var d = b - a;
    return d ? linear$4(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$4(isNaN(a) ? b : a);
  }
  function gamma$1(y) {
    return (y = +y) === 1 ? nogamma$1 : function (a, b) {
      return b - a ? exponential$2(a, b, y) : constant$4(isNaN(a) ? b : a);
    };
  }
  function nogamma$1(a, b) {
    var d = b - a;
    return d ? linear$4(a, d) : constant$4(isNaN(a) ? b : a);
  }

  var rgb$2 = (function rgbGamma(y) {
    var color = gamma$1(y);
    function rgb(start, end) {
      var r = color((start = rgb$3(start)).r, (end = rgb$3(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma$1(start.opacity, end.opacity);
      return function (t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }
    rgb.gamma = rgbGamma;
    return rgb;
  })(1);

  function array (a, b) {
    var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;
    for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
    for (; i < nb; ++i) c[i] = b[i];
    return function (t) {
      for (i = 0; i < na; ++i) c[i] = x[i](t);
      return c;
    };
  }

  function date$2 (a, b) {
    var d = new Date();
    return a = +a, b -= a, function (t) {
      return d.setTime(a + b * t), d;
    };
  }

  function interpolateNumber (a, b) {
    return a = +a, b -= a, function (t) {
      return a + b * t;
    };
  }

  function object$3 (a, b) {
    var i = {},
      c = {},
      k;
    if (a === null || typeof a !== "object") a = {};
    if (b === null || typeof b !== "object") b = {};
    for (k in b) {
      if (k in a) {
        i[k] = interpolateValue(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }
    return function (t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }

  var reA$1 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB$1 = new RegExp(reA$1.source, "g");
  function zero$2(b) {
    return function () {
      return b;
    };
  }
  function one$1(b) {
    return function (t) {
      return b(t) + "";
    };
  }
  function string$1 (a, b) {
    var bi = reA$1.lastIndex = reB$1.lastIndex = 0,
      // scan index for next number in b
      am,
      // current match in a
      bm,
      // current match in b
      bs,
      // string preceding current number in b, if any
      i = -1,
      // index in s
      s = [],
      // string constants and placeholders
      q = []; // number interpolators

    // Coerce inputs to strings.
    a = a + "", b = b + "";

    // Interpolate pairs of numbers in a & b.
    while ((am = reA$1.exec(a)) && (bm = reB$1.exec(b))) {
      if ((bs = bm.index) > bi) {
        // a string precedes the next number in b
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        // numbers in a & b match
        if (s[i]) s[i] += bm; // coalesce with previous string
        else s[++i] = bm;
      } else {
        // interpolate non-matching numbers
        s[++i] = null;
        q.push({
          i: i,
          x: interpolateNumber(am, bm)
        });
      }
      bi = reB$1.lastIndex;
    }

    // Add remains of b.
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? q[0] ? one$1(q[0].x) : zero$2(b) : (b = q.length, function (t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }

  function interpolateValue (a, b) {
    var t = typeof b,
      c;
    return b == null || t === "boolean" ? constant$4(b) : (t === "number" ? interpolateNumber : t === "string" ? (c = color$1(b)) ? (b = c, rgb$2) : string$1 : b instanceof color$1 ? rgb$2 : b instanceof Date ? date$2 : Array.isArray(b) ? array : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$3 : interpolateNumber)(a, b);
  }

  function interpolateRound$1 (a, b) {
    return a = +a, b -= a, function (t) {
      return Math.round(a + b * t);
    };
  }

  function cubehelix(hue) {
    return function cubehelixGamma(y) {
      y = +y;
      function cubehelix(start, end) {
        var h = hue((start = cubehelix$1(start)).h, (end = cubehelix$1(end)).h),
          s = nogamma$1(start.s, end.s),
          l = nogamma$1(start.l, end.l),
          opacity = nogamma$1(start.opacity, end.opacity);
        return function (t) {
          start.h = h(t);
          start.s = s(t);
          start.l = l(Math.pow(t, y));
          start.opacity = opacity(t);
          return start + "";
        };
      }
      cubehelix.gamma = cubehelixGamma;
      return cubehelix;
    }(1);
  }
  cubehelix(hue);
  cubehelix(nogamma$1);

  function constant$3 (x) {
    return function () {
      return x;
    };
  }

  function number$4 (x) {
    return +x;
  }

  var unit$1 = [0, 1];
  function identity$4(x) {
    return x;
  }
  function normalize$3(a, b) {
    return (b -= a = +a) ? function (x) {
      return (x - a) / b;
    } : constant$3(isNaN(b) ? NaN : 0.5);
  }
  function clamper$1(domain) {
    var a = domain[0],
      b = domain[domain.length - 1],
      t;
    if (a > b) t = a, a = b, b = t;
    return function (x) {
      return Math.max(a, Math.min(b, x));
    };
  }

  // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
  // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
  function bimap$1(domain, range, interpolate) {
    var d0 = domain[0],
      d1 = domain[1],
      r0 = range[0],
      r1 = range[1];
    if (d1 < d0) d0 = normalize$3(d1, d0), r0 = interpolate(r1, r0);else d0 = normalize$3(d0, d1), r0 = interpolate(r0, r1);
    return function (x) {
      return r0(d0(x));
    };
  }
  function polymap$1(domain, range, interpolate) {
    var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

    // Reverse descending domains.
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++i < j) {
      d[i] = normalize$3(domain[i], domain[i + 1]);
      r[i] = interpolate(range[i], range[i + 1]);
    }
    return function (x) {
      var i = bisectRight$1(domain, x, 1, j) - 1;
      return r[i](d[i](x));
    };
  }
  function copy$1(source, target) {
    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
  }
  function transformer$1() {
    var domain = unit$1,
      range = unit$1,
      interpolate = interpolateValue,
      transform,
      untransform,
      unknown,
      clamp = identity$4,
      piecewise,
      output,
      input;
    function rescale() {
      piecewise = Math.min(domain.length, range.length) > 2 ? polymap$1 : bimap$1;
      output = input = null;
      return scale;
    }
    function scale(x) {
      return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
    }
    scale.invert = function (y) {
      return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
    };
    scale.domain = function (_) {
      return arguments.length ? (domain = map$1.call(_, number$4), clamp === identity$4 || (clamp = clamper$1(domain)), rescale()) : domain.slice();
    };
    scale.range = function (_) {
      return arguments.length ? (range = slice$1.call(_), rescale()) : range.slice();
    };
    scale.rangeRound = function (_) {
      return range = slice$1.call(_), interpolate = interpolateRound$1, rescale();
    };
    scale.clamp = function (_) {
      return arguments.length ? (clamp = _ ? clamper$1(domain) : identity$4, scale) : clamp !== identity$4;
    };
    scale.interpolate = function (_) {
      return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };
    scale.unknown = function (_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function (t, u) {
      transform = t, untransform = u;
      return rescale();
    };
  }
  function continuous$2(transform, untransform) {
    return transformer$1()(transform, untransform);
  }

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimal(1.23) returns ["123", 0].
  function formatDecimal$1 (x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i,
      coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1)];
  }

  function exponent$1 (x) {
    return x = formatDecimal$1(Math.abs(x)), x ? x[1] : NaN;
  }

  function formatGroup$1 (grouping, thousands) {
    return function (value, width) {
      var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }
      return t.reverse().join(thousands);
    };
  }

  function formatNumerals$1 (numerals) {
    return function (value) {
      return value.replace(/[0-9]/g, function (i) {
        return numerals[+i];
      });
    };
  }

  // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
  var re$2 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier$1(specifier) {
    return new FormatSpecifier$1(specifier);
  }
  formatSpecifier$1.prototype = FormatSpecifier$1.prototype; // instanceof

  function FormatSpecifier$1(specifier) {
    if (!(match = re$2.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    this.fill = match[1] || " ";
    this.align = match[2] || ">";
    this.sign = match[3] || "-";
    this.symbol = match[4] || "";
    this.zero = !!match[5];
    this.width = match[6] && +match[6];
    this.comma = !!match[7];
    this.precision = match[8] && +match[8].slice(1);
    this.trim = !!match[9];
    this.type = match[10] || "";
  }
  FormatSpecifier$1.prototype.toString = function () {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width == null ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };

  // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
  function formatTrim$1 (s) {
    out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0) i0 = i;
          i1 = i;
          break;
        default:
          if (i0 > 0) {
            if (!+s[i]) break out;
            i0 = 0;
          }
          break;
      }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  var prefixExponent$1;
  function formatPrefixAuto$1 (x, p) {
    var d = formatDecimal$1(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent$1 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimal$1(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  }

  function formatRounded$1 (x, p) {
    var d = formatDecimal$1(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
      exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  var formatTypes$1 = {
    "%": function (x, p) {
      return (x * 100).toFixed(p);
    },
    "b": function (x) {
      return Math.round(x).toString(2);
    },
    "c": function (x) {
      return x + "";
    },
    "d": function (x) {
      return Math.round(x).toString(10);
    },
    "e": function (x, p) {
      return x.toExponential(p);
    },
    "f": function (x, p) {
      return x.toFixed(p);
    },
    "g": function (x, p) {
      return x.toPrecision(p);
    },
    "o": function (x) {
      return Math.round(x).toString(8);
    },
    "p": function (x, p) {
      return formatRounded$1(x * 100, p);
    },
    "r": formatRounded$1,
    "s": formatPrefixAuto$1,
    "X": function (x) {
      return Math.round(x).toString(16).toUpperCase();
    },
    "x": function (x) {
      return Math.round(x).toString(16);
    }
  };

  function identity$3 (x) {
    return x;
  }

  var prefixes$1 = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function formatLocale$3 (locale) {
    var group = locale.grouping && locale.thousands ? formatGroup$1(locale.grouping, locale.thousands) : identity$3,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals$1(locale.numerals) : identity$3,
      percent = locale.percent || "%";
    function newFormat(specifier) {
      specifier = formatSpecifier$1(specifier);
      var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

      // The "n" type is an alias for ",g".
      if (type === "n") comma = true, type = "g";

      // The "" type, and any invalid type, is an alias for ".12~g".
      else if (!formatTypes$1[type]) precision == null && (precision = 12), trim = true, type = "g";

      // If zero fill is specified, padding goes after sign and before digits.
      if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes$1[type],
        maybeSuffix = /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision == null ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
      function format(value) {
        var valuePrefix = prefix,
          valueSuffix = suffix,
          i,
          n,
          c;
        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Perform the initial formatting.
          var valueNegative = value < 0;
          value = formatType(Math.abs(value), precision);

          // Trim insignificant zeros.
          if (trim) value = formatTrim$1(value);

          // If a negative value rounds to zero during formatting, treat as positive.
          if (valueNegative && +value === 0) valueNegative = false;

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? sign === "(" ? sign : "-" : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes$1[8 + prefixExponent$1 / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<":
            value = valuePrefix + value + valueSuffix + padding;
            break;
          case "=":
            value = valuePrefix + padding + value + valueSuffix;
            break;
          case "^":
            value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
            break;
          default:
            value = padding + valuePrefix + value + valueSuffix;
            break;
        }
        return numerals(value);
      }
      format.toString = function () {
        return specifier + "";
      };
      return format;
    }
    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier$1(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes$1[8 + e / 3];
      return function (value) {
        return f(k * value) + prefix;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  }

  var locale$2;
  var format$1;
  var formatPrefix$1;
  defaultLocale$2({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale$2(definition) {
    locale$2 = formatLocale$3(definition);
    format$1 = locale$2.format;
    formatPrefix$1 = locale$2.formatPrefix;
    return locale$2;
  }

  function precisionFixed$1 (step) {
    return Math.max(0, -exponent$1(Math.abs(step)));
  }

  function precisionPrefix$1 (step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));
  }

  function precisionRound$1 (step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;
  }

  function tickFormat$1 (start, stop, count, specifier) {
    var step = tickStep$1(start, stop, count),
      precision;
    specifier = formatSpecifier$1(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s":
        {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix$1(step, value))) specifier.precision = precision;
          return formatPrefix$1(specifier, value);
        }
      case "":
      case "e":
      case "g":
      case "p":
      case "r":
        {
          if (specifier.precision == null && !isNaN(precision = precisionRound$1(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
      case "f":
      case "%":
        {
          if (specifier.precision == null && !isNaN(precision = precisionFixed$1(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
    }
    return format$1(specifier);
  }

  function linearish$1(scale) {
    var domain = scale.domain;
    scale.ticks = function (count) {
      var d = domain();
      return ticks$1(d[0], d[d.length - 1], count == null ? 10 : count);
    };
    scale.tickFormat = function (count, specifier) {
      var d = domain();
      return tickFormat$1(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };
    scale.nice = function (count) {
      if (count == null) count = 10;
      var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;
      if (stop < start) {
        step = start, start = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }
      step = tickIncrement$1(start, stop, count);
      if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
        step = tickIncrement$1(start, stop, count);
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
        step = tickIncrement$1(start, stop, count);
      }
      if (step > 0) {
        d[i0] = Math.floor(start / step) * step;
        d[i1] = Math.ceil(stop / step) * step;
        domain(d);
      } else if (step < 0) {
        d[i0] = Math.ceil(start * step) / step;
        d[i1] = Math.floor(stop * step) / step;
        domain(d);
      }
      return scale;
    };
    return scale;
  }
  function linear$3() {
    var scale = continuous$2(identity$4, identity$4);
    scale.copy = function () {
      return copy$1(scale, linear$3());
    };
    initRange$1.apply(scale, arguments);
    return linearish$1(scale);
  }

  function nice (domain, interval) {
    domain = domain.slice();
    var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;
    if (x1 < x0) {
      t = i0, i0 = i1, i1 = t;
      t = x0, x0 = x1, x1 = t;
    }
    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
  }

  function transformLog(x) {
    return Math.log(x);
  }
  function transformExp(x) {
    return Math.exp(x);
  }
  function transformLogn(x) {
    return -Math.log(-x);
  }
  function transformExpn(x) {
    return -Math.exp(-x);
  }
  function pow10$1(x) {
    return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
  }
  function powp(base) {
    return base === 10 ? pow10$1 : base === Math.E ? Math.exp : function (x) {
      return Math.pow(base, x);
    };
  }
  function logp(base) {
    return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function (x) {
      return Math.log(x) / base;
    });
  }
  function reflect(f) {
    return function (x) {
      return -f(-x);
    };
  }
  function loggish(transform) {
    var scale = transform(transformLog, transformExp),
      domain = scale.domain,
      base = 10,
      logs,
      pows;
    function rescale() {
      logs = logp(base), pows = powp(base);
      if (domain()[0] < 0) {
        logs = reflect(logs), pows = reflect(pows);
        transform(transformLogn, transformExpn);
      } else {
        transform(transformLog, transformExp);
      }
      return scale;
    }
    scale.base = function (_) {
      return arguments.length ? (base = +_, rescale()) : base;
    };
    scale.domain = function (_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale.ticks = function (count) {
      var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;
      if (r = v < u) i = u, u = v, v = i;
      var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];
      if (!(base % 1) && j - i < n) {
        i = Math.round(i) - 1, j = Math.round(j) + 1;
        if (u > 0) for (; i < j; ++i) {
          for (k = 1, p = pows(i); k < base; ++k) {
            t = p * k;
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        } else for (; i < j; ++i) {
          for (k = base - 1, p = pows(i); k >= 1; --k) {
            t = p * k;
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        }
      } else {
        z = ticks$1(i, j, Math.min(j - i, n)).map(pows);
      }
      return r ? z.reverse() : z;
    };
    scale.tickFormat = function (count, specifier) {
      if (specifier == null) specifier = base === 10 ? ".0e" : ",";
      if (typeof specifier !== "function") specifier = format$1(specifier);
      if (count === Infinity) return specifier;
      if (count == null) count = 10;
      var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
      return function (d) {
        var i = d / pows(Math.round(logs(d)));
        if (i * base < base - 0.5) i *= base;
        return i <= k ? specifier(d) : "";
      };
    };
    scale.nice = function () {
      return domain(nice(domain(), {
        floor: function (x) {
          return pows(Math.floor(logs(x)));
        },
        ceil: function (x) {
          return pows(Math.ceil(logs(x)));
        }
      }));
    };
    return scale;
  }
  function log$1() {
    var scale = loggish(transformer$1()).domain([1, 10]);
    scale.copy = function () {
      return copy$1(scale, log$1()).base(scale.base());
    };
    initRange$1.apply(scale, arguments);
    return scale;
  }

  var t0$2 = new Date(),
    t1$2 = new Date();
  function newInterval(floori, offseti, count, field) {
    function interval(date) {
      return floori(date = new Date(+date)), date;
    }
    interval.floor = interval;
    interval.ceil = function (date) {
      return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
    };
    interval.round = function (date) {
      var d0 = interval(date),
        d1 = interval.ceil(date);
      return date - d0 < d1 - date ? d0 : d1;
    };
    interval.offset = function (date, step) {
      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
    };
    interval.range = function (start, stop, step) {
      var range = [],
        previous;
      start = interval.ceil(start);
      step = step == null ? 1 : Math.floor(step);
      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
      do range.push(previous = new Date(+start)), offseti(start, step), floori(start); while (previous < start && start < stop);
      return range;
    };
    interval.filter = function (test) {
      return newInterval(function (date) {
        if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
      }, function (date, step) {
        if (date >= date) {
          if (step < 0) while (++step <= 0) {
            while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
          } else while (--step >= 0) {
            while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
          }
        }
      });
    };

    if (count) {
      interval.count = function (start, end) {
        t0$2.setTime(+start), t1$2.setTime(+end);
        floori(t0$2), floori(t1$2);
        return Math.floor(count(t0$2, t1$2));
      };
      interval.every = function (step) {
        step = Math.floor(step);
        return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function (d) {
          return field(d) % step === 0;
        } : function (d) {
          return interval.count(0, d) % step === 0;
        });
      };
    }
    return interval;
  }

  var millisecond = newInterval(function () {
    // noop
  }, function (date, step) {
    date.setTime(+date + step);
  }, function (start, end) {
    return end - start;
  });

  // An optimized implementation for this simple case.
  millisecond.every = function (k) {
    k = Math.floor(k);
    if (!isFinite(k) || !(k > 0)) return null;
    if (!(k > 1)) return millisecond;
    return newInterval(function (date) {
      date.setTime(Math.floor(date / k) * k);
    }, function (date, step) {
      date.setTime(+date + step * k);
    }, function (start, end) {
      return (end - start) / k;
    });
  };
  millisecond.range;

  var durationSecond$3 = 1e3;
  var durationMinute$3 = 6e4;
  var durationHour$3 = 36e5;
  var durationDay$3 = 864e5;
  var durationWeek$3 = 6048e5;

  var second$1 = newInterval(function (date) {
    date.setTime(Math.floor(date / durationSecond$3) * durationSecond$3);
  }, function (date, step) {
    date.setTime(+date + step * durationSecond$3);
  }, function (start, end) {
    return (end - start) / durationSecond$3;
  }, function (date) {
    return date.getUTCSeconds();
  });
  second$1.range;

  var minute = newInterval(function (date) {
    date.setTime(Math.floor(date / durationMinute$3) * durationMinute$3);
  }, function (date, step) {
    date.setTime(+date + step * durationMinute$3);
  }, function (start, end) {
    return (end - start) / durationMinute$3;
  }, function (date) {
    return date.getMinutes();
  });
  minute.range;

  var hour = newInterval(function (date) {
    var offset = date.getTimezoneOffset() * durationMinute$3 % durationHour$3;
    if (offset < 0) offset += durationHour$3;
    date.setTime(Math.floor((+date - offset) / durationHour$3) * durationHour$3 + offset);
  }, function (date, step) {
    date.setTime(+date + step * durationHour$3);
  }, function (start, end) {
    return (end - start) / durationHour$3;
  }, function (date) {
    return date.getHours();
  });
  hour.range;

  var day = newInterval(function (date) {
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setDate(date.getDate() + step);
  }, function (start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$3) / durationDay$3;
  }, function (date) {
    return date.getDate() - 1;
  });
  day.range;

  function weekday(i) {
    return newInterval(function (date) {
      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
      date.setHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setDate(date.getDate() + step * 7);
    }, function (start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$3) / durationWeek$3;
    });
  }
  var sunday = weekday(0);
  var monday = weekday(1);
  var tuesday = weekday(2);
  var wednesday = weekday(3);
  var thursday = weekday(4);
  var friday = weekday(5);
  var saturday = weekday(6);
  sunday.range;
  monday.range;
  tuesday.range;
  wednesday.range;
  thursday.range;
  friday.range;
  saturday.range;

  var month = newInterval(function (date) {
    date.setDate(1);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setMonth(date.getMonth() + step);
  }, function (start, end) {
    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
  }, function (date) {
    return date.getMonth();
  });
  month.range;

  var year = newInterval(function (date) {
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setFullYear(date.getFullYear() + step);
  }, function (start, end) {
    return end.getFullYear() - start.getFullYear();
  }, function (date) {
    return date.getFullYear();
  });

  // An optimized implementation for this simple case.
  year.every = function (k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
      date.setFullYear(Math.floor(date.getFullYear() / k) * k);
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setFullYear(date.getFullYear() + step * k);
    });
  };
  year.range;

  var utcMinute$1 = newInterval(function (date) {
    date.setUTCSeconds(0, 0);
  }, function (date, step) {
    date.setTime(+date + step * durationMinute$3);
  }, function (start, end) {
    return (end - start) / durationMinute$3;
  }, function (date) {
    return date.getUTCMinutes();
  });
  utcMinute$1.range;

  var utcHour$1 = newInterval(function (date) {
    date.setUTCMinutes(0, 0, 0);
  }, function (date, step) {
    date.setTime(+date + step * durationHour$3);
  }, function (start, end) {
    return (end - start) / durationHour$3;
  }, function (date) {
    return date.getUTCHours();
  });
  utcHour$1.range;

  var utcDay$2 = newInterval(function (date) {
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCDate(date.getUTCDate() + step);
  }, function (start, end) {
    return (end - start) / durationDay$3;
  }, function (date) {
    return date.getUTCDate() - 1;
  });
  utcDay$2.range;

  function utcWeekday$2(i) {
    return newInterval(function (date) {
      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
      date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setUTCDate(date.getUTCDate() + step * 7);
    }, function (start, end) {
      return (end - start) / durationWeek$3;
    });
  }
  var utcSunday$2 = utcWeekday$2(0);
  var utcMonday$2 = utcWeekday$2(1);
  var utcTuesday$2 = utcWeekday$2(2);
  var utcWednesday$2 = utcWeekday$2(3);
  var utcThursday$2 = utcWeekday$2(4);
  var utcFriday$2 = utcWeekday$2(5);
  var utcSaturday$2 = utcWeekday$2(6);
  utcSunday$2.range;
  utcMonday$2.range;
  utcTuesday$2.range;
  utcWednesday$2.range;
  utcThursday$2.range;
  utcFriday$2.range;
  utcSaturday$2.range;

  var utcMonth$1 = newInterval(function (date) {
    date.setUTCDate(1);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCMonth(date.getUTCMonth() + step);
  }, function (start, end) {
    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
  }, function (date) {
    return date.getUTCMonth();
  });
  utcMonth$1.range;

  var utcYear$2 = newInterval(function (date) {
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step);
  }, function (start, end) {
    return end.getUTCFullYear() - start.getUTCFullYear();
  }, function (date) {
    return date.getUTCFullYear();
  });

  // An optimized implementation for this simple case.
  utcYear$2.every = function (k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
      date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step * k);
    });
  };
  utcYear$2.range;

  function localDate$1(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
      date.setFullYear(d.y);
      return date;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
  }
  function utcDate$1(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      date.setUTCFullYear(d.y);
      return date;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  }
  function newYear(y) {
    return {
      y: y,
      m: 0,
      d: 1,
      H: 0,
      M: 0,
      S: 0,
      L: 0
    };
  }
  function formatLocale$2(locale) {
    var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;
    var periodRe = formatRe$1(locale_periods),
      periodLookup = formatLookup$1(locale_periods),
      weekdayRe = formatRe$1(locale_weekdays),
      weekdayLookup = formatLookup$1(locale_weekdays),
      shortWeekdayRe = formatRe$1(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup$1(locale_shortWeekdays),
      monthRe = formatRe$1(locale_months),
      monthLookup = formatLookup$1(locale_months),
      shortMonthRe = formatRe$1(locale_shortMonths),
      shortMonthLookup = formatLookup$1(locale_shortMonths);
    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday,
      "b": formatShortMonth,
      "B": formatMonth,
      "c": null,
      "d": formatDayOfMonth$1,
      "e": formatDayOfMonth$1,
      "f": formatMicroseconds$1,
      "H": formatHour24$1,
      "I": formatHour12$1,
      "j": formatDayOfYear$1,
      "L": formatMilliseconds$1,
      "m": formatMonthNumber$1,
      "M": formatMinutes$1,
      "p": formatPeriod,
      "Q": formatUnixTimestamp$1,
      "s": formatUnixTimestampSeconds$1,
      "S": formatSeconds$1,
      "u": formatWeekdayNumberMonday$1,
      "U": formatWeekNumberSunday$1,
      "V": formatWeekNumberISO$1,
      "w": formatWeekdayNumberSunday$1,
      "W": formatWeekNumberMonday$1,
      "x": null,
      "X": null,
      "y": formatYear$1,
      "Y": formatFullYear$1,
      "Z": formatZone$1,
      "%": formatLiteralPercent$1
    };
    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth$1,
      "e": formatUTCDayOfMonth$1,
      "f": formatUTCMicroseconds$1,
      "H": formatUTCHour24$1,
      "I": formatUTCHour12$1,
      "j": formatUTCDayOfYear$1,
      "L": formatUTCMilliseconds$1,
      "m": formatUTCMonthNumber$1,
      "M": formatUTCMinutes$1,
      "p": formatUTCPeriod,
      "Q": formatUnixTimestamp$1,
      "s": formatUnixTimestampSeconds$1,
      "S": formatUTCSeconds$1,
      "u": formatUTCWeekdayNumberMonday$1,
      "U": formatUTCWeekNumberSunday$1,
      "V": formatUTCWeekNumberISO$1,
      "w": formatUTCWeekdayNumberSunday$1,
      "W": formatUTCWeekNumberMonday$1,
      "x": null,
      "X": null,
      "y": formatUTCYear$1,
      "Y": formatUTCFullYear$1,
      "Z": formatUTCZone$1,
      "%": formatLiteralPercent$1
    };
    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth$1,
      "e": parseDayOfMonth$1,
      "f": parseMicroseconds$1,
      "H": parseHour24$1,
      "I": parseHour24$1,
      "j": parseDayOfYear$1,
      "L": parseMilliseconds$1,
      "m": parseMonthNumber$1,
      "M": parseMinutes$1,
      "p": parsePeriod,
      "Q": parseUnixTimestamp$1,
      "s": parseUnixTimestampSeconds$1,
      "S": parseSeconds$1,
      "u": parseWeekdayNumberMonday$1,
      "U": parseWeekNumberSunday$1,
      "V": parseWeekNumberISO$1,
      "w": parseWeekdayNumberSunday$1,
      "W": parseWeekNumberMonday$1,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear$1,
      "Y": parseFullYear$1,
      "Z": parseZone$1,
      "%": parseLiteralPercent$1
    };

    // These recursive directive definitions must be deferred.
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);
    function newFormat(specifier, formats) {
      return function (date) {
        var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;
        if (!(date instanceof Date)) date = new Date(+date);
        while (++i < n) {
          if (specifier.charCodeAt(i) === 37) {
            string.push(specifier.slice(j, i));
            if ((pad = pads$1[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);else pad = c === "e" ? " " : "0";
            if (format = formats[c]) c = format(date, pad);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(specifier.slice(j, i));
        return string.join("");
      };
    }
    function newParse(specifier, newDate) {
      return function (string) {
        var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week,
          day$1;
        if (i != string.length) return null;

        // If a UNIX timestamp is specified, return it.
        if ("Q" in d) return new Date(d.Q);

        // The am-pm flag is 0 for AM, and 1 for PM.
        if ("p" in d) d.H = d.H % 12 + d.p * 12;

        // Convert day-of-week and week-of-year to day-of-year.
        if ("V" in d) {
          if (d.V < 1 || d.V > 53) return null;
          if (!("w" in d)) d.w = 1;
          if ("Z" in d) {
            week = utcDate$1(newYear(d.y)), day$1 = week.getUTCDay();
            week = day$1 > 4 || day$1 === 0 ? utcMonday$2.ceil(week) : utcMonday$2(week);
            week = utcDay$2.offset(week, (d.V - 1) * 7);
            d.y = week.getUTCFullYear();
            d.m = week.getUTCMonth();
            d.d = week.getUTCDate() + (d.w + 6) % 7;
          } else {
            week = newDate(newYear(d.y)), day$1 = week.getDay();
            week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
            week = day.offset(week, (d.V - 1) * 7);
            d.y = week.getFullYear();
            d.m = week.getMonth();
            d.d = week.getDate() + (d.w + 6) % 7;
          }
        } else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
          day$1 = "Z" in d ? utcDate$1(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
          d.m = 0;
          d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
        }

        // If a time zone is specified, all fields are interpreted as UTC and then
        // offset according to the specified time zone.
        if ("Z" in d) {
          d.H += d.Z / 100 | 0;
          d.M += d.Z % 100;
          return utcDate$1(d);
        }

        // Otherwise, all fields are in local time.
        return newDate(d);
      };
    }
    function parseSpecifier(d, specifier, string, j) {
      var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;
      while (i < n) {
        if (j >= m) return -1;
        c = specifier.charCodeAt(i++);
        if (c === 37) {
          c = specifier.charAt(i++);
          parse = parses[c in pads$1 ? specifier.charAt(i++) : c];
          if (!parse || (j = parse(d, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    function parsePeriod(d, string, i) {
      var n = periodRe.exec(string.slice(i));
      return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }
    function parseShortWeekday(d, string, i) {
      var n = shortWeekdayRe.exec(string.slice(i));
      return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }
    function parseWeekday(d, string, i) {
      var n = weekdayRe.exec(string.slice(i));
      return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }
    function parseShortMonth(d, string, i) {
      var n = shortMonthRe.exec(string.slice(i));
      return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }
    function parseMonth(d, string, i) {
      var n = monthRe.exec(string.slice(i));
      return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }
    function parseLocaleDateTime(d, string, i) {
      return parseSpecifier(d, locale_dateTime, string, i);
    }
    function parseLocaleDate(d, string, i) {
      return parseSpecifier(d, locale_date, string, i);
    }
    function parseLocaleTime(d, string, i) {
      return parseSpecifier(d, locale_time, string, i);
    }
    function formatShortWeekday(d) {
      return locale_shortWeekdays[d.getDay()];
    }
    function formatWeekday(d) {
      return locale_weekdays[d.getDay()];
    }
    function formatShortMonth(d) {
      return locale_shortMonths[d.getMonth()];
    }
    function formatMonth(d) {
      return locale_months[d.getMonth()];
    }
    function formatPeriod(d) {
      return locale_periods[+(d.getHours() >= 12)];
    }
    function formatUTCShortWeekday(d) {
      return locale_shortWeekdays[d.getUTCDay()];
    }
    function formatUTCWeekday(d) {
      return locale_weekdays[d.getUTCDay()];
    }
    function formatUTCShortMonth(d) {
      return locale_shortMonths[d.getUTCMonth()];
    }
    function formatUTCMonth(d) {
      return locale_months[d.getUTCMonth()];
    }
    function formatUTCPeriod(d) {
      return locale_periods[+(d.getUTCHours() >= 12)];
    }
    return {
      format: function (specifier) {
        var f = newFormat(specifier += "", formats);
        f.toString = function () {
          return specifier;
        };
        return f;
      },
      parse: function (specifier) {
        var p = newParse(specifier += "", localDate$1);
        p.toString = function () {
          return specifier;
        };
        return p;
      },
      utcFormat: function (specifier) {
        var f = newFormat(specifier += "", utcFormats);
        f.toString = function () {
          return specifier;
        };
        return f;
      },
      utcParse: function (specifier) {
        var p = newParse(specifier, utcDate$1);
        p.toString = function () {
          return specifier;
        };
        return p;
      }
    };
  }
  var pads$1 = {
      "-": "",
      "_": " ",
      "0": "0"
    },
    numberRe$1 = /^\s*\d+/,
    // note: ignores next directive
    percentRe$1 = /^%/,
    requoteRe$1 = /[\\^$*+?|[\]().{}]/g;
  function pad$4(value, fill, width) {
    var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  function requote$1(s) {
    return s.replace(requoteRe$1, "\\$&");
  }
  function formatRe$1(names) {
    return new RegExp("^(?:" + names.map(requote$1).join("|") + ")", "i");
  }
  function formatLookup$1(names) {
    var map = {},
      i = -1,
      n = names.length;
    while (++i < n) map[names[i].toLowerCase()] = i;
    return map;
  }
  function parseWeekdayNumberSunday$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i, i + 1));
    return n ? (d.w = +n[0], i + n[0].length) : -1;
  }
  function parseWeekdayNumberMonday$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i, i + 1));
    return n ? (d.u = +n[0], i + n[0].length) : -1;
  }
  function parseWeekNumberSunday$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i, i + 2));
    return n ? (d.U = +n[0], i + n[0].length) : -1;
  }
  function parseWeekNumberISO$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i, i + 2));
    return n ? (d.V = +n[0], i + n[0].length) : -1;
  }
  function parseWeekNumberMonday$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i, i + 2));
    return n ? (d.W = +n[0], i + n[0].length) : -1;
  }
  function parseFullYear$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i, i + 4));
    return n ? (d.y = +n[0], i + n[0].length) : -1;
  }
  function parseYear$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i, i + 2));
    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
  }
  function parseZone$1(d, string, i) {
    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
  }
  function parseMonthNumber$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i, i + 2));
    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
  }
  function parseDayOfMonth$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i, i + 2));
    return n ? (d.d = +n[0], i + n[0].length) : -1;
  }
  function parseDayOfYear$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i, i + 3));
    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
  }
  function parseHour24$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i, i + 2));
    return n ? (d.H = +n[0], i + n[0].length) : -1;
  }
  function parseMinutes$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i, i + 2));
    return n ? (d.M = +n[0], i + n[0].length) : -1;
  }
  function parseSeconds$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i, i + 2));
    return n ? (d.S = +n[0], i + n[0].length) : -1;
  }
  function parseMilliseconds$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i, i + 3));
    return n ? (d.L = +n[0], i + n[0].length) : -1;
  }
  function parseMicroseconds$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i, i + 6));
    return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
  }
  function parseLiteralPercent$1(d, string, i) {
    var n = percentRe$1.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function parseUnixTimestamp$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i));
    return n ? (d.Q = +n[0], i + n[0].length) : -1;
  }
  function parseUnixTimestampSeconds$1(d, string, i) {
    var n = numberRe$1.exec(string.slice(i));
    return n ? (d.Q = +n[0] * 1000, i + n[0].length) : -1;
  }
  function formatDayOfMonth$1(d, p) {
    return pad$4(d.getDate(), p, 2);
  }
  function formatHour24$1(d, p) {
    return pad$4(d.getHours(), p, 2);
  }
  function formatHour12$1(d, p) {
    return pad$4(d.getHours() % 12 || 12, p, 2);
  }
  function formatDayOfYear$1(d, p) {
    return pad$4(1 + day.count(year(d), d), p, 3);
  }
  function formatMilliseconds$1(d, p) {
    return pad$4(d.getMilliseconds(), p, 3);
  }
  function formatMicroseconds$1(d, p) {
    return formatMilliseconds$1(d, p) + "000";
  }
  function formatMonthNumber$1(d, p) {
    return pad$4(d.getMonth() + 1, p, 2);
  }
  function formatMinutes$1(d, p) {
    return pad$4(d.getMinutes(), p, 2);
  }
  function formatSeconds$1(d, p) {
    return pad$4(d.getSeconds(), p, 2);
  }
  function formatWeekdayNumberMonday$1(d) {
    var day = d.getDay();
    return day === 0 ? 7 : day;
  }
  function formatWeekNumberSunday$1(d, p) {
    return pad$4(sunday.count(year(d), d), p, 2);
  }
  function formatWeekNumberISO$1(d, p) {
    var day = d.getDay();
    d = day >= 4 || day === 0 ? thursday(d) : thursday.ceil(d);
    return pad$4(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
  }
  function formatWeekdayNumberSunday$1(d) {
    return d.getDay();
  }
  function formatWeekNumberMonday$1(d, p) {
    return pad$4(monday.count(year(d), d), p, 2);
  }
  function formatYear$1(d, p) {
    return pad$4(d.getFullYear() % 100, p, 2);
  }
  function formatFullYear$1(d, p) {
    return pad$4(d.getFullYear() % 10000, p, 4);
  }
  function formatZone$1(d) {
    var z = d.getTimezoneOffset();
    return (z > 0 ? "-" : (z *= -1, "+")) + pad$4(z / 60 | 0, "0", 2) + pad$4(z % 60, "0", 2);
  }
  function formatUTCDayOfMonth$1(d, p) {
    return pad$4(d.getUTCDate(), p, 2);
  }
  function formatUTCHour24$1(d, p) {
    return pad$4(d.getUTCHours(), p, 2);
  }
  function formatUTCHour12$1(d, p) {
    return pad$4(d.getUTCHours() % 12 || 12, p, 2);
  }
  function formatUTCDayOfYear$1(d, p) {
    return pad$4(1 + utcDay$2.count(utcYear$2(d), d), p, 3);
  }
  function formatUTCMilliseconds$1(d, p) {
    return pad$4(d.getUTCMilliseconds(), p, 3);
  }
  function formatUTCMicroseconds$1(d, p) {
    return formatUTCMilliseconds$1(d, p) + "000";
  }
  function formatUTCMonthNumber$1(d, p) {
    return pad$4(d.getUTCMonth() + 1, p, 2);
  }
  function formatUTCMinutes$1(d, p) {
    return pad$4(d.getUTCMinutes(), p, 2);
  }
  function formatUTCSeconds$1(d, p) {
    return pad$4(d.getUTCSeconds(), p, 2);
  }
  function formatUTCWeekdayNumberMonday$1(d) {
    var dow = d.getUTCDay();
    return dow === 0 ? 7 : dow;
  }
  function formatUTCWeekNumberSunday$1(d, p) {
    return pad$4(utcSunday$2.count(utcYear$2(d), d), p, 2);
  }
  function formatUTCWeekNumberISO$1(d, p) {
    var day = d.getUTCDay();
    d = day >= 4 || day === 0 ? utcThursday$2(d) : utcThursday$2.ceil(d);
    return pad$4(utcThursday$2.count(utcYear$2(d), d) + (utcYear$2(d).getUTCDay() === 4), p, 2);
  }
  function formatUTCWeekdayNumberSunday$1(d) {
    return d.getUTCDay();
  }
  function formatUTCWeekNumberMonday$1(d, p) {
    return pad$4(utcMonday$2.count(utcYear$2(d), d), p, 2);
  }
  function formatUTCYear$1(d, p) {
    return pad$4(d.getUTCFullYear() % 100, p, 2);
  }
  function formatUTCFullYear$1(d, p) {
    return pad$4(d.getUTCFullYear() % 10000, p, 4);
  }
  function formatUTCZone$1() {
    return "+0000";
  }
  function formatLiteralPercent$1() {
    return "%";
  }
  function formatUnixTimestamp$1(d) {
    return +d;
  }
  function formatUnixTimestampSeconds$1(d) {
    return Math.floor(+d / 1000);
  }

  var locale$1;
  var utcFormat;
  var utcParse;
  defaultLocale$1({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });
  function defaultLocale$1(definition) {
    locale$1 = formatLocale$2(definition);
    locale$1.format;
    locale$1.parse;
    utcFormat = locale$1.utcFormat;
    utcParse = locale$1.utcParse;
    return locale$1;
  }

  var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
  function formatIsoNative(date) {
    return date.toISOString();
  }
  Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

  function parseIsoNative(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  }
  +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

  var durationSecond$2 = 1000,
    durationMinute$2 = durationSecond$2 * 60,
    durationHour$2 = durationMinute$2 * 60,
    durationDay$2 = durationHour$2 * 24,
    durationWeek$2 = durationDay$2 * 7,
    durationMonth = durationDay$2 * 30,
    durationYear = durationDay$2 * 365;
  function date$1(t) {
    return new Date(t);
  }
  function number$3(t) {
    return t instanceof Date ? +t : +new Date(+t);
  }
  function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
    var scale = continuous$2(identity$4, identity$4),
      invert = scale.invert,
      domain = scale.domain;
    var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");
    var tickIntervals = [[second, 1, durationSecond$2], [second, 5, 5 * durationSecond$2], [second, 15, 15 * durationSecond$2], [second, 30, 30 * durationSecond$2], [minute, 1, durationMinute$2], [minute, 5, 5 * durationMinute$2], [minute, 15, 15 * durationMinute$2], [minute, 30, 30 * durationMinute$2], [hour, 1, durationHour$2], [hour, 3, 3 * durationHour$2], [hour, 6, 6 * durationHour$2], [hour, 12, 12 * durationHour$2], [day, 1, durationDay$2], [day, 2, 2 * durationDay$2], [week, 1, durationWeek$2], [month, 1, durationMonth], [month, 3, 3 * durationMonth], [year, 1, durationYear]];
    function tickFormat(date) {
      return (second(date) < date ? formatMillisecond : minute(date) < date ? formatSecond : hour(date) < date ? formatMinute : day(date) < date ? formatHour : month(date) < date ? week(date) < date ? formatDay : formatWeek : year(date) < date ? formatMonth : formatYear)(date);
    }
    function tickInterval(interval, start, stop, step) {
      if (interval == null) interval = 10;

      // If a desired tick count is specified, pick a reasonable tick interval
      // based on the extent of the domain and a rough estimate of tick size.
      // Otherwise, assume interval is already a time interval and use it.
      if (typeof interval === "number") {
        var target = Math.abs(stop - start) / interval,
          i = bisector$1(function (i) {
            return i[2];
          }).right(tickIntervals, target);
        if (i === tickIntervals.length) {
          step = tickStep$1(start / durationYear, stop / durationYear, interval);
          interval = year;
        } else if (i) {
          i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
          step = i[1];
          interval = i[0];
        } else {
          step = Math.max(tickStep$1(start, stop, interval), 1);
          interval = millisecond;
        }
      }
      return step == null ? interval : interval.every(step);
    }
    scale.invert = function (y) {
      return new Date(invert(y));
    };
    scale.domain = function (_) {
      return arguments.length ? domain(map$1.call(_, number$3)) : domain().map(date$1);
    };
    scale.ticks = function (interval, step) {
      var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
      if (r) t = t0, t0 = t1, t1 = t;
      t = tickInterval(interval, t0, t1, step);
      t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
      return r ? t.reverse() : t;
    };
    scale.tickFormat = function (count, specifier) {
      return specifier == null ? tickFormat : format(specifier);
    };
    scale.nice = function (interval, step) {
      var d = domain();
      return (interval = tickInterval(interval, d[0], d[d.length - 1], step)) ? domain(nice(d, interval)) : scale;
    };
    scale.copy = function () {
      return copy$1(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
    };
    return scale;
  }

  function d3ScaleTime () {
    return initRange$1.apply(calendar(utcYear$2, utcMonth$1, utcSunday$2, utcDay$2, utcHour$1, utcMinute$1, second$1, millisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
  }

  // eslint-disable-next-line import/prefer-default-export
  function d3Nice(min, max, count) {
    const scale = linear$3().domain([min, max]);
    scale.nice(count);
    return scale;
  }

  const BOX_SHADOW_ALPHA = 0.0625;
  const EPSILON$6 = 1e-15;
  const PROPERTIES = {
    horizontal: {
      major: 'width',
      minor: 'height',
      start: 'left',
      end: 'right',
      shadow: {
        startOffset: '12px 0',
        endOffset: '-12px 0'
      }
    },
    vertical: {
      major: 'height',
      minor: 'width',
      start: 'top',
      end: 'bottom',
      shadow: {
        startOffset: '0 12px',
        endOffset: '0 -12px'
      }
    }
  };
  const getBoxShadow = offset => `${offset} 12px -12px inset rgba(0, 0, 0, ${BOX_SHADOW_ALPHA})`;
  const getStyles = orientation => {
    const property = PROPERTIES[orientation];
    return {
      base: {
        position: 'absolute',
        [property.major]: 12,
        [property.minor]: '100%'
      },
      towardsStart: {
        [property.start]: 0,
        [property.end]: 'auto',
        boxShadow: getBoxShadow(property.shadow.startOffset)
      },
      towardsEnd: {
        [property.start]: 'auto',
        [property.end]: 0,
        boxShadow: getBoxShadow(property.shadow.endOffset)
      }
    };
  };
  var scrollHintComponent = {
    defaultSettings: {
      settings: {
        orientation: 'horizontal',
        rtl: false,
        range: () => [0, 1]
      }
    },
    renderer: 'dom',
    render(h) {
      const {
        range,
        orientation,
        rtl
      } = this.settings.settings;
      const [start, end] = range();
      const atStart = Math.abs(start) < EPSILON$6;
      const atEnd = Math.abs(end - 1) < EPSILON$6;
      const styles = getStyles(orientation);
      const invert = orientation === 'horizontal' && rtl;
      const children = [];
      if (!atStart) {
        children.push(h('div', {
          style: {
            ...styles.base,
            ...(invert ? styles.towardsEnd : styles.towardsStart)
          },
          class: 'scroll-hint--towards-start'
        }));
      }
      if (!atEnd) {
        children.push(h('div', {
          style: {
            ...styles.base,
            ...(invert ? styles.towardsStart : styles.towardsEnd)
          },
          class: 'scroll-hint--towards-end'
        }));
      }
      return children;
    }
  };

  function fromZoom$1(viewState, viewCache) {
    const z = viewState.get('zoom');
    const min = viewCache.get('continuousMin');
    const max = viewCache.get('continuousMax');
    const start = (z.min - min) / (max - min);
    const end = (z.max - min) / (max - min);
    return [start, end];
  }
  function fromViewRange$1(viewState) {
    return viewState.get('viewRange');
  }
  function range$3({
    layoutService,
    viewState,
    viewCache
  }) {
    return layoutService.meta.isContinuous ? fromZoom$1(viewState, viewCache) : fromViewRange$1(viewState);
  }

  function scrollHint({
    viewState,
    viewCache,
    layoutService,
    dockService,
    rtl
  }) {
    if (layoutService.meta.isSnapshot) {
      return false;
    }
    return {
      key: 'scroll-hint',
      type: 'scroll-hint',
      settings: {
        orientation: dockService.meta.major.orientation,
        rtl,
        range: () => range$3({
          layoutService,
          viewState,
          viewCache
        })
      }
    };
  }

  let dummyContext;
  function setDummyContext() {
    dummyContext = dummyContext || document.createElement('canvas').getContext('2d');
  }
  const defaultEllipsis = '…';
  const defaultHyphen = '-';
  const textHelper = {
    measureTextWidth(text) {
      setDummyContext();
      const {
        width
      } = dummyContext.measureText(text);
      return width;
    },
    lineWrap(text, width, font, maxNumLines) {
      // wrap text at white space
      setDummyContext();
      let n;
      let r;
      const textLines = text ? text.split(/\n+|\r+|\r\n/) : [];
      const lines = [];
      let testLine;
      let testWidth;
      let words = text ? text.split(/\s+/) : [];
      let line = textLines[0];
      let remainder;
      let textLine;
      if (typeof width !== 'number' || width <= 0) {
        return [text];
      }
      if (typeof maxNumLines === 'number' && textLines.length >= maxNumLines) {
        return textLines.slice(0, maxNumLines);
      }
      if (font) {
        dummyContext.font = font;
      }
      for (r = 0; r < textLines.length; r++) {
        textLine = textLines[r] || '';
        words = textLine.split(/\s+/);
        [line] = words;
        remainder = '';
        for (n = 1; n < words.length; n++) {
          testLine = `${line} ${words[n]}`;
          testWidth = textHelper.measureTextWidth(testLine);
          if (testWidth > width && (typeof maxNumLines !== 'number' || maxNumLines > lines.length)) {
            lines.push(line);
            line = words[n];
          } else {
            line = testLine;
          }
          if (typeof maxNumLines === 'number' && lines.length >= maxNumLines) {
            remainder = words.slice(n + 1).join(' ');
            break;
          }
        }
        if (typeof maxNumLines !== 'number' || lines.length < maxNumLines) {
          lines.push(line);
        } else {
          lines[Math.max(0, lines.length - 1)] = `${lines[Math.max(0, lines.length - 1)] || ''} ${line} ${remainder}`;
        }
      }
      return lines;
    },
    wordWrap(lines, width, font, maxNumLines, ellipsis) {
      setDummyContext();
      if (!lines || !lines.length) {
        return [];
      }
      if (font) {
        dummyContext.font = font;
      }
      let result = [];
      const cLines = lines.slice();
      let exploded;
      let remainder;
      let line;
      let i;
      cLines.filter(s => !!s);
      if (typeof width !== 'number' || width < 0) {
        return lines.slice();
      }
      for (i = 0; i < cLines.length; i++) {
        line = cLines[i];
        remainder = null;
        if (line) {
          if (line.length <= 1 || textHelper.measureTextWidth(line) <= width) {
            result.push(line);
          } else {
            exploded = textHelper.splitWord(line, width, undefined, maxNumLines - result.length);
            if (exploded.length <= 1) {
              // could not shorten current line -> add it to results
              result.push(exploded[0]);
            } else {
              remainder = exploded.pop(); // last element could be longer than width limit
              result = result.concat(exploded);
              if (cLines[i + 1]) {
                // add remainder to next line
                if (textHelper.measureTextWidth(`${remainder} ${cLines[i + 1]}`) > width && result.length + cLines.length - i <= maxNumLines) {
                  // If adding to the next line will force that to break as well and we are not close to the max limit, then create a new line inbetween instead
                  cLines.splice(i + 1, 0, remainder);
                } else {
                  cLines[i + 1] = `${remainder} ${cLines[i + 1]}`;
                }
              } else {
                // TODO - safeguard against endless loop (mek)
                cLines.push(remainder);
              }
            }
          }
        }
      }
      result.forEach((s, k, arr) => {
        // eslint-disable-next-line no-param-reassign
        arr[k] = s ? s.trim() : s;
      });
      if (result.length > maxNumLines) {
        result = result.splice(0, maxNumLines); // if more lines than allowed, truncate the last line
        result[result.length - 1] = textHelper.truncate(result[result.length - 1], width, font, ellipsis).text;
      } else {
        // truncate last line only if that line does not fit
        line = result[result.length - 1];
        if (line && line.length > 1 && textHelper.measureTextWidth(line) > width) {
          result[result.length - 1] = textHelper.truncate(line, width, font, ellipsis).text;
        }
      }
      return result;
    },
    /**
     * Truncates a single line of text if the text does not fit inside the given width.
     * @param text
     * @param {Number} width
     * @param {String} font
     * @returns {{text: String, rest: String}}
     */
    truncate(text, width, font, ellipsis = defaultEllipsis) {
      setDummyContext();
      let s = text;
      let i;
      let temp;
      let tempEllipsis;
      let rest;
      const minCharWidth = textHelper.measureTextWidth('i');
      const maxNumLetters = Math.ceil(width / minCharWidth);
      if (font) {
        dummyContext.font = font;
      }
      if (!text || !width) {
        rest = undefined;
      } else if (textHelper.measureTextWidth(s) > width) {
        for (i = Math.min(maxNumLetters, s.length); i > 0; i--) {
          temp = s.substring(0, i - 1);
          tempEllipsis = temp.trim() + ellipsis;
          if (textHelper.measureTextWidth(tempEllipsis) <= width) {
            rest = s.substring(i - 1);
            s = tempEllipsis;
            break;
          }
        }
        if (!i) {
          rest = s;
          s = defaultEllipsis;
        }
      }
      return {
        text: s,
        rest
      };
    },
    isNumber(v) {
      return typeof v === 'number' && Number.isFinite(v);
    },
    /**
     * Splits a word into parts <= width .
     * @ignore
     * @param text
     * @param width
     * @param maxNumLines
     */
    explodeWord(text, width, maxNumLines, charWidth) {
      setDummyContext();
      let i;
      let left = text;
      let right = '';
      let lastChar;
      let result = [];
      if (textHelper.isNumber(maxNumLines) && maxNumLines <= 1) {
        return [text];
      }
      const maxNumChars = Math.ceil(width / charWidth);
      const num = Math.min(text.length, maxNumChars);
      for (i = num; i > 0; i--) {
        left = text.substring(0, i);
        lastChar = text.substring(i - 1, i);
        // When remainder is added to a new line there is a chance of breaking at a space
        if (lastChar === ' ') {
          left = text.substring(0, i - 1);
        } else {
          left += defaultHyphen;
        }
        right = text.substring(i);
        if (textHelper.measureTextWidth(left) <= width) {
          break;
        }
      }
      if (!i && !left || textHelper.measureTextWidth(left) > width) {
        left = text.substring(0, 1);
        right = text.substring(1);
      }
      result.push(left);
      if (!right) {
        return result;
      }
      if (textHelper.measureTextWidth(right) > width) {
        right = textHelper.explodeWord(right, width, maxNumLines - 1, charWidth);
        result = result.concat(right);
      } else {
        result.push(right);
      }
      // Remove any spaces added by the remainder
      return result.filter(item => item.trim() !== '');
    },
    splitWord(text, width, font, maxNumLines) {
      setDummyContext();
      if (!text || !width) {
        return [];
      }
      if (font) {
        dummyContext.font = font;
      }
      return textHelper.explodeWord(text, width, maxNumLines, Math.max(1, textHelper.measureTextWidth('i')));
    },
    wrapText(text, maxWidth, font, maxNumLines, ellipsis) {
      let lines;
      if (Number.isNaN(maxWidth)) {
        return [text];
      }
      lines = maxNumLines > 1 ? textHelper.lineWrap(text, maxWidth, font, maxNumLines) : [text];
      lines = textHelper.wordWrap(lines, maxWidth, font, maxNumLines, ellipsis);
      return lines;
    },
    getFontHeight(font) {
      setDummyContext();
      if (font) {
        dummyContext.font = font;
      }
      return textHelper.measureTextWidth('m') * 1.5;
    },
    tokenize(text, font, ellipsis, maxNumLines, maxWidth, maxHeight, lineHeightMultiplicator = 1) {
      setDummyContext();
      if (font) {
        dummyContext.font = font;
      }
      const fontHeight = textHelper.getFontHeight();
      const lineHeight = lineHeightMultiplicator * fontHeight;
      let maxLines = [];
      let totalMaxNumLines = 0;
      let lines = [];
      if (maxHeight < fontHeight) {
        return [];
      }
      const maxAllowedLines = maxHeight ? Math.max(1, Math.floor(maxHeight / lineHeight)) : maxNumLines || 1;
      if (Array.isArray(maxNumLines)) {
        maxNumLines.forEach(v => {
          totalMaxNumLines += Number.isNaN(v) || v <= 0 ? 0 : v;
        });
        maxNumLines.forEach(v => {
          maxLines.push(Number.isNaN(v) || v <= 0 ? maxAllowedLines - totalMaxNumLines : v); // if v < 0 then use the number of lines that are available
        });
      } else {
        maxLines = [Number.isNaN(maxNumLines) || maxNumLines <= 0 ? maxAllowedLines : Math.min(maxAllowedLines, maxNumLines)];
      }
      if (Array.isArray(text)) {
        text.forEach((s, i) => {
          if (lines.length < maxAllowedLines) {
            lines = lines.concat(textHelper.wrapText(s, maxWidth, font, maxLines[i]));
          }
        });
      } else {
        lines = textHelper.wrapText(text, maxWidth, font, maxLines[0], ellipsis);
      }
      return lines;
    }
  };

  const OOB_SIZE = 10;
  const oobHelper = {
    getDefaultSettings({
      size = OOB_SIZE,
      fill = '#999',
      alignment
    } = {}) {
      return {
        /** Whether or not to show the out-of-bounds
         * @type {function|boolean=} */
        show: true,
        type: 'n-polygon',
        /** Fill color
         * @type {datum-string=} */
        fill,
        /** Stroke color
         * @type {datum-string=} */
        stroke: '#000',
        /** Stroke width
         * @type {datum-number=} */
        strokeWidth: 0,
        /** Size of the component
         * @type {number=} */
        size,
        sides: 3,
        startAngle: -90,
        alignment
      };
    },
    /**
     * Out of bounds shape
     * @param {object} params parameters
     * @param {object} params.item Resolved styling item from box component with item.major
     * @param {number} params.dockValue 0 or 1 depending on where to render the oob shape
     * @param {number} params.boxWidth Un-calculated box width in relative/normalized format
     * @param {number} params.boxPadding Un-calculated box padding in relative/normalized format
     * @param {number} params.rendWidth The pixel width of the area to render upon
     * @param {number} params.rendHeight The pixel height of the area to render upon
     * @param {boolean} params.flipXY Wether or not to flip X and Y coordinates together with Width and Height
     * @param {function} params.symbol Symbol library function from component
     * @ignore
     */
    createOob({
      oob,
      dockValue,
      boxCenter,
      rendWidth,
      rendHeight,
      flipXY,
      symbol
    }) {
      let x = 'x';
      let y = 'y';
      let calcwidth = rendWidth;
      let calcheight = rendHeight;
      let startAngle = dockValue < 0.5 ? 90 : -90;
      if (flipXY) {
        x = 'y';
        y = 'x';
        calcwidth = rendHeight;
        calcheight = rendWidth;
        startAngle = dockValue < 0.5 ? 180 : 0;
      }
      return symbol(extend$7({}, oob, {
        [x]: boxCenter * calcwidth,
        [y]: Math.max(oob.size / 2, Math.min(dockValue * calcheight, calcheight - oob.size / 2)),
        startAngle
      }));
    }
  };

  /* eslint no-param-reassign: 0, no-restricted-globals: 0 */
  const extend$3 = extend$7.bind(null, true);
  const JSONPatch = {};
  const {
    isArray: isArray$2
  } = Array;
  function isObject$1(v) {
    return v != null && !Array.isArray(v) && typeof v === 'object';
  }
  function isUndef(v) {
    return typeof v === 'undefined';
  }
  function isFunction(v) {
    return typeof v === 'function';
  }

  /**
   * Generate an exact duplicate (with no references) of a specific value.
   *
   * @private
   * @param {Object} The value to duplicate
   * @returns {Object} a unique, duplicated value
   */
  function generateValue(val) {
    if (val) {
      return extend$3({}, {
        val
      }).val;
    }
    return val;
  }

  /**
   * An additional type checker used to determine if the property is of internal
   * use or not a type that can be translated into JSON (like functions).
   *
   * @private
   * @param {Object} obj The object which has the property to check
   * @param {String} The property name to check
   * @returns {Boolean} Whether the property is deemed special or not
   */
  function isSpecialProperty(obj, key) {
    return isFunction(obj[key]) || key.substring(0, 2) === '$$' || key.substring(0, 1) === '_';
  }

  /**
   * Finds the parent object from a JSON-Pointer ("/foo/bar/baz" = "bar" is "baz" parent),
   * also creates the object structure needed.
   *
   * @private
   * @param {Object} data The root object to traverse through
   * @param {String} The JSON-Pointer string to use when traversing
   * @returns {Object} The parent object
   */
  function getParent(data, str) {
    const seperator = '/';
    const parts = str.substring(1).split(seperator).slice(0, -1);
    let numPart;
    parts.forEach((part, i) => {
      if (i === parts.length) {
        return;
      }
      numPart = +part;
      const newPart = !isNaN(numPart) ? [] : {};
      data[numPart || part] = isUndef(data[numPart || part]) ? newPart : data[part];
      data = data[numPart || part];
    });
    return data;
  }

  /**
   * Cleans an object of all its properties, unless they're deemed special or
   * cannot be removed by configuration.
   *
   * @private
   * @param {Object} obj The object to clean
   */
  function emptyObject(obj) {
    Object.keys(obj).forEach(key => {
      const config = Object.getOwnPropertyDescriptor(obj, key);
      if (config.configurable && !isSpecialProperty(obj, key)) {
        delete obj[key];
      }
    });
  }

  /**
   * Compare an object with another, could be object, array, number, string, bool.
   *
   * @param {Object} a The first object to compare
   * @param {Object} a The second object to compare
   * @returns {Boolean} Whether the objects are identical
   */
  function compare(a, b) {
    let isIdentical = true;
    if (isObject$1(a) && isObject$1(b)) {
      if (Object.keys(a).length !== Object.keys(b).length) {
        return false;
      }
      Object.keys(a).forEach(key => {
        if (!compare(a[key], b[key])) {
          isIdentical = false;
        }
      });
      return isIdentical;
    }
    if (isArray$2(a) && isArray$2(b)) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0, l = a.length; i < l; i += 1) {
        if (!compare(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    return a === b;
  }

  /**
   * Generates patches by comparing two arrays.
   *
   * @private
   * @param {Array} oldA The old (original) array, which will be patched
   * @param {Array} newA The new array, which will be used to compare against
   * @returns {Array} An array of patches (if any)
   */
  function patchArray(original, newA, basePath) {
    let patches = [];
    const oldA = original.slice();
    let tmpIdx = -1;
    function findIndex(a, id, idx) {
      if (a[idx] && isUndef(a[idx].qInfo)) {
        return null;
      }
      if (a[idx] && a[idx].qInfo.qId === id) {
        // shortcut if identical
        return idx;
      }
      for (let ii = 0, ll = a.length; ii < ll; ii += 1) {
        if (a[ii] && a[ii].qInfo.qId === id) {
          return ii;
        }
      }
      return -1;
    }
    if (compare(newA, oldA)) {
      // array is unchanged
      return patches;
    }
    if (!isUndef(newA[0]) && isUndef(newA[0].qInfo) || newA.length === 0) {
      // we cannot create patches without unique identifiers, replace array...
      patches.push({
        op: 'replace',
        path: basePath,
        value: newA
      });
      return patches;
    }
    for (let i = oldA.length - 1; i >= 0; i -= 1) {
      tmpIdx = findIndex(newA, oldA[i].qInfo && oldA[i].qInfo.qId, i);
      if (tmpIdx === -1) {
        patches.push({
          op: 'remove',
          path: `${basePath}/${i}`
        });
        oldA.splice(i, 1);
      } else {
        patches = patches.concat(JSONPatch.generate(oldA[i], newA[tmpIdx], `${basePath}/${i}`));
      }
    }
    for (let i = 0, l = newA.length; i < l; i += 1) {
      tmpIdx = findIndex(oldA, newA[i].qInfo && newA[i].qInfo.qId);
      if (tmpIdx === -1) {
        patches.push({
          op: 'add',
          path: `${basePath}/${i}`,
          value: newA[i]
        });
        oldA.splice(i, 0, newA[i]);
      } else if (tmpIdx !== i) {
        patches.push({
          op: 'move',
          path: `${basePath}/${i}`,
          from: `${basePath}/${tmpIdx}`
        });
        oldA.splice(i, 0, oldA.splice(tmpIdx, 1)[0]);
      }
    }
    return patches;
  }

  /**
   * Generate an array of JSON-Patch:es following the JSON-Patch Specification Draft.
   *
   * See [specification draft](http://tools.ietf.org/html/draft-ietf-appsawg-json-patch-10)
   *
   * Does NOT currently generate patches for arrays (will replace them)
   *
   * @param {Object} original The object to patch to
   * @param {Object} newData The object to patch from
   * @param {String} [basePath] The base path to use when generating the paths for
   *                            the patches (normally not used)
   * @returns {Array} An array of patches
   */
  JSONPatch.generate = function generate(original, newData, basePath) {
    basePath = basePath || '';
    let patches = [];
    Object.keys(newData).forEach(key => {
      const val = generateValue(newData[key]);
      const oldVal = original[key];
      const tmpPath = `${basePath}/${key}`;
      if (compare(val, oldVal) || isSpecialProperty(newData, key)) {
        return;
      }
      if (isUndef(oldVal)) {
        // property does not previously exist
        patches.push({
          op: 'add',
          path: tmpPath,
          value: val
        });
      } else if (isObject$1(val) && isObject$1(oldVal)) {
        // we need to generate sub-patches for this, since it already exist
        patches = patches.concat(JSONPatch.generate(oldVal, val, tmpPath));
      } else if (isArray$2(val) && isArray$2(oldVal)) {
        patches = patches.concat(patchArray(oldVal, val, tmpPath));
      } else {
        // it's a simple property (bool, string, number)
        patches.push({
          op: 'replace',
          path: `${basePath}/${key}`,
          value: val
        });
      }
    });
    Object.keys(original).forEach(key => {
      if (isUndef(newData[key]) && !isSpecialProperty(original, key)) {
        // this property does not exist anymore
        patches.push({
          op: 'remove',
          path: `${basePath}/${key}`
        });
      }
    });
    return patches;
  };

  /**
   * Apply a list of patches to an object.
   *
   * @param {Object} original The object to patch
   * @param {Array} patches The list of patches to apply
   */
  JSONPatch.apply = function apply(original, patches) {
    patches.forEach(patch => {
      let parent = getParent(original, patch.path);
      let key = patch.path.split('/').splice(-1)[0];
      let target = key && isNaN(+key) ? parent[key] : parent[+key] || parent;
      const from = patch.from ? patch.from.split('/').splice(-1)[0] : null;
      if (patch.path === '/') {
        parent = null;
        target = original;
      }
      if (patch.op === 'add' || patch.op === 'replace') {
        if (isArray$2(parent)) {
          // trust indexes from patches, so don't replace the index if it's an add
          if (key === '-') {
            key = parent.length;
          }
          parent.splice(+key, patch.op === 'add' ? 0 : 1, patch.value);
        } else if (isArray$2(target) && isArray$2(patch.value)) {
          const newValues = patch.value.slice();
          // keep array reference if possible...
          target.length = 0;
          target.push(...newValues);
        } else if (isObject$1(target) && isObject$1(patch.value)) {
          // keep object reference if possible...
          emptyObject(target);
          extend$3(target, patch.value);
        } else if (!parent) {
          throw new Error('Patchee is not an object we can patch');
        } else {
          // simple value
          parent[key] = patch.value;
        }
      } else if (patch.op === 'move') {
        const oldParent = getParent(original, patch.from);
        if (isArray$2(parent)) {
          parent.splice(+key, 0, oldParent.splice(+from, 1)[0]);
        } else {
          parent[key] = oldParent[from];
          delete oldParent[from];
        }
      } else if (patch.op === 'remove') {
        if (isArray$2(parent)) {
          parent.splice(+key, 1);
        } else {
          delete parent[key];
        }
      }
    });
  };

  /**
   * Deep clone an object.
   *
   * @param {Object} obj The object to clone
   * @returns {Object} A new object identical to the `obj`
   */
  JSONPatch.clone = function clone(obj) {
    return extend$3({}, obj);
  };

  /**
   * Creates a JSON-patch.
   *
   * @param {String} op The operation of the patch. Available values: "add", "remove", "move"
   * @param {Object} [val] The value to set the `path` to. If `op` is `move`, `val`
   *                       is the "from JSON-path" path
   * @param {String} path The JSON-path for the property to change (e.g. "/qHyperCubeDef/columnOrder")
   * @returns {Object} A patch following the JSON-patch specification
   */
  JSONPatch.createPatch = function createPatch(op, val, path) {
    const patch = {
      op: op.toLowerCase(),
      path
    };
    if (patch.op === 'move') {
      patch.from = val;
    } else if (typeof val !== 'undefined') {
      patch.value = val;
    }
    return patch;
  };

  /**
   * Apply the differences of two objects (keeping references if possible).
   * Identical to running `JSONPatch.apply(original, JSONPatch.generate(original, newData));`
   *
   * @param {Object} original The object to update/patch
   * @param {Object} newData the object to diff against
   *
   * @example
   * var obj1 = { foo: [1,2,3], bar: { baz: true, qux: 1 } };
   * var obj2 = { foo: [4,5,6], bar: { baz: false } };
   * JSONPatch.updateObject(obj1, obj2);
   * // => { foo: [4,5,6], bar: { baz: false } };
   */
  JSONPatch.updateObject = function updateObject(original, newData) {
    if (!Object.keys(original).length) {
      extend$3(original, newData);
      return;
    }
    JSONPatch.apply(original, JSONPatch.generate(original, newData));
  };

  const log10$1 = Math.log(10);
  const epsilon$3 = 1e-12;
  function pow10(n) {
    return 10 ** n;
  }
  const NumberUtils = {
    pow10,
    log(value, base) {
      if (value <= 0 || base <= 0) {
        return NaN;
      }
      return Math.log(value) / Math.log(base);
    },
    log10(value) {
      if (value <= 0) {
        return NaN;
      }
      return Math.log(value) / log10$1;
    },
    eliminateFloatingError(value) {
      const round = Math.round(value);
      if (Math.abs(value - round) < epsilon$3) {
        return round;
      }
      return value;
    },
    /*
     * Returns a nice round number based on the magnitude of the given value and number of tick intervals.
     * Inspired by the article "Nice Number for Graph Labels" by Paul S. Heckbert.
     */
    getNiceNumber(value) {
      let roundedFraction;
      if (value === 0) {
        return 0;
      }
      const magnitude = Math.floor(Math.log(Math.abs(value)) / log10$1);
      const fraction = value / pow10(magnitude);
      if (fraction <= 1) {
        roundedFraction = 1;
      } else if (fraction <= 2) {
        roundedFraction = 2;
      } else if (fraction <= 5) {
        roundedFraction = 5;
      } else {
        roundedFraction = 10;
      }
      return roundedFraction * pow10(magnitude) * (value < 0 ? -1 : 1);
    },
    getSmallNiceNumber(value) {
      let magnitudeOrder;
      let roundedFraction;
      if (value === 0) {
        return 0;
      }
      magnitudeOrder = Math.floor(Math.log(Math.abs(value)) / log10$1);
      const fraction = value / pow10(magnitudeOrder);
      if (fraction < 1) {
        roundedFraction = 5;
        magnitudeOrder--;
      } else if (fraction < 2) {
        roundedFraction = 1;
      } else if (fraction < 5) {
        roundedFraction = 2;
      } else {
        roundedFraction = 5;
      }
      return roundedFraction * pow10(magnitudeOrder) * (value < 0 ? -1 : 1);
    },
    getMagnitude(value) {
      if (value === 0) {
        return 0;
      }
      const magnitude = Math.floor(Math.log(Math.abs(value)) / log10$1);
      return pow10(magnitude);
    },
    getFraction(value) {
      if (value === 0) {
        return 0;
      }
      const magnitude = Math.floor(Math.log(Math.abs(value)) / log10$1);
      return value / pow10(magnitude);
    },
    getGoodNumber(value) {
      let roundedFraction;
      if (value === 0) {
        return 0;
      }
      const magnitudeOrder = Math.floor(Math.log(Math.abs(value)) / log10$1);
      const fraction = value / pow10(magnitudeOrder);
      roundedFraction = Math.ceil(fraction);
      if (roundedFraction === 7 || roundedFraction === 9) {
        roundedFraction++;
      }
      if (fraction > 1 && fraction <= 1.5) {
        roundedFraction = 1.5;
      } else if (fraction > 2 && fraction <= 2.5) {
        roundedFraction = 2.5;
      }
      return roundedFraction * pow10(magnitudeOrder) * (value < 0 ? -1 : 1);
    },
    getValueWithOffset(value, offset = 0) {
      return value + Math.abs(value) * offset;
    },
    isNumber(v) {
      return typeof v === 'number' && !Number.isNaN(v);
    }
  };

  /* eslint-disable no-param-reassign */
  function fixMinusZero(tickModel) {
    if (tickModel.max === 0) {
      tickModel.max = 0;
    }
    if (tickModel.min === 0) {
      tickModel.min = 0;
    }
    if (tickModel.tickBaseValue === 0) {
      tickModel.tickBaseValue = 0;
    }
  }
  function calculateForOutOfRangeCase1(tickModel) {
    let min;
    const magnitude = tickModel.explicitMax === 0 ? 1 : NumberUtils.getMagnitude(tickModel.explicitMax);
    const max = tickModel.explicitMax;
    if (tickModel.maxNumIntervals < 2) {
      min = max - magnitude;
    } else {
      min = max - 2 * magnitude;
    }
    min = Math.ceil(min / magnitude) * magnitude;
    const range = max - min;
    tickModel.tickDataSpacing = Math.max(range / tickModel.maxNumIntervals, tickModel.minTickDataSpacing);
    tickModel.tickSpacing = Math.max(magnitude / 10, NumberUtils.getNiceNumber(tickModel.tickDataSpacing));
    tickModel.max = max;
    tickModel.min = min;
    tickModel.range = range;
    if (tickModel.maxNumIntervals < 1) {
      tickModel.tickBaseValue = tickModel.min;
    }
  }
  function calculateForOutOfRangeCase2(tickModel) {
    let max;
    const magnitude = tickModel.explicitMin === 0 ? 1 : NumberUtils.getMagnitude(tickModel.explicitMin);
    const min = tickModel.explicitMin;
    if (tickModel.maxNumIntervals < 2) {
      max = min + magnitude;
    } else {
      max = min + 2 * magnitude;
    }
    max = Math.floor(max / magnitude) * magnitude;
    const range = max - min;
    tickModel.tickDataSpacing = Math.max(range / tickModel.maxNumIntervals, tickModel.minTickDataSpacing);
    tickModel.tickSpacing = Math.max(magnitude / 10, NumberUtils.getNiceNumber(tickModel.tickDataSpacing));
    tickModel.max = max;
    tickModel.min = min;
    tickModel.range = range;
    if (tickModel.maxNumIntervals < 1) {
      tickModel.tickBaseValue = tickModel.max - tickModel.tickSpacing;
    }
  }
  function calculateForOutOfRangeCase(tickModel) {
    if (tickModel.explicitMax !== null && tickModel.explicitMax < tickModel.usedDataMin) {
      calculateForOutOfRangeCase1(tickModel);
    } else if (tickModel.explicitMin !== null && tickModel.explicitMin > tickModel.usedDataMax) {
      calculateForOutOfRangeCase2(tickModel);
    }
  }
  function calculateForSameMaxMinCase1(tickModel) {
    tickModel.tickBaseValue = tickModel.usedDataMin;
    tickModel.min = tickModel.usedDataMin;
    tickModel.max = tickModel.usedDataMin;
    tickModel.range = 0;
    tickModel.tickSpacing = tickModel.usedDataMin === 0 ? 1 : Math.abs(tickModel.usedDataMin);
    tickModel.tickDataSpacing = tickModel.tickSpacing;
    tickModel.tickMinIndex = 0;
    tickModel.tickMaxIndex = 0;
  }
  function calculateMaxMinAndTickBase(value, numIntervals) {
    const magnitude = NumberUtils.getMagnitude(value);
    const k = value / magnitude;
    const m = Math.floor(k);
    const n = Math.round(k);
    let min;
    let max;
    let tickBaseValue = 0;
    if (numIntervals < 2) {
      min = m * magnitude;
      max = (m + 1) * magnitude;
      if (numIntervals < 1) {
        tickBaseValue = min;
      }
    } else {
      min = (n - 1) * magnitude;
      max = (n + 1) * magnitude;
    }
    return {
      min,
      max,
      tickBaseValue,
      magnitude
    };
  }
  function calculateForSameMaxMinCase2(tickModel) {
    if (tickModel.usedDataMax === 0) {
      if (tickModel.maxNumIntervals < 2) {
        tickModel.min = 0;
        tickModel.max = 1;
      } else {
        tickModel.min = -1;
        tickModel.max = 1;
      }
      tickModel.range = tickModel.max - tickModel.min;
      tickModel.tickDataSpacing = Math.max(tickModel.range / tickModel.maxNumIntervals, tickModel.minTickDataSpacing);
      tickModel.tickSpacing = Math.max(0.1, NumberUtils.getNiceNumber(tickModel.tickDataSpacing));
      tickModel.tickMinIndex = Math.ceil(tickModel.min / tickModel.tickSpacing);
      tickModel.tickMaxIndex = Math.floor(tickModel.max / tickModel.tickSpacing);
    } else {
      const tickBase = calculateMaxMinAndTickBase(Math.abs(tickModel.usedDataMax), tickModel.maxNumIntervals);
      if (tickModel.usedDataMax > 0) {
        tickModel.max = tickBase.max;
        tickModel.min = tickBase.min;
        tickModel.tickBaseValue = tickBase.tickBaseValue;
      } else {
        tickModel.max = -tickBase.min;
        tickModel.min = -tickBase.max;
        tickModel.tickBaseValue = -tickBase.tickBaseValue;
      }
      tickModel.range = tickModel.max - tickModel.min;
      tickModel.tickDataSpacing = Math.max(tickModel.range / tickModel.maxNumIntervals, tickModel.minTickDataSpacing);
      tickModel.tickSpacing = Math.max(tickBase.magnitude / 10, NumberUtils.getNiceNumber(tickModel.tickDataSpacing));
      tickModel.tickMinIndex = Math.floor((tickModel.min - tickModel.tickBaseValue) / tickModel.tickSpacing);
      tickModel.tickMaxIndex = Math.floor((tickModel.max - tickModel.tickBaseValue) / tickModel.tickSpacing);
    }
  }
  function calculateForSameMaxMinCase3(tickModel) {
    if (tickModel.explicitMax === 0) {
      tickModel.max = 0;
      tickModel.min = -1;
      tickModel.range = tickModel.max - tickModel.min;
      tickModel.tickSpacing = Math.max(0.1, NumberUtils.getNiceNumber(tickModel.range / tickModel.maxNumIntervals));
    } else {
      calculateForOutOfRangeCase1(tickModel);
    }
  }
  function calculateForSameMaxMinCase4(tickModel) {
    if (tickModel.explicitMin === 0) {
      tickModel.max = 1;
      tickModel.min = 0;
      tickModel.range = tickModel.max - tickModel.min;
      tickModel.tickSpacing = Math.max(0.1, NumberUtils.getNiceNumber(tickModel.range / tickModel.maxNumIntervals));
    } else {
      calculateForOutOfRangeCase2(tickModel);
    }
  }
  function calculateForSameMaxMinCase(tickModel) {
    if (tickModel.explicitMin !== null && tickModel.explicitMax !== null) {
      calculateForSameMaxMinCase1(tickModel);
    } else if (tickModel.explicitMin === null && tickModel.explicitMax === null) {
      calculateForSameMaxMinCase2(tickModel);
    } else if (tickModel.explicitMin === null && tickModel.explicitMax !== null) {
      calculateForSameMaxMinCase3(tickModel);
    } else {
      calculateForSameMaxMinCase4(tickModel);
    }
  }
  function calculateTickMaxMinIndices({
    tickModel,
    minIsStrict,
    maxIsStrict
  }) {
    if (minIsStrict === undefined) {
      minIsStrict = tickModel.explicitMin !== null;
    }
    if (maxIsStrict === undefined) {
      maxIsStrict = tickModel.explicitMax !== null;
    }
    tickModel.tickMinIndex = minIsStrict ? Math.ceil(tickModel.usedDataMin / tickModel.tickSpacing) : Math.floor(tickModel.usedDataMin / tickModel.tickSpacing);
    tickModel.tickMaxIndex = maxIsStrict ? Math.floor(tickModel.usedDataMax / tickModel.tickSpacing) : Math.ceil(tickModel.usedDataMax / tickModel.tickSpacing);
    tickModel.min = minIsStrict ? tickModel.usedDataMin : tickModel.tickMinIndex * tickModel.tickSpacing;
    tickModel.max = maxIsStrict ? tickModel.usedDataMax : tickModel.tickMaxIndex * tickModel.tickSpacing;
    tickModel.range = tickModel.max - tickModel.min;
  }
  function calculateForSimpleCase({
    tickModel,
    minIsStrict,
    maxIsStrict,
    usingGoodNumber
  }) {
    tickModel.tickSpacing = usingGoodNumber ? NumberUtils.getGoodNumber(tickModel.tickDataSpacing) : NumberUtils.getNiceNumber(tickModel.tickDataSpacing);
    calculateTickMaxMinIndices({
      tickModel,
      minIsStrict,
      maxIsStrict
    });
  }
  function calculateForNormalCase(tickModel) {
    let range;
    let spaceConditionFailed;
    calculateForSimpleCase({
      tickModel
    });
    const numIntervals = tickModel.tickMaxIndex - tickModel.tickMinIndex;
    range = (tickModel.plotMaxCanBeTuned ? tickModel.usedDataMax : tickModel.max) - (tickModel.plotMinCanBeTuned ? tickModel.usedDataMin : tickModel.min);
    tickModel.spaceUseFactor = range / tickModel.range;
    spaceConditionFailed = tickModel.size * tickModel.tickSpacing / tickModel.range < tickModel.minTickSpacingInPixel || tickModel.spaceOptimizingEnabled && tickModel.spaceUseFactor < tickModel.spaceUseLimit;
    if (spaceConditionFailed && tickModel.maxNumIntervals >= 5) {
      while (tickModel.tickDataSpacing <= tickModel.absMax && spaceConditionFailed) {
        tickModel.tickDataSpacing = Math.max(tickModel.tickSpacing * 1.1, tickModel.minTickDataSpacing);
        calculateForSimpleCase({
          tickModel
        });
        range = (tickModel.plotMaxCanBeTuned ? tickModel.usedDataMax : tickModel.max) - (tickModel.plotMinCanBeTuned ? tickModel.usedDataMin : tickModel.min);
        tickModel.spaceUseFactor = range / tickModel.range;
        spaceConditionFailed = tickModel.size * tickModel.tickSpacing / tickModel.range < tickModel.minTickSpacingInPixel || tickModel.spaceOptimizingEnabled && tickModel.spaceUseFactor < tickModel.spaceUseLimit;
      }
      if (!spaceConditionFailed) {
        return;
      }
    }
    // after the step above if the constraint is still not met so continue with next step
    tickModel.tickDataSpacing = Math.max(tickModel.usedDataRange / tickModel.maxNumIntervals, tickModel.minTickDataSpacing);
    if (spaceConditionFailed || numIntervals <= 2 && tickModel.maxNumIntervals >= 2 * numIntervals) {
      calculateForSimpleCase({
        tickModel,
        usingGoodNumber: true
      });
    }
    range = (tickModel.plotMaxCanBeTuned ? tickModel.usedDataMax : tickModel.max) - (tickModel.plotMinCanBeTuned ? tickModel.usedDataMin : tickModel.min);
    tickModel.spaceUseFactor = range / tickModel.range;
    spaceConditionFailed = tickModel.size * tickModel.tickSpacing / tickModel.range < tickModel.minTickSpacingInPixel || tickModel.spaceOptimizingEnabled && tickModel.spaceUseFactor < tickModel.spaceUseLimit;
    while (tickModel.tickDataSpacing <= tickModel.absMax && spaceConditionFailed) {
      tickModel.tickDataSpacing = Math.max(tickModel.tickSpacing * 1.1, tickModel.minTickDataSpacing);
      calculateForSimpleCase({
        tickModel,
        usingGoodNumber: true
      });
      range = (tickModel.plotMaxCanBeTuned ? tickModel.usedDataMax : tickModel.max) - (tickModel.plotMinCanBeTuned ? tickModel.usedDataMin : tickModel.min);
      tickModel.spaceUseFactor = range / tickModel.range;
      spaceConditionFailed = tickModel.size * tickModel.tickSpacing / tickModel.range < tickModel.minTickSpacingInPixel || tickModel.spaceOptimizingEnabled && tickModel.spaceUseFactor < tickModel.spaceUseLimit;
    }
  }
  function calculateForMaxPositiveMinNegativeCase({
    tickModel,
    useGoodNumber
  }) {
    if (useGoodNumber) {
      tickModel.tickSpacing = NumberUtils.getGoodNumber(tickModel.absMax);
      tickModel.tickBaseValue = -tickModel.tickSpacing;
      tickModel.min = tickModel.explicitMin === null ? -tickModel.tickSpacing : tickModel.explicitMin;
      tickModel.max = tickModel.explicitMax === null ? tickModel.tickSpacing : tickModel.explicitMax;
      tickModel.tickMinIndex = tickModel.explicitMin === null ? 0 : 1;
      tickModel.tickMaxIndex = tickModel.explicitMax === null ? 1 : 1;
      tickModel.tickSpacing *= 2;
    } else {
      tickModel.max = tickModel.usedDataMax;
      tickModel.min = tickModel.usedDataMin;
      tickModel.range = tickModel.max - tickModel.min;
      tickModel.tickMinIndex = 0;
      tickModel.tickMaxIndex = 0;
      tickModel.tickSpacing = NumberUtils.getNiceNumber(tickModel.absMax);
      if (tickModel.tickSpacing === tickModel.absMax) {
        tickModel.tickSpacing = NumberUtils.getNiceNumber(tickModel.absMax * 1.1);
      }
    }
  }
  function calculateForSpecialCase1(tickModel) {
    let temp;
    tickModel.tickSpacing = NumberUtils.getNiceNumber(tickModel.tickDataSpacing);
    tickModel.min = tickModel.usedDataMin;
    tickModel.max = tickModel.usedDataMax;
    tickModel.range = tickModel.max - tickModel.min;
    tickModel.tickMinIndex = 0;
    tickModel.tickMaxIndex = 0;
    if (tickModel.usedDataMax < 0 || tickModel.usedDataMin > 0) {
      temp = NumberUtils.getSmallNiceNumber(tickModel.range);
      tickModel.tickBaseValue = Math.ceil(tickModel.min / temp) * temp;
    }
  }
  function calculateForSpecialCase2(tickModel) {
    // 1 < tickModel.maxNumIntervals < 2 && tickModel.usedDataMax > 0 > tickModel.usedDataMin
    const c = tickModel.usedDataMax >= -tickModel.usedDataMin;
    const minIsStrict = c || tickModel.explicitMin !== null;
    const maxIsStrict = !c || tickModel.explicitMax !== null;
    calculateForSimpleCase({
      tickModel,
      minIsStrict,
      maxIsStrict,
      usingGoodNumber: true
    });
    const maxDataSpacing = (tickModel.absMax + (1 - tickModel.spaceUseLimit) * tickModel.absMin) / tickModel.spaceUseLimit * 1.0001;
    while (tickModel.tickDataSpacing <= maxDataSpacing && tickModel.size * tickModel.tickSpacing / tickModel.range < tickModel.minTickSpacingInPixel) {
      tickModel.tickDataSpacing = Math.max(tickModel.tickSpacing * 1.1, tickModel.minTickDataSpacing);
      calculateForSimpleCase({
        tickModel,
        minIsStrict,
        maxIsStrict,
        usingGoodNumber: true
      });
    }
    const range = (tickModel.plotMaxCanBeTuned ? tickModel.usedDataMax : tickModel.max) - (tickModel.plotMinCanBeTuned ? tickModel.usedDataMin : tickModel.min);
    tickModel.spaceUseFactor = range / tickModel.range;
    if (tickModel.spaceOptimizingEnabled && tickModel.spaceUseFactor < tickModel.spaceUseLimit) {
      calculateForMaxPositiveMinNegativeCase({
        tickModel
      });
    }
  }
  function calculateForSpecialCase3(tickModel) {
    // 2 <= tickModel.maxNumIntervals < 5 && tickModel.usedDataMax > 0 > tickModel.usedDataMin
    calculateForNormalCase(tickModel);
    const range = (tickModel.plotMaxCanBeTuned ? tickModel.usedDataMax : tickModel.max) - (tickModel.plotMinCanBeTuned ? tickModel.usedDataMin : tickModel.min);
    tickModel.spaceUseFactor = range / tickModel.range;
    if (tickModel.spaceOptimizingEnabled && tickModel.spaceUseFactor < tickModel.spaceUseLimit) {
      tickModel.tickDataSpacing = Math.max(tickModel.usedDataRange / tickModel.maxNumIntervals, tickModel.minTickDataSpacing);
      calculateForSpecialCase2(tickModel);
    }
  }
  function refineTickDataSpacing(tickModel) {
    const nn = NumberUtils.getNiceNumber(tickModel.tickSpacing);
    if (tickModel.tickSpacing === nn || tickModel.tickBaseValue !== 0) {
      return;
    }
    const oldTickDataSpacingNN = tickModel.tickSpacing;
    const oldTickMinIndex = tickModel.tickMinIndex;
    const oldTickMaxIndex = tickModel.tickMaxIndex;
    const oldNumIntervals = oldTickMaxIndex - oldTickMinIndex;
    const oldPlotMin = tickModel.min;
    const oldPlotMax = tickModel.max;
    tickModel.tickSpacing = nn;
    calculateTickMaxMinIndices({
      tickModel
    });
    const range = (tickModel.plotMaxCanBeTuned ? tickModel.usedDataMax : tickModel.max) - (tickModel.plotMinCanBeTuned ? tickModel.usedDataMin : tickModel.min);
    tickModel.spaceUseFactor = range / tickModel.range;
    const spaceConditionFailed = tickModel.size * tickModel.tickSpacing / tickModel.range < tickModel.minTickSpacingInPixel || tickModel.spaceOptimizingEnabled && tickModel.spaceUseFactor < tickModel.spaceUseLimit;
    const numIntervals = tickModel.tickMaxIndex - tickModel.tickMinIndex;
    if (!spaceConditionFailed && (numIntervals === oldNumIntervals || numIntervals >= 10 || numIntervals >= 3 && numIntervals * 1.5 >= oldNumIntervals)) {
      return;
    }
    tickModel.tickSpacing = oldTickDataSpacingNN;
    tickModel.tickMinIndex = oldTickMinIndex;
    tickModel.tickMaxIndex = oldTickMaxIndex;
    tickModel.min = oldPlotMin;
    tickModel.max = oldPlotMax;
    tickModel.range = tickModel.max - tickModel.min;
  }
  function calculateMaxMinTickValues(tickModel) {
    if (!tickModel.niceNumberEnabled || tickModel.max === tickModel.min || tickModel.size === 0) {
      tickModel.minTickValue = tickModel.min;
      tickModel.maxTickValue = tickModel.max;
    } else {
      tickModel.minTickValue = tickModel.tickBaseValue + tickModel.tickMinIndex * tickModel.tickSpacing;
      tickModel.maxTickValue = tickModel.tickBaseValue + tickModel.tickMaxIndex * tickModel.tickSpacing;
    }
  }
  function calculateTickValues$1(tickModel) {
    let startValue;
    let i;
    tickModel.values = [];
    tickModel.secondaryValues = [];
    calculateMaxMinTickValues(tickModel);
    if (tickModel.size === 0) {
      return;
    }
    if (!tickModel.niceNumberEnabled) {
      tickModel.numIntervals = Math.floor(tickModel.maxNumIntervals);
      tickModel.tickDataSpacing = Math.max(tickModel.usedDataRange / tickModel.numIntervals, tickModel.minTickDataSpacing);
      startValue = tickModel.usedDataMin;
      for (i = 0; i <= tickModel.numIntervals; i++) {
        tickModel.values.push(startValue + i * tickModel.tickDataSpacing);
      }
      startValue = tickModel.usedDataMin + tickModel.tickDataSpacing / 2;
      for (i = 0; i < tickModel.numIntervals; i++) {
        tickModel.secondaryValues.push(startValue + i * tickModel.tickDataSpacing);
      }
      return;
    }
    startValue = tickModel.tickBaseValue;
    const range = tickModel.tickMaxIndex - tickModel.tickMinIndex;
    if (range < 1) {
      tickModel.values.push(startValue);
      return;
    }
    for (i = 0; i <= range; i++) {
      tickModel.values.push(startValue + (i + tickModel.tickMinIndex) * tickModel.tickSpacing);
    }
    startValue = tickModel.tickBaseValue + tickModel.tickSpacing / 2;
    for (i = 0; i < range; i++) {
      tickModel.secondaryValues.push(startValue + (i + tickModel.tickMinIndex) * tickModel.tickSpacing);
    }
  }
  function updatePlotMin(tickModel) {
    let min;
    let range;
    let s;
    let i;
    const fractions = [1 / 2];
    const tickMin = tickModel.values[0];
    for (i = 0; i < fractions.length; i++) {
      min = tickMin - tickModel.tickSpacing * fractions[i];
      range = tickModel.max - min;
      s = tickModel.size * tickModel.tickSpacing / range;
      if (s > 3 * tickModel.fontHeight) {
        tickModel.min = min;
        tickModel.range = range;
        tickModel.values.splice(0, 0, min);
        return;
      }
    }
  }
  function updatePlotMax(tickModel) {
    let max;
    let range;
    let s;
    let i;
    const fractions = [1 / 2];
    const tickMax = tickModel.values[tickModel.values.length - 1];
    for (i = 0; i < fractions.length; i++) {
      max = tickMax + tickModel.tickSpacing * fractions[i];
      range = max - tickModel.min;
      s = tickModel.size * tickModel.tickSpacing / range;
      if (s > 3 * tickModel.fontHeight) {
        tickModel.max = max;
        tickModel.range = range;
        tickModel.values.push(max);
        return;
      }
    }
  }
  function addMainExtraTicksIfNeeded(tickModel) {
    const oldPlotMin = tickModel.min;
    const oldPlotMax = tickModel.max;
    const oldTickMinIndex = tickModel.tickMinIndex;
    const oldTickMaxIndex = tickModel.tickMaxIndex;
    const oldTickDataSpacing = tickModel.tickSpacing;
    const oldNumIntervals = tickModel.tickMaxIndex - tickModel.tickMinIndex;
    const minTickSpacingInPixel = tickModel.fontHeight * 2;
    const numTicks = tickModel.values ? tickModel.values.length : 0;
    const tickMin = tickModel.values[0];
    const tickMax = tickModel.values[numTicks - 1];
    let cont = true;
    let newNumIntervals = oldNumIntervals;
    let numIntervals;
    let numLoops;
    if (tickModel.explicitMin === null && tickMin > tickModel.dataMin) {
      newNumIntervals++;
    }
    if (tickModel.explicitMax === null && tickMax < tickModel.dataMax) {
      newNumIntervals++;
    }
    if (newNumIntervals === oldNumIntervals) {
      return;
    }
    numLoops = 0;
    while (cont && numLoops < 10) {
      tickModel.tickSpacing = NumberUtils.getSmallNiceNumber(tickModel.tickSpacing * 0.99);
      calculateTickMaxMinIndices({
        tickModel
      });
      numIntervals = tickModel.tickMaxIndex - tickModel.tickMinIndex;
      if (numIntervals > newNumIntervals) {
        cont = false;
      }
      numLoops++;
    }
    cont = true;
    numLoops = 0;
    while (tickModel.tickSpacing < oldTickDataSpacing && cont && numLoops < 10) {
      tickModel.tickSpacing = NumberUtils.getGoodNumber(tickModel.tickSpacing * 1.1);
      calculateTickMaxMinIndices({
        tickModel
      });
      numIntervals = tickModel.tickMaxIndex - tickModel.tickMinIndex;
      if (numIntervals === newNumIntervals && tickModel.size * tickModel.tickSpacing / tickModel.range > minTickSpacingInPixel) {
        cont = false;
      }
      numLoops++;
    }
    if (cont) {
      tickModel.min = oldPlotMin;
      tickModel.max = oldPlotMax;
      tickModel.tickMinIndex = oldTickMinIndex;
      tickModel.tickMaxIndex = oldTickMaxIndex;
      tickModel.tickSpacing = oldTickDataSpacing;
    } else {
      calculateTickValues$1(tickModel);
    }
  }
  function addSubExtraTicksIfNeeded(tickModel) {
    const numTicks = tickModel.values ? tickModel.values.length : 0;
    const tickMin = tickModel.values[0];
    const tickMax = tickModel.values[numTicks - 1];
    if (tickModel.explicitMin === null && tickMin > tickModel.dataMin && tickModel.explicitMax === null && tickMax < tickModel.dataMax) {
      if (Math.abs(tickModel.dataMin) <= Math.abs(tickModel.dataMax)) {
        updatePlotMin(tickModel);
        updatePlotMax(tickModel);
      } else {
        updatePlotMax(tickModel);
        updatePlotMin(tickModel);
      }
    } else if (tickModel.explicitMin === null && tickMin > tickModel.dataMin) {
      updatePlotMin(tickModel);
    } else if (tickModel.explicitMax === null && tickMax < tickModel.dataMax) {
      updatePlotMax(tickModel);
    }
  }
  const ScaleUtils = {
    calculateTicks({
      size,
      dataMin,
      dataMax,
      explicitMin,
      explicitMax,
      minTickSpacingInPixel,
      fontHeight,
      niceNumberEnabled = true,
      spaceOptimizingEnabled = true,
      spaceUseLimit = 0.6,
      tickMinMaxCoverDataMinMax = true,
      minTickDataSpacing
    }) {
      let temp;
      let outOfRangeCase = false;
      if (Number.isNaN(+explicitMin)) {
        explicitMin = null;
      }
      if (Number.isNaN(+explicitMax)) {
        explicitMax = null;
      }
      if (dataMin > dataMax) {
        temp = dataMin;
        dataMin = dataMax;
        dataMax = temp;
      }
      if (explicitMin !== null && explicitMax !== null && explicitMin > explicitMax) {
        temp = explicitMin;
        explicitMin = explicitMax;
        explicitMax = temp;
      }
      minTickDataSpacing = minTickDataSpacing || 0;
      const minIsStrict = explicitMin !== null;
      const maxIsStrict = explicitMax !== null;
      const usedDataMin = minIsStrict ? explicitMin : dataMin;
      const usedDataMax = maxIsStrict ? explicitMax : dataMax;
      const usedDataRange = usedDataMax - usedDataMin;
      const maxNumIntervals = size / minTickSpacingInPixel;
      const maxNumTicks = maxNumIntervals + 1;
      const tickDataSpacing = Math.max(usedDataRange / maxNumIntervals, minTickDataSpacing);
      const tickModel = {
        size,
        dataMin,
        dataMax,
        explicitMin,
        explicitMax,
        minIsStrict,
        maxIsStrict,
        usedDataMin,
        usedDataMax,
        usedDataRange,
        minTickDataSpacing,
        minTickSpacingInPixel,
        maxNumIntervals,
        maxNumTicks,
        tickDataSpacing,
        fontHeight,
        niceNumberEnabled,
        spaceOptimizingEnabled,
        tickBaseValue: 0
      };
      tickModel.absMax = Math.max(Math.abs(usedDataMax), Math.abs(usedDataMin));
      tickModel.absMin = Math.min(Math.abs(usedDataMax), Math.abs(usedDataMin));
      tickModel.spaceUseLimit = spaceUseLimit;
      tickModel.plotMaxCanBeTuned = explicitMax === null && usedDataMax > 0;
      tickModel.plotMinCanBeTuned = explicitMin === null && usedDataMin < 0;
      if (!niceNumberEnabled || size === 0) {
        tickModel.min = usedDataMin;
        tickModel.max = usedDataMax;
        tickModel.tickSpacing = tickDataSpacing;
        calculateTickValues$1(tickModel);
        fixMinusZero(tickModel);
        return tickModel;
      }
      if (tickModel.explicitMax !== null && tickModel.explicitMax < tickModel.usedDataMin || tickModel.explicitMin !== null && tickModel.explicitMin > tickModel.usedDataMax) {
        outOfRangeCase = true;
        calculateForOutOfRangeCase(tickModel);
      } else if (tickModel.usedDataRange === 0) {
        calculateForSameMaxMinCase(tickModel);
      } else if (tickModel.maxNumIntervals < 1) {
        calculateForSpecialCase1(tickModel);
      } else {
        if (tickModel.usedDataMax > 0 && tickModel.usedDataMin < 0) {
          if (tickModel.maxNumIntervals === 1) {
            calculateForMaxPositiveMinNegativeCase({
              tickModel,
              useGoodNumber: true
            });
          } else if (tickModel.maxNumIntervals >= 5) {
            calculateForNormalCase(tickModel);
          } else if (tickModel.maxNumIntervals < 2) {
            calculateForSpecialCase2(tickModel);
          } else {
            calculateForSpecialCase3(tickModel);
          }
        } else {
          calculateForNormalCase(tickModel);
        }
        if (tickModel.tickMaxIndex < tickModel.tickMinIndex) {
          tickModel.tickDataSpacing = Math.max(tickModel.usedDataRange / tickModel.maxNumIntervals, tickModel.minTickDataSpacing);
          calculateForSpecialCase1(tickModel);
        } else {
          refineTickDataSpacing(tickModel);
        }
      }
      calculateTickValues$1(tickModel);
      if (tickMinMaxCoverDataMinMax && tickModel.maxNumIntervals >= 1 && !outOfRangeCase) {
        addMainExtraTicksIfNeeded(tickModel);
        addSubExtraTicksIfNeeded(tickModel);
      }
      fixMinusZero(tickModel);
      return tickModel;
    }
  };

  /* eslint-disable no-param-reassign */
  /* eslint no-sparse-arrays:0 */
  const log10 = Math.log(10);
  const epsilon$2 = 1e-12;
  const log10Of3 = Math.log(3) / log10;
  const referenceTable1 = [[2, 4, 6], [2, 4], [3]];
  const referenceTable2 = [, [,, [[1, 2]], [[1, 2, 3], [1, 3]], [[1, 2, 4], [1, 4]], [[1, 2, 4], [1, 5]], [[1, 2, 4, 6], [2, 4, 6], [1, 3, 6], [1, 6]], [[1, 2, 4, 6], [2, 4, 6], [1, 3, 6], [1, 7]], [[1, 2, 4, 8], [2, 4, 8], [1, 8]], [[1, 2, 4, 8], [2, 4, 8], [1, 3, 9], [1, 9]], [[1, 2, 4, 6, 10], [1, 2, 4, 10], [1, 3, 10], [3, 10], [1, 10]]], [,,, [[2, 3]], [[2, 3, 4], [2, 4]], [[2, 3, 4], [2, 4], [2, 5]], [[2, 4, 6], [2, 6]], [[2, 4, 6], [2, 6], [2, 7]], [[2, 4, 8], [2, 8]], [[2, 4, 8], [2, 8], [2, 9]], [[2, 4, 6, 10], [2, 4, 10], [5, 10], [3, 10]]], [,,,, [[3, 4]], [[3, 4, 5], [3, 5]], [[3, 4, 5, 6], [3, 6]], [[3, 4, 5, 6], [3, 5, 7], [3, 7]], [[3, 4, 5, 6, 8], [3, 5, 7], [4, 8], [3, 8]], [[3, 4, 5, 6, 8], [3, 4, 6, 9], [3, 4, 6, 8], [3, 6, 9], [4, 8], [3, 9]], [[4, 6, 10], [5, 10], [3, 10]]], [,,,,, [[4, 5]], [[4, 5, 6], [4, 6]], [[4, 5, 6, 7], [4, 5, 6], [4, 6]], [[4, 5, 6, 7, 8], [4, 5, 6, 7], [4, 6, 8], [4, 8]], [[4, 5, 6, 7, 8], [4, 6, 9], [4, 6, 8], [4, 8]], [[4, 6, 10], [5, 7, 9], [5, 10], [4, 10]]], [,,,,,, [[5, 6]], [[5, 6, 7], [5, 7]], [[5, 6, 7, 8], [5, 6, 7], [6, 8]], [[5, 6, 7, 8, 9], [5, 6, 7, 8], [5, 7, 9], [5, 9]], [[6, 8, 10], [5, 10]]], [,,,,,,, [[6, 7]], [[6, 7, 8], [6, 8]], [[6, 7, 8, 9], [6, 7, 8], [6, 9]], [[6, 7, 8, 9, 10], [6, 8, 10], [6, 10]]], [,,,,,,,, [[7, 8]], [[7, 8, 9], [7, 9]], [[7, 8, 9, 10], [8, 10], [7, 10], [7, 9]]], [,,,,,,,,, [[8, 9]], [[8, 9, 10], [8, 10]]], [,,,,,,,,,, [[9, 10]]]];
  const controlTable = [, [,, [1, 2], [1, 3], [1, 4], [1, 5, 1, 6], [1, 6], [1, 10, 1, 8, 1, 7], [1, 8, 1, 10], [1, 10, 1, 9]], [,,, [2, 3], [2, 4], [2, 6, 2, 5], [2, 6, 2, 8], [2, 8, 2, 7], [2, 8, 1, 10], [1, 10, 2, 10, 2, 9], [1, 10, 2, 10]], [,,,, [3, 4, 2, 4], [3, 6, 3, 5], [3, 6, 2, 6], [2, 8, 3, 8, 3, 7], [2, 8, 3, 8, 3, 9], [2, 10, 3, 10, 3, 9]], [,,,,, [4, 5, 4, 6, 3, 5], [4, 6], [4, 8, 4, 7], [4, 8], [4, 10, 4, 9, 3, 9], [4, 10]], [,,,,, [5, 6, 4, 6], [5, 7, 4, 8], [4, 8, 5, 8, 5, 10], [5, 10, 4, 10, 5, 9], [5, 10, 4, 10]], [,,,,,, [6, 7, 6, 8], [6, 8], [6, 10, 5, 10, 6, 9], [6, 10, 5, 10]], [,,,,,,, [7, 8, 6, 8], [7, 9, 6, 10], [6, 10, 7, 10]], [,,,,,,,, [8, 10, 8, 9], [8, 10]], [,,,,,,,,, [9, 10]]];
  function calculateMinRatio(array, min, max) {
    const len = array ? array.length : 0;
    let i;
    let ratio = min === undefined ? Number.MAX_VALUE : array[0] / min;
    for (i = 1; i < len; i++) {
      ratio = Math.min(ratio, array[i] / array[i - 1]);
    }
    if (max !== undefined) {
      ratio = Math.min(ratio, max / array[len - 1]);
    }
    array.splice(0, 0, ratio);
  }
  function calculateMinRatioArray2D(array, min, max) {
    let i;
    const len = array ? array.length : 0;
    for (i = 0; i < len; i++) {
      calculateMinRatio(array[i], min, max);
    }
  }
  function updateReferenceTables() {
    let i;
    let j;
    calculateMinRatioArray2D(referenceTable1, 1, 10);
    for (i = 0; i < referenceTable2.length; i++) {
      if (referenceTable2[i]) {
        for (j = 0; j < referenceTable2[i].length; j++) {
          if (Array.isArray(referenceTable2[i][j])) {
            calculateMinRatioArray2D(referenceTable2[i][j]);
          }
        }
      }
    }
  }
  updateReferenceTables();
  function calculateRoughMainTicks1(tickModel) {
    let cont = true;
    let numLoops = 0;
    let tickDataSpacingNNLog;
    let tickMinIndex;
    let tickMaxIndex;
    let plotMinLog;
    let plotMaxLog;
    let plotRangeLog;
    tickDataSpacingNNLog = tickModel.tickDataSpacingLog;
    const tickBaseValueLog = 0;
    while (cont && numLoops < 5) {
      tickDataSpacingNNLog = numLoops === 0 ? Math.ceil(tickModel.tickDataSpacingLog) : Math.ceil(tickDataSpacingNNLog * 1.01);
      tickMinIndex = tickModel.minIsStrict ? Math.ceil(tickModel.usedDataMinLog / tickDataSpacingNNLog) : Math.floor(tickModel.usedDataMinLog / tickDataSpacingNNLog);
      tickMaxIndex = tickModel.maxIsStrict ? Math.floor(tickModel.usedDataMaxLog / tickDataSpacingNNLog) : Math.ceil(tickModel.usedDataMaxLog / tickDataSpacingNNLog);
      plotMinLog = tickModel.minIsStrict ? tickModel.explicitPlotMinLog : tickMinIndex * tickDataSpacingNNLog;
      plotMaxLog = tickModel.maxIsStrict ? tickModel.explicitPlotMaxLog : tickMaxIndex * tickDataSpacingNNLog;
      plotRangeLog = plotMaxLog - plotMinLog;
      cont = tickDataSpacingNNLog / plotRangeLog * tickModel.size < tickModel.minTickSpacingInPixel;
      numLoops++;
    }
    if (cont) {
      tickDataSpacingNNLog = Math.ceil(tickModel.tickDataSpacingLog);
      tickMinIndex = tickModel.minIsStrict ? Math.ceil(tickModel.usedDataMinLog / tickDataSpacingNNLog) : Math.floor(tickModel.usedDataMinLog / tickDataSpacingNNLog);
      tickMaxIndex = tickModel.maxIsStrict ? Math.floor(tickModel.usedDataMaxLog / tickDataSpacingNNLog) : Math.ceil(tickModel.usedDataMaxLog / tickDataSpacingNNLog);
      plotMinLog = tickModel.minIsStrict ? tickModel.explicitPlotMinLog : tickMinIndex * tickDataSpacingNNLog;
      plotMaxLog = tickModel.maxIsStrict ? tickModel.explicitPlotMaxLog : tickMaxIndex * tickDataSpacingNNLog;
    }
    return {
      plotMinLog,
      plotMaxLog,
      tickMinIndex,
      tickMaxIndex,
      tickDataSpacingNNLog,
      tickBaseValueLog,
      success: !cont
    };
  }
  function calculateRoughMainTicks2(tickModel) {
    let cont = true;
    let numLoops = 0;
    let tickDataSpacingNNLog;
    let tickMinIndex;
    let tickMaxIndex;
    let plotMinLog;
    let plotMaxLog;
    let plotRangeLog;
    tickDataSpacingNNLog = tickModel.tickDataSpacingLog;
    tickMinIndex = 0;
    const tickBaseValueLog = tickModel.usedDataMinLogFloor;
    while (cont && numLoops < 5) {
      tickDataSpacingNNLog = numLoops === 0 ? Math.ceil(tickModel.tickDataSpacingLog) : Math.ceil(tickDataSpacingNNLog * 1.01);
      tickMinIndex = tickModel.minIsStrict ? Math.ceil((tickModel.usedDataMinLog - tickBaseValueLog) / tickDataSpacingNNLog) : Math.floor((tickModel.usedDataMinLog - tickBaseValueLog) / tickDataSpacingNNLog);
      tickMaxIndex = tickModel.maxIsStrict ? Math.floor((tickModel.usedDataMaxLog - tickBaseValueLog) / tickDataSpacingNNLog) : Math.ceil((tickModel.usedDataMaxLog - tickBaseValueLog) / tickDataSpacingNNLog);
      plotMinLog = tickModel.minIsStrict ? tickModel.explicitPlotMinLog : tickMinIndex * tickDataSpacingNNLog + tickBaseValueLog;
      plotMaxLog = tickModel.maxIsStrict ? tickModel.explicitPlotMaxLog : tickMaxIndex * tickDataSpacingNNLog + tickBaseValueLog;
      plotRangeLog = plotMaxLog - plotMinLog;
      cont = tickDataSpacingNNLog / plotRangeLog * tickModel.size < tickModel.minTickSpacingInPixel;
      numLoops++;
    }
    if (cont) {
      tickDataSpacingNNLog = numLoops === 0 ? Math.ceil(tickModel.tickDataSpacingLog) : Math.ceil(tickDataSpacingNNLog * 1.01);
      tickMinIndex = tickModel.minIsStrict ? Math.ceil((tickModel.usedDataMinLog - tickBaseValueLog) / tickDataSpacingNNLog) : Math.floor((tickModel.usedDataMinLog - tickBaseValueLog) / tickDataSpacingNNLog);
      tickMaxIndex = tickModel.maxIsStrict ? Math.floor((tickModel.usedDataMaxLog - tickBaseValueLog) / tickDataSpacingNNLog) : Math.ceil((tickModel.usedDataMaxLog - tickBaseValueLog) / tickDataSpacingNNLog);
      plotMinLog = tickModel.minIsStrict ? tickModel.explicitPlotMinLog : tickMinIndex * tickDataSpacingNNLog + tickBaseValueLog;
      plotMaxLog = tickModel.maxIsStrict ? tickModel.explicitPlotMaxLog : tickMaxIndex * tickDataSpacingNNLog + tickBaseValueLog;
    }
    return {
      plotMinLog,
      plotMaxLog,
      tickMinIndex,
      tickMaxIndex,
      tickDataSpacingNNLog,
      tickBaseValueLog,
      success: !cont
    };
  }
  function calculateRoughMainTicks(tickModel) {
    const ticks2 = calculateRoughMainTicks2(tickModel);
    if (!ticks2.success) {
      return calculateRoughMainTicks1(tickModel);
    }
    const usedDataLogRange = tickModel.usedDataMaxLog - tickModel.usedDataMinLog;
    const useFactor2 = usedDataLogRange / (ticks2.plotMaxLog - ticks2.plotMinLog);
    if (useFactor2 === 1) {
      return ticks2;
    }
    const ticks1 = calculateRoughMainTicks1(tickModel);
    if (!ticks1.success) {
      return ticks2;
    }
    const useFactor1 = usedDataLogRange / (ticks1.plotMaxLog - ticks1.plotMinLog);
    const numTicks1 = ticks1.tickMaxIndex - ticks1.tickMinIndex;
    const numTicks2 = ticks2.tickMaxIndex - ticks2.tickMinIndex;
    if (numTicks2 > numTicks1 || numTicks2 === numTicks1 && useFactor2 > useFactor1 || numTicks2 === numTicks1 && useFactor2 === useFactor1 && ticks2.plotMinLog < ticks1.plotMinLog) {
      return ticks2;
    }
    return ticks1;
  }
  function increaseTickDataSpacing(minIsStrict, maxIsStrict, dataMin, dataMax, previousTickDataSpacing) {
    const tickDataSpacing = NumberUtils.getNiceNumber(previousTickDataSpacing * 1.1);
    const tickMinIndex = minIsStrict ? Math.ceil(dataMin / tickDataSpacing) : Math.floor(dataMin / tickDataSpacing);
    const tickMaxIndex = maxIsStrict ? Math.floor(dataMax / tickDataSpacing) : Math.ceil(dataMax / tickDataSpacing);
    const min = minIsStrict || tickMinIndex === 0 ? dataMin : tickMinIndex * tickDataSpacing;
    const max = maxIsStrict ? dataMax : tickMaxIndex * tickDataSpacing;
    return {
      min,
      max,
      tickSpacing: tickDataSpacing,
      tickBaseValue: 0
    };
  }
  function findLowIndexOutOfRange(values, min) {
    let i;
    for (i = 0; i < values.length; i++) {
      if (values[i] >= min) {
        return i - 1;
      }
    }
    return null;
  }
  function findHighIndexOutOfRange(values, max) {
    let i;
    for (i = values.length - 1; i >= 0; i--) {
      if (values[i] <= max) {
        return i + 1;
      }
    }
    return null;
  }
  function removeOutOfRangeTicks(values, dataMin, dataMax, minIsStrict, maxIsStrict) {
    let idx1;
    let idx2;
    idx1 = findLowIndexOutOfRange(values, dataMin);
    idx2 = findHighIndexOutOfRange(values, dataMax);
    if (idx1 !== null && !minIsStrict && values[idx1 + 1] !== undefined && values[idx1 + 1] > dataMin) {
      idx1 -= 1;
    }
    if (idx2 !== null && !maxIsStrict && idx2 > 0 && values[idx2 - 1] !== undefined && values[idx2 - 1] < dataMax) {
      idx2 += 1;
    }
    if (idx2 !== null && idx2 < values.length) {
      values.splice(idx2, values.length - idx2);
    }
    if (idx1 !== null && idx1 >= 0) {
      values.splice(0, idx1 + 1);
    }
  }
  function checkTickSpaceCondition(tickModel, values, min, max, threshold) {
    let minTickSpacingLog = Number.MAX_VALUE;
    let maxTickSpacingLog = -Number.MAX_VALUE;
    let tickSpacing;
    const maxLog = NumberUtils.log10(max);
    const minLog = NumberUtils.log10(min);
    const rangeLog = maxLog - minLog;
    const tickValuesLog = values.map(NumberUtils.log10);
    const len = values ? values.length : 0;
    if (threshold === null || Number.isNaN(+threshold)) {
      threshold = 1.71;
    }
    for (let i = 1; i < len; i++) {
      tickSpacing = tickValuesLog[i] - tickValuesLog[i - 1];
      minTickSpacingLog = Math.min(minTickSpacingLog, tickSpacing);
      maxTickSpacingLog = Math.max(maxTickSpacingLog, tickSpacing);
    }
    maxTickSpacingLog = Math.max(maxTickSpacingLog, Math.abs(tickValuesLog[0] - minLog));
    maxTickSpacingLog = Math.max(maxTickSpacingLog, Math.abs(maxLog - tickValuesLog[len - 1]));
    return minTickSpacingLog / rangeLog * tickModel.size >= tickModel.minTickSpacingInPixel - epsilon$2 && maxTickSpacingLog / minTickSpacingLog <= threshold && values.length - 1 <= tickModel.maxNumIntervals;
  }
  function calculateSpaceDistributionFactor(tickModel, ticks) {
    let minTickSpacing = Number.MAX_VALUE;
    let maxTickSpacing = -Number.MAX_VALUE;
    let tickSpacing;
    const {
      values
    } = ticks;
    const tickValuesLog = values.map(NumberUtils.log10);
    const len = values ? values.length : 0;
    for (let i = 1; i < len; i++) {
      tickSpacing = tickValuesLog[i] - tickValuesLog[i - 1];
      minTickSpacing = Math.min(minTickSpacing, tickSpacing);
      maxTickSpacing = Math.max(maxTickSpacing, tickSpacing);
    }
    ticks.maxTickSpacing = maxTickSpacing;
    ticks.minTickSpacing = minTickSpacing;
    ticks.tickSpacingRatio = maxTickSpacing / minTickSpacing;
    ticks.spaceUseFactor = tickModel.usedDataRange / (ticks.max - ticks.min);
    ticks.factor = ticks.spaceUseFactor / (ticks.tickSpacingRatio * ticks.tickSpacingRatio);
  }
  function findGoodNumberBetweenMaxAndMin(min, max, logMin, logMax, closedValue) {
    let middleRound;
    let middleFloor;
    let middleCeil;
    let temp;
    const middle = (logMax + logMin) / 2;
    if (closedValue === undefined) {
      middleRound = Math.round(middle);
      if (middleRound >= logMin && middleRound <= logMax) {
        return NumberUtils.pow10(middleRound);
      }
      middleFloor = Math.floor(middle);
      if (middleFloor >= logMin && middleFloor <= logMax) {
        return NumberUtils.pow10(middleFloor);
      }
      middleCeil = Math.ceil(middle);
      if (middleCeil >= logMin && middleCeil <= logMax) {
        return NumberUtils.pow10(middleCeil);
      }
      temp = NumberUtils.getSmallNiceNumber(Math.max(1, max - min));
      return Math.ceil(min / temp) * temp;
    }
    middleFloor = NumberUtils.pow10(Math.floor(middle));
    middleCeil = NumberUtils.pow10(Math.ceil(middle));
    if (Math.abs(middleFloor - closedValue) < Math.abs(middleCeil - closedValue)) {
      return middleFloor;
    }
    return middleCeil;
  }
  function calculateTickValues(dataMin, dataMax, tickBaseValue, tickDataSpacing, minIsStrict, maxIsStrict) {
    const tickMinIndex = minIsStrict ? Math.ceil((dataMin - tickBaseValue) / tickDataSpacing) : Math.floor((dataMin - tickBaseValue) / tickDataSpacing);
    const tickMaxIndex = maxIsStrict ? Math.floor((dataMax - tickBaseValue) / tickDataSpacing) : Math.ceil((dataMax - tickBaseValue) / tickDataSpacing);
    let i;
    let v;
    const values = [];
    for (i = tickMinIndex; i <= tickMaxIndex; i++) {
      v = i * tickDataSpacing + tickBaseValue;
      if (v > 0) {
        values.push(i * tickDataSpacing + tickBaseValue);
      }
    }
    return values;
  }
  function determineSubCase(tickModel) {
    if (tickModel.usedDataMax >= 10 * tickModel.usedDataMin) {
      return 1;
    }
    if (tickModel.usedDataMaxLogFloor === tickModel.usedDataMinLogFloor) {
      if (tickModel.maxIsStrict && tickModel.minIsStrict) {
        return 2;
      }
      return 3;
    }
    return 1;
  }
  function sortArray(array) {
    array.sort((a, b) => a - b);
  }
  function calculateForSubCase1(tickModel, referenceTable, tickDataSpacing, initTickValues, tickMinIndex, tickMaxIndex, tickDataSpacingNNLog, tickBaseValueLog) {
    let i = 0;
    let j;
    let k;
    let values;
    let min;
    let max;
    const ticks = [];
    for (i = 0; i < referenceTable.length; i++) {
      if (tickDataSpacing <= referenceTable[i][0] + epsilon$2) {
        values = initTickValues.concat();
        for (j = tickMinIndex; j < tickMaxIndex; j++) {
          for (k = 1; k < referenceTable[i].length; k++) {
            values.push(referenceTable[i][k] * NumberUtils.pow10(j * tickDataSpacingNNLog + tickBaseValueLog));
          }
        }
        sortArray(values);
        removeOutOfRangeTicks(values, tickModel.usedDataMin, tickModel.usedDataMax, tickModel.minIsStrict, tickModel.maxIsStrict);
        min = tickModel.minIsStrict ? tickModel.explicitMin : values[0];
        max = tickModel.maxIsStrict ? tickModel.explicitMax : values[values.length - 1];
        if (checkTickSpaceCondition(tickModel, values, min, max)) {
          ticks.push({
            values,
            min,
            max
          });
        }
      }
    }
    if (ticks.length === 0) {
      values = initTickValues;
      removeOutOfRangeTicks(values, tickModel.usedDataMin, tickModel.usedDataMax, tickModel.minIsStrict, tickModel.maxIsStrict);
      min = tickModel.minIsStrict ? tickModel.explicitMin : values[0];
      max = tickModel.maxIsStrict ? tickModel.explicitMax : values[values.length - 1];
      return {
        values,
        min,
        max
      };
    }
    if (ticks.length === 1) {
      return ticks[0];
    }
    const l0 = initTickValues.length - 1;
    for (i = 0; i < ticks.length; i++) {
      const l1 = ticks[i].values.length - 1;
      if (ticks[i].values[0] === initTickValues[0] && ticks[i].values[l1] === initTickValues[l0]) {
        return ticks[i];
      }
    }
    return ticks[0];
  }
  function calculateForSubCase2(tickModel, referenceTable, tickDataSpacing) {
    let cont = true;
    const from = Math.ceil(tickModel.fractionMinLog);
    const to = Math.floor(tickModel.fractionMaxLog);
    let i = 0;
    let j;
    let values;
    if (referenceTable[from] && referenceTable[from][to]) {
      const table = referenceTable[from][to];
      const len = table.length;
      while (i < len && cont) {
        if (tickDataSpacing <= table[i][0] + epsilon$2 && table[i].length - 2 <= tickModel.maxNumIntervals) {
          values = [];
          for (j = 1; j < table[i].length; j++) {
            values.push(table[i][j] * tickModel.dataMinMagnitude);
          }
          cont = !checkTickSpaceCondition(tickModel, values, tickModel.usedDataMin, tickModel.usedDataMax);
        }
        if (cont) {
          i++;
        }
      }
    }
    if (cont) {
      values = [findGoodNumberBetweenMaxAndMin(tickModel.usedDataMin, tickModel.usedDataMax, tickModel.usedDataMinLog, tickModel.usedDataMaxLog)];
    }
    const min = tickModel.minIsStrict ? tickModel.explicitMin : values[0];
    const max = tickModel.maxIsStrict ? tickModel.explicitMax : values[values.length - 1];
    return {
      values,
      min,
      max
    };
  }
  function calculateForSubCase3(tickModel, referenceTable, tickDataSpacing) {
    const idx1 = tickModel.minIsStrict ? Math.ceil(tickModel.fractionMinLog) : Math.floor(tickModel.fractionMinLog);
    const idx2 = tickModel.maxIsStrict ? Math.floor(tickModel.fractionMaxLog) : Math.ceil(tickModel.fractionMaxLog);
    let i;
    let j;
    let k;
    let values;
    let min;
    let max;
    let ticks = {};
    let fromToArray;
    let numFromTos;
    let from;
    let to;
    let table;
    let n;
    let b;
    let tmin;
    let tmax;
    if (controlTable[idx1] && controlTable[idx1][idx2]) {
      fromToArray = controlTable[idx1][idx2];
      numFromTos = Array.isArray(fromToArray) ? fromToArray.length / 2 : 0;
      ticks.values = [];
      for (i = 0; i < numFromTos; i++) {
        from = fromToArray[2 * i];
        to = fromToArray[2 * i + 1];
        if (referenceTable[from] && referenceTable[from][to]) {
          table = referenceTable[from][to];
          n = table.length;
          for (j = 0; j < n; j++) {
            b = tickDataSpacing <= table[j][0] + epsilon$2 && table[j].length - 2 <= tickModel.maxNumIntervals;
            tmin = table[j][1] * tickModel.dataMinMagnitude;
            tmax = table[j][table[j].length - 1] * tickModel.dataMinMagnitude;
            b = tickModel.minIsStrict ? b && tmin >= tickModel.usedDataMin : b && tmin <= tickModel.usedDataMin;
            b = tickModel.maxIsStrict ? b && tmax <= tickModel.usedDataMax : b && tmax >= tickModel.usedDataMax;
            if (b) {
              values = [];
              for (k = 1; k < table[j].length; k++) {
                values.push(table[j][k] * tickModel.dataMinMagnitude);
              }
              removeOutOfRangeTicks(values, tickModel.usedDataMin, tickModel.usedDataMax, tickModel.minIsStrict, tickModel.maxIsStrict);
              min = tickModel.minIsStrict ? tickModel.explicitMin : values[0];
              max = tickModel.maxIsStrict ? tickModel.explicitMax : values[values.length - 1];
              if (checkTickSpaceCondition(tickModel, values, min, max)) {
                if (ticks.values.length < values.length) {
                  ticks = {
                    values,
                    min,
                    max
                  };
                }
                break;
              }
            }
          }
        }
      }
    }
    if (!ticks.values || ticks.values.length === 0) {
      ticks.values = [findGoodNumberBetweenMaxAndMin(tickModel.usedDataMin, tickModel.usedDataMax, tickModel.usedDataMinLog, tickModel.usedDataMaxLog)];
    }
    const v = ticks.values;
    ticks.min = tickModel.minIsStrict ? tickModel.explicitMin : v[0];
    ticks.max = tickModel.maxIsStrict ? tickModel.explicitMax : v[v.length - 1];
    return ticks;
  }
  function checkAgainstPattern(tickModel, values, partern, backward) {
    const len = values.length;
    let i;
    if (backward) {
      for (i = len - 1; i >= 0; i--) {
        if (Math.abs(values[i] - partern[i] * tickModel.dataMinMagnitude) > epsilon$2) {
          return false;
        }
      }
      return true;
    }
    for (i = 0; i < len; i++) {
      if (Math.abs(values[i] - partern[i] * tickModel.dataMinMagnitude) > epsilon$2) {
        return false;
      }
    }
    return true;
  }
  function refineTickValues(tickModel, ticks) {
    const {
      values
    } = ticks;
    const len = values.length;
    let oldValue;
    let newValue;
    if (len < 2 || len > 4) {
      return;
    }
    newValue = 5 * tickModel.dataMinMagnitude;
    if ((tickModel.minIsStrict && tickModel.usedDataMin <= newValue || !tickModel.minIsStrict && tickModel.usedDataMin >= newValue) && (checkAgainstPattern(tickModel, values, [6, 10, 20, 40]) || checkAgainstPattern(tickModel, values, [4, 10, 20, 40]))) {
      [oldValue] = values;
      values[0] = newValue;
      ticks.min = tickModel.minIsStrict ? tickModel.explicitMin : values[0];
      if (!checkTickSpaceCondition(tickModel, values, ticks.min, ticks.max)) {
        values[0] = oldValue;
        ticks.min = tickModel.minIsStrict ? tickModel.explicitMin : values[0];
      }
      return;
    }
    newValue = 80 * tickModel.dataMinMagnitude;
    if ((tickModel.maxIsStrict && tickModel.usedDataMax >= newValue || !tickModel.maxIsStrict && tickModel.usedDataMax <= newValue) && checkAgainstPattern(tickModel, values, [10, 20, 40, 60], true)) {
      oldValue = values[len - 1];
      values[len - 1] = newValue;
      ticks.max = tickModel.maxIsStrict ? tickModel.explicitMax : values[len - 1];
      if (!checkTickSpaceCondition(tickModel, values, ticks.min, ticks.max)) {
        values[len - 1] = oldValue;
        ticks.max = tickModel.maxIsStrict ? tickModel.explicitMax : values[len - 1];
      }
    }
  }
  function calculateForLinearCase(tickModel) {
    const {
      dataMin,
      dataMax,
      explicitMin,
      explicitMax,
      minIsStrict,
      maxIsStrict,
      usedDataMin,
      usedDataMax
    } = tickModel;
    let ticks = ScaleUtils.calculateTicks(tickModel);
    let min;
    let max;
    let numLoops = 1;
    let fraction;
    if (ticks.min === 0) {
      ticks.min = minIsStrict ? explicitMin : dataMin;
    }
    let {
      values
    } = ticks;
    min = minIsStrict ? explicitMin : Math.min(dataMin, values[0]);
    max = maxIsStrict ? explicitMax : Math.max(values[values.length - 1], dataMax);
    while (!checkTickSpaceCondition(tickModel, values, min, max) && numLoops <= 20) {
      ticks = increaseTickDataSpacing(minIsStrict || ticks.tickSpacing > usedDataMin, maxIsStrict, usedDataMin, usedDataMax, ticks.tickSpacing);
      values = calculateTickValues(usedDataMin, usedDataMax, ticks.tickBaseValue, ticks.tickSpacing, minIsStrict, maxIsStrict);
      min = minIsStrict ? explicitMin : Math.min(dataMin, values[0]);
      max = maxIsStrict ? explicitMax : Math.max(values[values.length - 1], dataMax);
      numLoops++;
    }
    if (!checkTickSpaceCondition(tickModel, values, min, max)) {
      values = [];
    } else {
      fraction = NumberUtils.getFraction(values[0]) / 2;
      if (values.length === 2 && values[1] / values[0] === 2 && values[0] / 2 >= min && fraction === Math.floor(fraction)) {
        values.splice(0, 0, values[0] / 2);
        fraction = NumberUtils.getFraction(values[0]) / 2;
        if (values[0] / 2 >= min && fraction === Math.floor(fraction)) {
          values.splice(0, 0, values[0] / 2);
        }
      }
    }
    ticks.values = values;
    ticks.numLoops = numLoops;
    return ticks;
  }
  function calculateForLogCase(tickModel) {
    let closedValue;
    let i;
    let values;
    let ticks = {};
    if (tickModel.maxIsStrict && tickModel.explicitMax <= tickModel.usedDataMin) {
      // out of range case 1
      tickModel.dataMinLog = Math.ceil(tickModel.explicitPlotMaxLog - (tickModel.maxNumIntervals < 2 ? 1 : 2));
      tickModel.dataMin = NumberUtils.pow10(tickModel.dataMinLog);
    } else if (tickModel.minIsStrict && tickModel.explicitMin >= tickModel.usedDataMax) {
      // out of range case 2
      tickModel.dataMaxLog = Math.floor(tickModel.explicitPlotMinLog + (tickModel.maxNumIntervals < 2 ? 1 : 2));
      tickModel.dataMax = NumberUtils.pow10(tickModel.dataMaxLog);
    } else if (tickModel.usedDataMin === tickModel.usedDataMax) {
      closedValue = tickModel.usedDataMin;
      tickModel.dataMinLog = Math.floor(tickModel.dataMinLog);
      tickModel.dataMaxLog = tickModel.dataMinLog + 1;
      tickModel.dataMin = NumberUtils.pow10(tickModel.dataMinLog);
      tickModel.dataMax = NumberUtils.pow10(tickModel.dataMaxLog);
    }
    // Update used data max and used data min again
    tickModel.usedDataMin = tickModel.minIsStrict ? tickModel.explicitMin : tickModel.dataMin;
    tickModel.usedDataMax = tickModel.maxIsStrict ? tickModel.explicitMax : tickModel.dataMax;
    tickModel.usedDataMinLog = tickModel.minIsStrict ? tickModel.explicitPlotMinLog : tickModel.dataMinLog;
    tickModel.usedDataMaxLog = tickModel.maxIsStrict ? tickModel.explicitPlotMaxLog : tickModel.dataMaxLog;
    if (tickModel.maxNumIntervals < 1) {
      return {
        values: [findGoodNumberBetweenMaxAndMin(tickModel.usedDataMin, tickModel.usedDataMax, tickModel.usedDataMinLog, tickModel.usedDataMaxLog, closedValue)],
        min: tickModel.usedDataMin,
        max: tickModel.usedDataMax
      };
    }
    tickModel.tickDataSpacingLog = (tickModel.usedDataMaxLog - tickModel.usedDataMinLog) / tickModel.maxNumIntervals;
    tickModel.usedDataMinLogFloor = Math.floor(tickModel.usedDataMinLog);
    tickModel.usedDataMaxLogFloor = Math.floor(tickModel.usedDataMaxLog);
    tickModel.dataMinMagnitude = NumberUtils.pow10(tickModel.usedDataMinLogFloor);
    tickModel.fractionMinLog = tickModel.usedDataMin / tickModel.dataMinMagnitude;
    tickModel.fractionMaxLog = tickModel.usedDataMax / tickModel.dataMinMagnitude;
    const usedDataMaxLogCeil = Math.ceil(tickModel.usedDataMaxLog);
    if (tickModel.usedDataMinLog === tickModel.usedDataMinLogFloor && tickModel.usedDataMaxLog === usedDataMaxLogCeil && tickModel.maxNumIntervals >= 2 && tickModel.maxNumIntervals < 3 && tickModel.tickDataSpacingLog > 1 && tickModel.tickDataSpacingLog - Math.floor(tickModel.tickDataSpacingLog) < log10Of3) {
      const usedDataMiddleLog = Math.floor((tickModel.usedDataMinLogFloor + usedDataMaxLogCeil) / 2);
      values = [NumberUtils.pow10(tickModel.usedDataMinLogFloor), NumberUtils.pow10(usedDataMiddleLog) * 3, NumberUtils.pow10(usedDataMaxLogCeil)];
      removeOutOfRangeTicks(values, tickModel.usedDataMin, tickModel.usedDataMax, tickModel.minIsStrict, tickModel.maxIsStrict);
      const min = tickModel.minIsStrict ? tickModel.explicitMin : values[0];
      const max = tickModel.maxIsStrict ? tickModel.explicitMax : values[values.length - 1];
      if (values.length >= 2 && checkTickSpaceCondition(tickModel, values, min, max)) {
        return {
          values,
          min,
          max
        };
      }
    }
    const roughMainTicks = calculateRoughMainTicks(tickModel);
    if (!roughMainTicks.success) {
      return {
        values: [findGoodNumberBetweenMaxAndMin(tickModel.usedDataMin, tickModel.usedDataMax, tickModel.usedDataMinLog, tickModel.usedDataMaxLog)],
        min: tickModel.usedDataMin,
        max: tickModel.usedDataMax
      };
    }
    let {
      tickMinIndex,
      tickMaxIndex
    } = roughMainTicks;
    const {
      tickDataSpacingNNLog,
      tickBaseValueLog
    } = roughMainTicks;
    if (tickModel.minIsStrict) {
      tickMinIndex--;
    }
    if (tickModel.maxIsStrict) {
      tickMaxIndex++;
    }
    const initTickValues = [];
    for (i = tickMinIndex; i <= tickMaxIndex; i++) {
      initTickValues.push(NumberUtils.pow10(i * tickDataSpacingNNLog + tickBaseValueLog));
    }
    const tickDataSpacing = NumberUtils.pow10(tickModel.tickDataSpacingLog);
    const subCase = determineSubCase(tickModel);
    if (subCase === 2) {
      return calculateForSubCase2(tickModel, referenceTable2, tickDataSpacing);
    }
    if (subCase === 3) {
      return calculateForSubCase3(tickModel, referenceTable2, tickDataSpacing);
    }
    ticks = calculateForSubCase1(tickModel, referenceTable1, tickDataSpacing, initTickValues, tickMinIndex, tickMaxIndex, tickDataSpacingNNLog, tickBaseValueLog);
    refineTickValues(tickModel, ticks);
    return ticks;
  }
  function calculateForTrivialCase(tickModel) {
    tickModel.min = tickModel.usedDataMin;
    tickModel.max = tickModel.usedDataMax;
    const n = Math.floor(tickModel.maxNumIntervals);
    const d = (tickModel.dataMaxLog - tickModel.dataMinLog) / n;
    const values = [tickModel.usedDataMin];
    for (let i = 0; i < n; i++) {
      values.push(NumberUtils.pow10(tickModel.dataMinLog + (i + 1) * d));
    }
    return {
      values,
      min: tickModel.min,
      max: tickModel.max
    };
  }
  const ScaleLogUtils = {
    calculateTicksLogPositive({
      size,
      dataMin,
      dataMax,
      explicitMin,
      explicitMax,
      minTickSpacingInPixel,
      fontHeight,
      niceNumberEnabled,
      spaceOptimizingEnabled
    }) {
      let temp;
      if (Number.isNaN(+explicitMin)) {
        explicitMin = null;
      }
      if (Number.isNaN(+explicitMax)) {
        explicitMax = null;
      }
      if (dataMin > dataMax) {
        temp = dataMin;
        dataMin = dataMax;
        dataMax = temp;
      }
      if (explicitMin !== null && explicitMax !== null && explicitMin > explicitMax) {
        temp = explicitMin;
        explicitMin = explicitMax;
        explicitMax = temp;
      }
      const minIsStrict = explicitMin !== null;
      const maxIsStrict = explicitMax !== null;
      const usedDataMin = minIsStrict ? explicitMin : dataMin;
      const usedDataMax = maxIsStrict ? explicitMax : dataMax;
      const usedDataRange = usedDataMax - usedDataMin;
      const maxNumIntervals = size / minTickSpacingInPixel;
      const maxNumTicks = maxNumIntervals + 1;
      const tickModel = {
        size,
        dataMin,
        dataMax,
        explicitMin,
        explicitMax,
        minIsStrict,
        maxIsStrict,
        usedDataMin,
        usedDataMax,
        usedDataRange,
        minTickSpacingInPixel,
        maxNumIntervals,
        maxNumTicks,
        fontHeight,
        niceNumberEnabled,
        spaceOptimizingEnabled
      };
      tickModel.explicitPlotMinLog = tickModel.minIsStrict ? NumberUtils.eliminateFloatingError(NumberUtils.log10(explicitMin)) : null;
      tickModel.explicitPlotMaxLog = tickModel.maxIsStrict ? NumberUtils.eliminateFloatingError(NumberUtils.log10(explicitMax)) : null;
      tickModel.dataMinLog = NumberUtils.eliminateFloatingError(NumberUtils.log10(dataMin));
      tickModel.dataMaxLog = NumberUtils.eliminateFloatingError(NumberUtils.log10(dataMax));
      if (!niceNumberEnabled || size === 0) {
        return calculateForTrivialCase(tickModel);
      }
      if (tickModel.minIsStrict && tickModel.maxIsStrict && tickModel.explicitMin === tickModel.explicitMax) {
        return {
          values: [tickModel.explicitMin],
          min: tickModel.explicitMin,
          max: tickModel.explicitMax
        };
      }
      const ticks2 = calculateForLogCase(tickModel);
      if (tickModel.usedDataMax >= 10 * tickModel.usedDataMin) {
        return ticks2;
      }
      const ticks1 = calculateForLinearCase(tickModel);
      if (ticks1.values.length < 2) {
        return ticks2;
      }
      if (ticks2.values.length < 2) {
        return ticks1;
      }
      if (ticks1.values.length === ticks2.values.length) {
        calculateSpaceDistributionFactor(tickModel, ticks1);
        calculateSpaceDistributionFactor(tickModel, ticks2);
        if (ticks1.factor > ticks2.factor) {
          return ticks1;
        }
        return ticks2;
      }
      if (ticks1.values.length - 1 >= 1.5 * (ticks2.values.length - 1) && ticks1.values.length > ticks2.values.length) {
        return ticks1;
      }
      return ticks2;
    },
    calculateTicks({
      size,
      dataMin,
      dataMax,
      explicitMin,
      explicitMax,
      minTickSpacingInPixel,
      fontHeight,
      niceNumberEnabled = true,
      spaceOptimizingEnabled = true
    }) {
      let temp;
      let ticks1;
      let ticks2;
      let values1;
      let values2;
      let len;
      let i;
      if (Number.isNaN(+explicitMin)) {
        explicitMin = null;
      }
      if (Number.isNaN(+explicitMax)) {
        explicitMax = null;
      }
      if (dataMin > dataMax) {
        temp = dataMin;
        dataMin = dataMax;
        dataMax = temp;
      }
      if (explicitMin !== null && explicitMax !== null && explicitMin > explicitMax) {
        temp = explicitMin;
        explicitMin = explicitMax;
        explicitMax = temp;
      }
      if (dataMin * dataMax <= 0) {
        dataMin = explicitMin === null ? dataMin : explicitMin;
        dataMax = explicitMax === null ? dataMax : explicitMax;
      }
      if (dataMin > 0 && dataMax > 0 && (explicitMin === null || explicitMin > 0) && (explicitMax === null || explicitMax > 0)) {
        ticks1 = ScaleLogUtils.calculateTicksLogPositive({
          size,
          dataMin,
          dataMax,
          explicitMin,
          explicitMax,
          minTickSpacingInPixel,
          fontHeight,
          niceNumberEnabled,
          spaceOptimizingEnabled
        });
        ticks1.sign = 1;
        return ticks1;
      }
      if (dataMin < 0 && dataMax < 0 && (explicitMin === null || explicitMin < 0) && (explicitMax === null || explicitMax < 0)) {
        ticks2 = ScaleLogUtils.calculateTicksLogPositive({
          size,
          dataMin: -dataMax,
          dataMax: -dataMin,
          explicitMin: explicitMax === null ? null : -explicitMax,
          explicitMax: explicitMin === null ? null : -explicitMin,
          minTickSpacingInPixel,
          fontHeight,
          niceNumberEnabled,
          spaceOptimizingEnabled
        });
        ticks1 = {};
        ticks1.min = -ticks2.max;
        ticks1.max = -ticks2.min;
        values2 = ticks2.values;
        len = values2 ? values2.length : 0;
        values1 = new Array(len);
        for (i = 0; i < len; i++) {
          values1[i] = -values2[len - 1 - i];
        }
        ticks1.values = values1;
        ticks1.sign = -1;
        return ticks1;
      }
      return {
        values: [],
        min: explicitMin === null ? dataMin : explicitMin,
        max: explicitMax === null ? dataMax : explicitMax
      };
    }
  };

  // segments needs to be sorted ascendingly based on its center

  const labelLayout = {
    isInside(segment, min, max, isContinuous) {
      if (!isContinuous) {
        return true;
      }
      const smin = segment.position - segment.radius;
      const smax = segment.position + segment.radius;
      return smin >= min && smax <= max;
    },
    getCenterDistance(segment1, segment2) {
      return Math.abs(segment1.center - segment2.center);
    },
    getGap(segment1, segment2) {
      const minSegment = segment1.position < segment2.position ? segment1 : segment2;
      const maxSegment = segment1.position < segment2.position ? segment2 : segment1;
      return maxSegment.position - maxSegment.radius - (minSegment.position + minSegment.radius);
    },
    findSegmentPositionMeetMax(segment, max) {
      const d = Math.max(0, segment.max - max);
      return segment.center - d;
    },
    findSegmentPositionMeetMin(segment, min) {
      const d = Math.max(0, min - segment.min);
      return segment.center + d;
    },
    findSegmentPositionMeetMinThenMax(segment, min, max) {
      const position = labelLayout.findSegmentPositionMeetMin(segment, min);
      return labelLayout.findSegmentPositionMeetMax({
        center: position,
        max: position + segment.radius
      }, max);
    },
    findSegmentPositionMeetMaxThenMin(segment, min, max) {
      const position = labelLayout.findSegmentPositionMeetMax(segment, max);
      return labelLayout.findSegmentPositionMeetMin({
        center: position,
        min: position - segment.radius
      }, min);
    },
    layoutPositionFromMin(segments, min, max, gap = 0) {
      const n = segments.length - 1;
      let segment;
      let nextSegment;
      let min1 = min;
      for (let i = 0; i < n; i++) {
        segment = segments[i];
        nextSegment = segments[i + 1];
        segment.position = labelLayout.findSegmentPositionMeetMaxThenMin(segment, min1, (segment.center + nextSegment.center - gap) / 2);
        min1 = segment.position + segment.radius + gap / 2;
      }
      nextSegment.position = labelLayout.findSegmentPositionMeetMaxThenMin(nextSegment, min1, max);
    },
    adjustPositionFromMax(segments, min, max, gap = 0) {
      const n = segments.length - 1;
      let i;
      let segment;
      let prevSegment;
      const d = Math.max(0, segments[n].position + segments[n].radius - max);
      if (d === 0) {
        return;
      }
      let move;
      let totalMove = 0;
      for (i = n; i > 0; i--) {
        segment = segments[i];
        prevSegment = segments[i - 1];
        move = Math.max(0, labelLayout.getGap(prevSegment, segment) - gap);
        move -= Math.max(0, totalMove + move - d);
        totalMove += move;
        segment.move = move;
        if (totalMove >= d) {
          break;
        }
      }
      if (totalMove < d) {
        move = Math.max(0, prevSegment.position - prevSegment.radius - min);
        move -= Math.max(0, totalMove + move - d);
        totalMove += move;
        prevSegment.move = move;
      }
      totalMove = 0;
      for (i = 0; i <= n; i++) {
        segment = segments[i];
        totalMove += segment.move || 0;
        segment.move = totalMove;
        segment.position -= totalMove;
      }
    },
    layout(segments, min, max, gap = 0) {
      const n = segments.length - 1;
      if (n < 0) {
        return;
      }
      if (n === 0) {
        const segment = segments[0];
        segment.position = labelLayout.findSegmentPositionMeetMaxThenMin(segment, min, max);
        return;
      }
      labelLayout.layoutPositionFromMin(segments, min, max, gap);
      labelLayout.adjustPositionFromMax(segments, min, max, gap);
    }
  };

  const alignAdjustment = (scale, align, invert, numItems = 1) => {
    const bw = scale.bandwidth();
    if (invert) {
      if (align === 'start') {
        return bw;
      }
      if (align === 'end') {
        return bw * (1 - numItems);
      }
      return bw * (2 - numItems) / 2;
    }
    if (align === 'start') {
      return 0;
    }
    if (align === 'end') {
      return bw * numItems;
    }
    return bw * numItems / 2;
  };
  const getItemSize = ({
    pxScale,
    invert
  }) => {
    return pxScale.bandwidth() * (invert ? -1 : 1);
  };
  const getFirstItemPosition = ({
    pxScale,
    value,
    innerValues,
    invert,
    minOrder
  }) => {
    const itemSize = getItemSize({
      pxScale,
      invert
    });
    for (let i = 0; i < innerValues.length; i++) {
      const {
        id,
        order
      } = innerValues[i];
      const p = pxScale([value, id]);
      if (p !== undefined) {
        return p - itemSize * (order - minOrder);
      }
    }
    return undefined;
  };
  const isRefLineVisible = refLine => refLine.show !== false && refLine.show !== 0 && refLine.show !== '0';
  const getVisibleRefLines = refLinesLayout => refLinesLayout.filter(isRefLineVisible);
  const getRefLines = (layout, path) => getVisibleRefLines(util$2.getValue(layout, path, []));
  const getMeasureRefLines = layout => getRefLines(layout, 'refLine.refLines');
  const getDimensionRefLines = (layout, isDimensionless) => isDimensionless ? [] : getRefLines(layout, 'refLine.dimRefLines');
  const isRefLineLabelVisible = refLine => isRefLineVisible(refLine) && (refLine.showValue !== false || refLine.showLabel !== false);
  const getVisibleRefLineLabels = refLinesLayout => refLinesLayout.filter(isRefLineLabelVisible);
  const getRefLineLabels = (layout, path) => getVisibleRefLineLabels(util$2.getValue(layout, path, []));
  const getMeasureRefLineLabels = layout => getRefLineLabels(layout, 'refLine.refLines');
  const getDimensionRefLineLabels = (layout, isDimensionless) => isDimensionless ? [] : getRefLineLabels(layout, 'refLine.dimRefLines');
  const getScaledPosition = ({
    scale,
    size,
    value,
    valueInfo,
    align,
    invert = false,
    layoutService,
    isContinuous
  }) => {
    if (!isContinuous) {
      const pxScale = scale.pxScale(size); // TODO: optimize (don't have to create pxScale every time?)
      let adjustment;
      if (layoutService.meta.isGroupedByMeasure) {
        adjustment = alignAdjustment(pxScale, align, invert, layoutService.meta.measureCount);
        return pxScale([value, 0]) + adjustment;
      }
      if (layoutService.meta.isGroupedByDimension) {
        if (!valueInfo) {
          return NaN;
        }
        const {
          innerValues,
          numInnerValues,
          minOrder
        } = valueInfo;
        adjustment = alignAdjustment(pxScale, align, invert, numInnerValues);
        let start;
        if (innerValues && innerValues.length) {
          start = getFirstItemPosition({
            pxScale,
            value,
            innerValues,
            invert,
            minOrder
          });
        }
        return (start === undefined ? pxScale(value) : start) + adjustment;
      }
      adjustment = alignAdjustment(pxScale, align, invert);
      return pxScale(value) + adjustment;
    }
    return scale(value);
  };
  const getKeyAttribute = (canBeContinuous, isKMode) => {
    if (canBeContinuous) {
      return isKMode ? 'qValue' : 'qNum';
    }
    return 'qText';
  };
  const getDataPageRef = mode => {
    return mode === 'S' ? 'qDataPages.0' : 'qStackedDataPages.0';
  };
  const getStartIndex = dataPages => {
    return dataPages.qArea.qTop;
  };
  const getDimensionValuesInfo = ({
    layout,
    canBeContinuous,
    discreteModel,
    layoutService
  }) => {
    const {
      isGroupedByDimension
    } = layoutService.meta;
    const dic = {};
    const hyperCube = util$2.getValue(layout, 'qHyperCube');
    const isKMode = hyperCube.qMode === 'K';
    const dataPages = discreteModel ? discreteModel.query.getCurrentDataPage() : util$2.getValue(hyperCube, getDataPageRef(hyperCube.qMode), []);
    const path = isKMode ? 'qData.0.qSubNodes' : 'qMatrix';
    const dataNodes = util$2.getValue(dataPages, path, []);
    const attr = getKeyAttribute(canBeContinuous, isKMode);
    const startIndex = getStartIndex(dataPages);
    const processKMode = () => {
      for (let i = 0; i < dataNodes.length; i++) {
        const node = dataNodes[i];
        const order = i + startIndex;
        const key = node[attr];
        if (!dic[key]) {
          dic[key] = {
            id: node.qElemNo,
            qText: node.qText,
            minOrder: order,
            maxOrder: order
          };
        }
      }
    };
    const processGroupedByDimension = () => {
      let preKey;
      for (let i = 0; i < dataNodes.length; i++) {
        const node = dataNodes[i][0];
        const node2 = dataNodes[i][1];
        const order = i + startIndex;
        const key = node[attr];
        if (!dic[key]) {
          dic[key] = {
            id: node.qElemNumber,
            qText: node.qText,
            minOrder: order,
            maxOrder: order,
            innerValues: [{
              id: node2.qElemNumber,
              order
            }]
          };
        } else {
          dic[key].minOrder = Math.min(dic[key].minOrder, order);
          dic[key].maxOrder = Math.max(dic[key].maxOrder, order);
          dic[key].innerValues[dic[key].innerValues.length] = {
            id: node2.qElemNumber,
            order
          };
        }
        if (i === 0) {
          if (order === 0) {
            dic[key].isMinOrderOk = true;
          }
        } else if (key !== preKey) {
          dic[key].isMinOrderOk = true;
          dic[preKey].isMaxOrderOk = true;
        }
        preKey = key;
      }
    };
    const processNormal = () => {
      for (let i = 0; i < dataNodes.length; i++) {
        const node = dataNodes[i][0];
        const order = i + startIndex;
        const key = node[attr];
        if (!dic[key]) {
          dic[key] = {
            id: node.qElemNumber,
            qText: node.qText,
            minOrder: order,
            maxOrder: order
          };
        }
      }
    };
    if (isKMode) {
      processKMode();
    } else if (isGroupedByDimension) {
      processGroupedByDimension();
    } else {
      processNormal();
    }
    return dic;
  };
  const getInputValue$1 = ({
    refLineLayout,
    layoutService
  }) => {
    return layoutService.meta.canBeContinuous ? refLineLayout.refLineExpr.value : refLineLayout.refLineExpr.stringValue;
  };
  const extractInfoFromInputValue$1 = (inputValue, refLineModel, nodeAttr) => {
    const {
      dimensionRefLineInfo
    } = refLineModel;
    if (dimensionRefLineInfo[inputValue]) {
      return dimensionRefLineInfo[inputValue][nodeAttr];
    }
    return undefined;
  };
  const resolveValue$1 = ({
    refLineLayout,
    refLineModel,
    layoutService
  }) => {
    const inputValue = getInputValue$1({
      refLineLayout,
      layoutService
    });
    return extractInfoFromInputValue$1(inputValue, refLineModel, 'id');
  };
  const isDiscreteMinOutOfBounds = ({
    label,
    dataPages
  }) => {
    const {
      qArea = {}
    } = dataPages || {};
    const {
      qTop,
      qHeight
    } = qArea;
    if (qTop !== undefined && qHeight !== undefined && label.valueInfo !== undefined) {
      return label.valueInfo.maxOrder < qTop;
    }
    return false;
  };
  const isDiscreteMaxOutOfBounds = ({
    label,
    dataPages
  }) => {
    const {
      qArea = {}
    } = dataPages || {};
    const {
      qTop,
      qHeight
    } = qArea;
    if (qTop !== undefined && qHeight !== undefined && label.valueInfo !== undefined) {
      return label.valueInfo.minOrder >= qTop + qHeight;
    }
    return false;
  };
  const isContinuousMinOutOfBounds = ({
    value,
    qMin
  }) => {
    return qMin !== 'NaN' && value < qMin;
  };
  const isContinuousMaxOutOfBounds = ({
    value,
    qMax
  }) => {
    return qMax !== 'NaN' && value > qMax;
  };
  const isOutOfRange = ({
    value,
    qMin,
    qMax
  }) => {
    return isContinuousMinOutOfBounds({
      value,
      qMin
    }) || isContinuousMaxOutOfBounds({
      value,
      qMax
    });
  };
  const isOutOfDataPages = ({
    label,
    dataPages
  }) => {
    return label.valueInfo.isMinOrderOk && isDiscreteMaxOutOfBounds({
      label,
      dataPages
    }) || label.valueInfo.isMaxOrderOk && isDiscreteMinOutOfBounds({
      label,
      dataPages
    });
  };
  const getInvert = ({
    orientation,
    rtl,
    isContinuous
  }) => {
    if (orientation === 'horizontal') {
      return rtl;
    }
    return isContinuous;
  };
  const refLineHelper = {
    isRefLineVisible,
    getVisibleRefLines,
    getRefLines,
    getMeasureRefLines,
    getDimensionRefLines,
    isRefLineLabelVisible,
    getVisibleRefLineLabels,
    getRefLineLabels,
    getMeasureRefLineLabels,
    getDimensionRefLineLabels,
    getScaledPosition,
    getDimensionValuesInfo,
    getInputValue: getInputValue$1,
    extractInfoFromInputValue: extractInfoFromInputValue$1,
    resolveValue: resolveValue$1,
    isDiscreteMinOutOfBounds,
    isDiscreteMaxOutOfBounds,
    isContinuousMinOutOfBounds,
    isContinuousMaxOutOfBounds,
    isOutOfRange,
    isOutOfDataPages,
    getInvert
  };

  const ellipsis$2 = '…';
  function tokenizeLabels(labels, fontString, maxLabelWidth = 70) {
    for (let i = 0; i < labels.length; i++) {
      const label = labels[i];
      label.lines = textHelper.tokenize(label.title, fontString, `${ellipsis$2} ${label.valueString}`, 3, maxLabelWidth);
      label.maxNumLines = label.lines.length;
    }
  }
  function retokenizeLabels(labels, fontString, maxLabelWidth = 70) {
    for (let i = 0; i < labels.length; i++) {
      const label = labels[i];
      if (label.lines.length > label.maxNumLines) {
        label.lines = textHelper.tokenize(label.title, fontString, `${ellipsis$2} ${label.valueString}`, label.maxNumLines, maxLabelWidth);
      }
    }
  }

  function getLabelTooltip({
    title,
    font,
    ellipsis,
    maxNumLines = 5,
    maxWidth = 200
  }) {
    const lines = textHelper.tokenize(title, font, ellipsis, maxNumLines, maxWidth);
    const numLines = lines.length;
    let text = '';
    if (numLines) {
      [text] = lines;
      for (let i = 1; i < numLines; i++) {
        text = `${text}\n${lines[i]}`;
      }
    }
    return text;
  }
  function getOobsTooltip({
    oobs,
    font,
    ellipsis,
    maxNumLines = 5,
    maxWidth = 200
  }) {
    const tooltips = oobs.map(oob => getLabelTooltip({
      title: oob.title,
      font,
      ellipsis: `${ellipsis} ${oob.valueString}`,
      maxNumLines,
      maxWidth
    }));
    const numTooltips = tooltips.length;
    let text = '';
    if (numTooltips) {
      [text] = tooltips;
      for (let i = 1; i < numTooltips; i++) {
        text = `${text}\n\n${tooltips[i]}`;
      }
    }
    return text;
  }

  function sortLabels(labels, prop = 'value') {
    labels.sort((l1, l2) => l1[prop] - l2[prop]);
  }

  const ellipsis$1 = '…';
  const BORDER_RADIUS = 3;
  const PADDING$4 = 2;
  const EPSILON$5 = 0.1;
  function escapeRegExp$1(str) {
    return str.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&');
  }
  function getBackgroundRect({
    minorCenter,
    majorAxis,
    minorAxis,
    dock,
    label,
    lineHeight,
    background
  }) {
    const {
      lines
    } = label;
    const {
      borderRadius = BORDER_RADIUS,
      padding = {}
    } = background;
    const {
      top = PADDING$4,
      bottom = PADDING$4,
      left = PADDING$4,
      right = PADDING$4
    } = padding;
    const count = lines.length;
    const obj = {
      type: 'rect',
      rx: borderRadius,
      ry: borderRadius,
      fill: label.background.fill,
      width: label.width + (left + right),
      height: label.height + (top + bottom),
      value: label.value,
      dock
    };
    obj[minorAxis] = minorCenter;
    obj[majorAxis] = label.segment.position;
    obj.x -= label.width / 2 + left;
    obj.y -= count * lineHeight / 2 + top;
    return obj;
  }

  // This can be improved
  function isDateWithHyphenFormat(inputValueLabel) {
    const hasE = inputValueLabel.indexOf('e') > -1;
    if (hasE) {
      return false;
    }
    const idx1 = inputValueLabel.indexOf('-');
    if (idx1 === -1) {
      return false;
    }
    const idx2 = inputValueLabel.lastIndexOf('-');
    if (idx2 !== idx1) {
      return true;
    }
    if (idx1 === 0) {
      return false;
    }
    return true;
  }
  function hasEngineFormat({
    inputValue,
    inputValueLabel,
    localeInfo
  }) {
    if (inputValue === undefined || inputValueLabel === undefined || inputValue.toString() === inputValueLabel) {
      return false;
    }
    if (!localeInfo) {
      return true;
    }
    const specialChars = escapeRegExp$1(`+-${localeInfo.qDecimalSep || ''}${localeInfo.qThousandSep || ''}`);
    const s = inputValueLabel.replace(new RegExp(`[0-9e${specialChars}]`, 'g'), '');
    if (s.length > 0) {
      return true;
    }
    return isDateWithHyphenFormat(inputValueLabel);
  }
  const checkOutOfBounds = ({
    label,
    dataPages,
    qMin,
    qMax
  }) => {
    if (qMin !== undefined && qMax !== undefined) {
      const {
        inputValue: value
      } = label;
      if (refLineHelper.isContinuousMaxOutOfBounds({
        value,
        qMax
      })) {
        return 1;
      }
      if (refLineHelper.isContinuousMinOutOfBounds({
        value,
        qMin
      })) {
        return -1;
      }
    }
    if (refLineHelper.isDiscreteMaxOutOfBounds({
      label,
      dataPages
    })) {
      return 1;
    }
    if (refLineHelper.isDiscreteMinOutOfBounds({
      label,
      dataPages
    })) {
      return -1;
    }
    return 0;
  };
  const labelHelper = {
    hasEngineFormat,
    calculateLabelPositions({
      labels,
      scale,
      size,
      layoutService,
      orientation,
      rtl,
      isContinuous,
      isDimension
    }) {
      const invert = refLineHelper.getInvert({
        orientation,
        rtl,
        isContinuous
      });
      const path = layoutService.getHyperCubeValue('qMode') === 'S' ? 'qDataPages.0' : 'qStackedDataPages.0';
      const dataPages = layoutService.getHyperCubeValue(path);
      const {
        canBeContinuous
      } = layoutService.meta;
      let qMin;
      let qMax;
      if (isDimension && canBeContinuous) {
        const dimInfo = layoutService.getLayoutValue('qHyperCube.qDimensionInfo.0');
        qMin = dimInfo.qMin;
        qMax = dimInfo.qMax;
      }
      for (let i = 0; i < labels.length; i++) {
        const label = labels[i];
        const {
          value,
          align,
          valueInfo
        } = label;
        const oobType = checkOutOfBounds({
          label,
          dataPages,
          qMin,
          qMax
        });
        if (oobType === 1) {
          label.scaledValue = invert ? -EPSILON$5 : 1 + EPSILON$5;
        } else if (oobType === -1) {
          label.scaledValue = invert ? 1 + EPSILON$5 : -EPSILON$5;
        } else {
          label.scaledValue = refLineHelper.getScaledPosition({
            scale,
            size,
            value,
            valueInfo,
            align,
            invert,
            layoutService,
            isContinuous
          });
        }
        label.center = label.scaledValue * size;
      }
    },
    getTitle(label) {
      if (label.showValue !== false) {
        if (label.showLabel !== false) {
          return `${label.text} ${label.valueString}`;
        }
        return label.valueString;
      }
      if (label.showLabel !== false) {
        return label.text;
      }
      return '';
    },
    addLabelTitles({
      labels,
      formatter,
      isContinuous,
      canBeContinuous,
      localeInfo
    }) {
      let valueString;
      if (isContinuous) {
        for (let i = 0; i < labels.length; i++) {
          const label = labels[i];
          const {
            value,
            inputValue,
            inputValueLabel
          } = label;
          if (hasEngineFormat({
            inputValue,
            inputValueLabel,
            localeInfo
          })) {
            valueString = inputValueLabel;
          } else {
            valueString = formatter ? formatter(value) : value;
          }
          label.valueString = `${rtlUtils.lrm}(${valueString})${rtlUtils.lrm}`;
          label.title = labelHelper.getTitle(label);
        }
      } else if (canBeContinuous) {
        for (let i = 0; i < labels.length; i++) {
          const label = labels[i];
          const {
            valueText,
            inputValue,
            inputValueLabel
          } = label;
          if (hasEngineFormat({
            inputValue,
            inputValueLabel,
            localeInfo
          })) {
            valueString = inputValueLabel;
          } else {
            valueString = valueText;
          }
          label.valueString = `${rtlUtils.lrm}(${valueString})${rtlUtils.lrm}`;
          label.title = labelHelper.getTitle(label);
        }
      } else {
        for (let i = 0; i < labels.length; i++) {
          const label = labels[i];
          valueString = label.valueText;
          label.valueString = `${rtlUtils.lrm}(${valueString})${rtlUtils.lrm}`;
          label.title = labelHelper.getTitle(label);
        }
      }
    },
    measureLabelsWidth(labels, measureText) {
      for (let i = 0; i < labels.length; i++) {
        const label = labels[i];
        label.totalWidth = measureText(label.title).width;
      }
    },
    measureLabelMaxLineWidth(label, measureText) {
      const width = Math.max(...label.lines.map(line => measureText(line).width));
      return width;
    },
    getMaxTextWidth(labels) {
      const widths = labels.map(label => label.totalWidth);
      const maxWidth = Math.max(...widths);
      return maxWidth;
    },
    addLabelsNeighborInfo(labels, min, max, gap = 0) {
      const n = labels.length - 1;
      if (n < 0) {
        return;
      }
      let label;
      let nextLabel;
      [label] = labels;
      label.cMin = min;
      if (n === 0) {
        label.cMax = max;
        return;
      }
      for (let i = 0; i < n; i++) {
        label = labels[i];
        nextLabel = labels[i + 1];
        label.cMax = (label.center + nextLabel.center - gap) / 2;
        nextLabel.cMin = label.cMax + gap;
      }
      nextLabel.cMax = max;
    },
    getTotalNumLines(labels) {
      let numLines = 0;
      labels.forEach(label => {
        numLines += label.maxNumLines;
      });
      return numLines;
    },
    reduceLabelsHavingMaxNumLines(labels, labelMaxNumLines, totalNumLinesReduced) {
      const newLabelMaxNumLines = labelMaxNumLines - 1;
      const filteredLabels = labels.filter(label => label.maxNumLines === labelMaxNumLines);
      const numLinesReduced = Math.min(totalNumLinesReduced, filteredLabels.length);
      for (let i = filteredLabels.length - 1; i >= filteredLabels.length - numLinesReduced; i--) {
        filteredLabels[i].maxNumLines = newLabelMaxNumLines;
      }
    },
    reduceTotalMaxNumLines(labels, lineHeight, size) {
      const totalMaxNumLines = Math.floor(size / lineHeight);
      let maxLabelNumLines = 3;
      do {
        const totalNumLinesOfLabels = labelHelper.getTotalNumLines(labels);
        const totalNumLinesReduced = totalNumLinesOfLabels - totalMaxNumLines;
        if (totalNumLinesReduced <= 0) {
          return;
        }
        labelHelper.reduceLabelsHavingMaxNumLines(labels, maxLabelNumLines, totalNumLinesReduced);
        maxLabelNumLines--;
      } while (maxLabelNumLines > 1);
    },
    reduceMaxNumLines(labels, lineHeight, epsilon = 0) {
      for (let i = 0; i < labels.length; i++) {
        const label = labels[i];
        label.maxNumLines = Math.max(1, Math.min(label.maxNumLines, Math.floor((Math.max(0, label.cMax - label.cMin) + epsilon) / lineHeight)));
      }
    },
    addLabelsSize(labels, labelMaxWidth, lineHeight = 15, measureText) {
      for (let i = 0; i < labels.length; i++) {
        const label = labels[i];
        label.width = Math.min(labelMaxWidth, labelHelper.measureLabelMaxLineWidth(label, measureText));
        label.height = label.lines.length * lineHeight;
      }
    },
    addLabelSegments(labels, majorDimension) {
      for (let i = 0; i < labels.length; i++) {
        const label = labels[i];
        const {
          center
        } = label;
        const range = label[majorDimension];
        const radius = range / 2;
        label.segment = {
          center,
          range,
          min: center - radius,
          max: center + radius,
          radius
        };
      }
    },
    addLabelsInfo({
      labels,
      scale,
      majorSize,
      lowerLimit,
      upperLimit,
      gap,
      font,
      maxLabelWidth,
      lineHeight,
      majorDimension,
      orientation,
      measureText,
      rtl,
      layoutService,
      isContinuous,
      isDimension
    }) {
      const prioritizedLabels = labels.map(label => label);
      const size = majorSize;
      labelHelper.calculateLabelPositions({
        labels,
        scale,
        size,
        layoutService,
        orientation,
        rtl,
        isContinuous,
        isDimension
      });
      sortLabels(labels, 'center');
      labelHelper.addLabelsNeighborInfo(labels, lowerLimit, upperLimit, gap);
      tokenizeLabels(labels, font, maxLabelWidth);
      labelHelper.reduceTotalMaxNumLines(prioritizedLabels, lineHeight, upperLimit - (prioritizedLabels.length - 1) * gap);
      if (orientation === 'vertical') {
        labelHelper.reduceMaxNumLines(labels, lineHeight, gap * 0.05);
        retokenizeLabels(labels, font, maxLabelWidth);
      }
      labelHelper.addLabelsSize(labels, maxLabelWidth, lineHeight, measureText);
      labelHelper.addLabelSegments(labels, majorDimension);
    },
    createLabels({
      labels,
      style,
      maxLabelWidth,
      areaProps,
      area,
      lineHeight = 15,
      font
    }) {
      const {
        majorAxis,
        minorAxis,
        dock
      } = areaProps;
      const {
        minorCenter
      } = area;
      const {
        fontSize,
        fontFamily,
        background
      } = style;
      let result = [];
      labels.forEach(label => {
        const {
          lines
        } = label;
        const count = lines.length;
        const renderedTextLines = lines.map((line, idx) => {
          const obj = {
            type: 'text',
            text: line,
            title: getLabelTooltip({
              title: label.title,
              font,
              ellipsis: `${ellipsis$1} ${label.valueString}`
            }),
            dx: 0,
            dy: 0,
            maxWidth: maxLabelWidth,
            width: maxLabelWidth,
            fontSize,
            fontFamily,
            fill: label.fill,
            baseline: 'central',
            anchor: 'middle',
            value: label.value,
            dock
          };
          obj[minorAxis] = minorCenter;
          obj[majorAxis] = label.segment.position;
          obj.y += (idx - (count - 1) / 2) * lineHeight;
          return obj;
        });
        if (label.background) {
          result.push(getBackgroundRect({
            minorCenter,
            majorAxis,
            minorAxis,
            dock,
            label,
            lineHeight,
            background
          }));
        }
        result = result.concat(renderedTextLines);
      });
      return result;
    }
  };

  function getFormatter$1(chart, formatter, scale) {
    let formatterFn;
    const s = typeof formatter;
    if (s === 'string' || s === 'object') {
      formatterFn = chart.formatter(formatter);
    } else if (typeof scale !== 'undefined' && scale.data) {
      const scaleData = scale.data() && scale.data().fields;
      formatterFn = scaleData && scaleData[0] ? scaleData[0].formatter() : null;
    }
    return formatterFn;
  }

  const createVerticalAreaProps = dock => ({
    dock,
    orientation: 'vertical',
    majorAxis: 'y',
    minorAxis: 'x',
    majorDimension: 'height',
    minorDimension: 'width',
    flipXY: false
  });
  const createHorizontalAreaProps = dock => ({
    dock,
    orientation: 'horizontal',
    majorAxis: 'x',
    minorAxis: 'y',
    majorDimension: 'width',
    minorDimension: 'height',
    flipXY: true
  });
  function createAreaProps(dock) {
    return dock === 'left' || dock === 'right' ? createVerticalAreaProps(dock) : createHorizontalAreaProps(dock);
  }
  function createArea(rect, areaProps, padding) {
    const minorSize = rect[areaProps.minorDimension];
    const majorSize = rect[areaProps.majorDimension];
    const minorCenter = areaProps.orientation === 'vertical' ? (minorSize - padding.right - padding.left) / 2 + padding.left : (minorSize - padding.top - padding.bottom) / 2 + padding.top;
    return {
      minorSize,
      majorSize,
      minorCenter
    };
  }
  function getPreferredWidth(labels, labelStyle) {
    const {
      left,
      right,
      maxLabelWidth
    } = labelStyle;
    return Math.min(maxLabelWidth, labelHelper.getMaxTextWidth(labels)) + left + right;
  }
  function getPreferredHeight(labels, labelStyle) {
    const {
      font,
      lineHeight,
      top,
      bottom,
      maxLabelWidth
    } = labelStyle;
    let numLines = 1;
    if (labelHelper.getMaxTextWidth(labels) > maxLabelWidth) {
      tokenizeLabels(labels, font, maxLabelWidth);
      numLines = Math.max(...labels.map(label => label.lines.length));
    }
    return numLines * lineHeight + top + bottom;
  }
  function getPreferredSize(dock, labels, labelStyle) {
    return dock === 'top' || dock === 'bottom' ? getPreferredHeight(labels, labelStyle) : getPreferredWidth(labels, labelStyle);
  }

  function getMinMaxValues(scale, isContinuous) {
    if (!isContinuous) {
      return [0, 1];
    }
    return scale.domain();
  }

  const ellipsis = '…';
  function filterOobLabels(labels, minValue, maxValue, prop = 'value') {
    let filteredLabels = labels.filter(label => label[prop] >= minValue);
    filteredLabels = filteredLabels.filter(label => label[prop] <= maxValue);
    const minOobs = labels.filter(label => label[prop] < minValue);
    const maxOobs = labels.filter(label => label[prop] > maxValue);
    const numMinOobs = minOobs.length;
    const numMaxOobs = maxOobs.length;
    return {
      filteredLabels,
      minOobs,
      maxOobs,
      numMinOobs,
      numMaxOobs
    };
  }
  function getLowerOobs(minOobs, maxOobs, invert) {
    return invert ? maxOobs : minOobs;
  }
  function getUpperOobs(minOobs, maxOobs, invert) {
    return invert ? minOobs : maxOobs;
  }
  function getLowerOobSpace(numMinOobs, oobSize, minCircleSize, orientation, padding) {
    const p = orientation === 'vertical' ? padding.top : padding.left;
    return p + (numMinOobs > 0 ? oobSize + minCircleSize : 0);
  }
  function getUpperOobSpace(numMaxOobs, oobSize, maxCircleSize, orientation, padding) {
    const p = orientation === 'vertical' ? padding.bottom : padding.right;
    return p + (numMaxOobs > 0 ? oobSize + maxCircleSize : 0);
  }
  function getOobSizes(measureText) {
    let max = 0;
    let s;
    for (let i = 1; i < 10; i++) {
      s = measureText(i);
      max = Math.max(max, Math.sqrt(s.width * s.width + s.height * s.height));
    }
    s = measureText('9+');
    return [max, Math.max(max, Math.sqrt(s.width * s.width + s.height * s.height))];
  }
  function getCircleSize(numOobs, circleSizes) {
    return numOobs > 9 ? circleSizes[1] : circleSizes[0];
  }
  function createOobsInfo({
    labels,
    minValue,
    maxValue,
    orientation,
    rtl,
    isContinuous,
    style,
    padding,
    measureText,
    prop = 'value'
  }) {
    const {
      maxOobs,
      minOobs,
      filteredLabels
    } = filterOobLabels(labels, minValue, maxValue, prop);
    const invert = prop === 'scaledValue' ? false : refLineHelper.getInvert({
      orientation,
      rtl,
      isContinuous
    });
    const lowerOobs = getLowerOobs(minOobs, maxOobs, invert);
    const upperOobs = getUpperOobs(minOobs, maxOobs, invert);
    const numLowerOobs = lowerOobs.length;
    const numUpperOobs = upperOobs.length;
    const circleSizes = getOobSizes(measureText);
    const lowerCircleSize = getCircleSize(numLowerOobs, circleSizes);
    const upperCircleSize = getCircleSize(numUpperOobs, circleSizes);
    const lowerOobSpace = getLowerOobSpace(numLowerOobs, style.oob.size, lowerCircleSize, orientation, padding);
    const upperOobSpace = getUpperOobSpace(numUpperOobs, style.oob.size, upperCircleSize, orientation, padding);
    return {
      filteredLabels,
      lowerOobs,
      upperOobs,
      lowerCircleSize,
      upperCircleSize,
      lowerOobSpace,
      upperOobSpace
    };
  }
  function createOobs({
    alignment,
    dockValue,
    oobs,
    style,
    rect,
    symbol,
    position,
    areaProps,
    radius,
    font
  }) {
    const numOobs = oobs ? oobs.length : 0;
    if (numOobs < 1) {
      return [];
    }
    const {
      flipXY,
      majorAxis,
      minorAxis,
      minorDimension,
      dock
    } = areaProps;
    const minorSize = rect[minorDimension];
    const oobSymbol = oobHelper.createOob({
      oob: oobHelper.getDefaultSettings({
        size: style.size,
        fill: style.fill,
        alignment
      }),
      dockValue,
      boxCenter: 0.5,
      rendWidth: rect.width,
      rendHeight: rect.height,
      flipXY,
      symbol
    });
    oobSymbol.dock = dock;
    const cMajorAxis = `c${majorAxis}`;
    const cMinorAxis = `c${minorAxis}`;
    const circle = {
      type: 'circle',
      r: radius,
      stroke: 'transparent',
      fill: style.text.background.fill,
      strokeWidth: 0,
      dock
    };
    circle[cMinorAxis] = minorSize / 2;
    circle[cMajorAxis] = position;
    const oobText = {
      type: 'text',
      text: numOobs > 9 ? '9+' : numOobs,
      title: getOobsTooltip({
        oobs,
        font,
        ellipsis
      }),
      dx: 0,
      dy: 0,
      maxWidth: minorSize,
      width: minorSize,
      fontSize: style.text.fontSize,
      fontFamily: style.text.fontFamily,
      fill: style.text.fill,
      baseline: 'central',
      anchor: 'middle',
      dock
    };
    oobText[minorAxis] = minorSize / 2;
    oobText[majorAxis] = position;
    return [oobSymbol, circle, oobText];
  }

  function getLabelStyle (labelStyle) {
    const font = `normal ${labelStyle.fontSize} '${labelStyle.fontFamily}'`;
    const fontHeight = textHelper.getFontHeight(font);
    const lineHeightMultiplicator = labelStyle.lineHeightMultiplicator || 1;
    const lineHeight = fontHeight * lineHeightMultiplicator;
    const gap = labelStyle.gap || 12;
    const maxLabelWidth = labelStyle.maxWidth || 75;
    const top = labelStyle.padding.top || 0;
    const bottom = labelStyle.padding.bottom || 0;
    const left = labelStyle.padding.left || 0;
    const right = labelStyle.padding.right || 0;
    return {
      font,
      lineHeight,
      gap,
      maxLabelWidth,
      top,
      bottom,
      left,
      right
    };
  }

  const resolveLabels = labels => labels.map(label => ({
    ...label,
    value: typeof label.value === 'function' ? label.value() : label.value,
    valueText: typeof label.valueText === 'function' ? label.valueText() : label.valueText,
    valueInfo: typeof label.valueInfo === 'function' ? label.valueInfo() : label.valueInfo
  }));
  const getFilteredLabels = ({
    labels,
    scale,
    isContinuous,
    canBeContinuous,
    layoutService
  }) => {
    if (isContinuous) {
      const [qMin, qMax] = getMinMaxValues(scale, isContinuous);
      return filterOobLabels(labels, qMin, qMax);
    }
    // TODO: Need to find only labels exist in the dimension
    if (canBeContinuous) {
      const dimInfo = layoutService.getLayoutValue('qHyperCube.qDimensionInfo.0');
      const {
        qMin,
        qMax
      } = dimInfo;
      if (qMin !== 'NaN' && qMax !== 'NaN') {
        return filterOobLabels(labels, qMin, qMax, 'inputValue');
      }
    }
    return {
      filteredLabels: labels
    };
  };
  var refLineLabelsComponent = {
    require: ['renderer', 'chart', 'symbol'],
    defaultSettings: {
      layout: {
        displayOrder: 0,
        prioOrder: 0
      }
    },
    preferredSize() {
      const {
        scale
      } = this;
      const {
        style,
        layoutService,
        isContinuous,
        localeInfo
      } = this.settings;
      const canBeContinuous = isContinuous ? true : layoutService.meta.canBeContinuous;
      const labels = resolveLabels(this.settings.labels);
      const formatter = getFormatter$1(this.chart, this.settings.formatter, scale);
      labelHelper.addLabelTitles({
        labels,
        formatter,
        isContinuous,
        canBeContinuous,
        localeInfo
      });
      const {
        numMaxOobs,
        numMinOobs,
        filteredLabels
      } = getFilteredLabels({
        labels,
        scale,
        isContinuous,
        canBeContinuous,
        layoutService
      });
      this.measureText = text => this.renderer.measureText({
        text,
        fontSize: style.label.fontSize,
        fontFamily: style.label.fontFamily
      });
      let preferredSize;
      if (filteredLabels && filteredLabels.length) {
        const labelStyle = getLabelStyle(style.label);
        const {
          dock
        } = this.settings.layout;
        labelHelper.measureLabelsWidth(filteredLabels, this.measureText);
        preferredSize = getPreferredSize(dock, filteredLabels, labelStyle);
        return preferredSize;
      }
      const circleSizes = getOobSizes(this.measureText);
      const maxCircleSize = numMaxOobs ? getCircleSize(numMaxOobs, circleSizes) : 0;
      const minCircleSize = numMinOobs ? getCircleSize(numMinOobs, circleSizes) : 0;
      preferredSize = Math.max(maxCircleSize, minCircleSize);
      return preferredSize;
    },
    render() {
      const {
        scale
      } = this;
      if (!scale.domain().length) {
        return undefined;
      }
      const {
        symbol
      } = this;
      const {
        style,
        layoutService,
        theme,
        isContinuous,
        isDimension,
        localeInfo
      } = this.settings;
      const canBeContinuous = isContinuous ? true : layoutService.meta.canBeContinuous;
      const labels = resolveLabels(this.settings.labels);
      const {
        dock,
        rtl
      } = this.settings.layout;
      const {
        padding
      } = style.label;
      const areaProps = createAreaProps(dock);
      const area = createArea(this.rect, areaProps, padding);
      const {
        orientation,
        majorDimension
      } = areaProps;
      const {
        majorSize
      } = area;
      const {
        font,
        lineHeight,
        gap,
        maxLabelWidth
      } = getLabelStyle(style.label);
      const formatter = getFormatter$1(this.chart, this.settings.formatter, scale);
      const size = majorSize;
      labelHelper.addLabelTitles({
        labels,
        formatter,
        isContinuous,
        canBeContinuous,
        localeInfo
      });
      labelHelper.calculateLabelPositions({
        labels,
        scale,
        size,
        layoutService,
        orientation,
        rtl,
        isContinuous,
        isDimension
      });
      const [minValue, maxValue] = getMinMaxValues(scale, isContinuous);
      const {
        filteredLabels,
        lowerOobs,
        upperOobs,
        lowerCircleSize,
        upperCircleSize,
        lowerOobSpace,
        upperOobSpace
      } = createOobsInfo({
        labels,
        minValue,
        maxValue,
        orientation,
        rtl,
        isContinuous,
        style,
        padding,
        measureText: this.measureText,
        prop: isContinuous ? 'value' : 'scaledValue'
      });
      const lowerLimit = lowerOobSpace;
      const upperLimit = majorSize - upperOobSpace;
      sortLabels(lowerOobs);
      sortLabels(upperOobs);
      const renderedLowerOobs = createOobs({
        alignment: 0,
        dockValue: 0,
        oobs: lowerOobs,
        style: style.oob,
        rect: this.rect,
        symbol,
        position: style.oob.size + lowerCircleSize / 2,
        areaProps,
        radius: lowerCircleSize / 2,
        font
      });
      const renderedUpperOobs = createOobs({
        alignment: 1,
        dockValue: 1,
        oobs: upperOobs,
        style: style.oob,
        rect: this.rect,
        symbol,
        position: majorSize - (style.oob.size + upperCircleSize / 2),
        areaProps,
        radius: upperCircleSize / 2,
        font
      });
      labelHelper.addLabelsInfo({
        labels: filteredLabels,
        scale,
        majorSize,
        lowerLimit,
        upperLimit,
        font,
        lineHeight,
        gap,
        maxLabelWidth,
        majorDimension,
        orientation,
        measureText: this.measureText,
        rtl,
        layoutService,
        isContinuous,
        isDimension
      });
      labelLayout.layout(filteredLabels.map(label => label.segment), lowerLimit, upperLimit, style.label.gap);
      const filteredLabels2 = filteredLabels.filter(label => labelLayout.isInside(label.segment, lowerLimit, upperLimit, isContinuous));
      const renderedLabels = labelHelper.createLabels({
        labels: filteredLabels2,
        style: style.label,
        maxLabelWidth,
        areaProps,
        area,
        lineHeight,
        font,
        theme
      });
      return renderedLabels.concat([...renderedLowerOobs, ...renderedUpperOobs]);
    }
  };

  function trackByAxes({
    isTime,
    isContinuous,
    isMeasure,
    isMajor
  }) {
    return node => {
      // Measure axis or continuous/time dimension axis
      if (isTime || isContinuous || isMeasure) {
        if (node.type === 'line') {
          var _node$tickValue;
          // Ticks or Guidelines, or Axis if it has no tickValue
          return (_node$tickValue = node.tickValue) !== null && _node$tickValue !== void 0 ? _node$tickValue : 'axis';
        }
        // Labels
        if (node.type === 'text') {
          return `${node.tickValue} ${node.text}`;
        }
        // Containers (e.g. bullet chart box axis)
        if (node.type === 'container') {
          const axisLabels = node.children.filter(childNode => childNode.type === 'text').map(childNode => childNode.text);
          return `${node.data.value} ${axisLabels.join('')}`;
        }
        return Math.random();
      }

      // Major dimension axis
      if (isMajor) {
        if (node.type === 'line' && node.tickValue === undefined) {
          return 'axis';
        }

        // To avoid glitches when a label rotates: if a label changes angle (0 <--> some angle), consider it's a new node
        const rotation = node.transform && node.transform.match(/rotate/gi) ? 'rotated' : 'horizontal';

        // For a grouped bar chart with multiple dimensions, bar labels can have the same text and value
        // across different groups, so group.value is needed to distinguish them.
        const groupValue = node.data.group ? `${node.data.group.value} ` : '';
        return `${groupValue}${node.data.value} ${node.text} ${rotation}`;
      }
      return Math.random();
    };
  }

  function trackByBars(node) {
    if (node.data.measureIndex) {
      return `${node.data.value} ${node.data.measureIndex.value}`;
    }
    if (node.data.group) {
      return `${node.data.value} ${node.data.group.value}`;
    }
    if (node.data.stack) {
      return `${node.data.value} ${node.data.stack.value}`;
    }
    return `${node.data.value}`;
  }

  function trackByLabels(node) {
    if (node.type === 'rect') {
      // data: others
      if (node.data === '-3') {
        return Math.random();
      }
      return `${node.type} ${node.data} ${node.rotation}`;
    }
    // To avoid glitches when a label rotates: if a label changes angle, consider it's a new node
    const rotation = node.transform && node.transform.match(/rotate/gi) ? 'rotated' : 'horizontal';
    return `${node.type} ${node.data} ${node.text} ${rotation}`;
  }

  function trackByLines(node) {
    if (node.type === 'line') {
      var _node$value;
      return (_node$value = node.value) !== null && _node$value !== void 0 ? _node$value : Math.random();
    }
    if (node.type === 'path') {
      return `${node.generatorType} ${node.layerObj.id} ${node.data.source.key}`;
    }
    return Math.random();
  }

  function trackByPoints(node) {
    return node.data.line ? `${node.data.line.value} ${node.data.major.value}` : `${node.data.major.value}`;
  }

  function trackByRefLineLabels(node) {
    // Labels and background rects
    if (node.value !== undefined) {
      if (node.type === 'rect') {
        return `${node.value}`;
      }
      if (node.type === 'text') {
        return `${node.value} ${node.text}`;
      }
    }
    // Out of bound circles, triangles, and texts
    return Math.random();
  }

  function trackByShadowBars() {
    // Skip transition stage since the shadow bars behave strangely
    // Give node a random ID, effectively skipping updating stage of Picasso's tweening
    return Math.random();
  }

  function trackByNonUpdatingNode() {
    return Math.random();
  }

  /* eslint-disable no-param-reassign */
  function compensateAxesForLayoutChanges({
    isMeasure,
    isTime,
    isContinuous,
    isHorizontal,
    dock
  }) {
    return ({
      currentNodes,
      currentRect,
      previousRect
    }) => {
      const deltaX = currentRect.x - previousRect.x;
      const deltaY = currentRect.y - previousRect.y;
      const deltaWidth = currentRect.width - previousRect.width;
      const deltaHeight = currentRect.height - previousRect.height;
      // Measure axis, both vertical and horizontal
      if (isMeasure) {
        if (dock === 'left') {
          // Move y axis' ticks, axis, and labels left/right to match with the currentRect
          currentNodes.forEach(node => {
            // ticks + axis
            if (node.type === 'line') {
              node.x1 += deltaWidth;
              node.x2 += deltaWidth;
            } else if (node.type === 'text') {
              node.x += deltaWidth;
            }
          });
        }
        if (dock === 'left' || dock === 'right') {
          // Move y axis' ticks, axis, and labels up/down to match with the currentRect
          currentNodes.forEach(node => {
            if (node.type === 'line') {
              // Axis
              if (node.x1 === node.x2) {
                node.y1 = currentRect.y;
                node.y2 = node.y1 + currentRect.height;
              }
              // Ticks: hide the ones that are outside currentRect
              else if (Math.round(node.y1) < currentRect.y || node.y1 > currentRect.y + currentRect.height) {
                node.strokeWidth = 0;
              }
            }
            if (node.type === 'text') {
              // Texts: hide the ones that are outside currentRect
              if (node.y < currentRect.y || node.y > currentRect.y + currentRect.height) {
                var _node$fill;
                node.fontSize = '1px';
                if (((_node$fill = node.fill) === null || _node$fill === void 0 ? void 0 : _node$fill[0]) === '#') {
                  node.fill = `${node.fill.slice(0, 1)}00${node.fill.slice(1)}`;
                }
              }
            }
          });
        }
        if (dock === 'top' || dock === 'bottom') {
          // Move y axis' ticks, axis, and labels left/right to match with the currentRect
          currentNodes.forEach(node => {
            if (node.type === 'line') {
              // Axis
              if (node.y1 === node.y2) {
                node.x1 = currentRect.x;
                node.x2 = node.x1 + currentRect.width;
              }
              // Ticks: hide the ones that are outside currentRect
              else if (Math.round(node.x1) < currentRect.x || node.x1 > currentRect.x + currentRect.width) {
                node.strokeWidth = 0;
              }
            }
            if (node.type === 'text') {
              // Texts: hide the ones that are outside currentRect
              if (node.x < currentRect.x || node.x > currentRect.x + currentRect.width) {
                var _node$fill2;
                node.fontSize = '1px';
                if (((_node$fill2 = node.fill) === null || _node$fill2 === void 0 ? void 0 : _node$fill2[0]) === '#') {
                  node.fill = `${node.fill.slice(0, 1)}00${node.fill.slice(1)}`;
                }
              }
            }
          });
        }
      }
      // Dimension axis: time axis (time axis is special compared to other types of axis
      // because nodes' positions are relative to rect, not chart)
      else if (isTime) {
        // Extend the time axis to match with the new layout
        // Move the guidelines and the labels in the opposite direction of the change
        currentNodes.forEach(node => {
          if (node.type === 'line') {
            if (node.y1 === node.y2) {
              node.x2 += deltaWidth;
            } else if (node.x1 === node.x2) {
              node.x1 -= deltaX;
              node.x2 -= deltaX;
            }
          } else if (node.type === 'text') {
            node.x -= deltaX;
          }
        });
      }
      // Dimension axis: continuous axis or major axis (horizontal + vertical)
      else if (isContinuous || isHorizontal) {
        currentNodes.forEach(node => {
          if (node.type === 'line' && node.y1 === node.y2) {
            // Ajust position and length of axis
            node.x1 += deltaX;
            node.x2 += deltaX + deltaWidth;
          }
        });
      } else {
        currentNodes.forEach(node => {
          if (node.type === 'line' && node.x1 === node.x2) {
            // Ajust position and length of axis
            node.y1 += deltaY;
            node.y2 += deltaY + deltaHeight;
          }
        });
      }
    };
  }

  /* eslint-disable no-param-reassign */
  function compensateBarOobsForLayoutChanges({
    currentNodes,
    currentRect,
    previousRect
  }) {
    const deltaX = currentRect.x - previousRect.x;
    const deltaY = currentRect.y - previousRect.y;
    // Since the bar OOBs are contained in a narrow, OOB-height rect, there's no way to compensate
    // for the change in position of the rect. Simply hide the OOBs if the layout changes.
    if (deltaY !== 0 || deltaX !== 0) {
      currentNodes.forEach(node => {
        if (node.children && node.children.length > 0) {
          node.children.forEach(child => {
            child.opacity = 0;
          });
        }
      });
    }
  }

  /* eslint-disable no-param-reassign */
  function compensateLineOobsForLayoutChanges({
    currentNodes,
    currentRect,
    previousRect
  }) {
    const deltaX = currentRect.x - previousRect.x;
    const deltaY = currentRect.y - previousRect.y;
    // Since the bar OOBs are contained in a narrow, OOB-height rect, there's no way to compensate
    // for the change in position of the rect. Simply hide the OOBs if the layout changes.
    if (deltaY !== 0 || deltaX !== 0) {
      currentNodes.forEach(node => {
        node.opacity = 0;
      });
    }
  }

  /* eslint-disable no-param-reassign */
  function compensateBarsForLayoutChanges({
    currentNodes,
    currentRect,
    previousRect
  }) {
    // Bars' positions are relative to the rect, so to compensate
    // we move bars in the opposive direction to the changes
    const deltaX = currentRect.x - previousRect.x;
    const deltaY = currentRect.y - previousRect.y;
    if (deltaX !== 0 || deltaY !== 0) {
      currentNodes.forEach(node => {
        if (node.children && node.children.length > 0) {
          node.children.forEach(childNode => {
            if (childNode.x !== undefined && childNode.y !== undefined) {
              childNode.x -= deltaX;
              childNode.y -= deltaY;
            } else {
              childNode.transform = `translate(${-deltaX}, ${-deltaY})`;
            }
          });
        }
      });
    }
  }

  /* eslint-disable no-param-reassign */
  function compensateLabelsForLayoutChanges({
    currentNodes,
    currentRect,
    previousRect
  }) {
    // Labels' positions are relative to the rect, so to compensate
    // we move labels in the opposive direction to the changes
    const deltaX = currentRect.x - previousRect.x;
    const deltaY = currentRect.y - previousRect.y;
    if (deltaX !== 0 || deltaY !== 0) {
      currentNodes.forEach(node => {
        if (node.transform && node.transform.match(/rotate\(-90/gi)) {
          node.x += deltaY;
          node.y -= deltaX;
        } else {
          node.x -= deltaX;
          node.y -= deltaY;
        }
      });
    }
  }

  /* eslint-disable no-param-reassign */
  function compensateLinesForLayoutChanges({
    currentNodes,
    currentRect,
    previousRect
  }) {
    const deltaX = currentRect.x - previousRect.x;
    const deltaY = currentRect.y - previousRect.y;
    currentNodes.forEach(node => {
      if (node.x1 !== undefined && node.y1 !== undefined) {
        // Horizontal line
        if (node.y1 === node.y2) {
          node.x2 = node.x1 + currentRect.width;
          node.y1 -= deltaY;
          node.y2 -= deltaY;
        }
        // Vertical line
        else if (node.x1 === node.x2) {
          node.y2 = node.y1 + currentRect.height;
          node.x1 -= deltaX;
          node.x2 -= deltaX;
        }
      } // Path
      else {
        const deltaMajor = node.major.p === 'x' ? deltaX / node.major.size : deltaY / node.major.size;
        const deltaMinor = node.minor.p === 'y' ? deltaY / node.minor.size : deltaX / node.minor.size;
        node.points.forEach(point => {
          if (!point.modified) {
            point.major -= deltaMajor;
            point.minor -= deltaMinor;
            point.minor0 -= deltaMinor;
            point.modified = true;
          }
        });
      }
    });
  }

  /* eslint-disable no-param-reassign */
  function compensatePointsForLayoutChanges({
    currentNodes,
    currentRect,
    previousRect
  }) {
    // Points' positions are relative to the rect, so to compensate
    // we move points in the opposive direction to the changes
    const deltaX = currentRect.x - previousRect.x;
    const deltaY = currentRect.y - previousRect.y;
    if (deltaX !== 0 || deltaY !== 0) {
      currentNodes.forEach(node => {
        node.cx -= deltaX;
        node.cy -= deltaY;
      });
    }
  }

  /* eslint-disable no-param-reassign */
  function compensateRefLineLabelsForLayoutChanges({
    currentNodes,
    currentRect,
    previousRect
  }) {
    const deltaX = currentRect.x - previousRect.x;
    const deltaY = currentRect.y - previousRect.y;
    const deltaWidth = currentRect.width - previousRect.width;
    const deltaHeight = currentRect.height - previousRect.height;
    let dx = -deltaX;
    let dy = -deltaY;
    // In general, we want to move the labels and oobs in the opposite direction to the layout changes (hence, -delta X and -deltaY).
    // However, in some cases when the old labels overlap with (and are hidden behind) the new center rect,
    // we want to hide the labels instead, by moving them out of the view (the 1st switch below).
    currentNodes.forEach(node => {
      switch (node.dock) {
        case 'right':
          if (deltaX > 0) {
            dx = currentRect.width;
          }
          break;
        case 'left':
          if (deltaWidth < 0) {
            dx = -previousRect.width;
          }
          break;
        case 'top':
          if (deltaHeight < 0) {
            dy = -previousRect.height;
          }
          break;
        case 'bottom':
          if (deltaY > 0) {
            dy = currentRect.height;
          }
          break;
      }
      switch (node.type) {
        case 'text':
        case 'rect':
          node.x += dx;
          node.y += dy;
          break;
        case 'circle':
          node.cx += dx;
          node.cy += dy;
          break;
        case 'path':
          node.transform = `translate(${dx}, ${dy})`;
          break;
      }
    });
  }

  function linkDataForLabels(node) {
    if (node.data.measureIndex) {
      return `${node.data.value} ${node.data.measureIndex.value}`;
    }
    if (node.data.group) {
      return `${node.data.value} ${node.data.group.value}`;
    }
    if (node.data.stack) {
      return `${node.data.value} ${node.data.stack.value}`;
    }
    return `${node.data.value}`;
  }

  /*
  * qlik-chart-modules v0.59.0
  * Copyright (c) 2023 QlikTech International AB
  * Released under the MIT license.
  */

  function e(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(e);
      t && (r = r.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable;
      })), n.push.apply(n, r);
    }
    return n;
  }
  function t$1(t) {
    for (var n = 1; n < arguments.length; n++) {
      var r = null != arguments[n] ? arguments[n] : {};
      n % 2 ? e(Object(r), !0).forEach(function (e) {
        a$1(t, e, r[e]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : e(Object(r)).forEach(function (e) {
        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e));
      });
    }
    return t;
  }
  function n$1() {
    n$1 = function () {
      return e;
    };
    var e = {},
      t = Object.prototype,
      r = t.hasOwnProperty,
      o = Object.defineProperty || function (e, t, n) {
        e[t] = n.value;
      },
      i = "function" == typeof Symbol ? Symbol : {},
      a = i.iterator || "@@iterator",
      l = i.asyncIterator || "@@asyncIterator",
      u = i.toStringTag || "@@toStringTag";
    function c(e, t, n) {
      return Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), e[t];
    }
    try {
      c({}, "");
    } catch (e) {
      c = function (e, t, n) {
        return e[t] = n;
      };
    }
    function s(e, t, n, r) {
      var i = t && t.prototype instanceof p ? t : p,
        a = Object.create(i.prototype),
        l = new C(r || []);
      return o(a, "_invoke", {
        value: w(e, n, l)
      }), a;
    }
    function f(e, t, n) {
      try {
        return {
          type: "normal",
          arg: e.call(t, n)
        };
      } catch (e) {
        return {
          type: "throw",
          arg: e
        };
      }
    }
    e.wrap = s;
    var d = {};
    function p() {}
    function h() {}
    function m() {}
    var v = {};
    c(v, a, function () {
      return this;
    });
    var y = Object.getPrototypeOf,
      g = y && y(y(D([])));
    g && g !== t && r.call(g, a) && (v = g);
    var b = m.prototype = p.prototype = Object.create(v);
    function x(e) {
      ["next", "throw", "return"].forEach(function (t) {
        c(e, t, function (e) {
          return this._invoke(t, e);
        });
      });
    }
    function q(e, t) {
      function n(o, i, a, l) {
        var u = f(e[o], e, i);
        if ("throw" !== u.type) {
          var c = u.arg,
            s = c.value;
          return s && "object" == typeof s && r.call(s, "__await") ? t.resolve(s.__await).then(function (e) {
            n("next", e, a, l);
          }, function (e) {
            n("throw", e, a, l);
          }) : t.resolve(s).then(function (e) {
            c.value = e, a(c);
          }, function (e) {
            return n("throw", e, a, l);
          });
        }
        l(u.arg);
      }
      var i;
      o(this, "_invoke", {
        value: function (e, r) {
          function o() {
            return new t(function (t, o) {
              n(e, r, t, o);
            });
          }
          return i = i ? i.then(o, o) : o();
        }
      });
    }
    function w(e, t, n) {
      var r = "suspendedStart";
      return function (o, i) {
        if ("executing" === r) throw new Error("Generator is already running");
        if ("completed" === r) {
          if ("throw" === o) throw i;
          return {
            value: void 0,
            done: !0
          };
        }
        for (n.method = o, n.arg = i;;) {
          var a = n.delegate;
          if (a) {
            var l = M(a, n);
            if (l) {
              if (l === d) continue;
              return l;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if ("suspendedStart" === r) throw r = "completed", n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          r = "executing";
          var u = f(e, t, n);
          if ("normal" === u.type) {
            if (r = n.done ? "completed" : "suspendedYield", u.arg === d) continue;
            return {
              value: u.arg,
              done: n.done
            };
          }
          "throw" === u.type && (r = "completed", n.method = "throw", n.arg = u.arg);
        }
      };
    }
    function M(e, t) {
      var n = t.method,
        r = e.iterator[n];
      if (void 0 === r) return t.delegate = null, "throw" === n && e.iterator.return && (t.method = "return", t.arg = void 0, M(e, t), "throw" === t.method) || "return" !== n && (t.method = "throw", t.arg = new TypeError("The iterator does not provide a '" + n + "' method")), d;
      var o = f(r, e.iterator, t.arg);
      if ("throw" === o.type) return t.method = "throw", t.arg = o.arg, t.delegate = null, d;
      var i = o.arg;
      return i ? i.done ? (t[e.resultName] = i.value, t.next = e.nextLoc, "return" !== t.method && (t.method = "next", t.arg = void 0), t.delegate = null, d) : i : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, d);
    }
    function k(e) {
      var t = {
        tryLoc: e[0]
      };
      1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t);
    }
    function S(e) {
      var t = e.completion || {};
      t.type = "normal", delete t.arg, e.completion = t;
    }
    function C(e) {
      this.tryEntries = [{
        tryLoc: "root"
      }], e.forEach(k, this), this.reset(!0);
    }
    function D(e) {
      if (e || "" === e) {
        var t = e[a];
        if (t) return t.call(e);
        if ("function" == typeof e.next) return e;
        if (!isNaN(e.length)) {
          var n = -1,
            o = function t() {
              for (; ++n < e.length;) if (r.call(e, n)) return t.value = e[n], t.done = !1, t;
              return t.value = void 0, t.done = !0, t;
            };
          return o.next = o;
        }
      }
      throw new TypeError(typeof e + " is not iterable");
    }
    return h.prototype = m, o(b, "constructor", {
      value: m,
      configurable: !0
    }), o(m, "constructor", {
      value: h,
      configurable: !0
    }), h.displayName = c(m, u, "GeneratorFunction"), e.isGeneratorFunction = function (e) {
      var t = "function" == typeof e && e.constructor;
      return !!t && (t === h || "GeneratorFunction" === (t.displayName || t.name));
    }, e.mark = function (e) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(e, m) : (e.__proto__ = m, c(e, u, "GeneratorFunction")), e.prototype = Object.create(b), e;
    }, e.awrap = function (e) {
      return {
        __await: e
      };
    }, x(q.prototype), c(q.prototype, l, function () {
      return this;
    }), e.AsyncIterator = q, e.async = function (t, n, r, o, i) {
      void 0 === i && (i = Promise);
      var a = new q(s(t, n, r, o), i);
      return e.isGeneratorFunction(n) ? a : a.next().then(function (e) {
        return e.done ? e.value : a.next();
      });
    }, x(b), c(b, u, "Generator"), c(b, a, function () {
      return this;
    }), c(b, "toString", function () {
      return "[object Generator]";
    }), e.keys = function (e) {
      var t = Object(e),
        n = [];
      for (var r in t) n.push(r);
      return n.reverse(), function e() {
        for (; n.length;) {
          var r = n.pop();
          if (r in t) return e.value = r, e.done = !1, e;
        }
        return e.done = !0, e;
      };
    }, e.values = D, C.prototype = {
      constructor: C,
      reset: function (e) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(S), !e) for (var t in this) "t" === t.charAt(0) && r.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0);
      },
      stop: function () {
        this.done = !0;
        var e = this.tryEntries[0].completion;
        if ("throw" === e.type) throw e.arg;
        return this.rval;
      },
      dispatchException: function (e) {
        if (this.done) throw e;
        var t = this;
        function n(n, r) {
          return a.type = "throw", a.arg = e, t.next = n, r && (t.method = "next", t.arg = void 0), !!r;
        }
        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
          var i = this.tryEntries[o],
            a = i.completion;
          if ("root" === i.tryLoc) return n("end");
          if (i.tryLoc <= this.prev) {
            var l = r.call(i, "catchLoc"),
              u = r.call(i, "finallyLoc");
            if (l && u) {
              if (this.prev < i.catchLoc) return n(i.catchLoc, !0);
              if (this.prev < i.finallyLoc) return n(i.finallyLoc);
            } else if (l) {
              if (this.prev < i.catchLoc) return n(i.catchLoc, !0);
            } else {
              if (!u) throw new Error("try statement without catch or finally");
              if (this.prev < i.finallyLoc) return n(i.finallyLoc);
            }
          }
        }
      },
      abrupt: function (e, t) {
        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
          var o = this.tryEntries[n];
          if (o.tryLoc <= this.prev && r.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
            var i = o;
            break;
          }
        }
        i && ("break" === e || "continue" === e) && i.tryLoc <= t && t <= i.finallyLoc && (i = null);
        var a = i ? i.completion : {};
        return a.type = e, a.arg = t, i ? (this.method = "next", this.next = i.finallyLoc, d) : this.complete(a);
      },
      complete: function (e, t) {
        if ("throw" === e.type) throw e.arg;
        return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), d;
      },
      finish: function (e) {
        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
          var n = this.tryEntries[t];
          if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), S(n), d;
        }
      },
      catch: function (e) {
        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
          var n = this.tryEntries[t];
          if (n.tryLoc === e) {
            var r = n.completion;
            if ("throw" === r.type) {
              var o = r.arg;
              S(n);
            }
            return o;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (e, t, n) {
        return this.delegate = {
          iterator: D(e),
          resultName: t,
          nextLoc: n
        }, "next" === this.method && (this.arg = void 0), d;
      }
    }, e;
  }
  function r$3(e) {
    return r$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
      return typeof e;
    } : function (e) {
      return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, r$3(e);
  }
  function o$1(e, t, n, r, o, i, a) {
    try {
      var l = e[i](a),
        u = l.value;
    } catch (e) {
      return void n(e);
    }
    l.done ? t(u) : Promise.resolve(u).then(r, o);
  }
  function i(e) {
    return function () {
      var t = this,
        n = arguments;
      return new Promise(function (r, i) {
        var a = e.apply(t, n);
        function l(e) {
          o$1(a, r, i, l, u, "next", e);
        }
        function u(e) {
          o$1(a, r, i, l, u, "throw", e);
        }
        l(void 0);
      });
    };
  }
  function a$1(e, t, n) {
    return (t = function (e) {
      var t = function (e, t) {
        if ("object" != typeof e || null === e) return e;
        var n = e[Symbol.toPrimitive];
        if (void 0 !== n) {
          var r = n.call(e, t || "default");
          if ("object" != typeof r) return r;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t ? String : Number)(e);
      }(e, "string");
      return "symbol" == typeof t ? t : String(t);
    }(t)) in e ? Object.defineProperty(e, t, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[t] = n, e;
  }
  function l$1(e, t) {
    if (null == e) return {};
    var n,
      r,
      o = function (e, t) {
        if (null == e) return {};
        var n,
          r,
          o = {},
          i = Object.keys(e);
        for (r = 0; r < i.length; r++) n = i[r], t.indexOf(n) >= 0 || (o[n] = e[n]);
        return o;
      }(e, t);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(e);
      for (r = 0; r < i.length; r++) n = i[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
    }
    return o;
  }
  function u$1(e, t) {
    return function (e) {
      if (Array.isArray(e)) return e;
    }(e) || function (e, t) {
      var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
      if (null != n) {
        var r,
          o,
          i,
          a,
          l = [],
          u = !0,
          c = !1;
        try {
          if (i = (n = n.call(e)).next, 0 === t) {
            if (Object(n) !== n) return;
            u = !1;
          } else for (; !(u = (r = i.call(n)).done) && (l.push(r.value), l.length !== t); u = !0);
        } catch (e) {
          c = !0, o = e;
        } finally {
          try {
            if (!u && null != n.return && (a = n.return(), Object(a) !== a)) return;
          } finally {
            if (c) throw o;
          }
        }
        return l;
      }
    }(e, t) || s$1(e, t) || function () {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function c$1(e) {
    return function (e) {
      if (Array.isArray(e)) return f$1(e);
    }(e) || function (e) {
      if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e);
    }(e) || s$1(e) || function () {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function s$1(e, t) {
    if (e) {
      if ("string" == typeof e) return f$1(e, t);
      var n = Object.prototype.toString.call(e).slice(8, -1);
      return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? f$1(e, t) : void 0;
    }
  }
  function f$1(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r;
  }
  function d(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
  }
  var p$2 = Object.prototype.hasOwnProperty,
    h$1 = Object.prototype.toString,
    m$2 = Object.defineProperty,
    v$1 = Object.getOwnPropertyDescriptor,
    y$2 = function (e) {
      return "function" == typeof Array.isArray ? Array.isArray(e) : "[object Array]" === h$1.call(e);
    },
    g$1 = function (e) {
      if (!e || "[object Object]" !== h$1.call(e)) return !1;
      var t,
        n = p$2.call(e, "constructor"),
        r = e.constructor && e.constructor.prototype && p$2.call(e.constructor.prototype, "isPrototypeOf");
      if (e.constructor && !n && !r) return !1;
      for (t in e);
      return void 0 === t || p$2.call(e, t);
    },
    b$1 = function (e, t) {
      m$2 && "__proto__" === t.name ? m$2(e, t.name, {
        enumerable: !0,
        configurable: !0,
        value: t.newValue,
        writable: !0
      }) : e[t.name] = t.newValue;
    },
    x$2 = function (e, t) {
      if ("__proto__" === t) {
        if (!p$2.call(e, t)) return;
        if (v$1) return v$1(e, t).value;
      }
      return e[t];
    },
    q$2 = function e() {
      var t,
        n,
        r,
        o,
        i,
        a,
        l = arguments[0],
        u = 1,
        c = arguments.length,
        s = !1;
      for ("boolean" == typeof l && (s = l, l = arguments[1] || {}, u = 2), (null == l || "object" != typeof l && "function" != typeof l) && (l = {}); u < c; ++u) if (null != (t = arguments[u])) for (n in t) r = x$2(l, n), l !== (o = x$2(t, n)) && (s && o && (g$1(o) || (i = y$2(o))) ? (i ? (i = !1, a = r && y$2(r) ? r : []) : a = r && g$1(r) ? r : {}, b$1(l, {
        name: n,
        newValue: e(s, a, o)
      })) : void 0 !== o && b$1(l, {
        name: n,
        newValue: o
      }));
      return l;
    },
    w$1 = d(q$2);
  function M$1(e, t) {
    return {
      range: function (e) {
        var n = e.resources,
          r = e.data,
          o = n.theme.palette("categorical", 0 === t ? r.items.length : t);
        return r.items.map(function (e) {
          return o[e.value % o.length];
        });
      },
      valueAccessor: e.value
    };
  }
  function k$1(e, t) {
    return {
      range: function (e) {
        var n = e.resources,
          r = e.data,
          o = n.theme.palette("categorical", 0 === t ? r.items.length : t);
        return r.items.map(function (e) {
          return o[e.row.value % o.length];
        });
      },
      valueAccessor: e.value
    };
  }
  function S$1(e, t, n, r, o) {
    var i,
      a,
      l = o.byRow,
      u = o.byElemNo;
    if (r && (t.input.persistent || e.hc.qDimensionInfo.length > 1 || void 0 === n.activeDimensionIndex && e.hc.qSize.qcy > (i = e.hc, (null === (a = i.qDataPages[0] || i.qStackedDataPages[0]) || void 0 === a ? void 0 : a.qArea.qHeight) || 0))) return u(r, r.raw().qCardinal);
    if (r) {
      var c = t.pic.extract({
        field: r.key(),
        trackBy: r.value
      }).length;
      return l(r, c);
    }
    return {};
  }
  function C$1(e, t) {
    var n = e.hc.qDimensionInfo,
      r = t.input.byDimDef || {
        activeDimensionIndex: n.length - 1
      };
    if (r.activeDimensionIndex >= 0) {
      var o = n[r.activeDimensionIndex];
      r = o.coloring && o.coloring.colorMapRef ? {
        type: "libraryItem",
        key: o.coloring.colorMapRef,
        activeDimensionIndex: r.activeDimensionIndex
      } : {
        activeDimensionIndex: r.activeDimensionIndex
      };
    }
    return r;
  }
  function D(e, t) {
    var n;
    return t.activeDimensionIndex >= 0 ? n = e.pic.fields().filter(function (e) {
      return "dimension" === e.type();
    })[t.activeDimensionIndex] : "libraryItem" === t.type ? !1 === (n = t.key ? e.pic.field(function (e) {
      return e.raw().colorMapRef === t.key;
    }) : void 0) && (n = e.pic.field(function (e) {
      return "colorByAlternative" === e.raw().id;
    })) : "expression" === t.type && (n = e.pic.field(function (e) {
      return "colorByAlternative" === e.raw().id;
    })), n;
  }
  function I$1(e, t, n) {
    e.prototype = t.prototype = n, n.constructor = e;
  }
  function O$1(e, t) {
    var n = Object.create(e.prototype);
    for (var r in t) n[r] = t[r];
    return n;
  }
  function E() {}
  var A$1 = 1 / .7,
    N$1 = "\\s*([+-]?\\d+)\\s*",
    L$1 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    T$1 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    P = /^#([0-9a-f]{3,8})$/,
    j$1 = new RegExp(`^rgb\\(${N$1},${N$1},${N$1}\\)$`),
    F = new RegExp(`^rgb\\(${T$1},${T$1},${T$1}\\)$`),
    H$1 = new RegExp(`^rgba\\(${N$1},${N$1},${N$1},${L$1}\\)$`),
    R = new RegExp(`^rgba\\(${T$1},${T$1},${T$1},${L$1}\\)$`),
    z$1 = new RegExp(`^hsl\\(${L$1},${T$1},${T$1}\\)$`),
    V = new RegExp(`^hsla\\(${L$1},${T$1},${T$1},${L$1}\\)$`),
    _$1 = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
  function B$1() {
    return this.rgb().formatHex();
  }
  function Y() {
    return this.rgb().formatRgb();
  }
  function $$1(e) {
    var t, n;
    return e = (e + "").trim().toLowerCase(), (t = P.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), 6 === n ? U(t) : 3 === n ? new X(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | 240 & t, (15 & t) << 4 | 15 & t, 1) : 8 === n ? K(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (255 & t) / 255) : 4 === n ? K(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | 240 & t, ((15 & t) << 4 | 15 & t) / 255) : null) : (t = j$1.exec(e)) ? new X(t[1], t[2], t[3], 1) : (t = F.exec(e)) ? new X(255 * t[1] / 100, 255 * t[2] / 100, 255 * t[3] / 100, 1) : (t = H$1.exec(e)) ? K(t[1], t[2], t[3], t[4]) : (t = R.exec(e)) ? K(255 * t[1] / 100, 255 * t[2] / 100, 255 * t[3] / 100, t[4]) : (t = z$1.exec(e)) ? ne(t[1], t[2] / 100, t[3] / 100, 1) : (t = V.exec(e)) ? ne(t[1], t[2] / 100, t[3] / 100, t[4]) : _$1.hasOwnProperty(e) ? U(_$1[e]) : "transparent" === e ? new X(NaN, NaN, NaN, 0) : null;
  }
  function U(e) {
    return new X(e >> 16 & 255, e >> 8 & 255, 255 & e, 1);
  }
  function K(e, t, n, r) {
    return r <= 0 && (e = t = n = NaN), new X(e, t, n, r);
  }
  function G(e) {
    return e instanceof E || (e = $$1(e)), e ? new X((e = e.rgb()).r, e.g, e.b, e.opacity) : new X();
  }
  function W(e, t, n, r) {
    return 1 === arguments.length ? G(e) : new X(e, t, n, null == r ? 1 : r);
  }
  function X(e, t, n, r) {
    this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
  }
  function Z() {
    return `#${te(this.r)}${te(this.g)}${te(this.b)}`;
  }
  function J() {
    const e = Q(this.opacity);
    return `${1 === e ? "rgb(" : "rgba("}${ee(this.r)}, ${ee(this.g)}, ${ee(this.b)}${1 === e ? ")" : `, ${e})`}`;
  }
  function Q(e) {
    return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
  }
  function ee(e) {
    return Math.max(0, Math.min(255, Math.round(e) || 0));
  }
  function te(e) {
    return ((e = ee(e)) < 16 ? "0" : "") + e.toString(16);
  }
  function ne(e, t, n, r) {
    return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new oe(e, t, n, r);
  }
  function re$1(e) {
    if (e instanceof oe) return new oe(e.h, e.s, e.l, e.opacity);
    if (e instanceof E || (e = $$1(e)), !e) return new oe();
    if (e instanceof oe) return e;
    var t = (e = e.rgb()).r / 255,
      n = e.g / 255,
      r = e.b / 255,
      o = Math.min(t, n, r),
      i = Math.max(t, n, r),
      a = NaN,
      l = i - o,
      u = (i + o) / 2;
    return l ? (a = t === i ? (n - r) / l + 6 * (n < r) : n === i ? (r - t) / l + 2 : (t - n) / l + 4, l /= u < .5 ? i + o : 2 - i - o, a *= 60) : l = u > 0 && u < 1 ? 0 : a, new oe(a, l, u, e.opacity);
  }
  function oe(e, t, n, r) {
    this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
  }
  function ie(e) {
    return (e = (e || 0) % 360) < 0 ? e + 360 : e;
  }
  function ae(e) {
    return Math.max(0, Math.min(1, e || 0));
  }
  function le(e, t, n) {
    return 255 * (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t);
  }
  I$1(E, $$1, {
    copy(e) {
      return Object.assign(new this.constructor(), this, e);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: B$1,
    formatHex: B$1,
    formatHex8: function () {
      return this.rgb().formatHex8();
    },
    formatHsl: function () {
      return re$1(this).formatHsl();
    },
    formatRgb: Y,
    toString: Y
  }), I$1(X, W, O$1(E, {
    brighter(e) {
      return e = null == e ? A$1 : Math.pow(A$1, e), new X(this.r * e, this.g * e, this.b * e, this.opacity);
    },
    darker(e) {
      return e = null == e ? .7 : Math.pow(.7, e), new X(this.r * e, this.g * e, this.b * e, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new X(ee(this.r), ee(this.g), ee(this.b), Q(this.opacity));
    },
    displayable() {
      return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: Z,
    formatHex: Z,
    formatHex8: function () {
      return `#${te(this.r)}${te(this.g)}${te(this.b)}${te(255 * (isNaN(this.opacity) ? 1 : this.opacity))}`;
    },
    formatRgb: J,
    toString: J
  })), I$1(oe, function (e, t, n, r) {
    return 1 === arguments.length ? re$1(e) : new oe(e, t, n, null == r ? 1 : r);
  }, O$1(E, {
    brighter(e) {
      return e = null == e ? A$1 : Math.pow(A$1, e), new oe(this.h, this.s, this.l * e, this.opacity);
    },
    darker(e) {
      return e = null == e ? .7 : Math.pow(.7, e), new oe(this.h, this.s, this.l * e, this.opacity);
    },
    rgb() {
      var e = this.h % 360 + 360 * (this.h < 0),
        t = isNaN(e) || isNaN(this.s) ? 0 : this.s,
        n = this.l,
        r = n + (n < .5 ? n : 1 - n) * t,
        o = 2 * n - r;
      return new X(le(e >= 240 ? e - 240 : e + 120, o, r), le(e, o, r), le(e < 120 ? e + 240 : e - 120, o, r), this.opacity);
    },
    clamp() {
      return new oe(ie(this.h), ae(this.s), ae(this.l), Q(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl() {
      const e = Q(this.opacity);
      return `${1 === e ? "hsl(" : "hsla("}${ie(this.h)}, ${100 * ae(this.s)}%, ${100 * ae(this.l)}%${1 === e ? ")" : `, ${e})`}`;
    }
  }));
  const ue = Math.PI / 180,
    ce = 180 / Math.PI,
    se = 4 / 29,
    fe = 6 / 29,
    de = 3 * fe * fe;
  function pe(e) {
    if (e instanceof he) return new he(e.l, e.a, e.b, e.opacity);
    if (e instanceof qe) return we(e);
    e instanceof X || (e = G(e));
    var t,
      n,
      r = ge(e.r),
      o = ge(e.g),
      i = ge(e.b),
      a = me((.2225045 * r + .7168786 * o + .0606169 * i) / 1);
    return r === o && o === i ? t = n = a : (t = me((.4360747 * r + .3850649 * o + .1430804 * i) / .96422), n = me((.0139322 * r + .0971045 * o + .7141733 * i) / .82521)), new he(116 * a - 16, 500 * (t - a), 200 * (a - n), e.opacity);
  }
  function he(e, t, n, r) {
    this.l = +e, this.a = +t, this.b = +n, this.opacity = +r;
  }
  function me(e) {
    return e > .008856451679035631 ? Math.pow(e, 1 / 3) : e / de + se;
  }
  function ve(e) {
    return e > fe ? e * e * e : de * (e - se);
  }
  function ye(e) {
    return 255 * (e <= .0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - .055);
  }
  function ge(e) {
    return (e /= 255) <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);
  }
  function be(e) {
    if (e instanceof qe) return new qe(e.h, e.c, e.l, e.opacity);
    if (e instanceof he || (e = pe(e)), 0 === e.a && 0 === e.b) return new qe(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
    var t = Math.atan2(e.b, e.a) * ce;
    return new qe(t < 0 ? t + 360 : t, Math.sqrt(e.a * e.a + e.b * e.b), e.l, e.opacity);
  }
  function xe(e, t, n, r) {
    return 1 === arguments.length ? be(e) : new qe(e, t, n, null == r ? 1 : r);
  }
  function qe(e, t, n, r) {
    this.h = +e, this.c = +t, this.l = +n, this.opacity = +r;
  }
  function we(e) {
    if (isNaN(e.h)) return new he(e.l, 0, 0, e.opacity);
    var t = e.h * ue;
    return new he(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity);
  }
  I$1(he, function (e, t, n, r) {
    return 1 === arguments.length ? pe(e) : new he(e, t, n, null == r ? 1 : r);
  }, O$1(E, {
    brighter(e) {
      return new he(this.l + 18 * (null == e ? 1 : e), this.a, this.b, this.opacity);
    },
    darker(e) {
      return new he(this.l - 18 * (null == e ? 1 : e), this.a, this.b, this.opacity);
    },
    rgb() {
      var e = (this.l + 16) / 116,
        t = isNaN(this.a) ? e : e + this.a / 500,
        n = isNaN(this.b) ? e : e - this.b / 200;
      return new X(ye(3.1338561 * (t = .96422 * ve(t)) - 1.6168667 * (e = 1 * ve(e)) - .4906146 * (n = .82521 * ve(n))), ye(-.9787684 * t + 1.9161415 * e + .033454 * n), ye(.0719453 * t - .2289914 * e + 1.4052427 * n), this.opacity);
    }
  })), I$1(qe, xe, O$1(E, {
    brighter(e) {
      return new qe(this.h, this.c, this.l + 18 * (null == e ? 1 : e), this.opacity);
    },
    darker(e) {
      return new qe(this.h, this.c, this.l - 18 * (null == e ? 1 : e), this.opacity);
    },
    rgb() {
      return we(this).rgb();
    }
  }));
  var Me = e => () => e;
  function ke(e) {
    return 1 == (e = +e) ? Se : function (t, n) {
      return n - t ? function (e, t, n) {
        return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function (r) {
          return Math.pow(e + r * t, n);
        };
      }(t, n, e) : Me(isNaN(t) ? n : t);
    };
  }
  function Se(e, t) {
    var n = t - e;
    return n ? function (e, t) {
      return function (n) {
        return e + n * t;
      };
    }(e, n) : Me(isNaN(e) ? t : e);
  }
  var Ce = function e(t) {
      var n = ke(t);
      function r(e, t) {
        var r = n((e = W(e)).r, (t = W(t)).r),
          o = n(e.g, t.g),
          i = n(e.b, t.b),
          a = Se(e.opacity, t.opacity);
        return function (t) {
          return e.r = r(t), e.g = o(t), e.b = i(t), e.opacity = a(t), e + "";
        };
      }
      return r.gamma = e, r;
    }(1),
    De = /^class(-pyramid)?/,
    Ie = function (e, t, n, r) {
      var o = void 0 !== n.min ? n.min : r.min(),
        i = void 0 !== n.max ? n.max : r.max(),
        a = o,
        l = i,
        u = t.limits,
        s = {},
        f = "percent" === t.limitType ? u.map(function (e) {
          return o + (i - o) * e;
        }) : u,
        d = t.colors.map(function (t) {
          return e.resolveUIColor(t);
        });
      if (o = Math.min.apply(Math, [o].concat(c$1(f))), i = Math.max.apply(Math, [i].concat(c$1(f))), s.min = o, s.max = i, t.breakTypes && -1 === t.breakTypes.indexOf(!0)) s.type = "categorical", Object.assign(s, function (e) {
        var t = e.min,
          n = e.max,
          r = e.limits,
          o = e.range,
          i = [],
          a = [];
        if (r.length) {
          if (r[r.length - 1] < t) a.push(t, n), i.push(o[o.length - 1], o[o.length - 1], o[o.length - 1]);else if (r[0] > n) a.push(t, n), i.push(o[0], o[0], o[0]);else {
            if (r[0] > t) a.push(t), i.push(o[0]);else {
              a.push(t);
              for (var l = 0; l < r.length; l++) if (t < r[l]) {
                i.push(o[l]);
                break;
              }
            }
            for (var u = 0; u < r.length; u++) t < r[u] && r[u] < n && (a.push(r[u]), i.push(o[u]));
            if (r[r.length - 1] < n) a.push(n), i.push(o[r.length]), i.push(o[r.length]);else {
              a.push(n);
              for (var c = 0; c < r.length; c++) if (r[c] > n) {
                i.push(o[c]), i.push(o[c]);
                break;
              }
            }
          }
        } else i.push(o[0]);
        return {
          min: t,
          max: n,
          range: i,
          domain: a
        };
      }({
        min: "percent" === t.limitType ? o : a,
        max: "percent" === t.limitType ? i : l,
        range: d,
        limits: "percent" === t.limitType ? f : u
      }));else if (t.breakTypes) {
        var p = t.breakTypes;
        s.type = "continuous", s.domain = [o], s.range = [d[0]];
        for (var h = 0; h < f.length; h += 1) if (p[h]) {
          var m = d[h],
            v = d[h + 1],
            y = Ce(m, v)(.5);
          s.range.push(y), s.domain.push(f[h]), h < f.length - 1 && p[h + 1] && (s.range.push(d[h + 1]), s.domain.push((f[h] + f[h + 1]) / 2));
        } else s.range.push(d[h]), s.range.push(d[h + 1]), s.domain.push(f[h]), s.domain.push(f[h] + Math.min(1e-6, (i - o) / 1e6));
        s.range.push(d[d.length - 1]), s.domain.push(i);
      } else s.domain = f, s.range = d;
      return s;
    };
  function Oe(e, t, n, r, o) {
    var i,
      a,
      l,
      u = 0,
      c = [],
      s = (e - t) / (r + 1);
    if (0 === s) return 1;
    for (i = 0; i < n.length; i += 1) a = .99 * (n[i] - t), l = n[i] > e ? Math.floor(e / s) : n[i] < t ? 0 : Math.floor(a / s), Number.isNaN(l) || (c[l] ? c[l] += 1 : c[l] = 1);
    for (i = 0; i < c.length; i += 1) c[i] && (u += 1);
    return u <= r || u >= o ? Math.max(u, r) : Oe(e, t, n, r + 1, o);
  }
  var Ee = function (e, t, n, r) {
    var o,
      i,
      a = t.theme,
      l = t.hc,
      u = r.f,
      s = {
        mode: "field",
        fieldType: "measure",
        field: u ? u.key() : void 0,
        reverse: n.input.reverseScheme || !1,
        type: "continuous",
        range: function (e) {
          return e.resources.theme.palette("quant");
        }
      },
      f = [],
      d = !0;
    if (u) {
      if (Number.isNaN(+u.min()) || Number.isNaN(+u.max())) return {
        invalid: !0
      };
      (d = !("S" === (o = n.pic.raw()).qMode && (o.qDataPages[0] && o.qSize.qcy > o.qDataPages[0].qArea.qHeight || !o.qDataPages.length && o.qSize.qcy > 0) || "K" === o.qMode && o.qStackedDataPages[0] && o.qSize.qcy > o.qStackedDataPages[0].qArea.qHeight || "T" === o.qMode && o.qSize.qcy > o.qTreeDataPages[0].qGroupSize)) && (f = n.pic.extract({
        field: 0,
        props: {
          num: {
            field: u.key()
          },
          exclude: {
            fields: l.qDimensionInfo.map(function (e, t) {
              return {
                field: "qDimensionInfo/".concat(t)
              };
            }),
            value: function (e) {
              return Math.min.apply(Math, c$1(e)) < 0;
            }
          }
        }
      }).filter(function (e) {
        return e.value >= 0 && !e.exclude.value;
      }).map(function (e) {
        return e.num.value;
      }).filter(function (e) {
        return "number" == typeof e;
      }));
    }
    if (!1 === n.input.autoMinMax) {
      if (s.min = n.input.measureMin, s.max = n.input.measureMax, s.max < s.min) return {
        invalid: !0
      };
    } else if (u && !d) s.min = u.min(), s.max = u.max();else if (u) {
      if (!f.length) return {
        invalid: !0
      };
      s.min = Math.min.apply(Math, c$1(f)), s.max = Math.max.apply(Math, c$1(f));
    }
    if (n.input.measureScheme && (s.palettes = {
      quant: n.input.measureScheme
    }), a) {
      var p = a.getDataColorScales().filter(function (e) {
        return e.key === n.input.measureScheme;
      })[0];
      s.type = p && De.test(p.type) ? "categorical" : "continuous", "categorical" === s.type && (i = p.colors.some(function (e) {
        return Array.isArray(e);
      }) ? Math.max.apply(Math, c$1(p.colors.map(function (e) {
        return e ? e.length : 0;
      }))) : p.colors.length);
    }
    if ("categorical" === s.type) {
      for (var h = d ? Oe(s.max, s.min, f, 1, i) : i, m = (s.max - s.min) / h, v = [], y = 0; y < h + 1; y += 1) v.push(s.min + m * y);
      s.domain = v, s.range = function (e) {
        for (var t = e.resources.theme.palette("quant", h), n = Math.max(1, Math.floor(t.length / h)), r = [], o = 0; o < h; o += 1) r.push(t[o * n]);
        return [r[0]].concat(r, [r[r.length - 1]]);
      };
    }
    return s;
  };
  function Ae(e, t) {
    var n;
    return t.activeMeasureIndex >= 0 ? n = e.pic.fields().filter(function (e) {
      return "measure" === e.type();
    })[t.activeMeasureIndex] : "libraryItem" === t.type ? n = e.pic.field(function (e) {
      return e.raw().colorMapRef === t.key && void 0 !== t.key;
    }) : "expression" === t.type && (n = e.pic.field(function (e) {
      return "colorByAlternative" === e.raw().id;
    })), n || (n = e.pic.field(function (e) {
      return void 0 !== e.raw().matchMeasure;
    })) && (n = e.pic.fields().filter(function (e) {
      return "measure" === e.type();
    })[n.raw().matchMeasure]), n;
  }
  function Ne(e) {
    var n,
      r = e.cm,
      o = e.defaults,
      i = e.index,
      a = e.input,
      l = e.pic;
    if (!a || !a.on) return null;
    var u = null !== (n = a.mode) && void 0 !== n ? n : "primary";
    return "primary" === u ? function (e, n, r) {
      var o = r.primary;
      return void 0 !== n.paletteColor && n.paletteColor && (o = e.resolveUIColor(n.paletteColor)), t$1(t$1({}, r), {}, {
        mode: "constant",
        type: "constant",
        primary: o
      });
    }(r, a, o) : "byExpression" === u ? function (e, n, r) {
      var o = "qMeasureInfo/".concat(e, "/"),
        i = n.field(function (e) {
          return e.id().startsWith(o) && "colorByMeasureExpression" === e.raw().id;
        }),
        a = i;
      return t$1(t$1({}, r), {}, a ? {
        mode: "field",
        fieldType: "expression",
        field: i ? i.key() : void 0,
        type: "color"
      } : {
        mode: "constant",
        type: "constant",
        primary: r.nil
      });
    }(i, l, o) : null;
  }
  function Le(e) {
    e.measureOverrides.every(function (e) {
      return !e;
    }) && (e.measureOverrides = null);
  }
  function Te(e, t) {
    for (var n = (null == t ? void 0 : t.domain) || [], r = (null == t ? void 0 : t.range) || [], o = [], i = 0; i < e.length; ++i) {
      var a = e[i];
      if ("constant" === (null == a ? void 0 : a.mode)) {
        var l = n.indexOf(i);
        -1 === l ? (n.push(i), r.push(a.primary)) : r[l] = a.primary, e[i] = null;
      } else if (a) {
        o.push(i);
        var u = n.indexOf(i);
        -1 !== u && (n.splice(u, 1), r.splice(u, 1));
      }
    }
    return {
      domain: n,
      range: r,
      exclude: o
    };
  }
  function Pe(e, t, n, r) {
    if (t.input && !t.input.auto) {
      if ("byMeasure" === t.input.mode) return function (e, t, n) {
        var r = t.theme,
          o = t.hc,
          i = (arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}).getCField,
          a = void 0 === i ? Ae : i,
          l = n.input.byMeasureDef || {
            activeMeasureIndex: 0
          },
          u = a(n, l),
          c = Ee(0, {
            theme: r,
            hc: o
          }, n, {
            f: u
          });
        if (c.invalid) return c;
        "expression" === l.type && (l.activeMeasureIndex < 0 || void 0 === l.activeMeasureIndex) && (c.label = l.label, u && "color.altLabel" === u.raw().labelExpRef && (c.label = n.input.altLabel)), !c.label && u && (c.label = u.title());
        var s = l.activeMeasureIndex >= 0 ? u : null;
        if (!s && u && void 0 !== u.raw().matchMeasure && u.raw().matchMeasure > -1 && (s = n.pic.fields().filter(function (e) {
          return "measure" === e.type();
        })[u.raw().matchMeasure]), n.input.useMeasureGradient && "libraryItem" === l.type) if (s) {
          var f = s.raw().coloring;
          f && f.gradient && w$1(c, Ie(e, f.gradient, c, s));
        } else c.auxiliary = l;
        return c;
      }(e, n, t);
      if ("byDimension" === t.input.mode) return function (e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
          o = r.getCDef,
          i = void 0 === o ? C$1 : o,
          a = r.getCByField,
          l = void 0 === a ? D : a,
          u = r.getPersistence,
          c = void 0 === u ? S$1 : u,
          s = i(t, n),
          f = l(n, s),
          d = f ? f.raw() : {},
          p = n && n.pic ? n.pic.raw() : {};
        if (d.qError || d.qSize && 0 === d.qSize.qcy && !p.qHasOtherValues) return {
          invalid: !0
        };
        var h = {
          mode: "field",
          fieldType: "dimension",
          type: "categorical",
          field: f ? f.key() : void 0,
          isFieldLocked: d.qLocked
        };
        return ("expression" === s.type || s.activeDimensionIndex < 0) && (h.label = s.label, "color.altLabel" === d.labelExpRef && (h.label = n.input.altLabel)), !h.label && f && (h.label = f.title()), n.input.dimensionScheme && (h.palettes = {
          categorical: n.input.dimensionScheme
        }), n.input.useDimColVal && "libraryItem" === s.type && (h.auxiliary = s), w$1(h, c(t, n, s, f, {
          byRow: k$1,
          byElemNo: M$1
        })), h;
      }(e, n, t);
      if ("byExpression" === t.input.mode) return function (e, t, n, r) {
        var o = t.hc,
          i = t.theme,
          a = t.translator,
          l = n.pic.field(function (e) {
            return "colorByExpression" === e.raw().id;
          });
        if (!l || !l.raw().qFallbackTitle && !n.input.colorExpression || !(Number.isFinite(l.raw().qMin) && Number.isFinite(l.raw().qMax) || n.input.expressionIsColor)) return {
          mode: "constant",
          type: "constant",
          primary: r.nil
        };
        if (n.input.expressionIsColor) return {
          mode: "field",
          fieldType: "expression",
          field: l ? l.key() : void 0,
          type: "color"
        };
        var u = Ee(0, {
          hc: o,
          theme: i
        }, n, {
          f: l
        });
        return u.invalid || (u.label = n.input.expressionLabel || a.get("Object.ChartTooltip.ColorExpression")), u;
      }(0, n, t, r);
      if ("byMultiple" === t.input.mode || "primary" === t.input.mode) return function (e, t, n, r) {
        var o = t.hc,
          i = t.theme,
          a = t.translator,
          l = n.input.useBaseColors;
        if (("byMultiple" === n.input.mode || "primary" === n.input.mode && "measure" === n.input.useBaseColors) && o.qMeasureInfo.length > 1 && (l = "measure"), "measure" === l) {
          var u = [],
            c = [];
          "measure" === n.input.useBaseColors && o.qMeasureInfo.forEach(function (t, n) {
            if (t.baseColor || t.coloring && t.coloring.baseColor) {
              u.push(n);
              var o = e.resolveUIColor(t.baseColor || t.coloring.baseColor);
              "none" === o ? c.push(r.primary) : c.push(o);
            }
          });
          var s = n.input.dimensionScheme ? {
              categorical: n.input.dimensionScheme
            } : void 0,
            f = i ? i.getDataColorPalettes()[0] : void 0;
          return "measure" === n.input.useBaseColors && f && (s = {
            categorical: f.key
          }), {
            mode: "measure",
            type: "categorical",
            palettes: s,
            label: a ? a.get("Common.Measures") : void 0,
            explicit: u.length ? {
              domain: u,
              range: c
            } : void 0
          };
        }
        if ("dimension" === l) {
          var d = [],
            p = [];
          return o.qDimensionInfo.forEach(function (t, n) {
            if (t.baseColor || t.coloring && t.coloring.baseColor) {
              d.push(n);
              var o = e.resolveUIColor(t.baseColor || t.coloring.baseColor);
              "none" === o ? p.push(r.primary) : p.push(o);
            }
          }), {
            mode: "dimension",
            type: "categorical",
            field: d.length ? d[0] : void 0,
            explicit: d.length ? {
              domain: d,
              range: p
            } : void 0
          };
        }
        var h = r.primary;
        if (void 0 !== n.input.paletteColor) n.input.paletteColor && (h = e.resolveUIColor(n.input.paletteColor));else {
          var m = n.input.singleColor;
          "number" != typeof m || Number.isNaN(m) || (h = ["#b0afae", "#7b7a78", "#545352", "#4477aa", "#7db8da", "#b6d7ea", "#46c646", "#f93f17", "#ffcf02", "#276e27", "#ffffff", "#000000"][m]);
        }
        return {
          mode: "constant",
          type: "constant",
          primary: h
        };
      }(e, n, t, r);
    }
    return {};
  }
  function je(e, t, n, r) {
    var o,
      i = Pe(e, t, n, r);
    return null !== (o = t.input) && void 0 !== o && o.measureOverrides ? (i.measureOverrides = t.input.measureOverrides.map(function (n, o) {
      return Ne({
        cm: e,
        input: n,
        defaults: r,
        index: o,
        pic: t.pic
      });
    }), function (e, t) {
      var n,
        r,
        o,
        i = t.translator;
      if (Le(e), 1 === (null === (n = e.measureOverrides) || void 0 === n ? void 0 : n.length)) return e.measureOverrides[0];
      if ("measure" === e.mode && e.measureOverrides && (e.explicit = Te(e.measureOverrides, e.explicit), Le(e)), null !== (r = e.measureOverrides) && void 0 !== r && r.every(function (e) {
        return "constant" === (null == e ? void 0 : e.mode);
      })) {
        var a = {
          mode: "measure",
          type: "categorical",
          label: null == i ? void 0 : i.get("Common.Measures")
        };
        return a.explicit = Te(e.measureOverrides), a;
      }
      return null !== (o = e.measureOverrides) && void 0 !== o && o.every(function (e) {
        return e;
      }) ? {
        invalid: !0,
        measureOverrides: e.measureOverrides
      } : e;
    }(i, n)) : i;
  }
  function Fe(e) {
    var n = t$1({
        hc: null,
        colorProps: null,
        layout: null,
        theme: null
      }, e),
      r = {},
      o = {
        auto: function () {
          return {
            mode: "primary"
          };
        },
        getDimensionColorMap: function () {
          return Promise.reject();
        },
        getMeasure: function () {
          return Promise.reject();
        },
        getAttributeDimension: function () {
          return Promise.reject();
        }
      },
      i = {
        auto: function (e) {
          return e ? (o.auto = e, i) : o.auto;
        },
        getDimensionColorMap: function (e) {
          return e ? (o.getDimensionColorMap = e, i) : o.getDimensionColorMap;
        },
        getAttributeDimension: function (e) {
          return e ? (o.getAttributeDimension = e, i) : o.getAttributeDimension;
        },
        getMeasure: function (e) {
          return e ? (o.getMeasure = e, i) : o.getMeasure;
        },
        set: function (e) {
          var t;
          if (!e.colorProps) throw new Error('Missing "colorProps"');
          if (w$1(n, e), (r = {
            pic: n.picasso.data("q")({
              data: n.hc,
              config: {
                localeInfo: n.localeInfo
              }
            }),
            input: n.colorProps
          }).input.auto) {
            var i = o.auto(e.layout);
            r.input = w$1(!0, {}, r.input, i, {
              auto: !1
            });
            var a = n.theme ? n.theme.getDataColorPalettes() : [];
            a[0] && (r.input.dimensionScheme = a[0].key);
            var l = 0;
            r.input.byDimDef && +r.input.byDimDef.activeDimensionIndex >= 0 && (l = +r.input.byDimDef.activeDimensionIndex), n.hc && n.hc.qDimensionInfo[l] && n.hc.qDimensionInfo[l].coloring && n.hc.qDimensionInfo[l].coloring.colorMapRef && r.input.byDimDef && (r.input.byDimDef.type = "libraryItem", r.input.byDimDef.key = n.hc.qDimensionInfo[l].coloring.colorMapRef);
          }
          null !== (t = r.input.measureOverrides) && void 0 !== t && t.every(function (e) {
            return !e || !e.on;
          }) && (r.input = w$1(!1, {}, r.input, {
            measureOverrides: null
          }));
        },
        palettes: function () {
          if (!r.palettes) {
            var e = n.theme,
              t = [];
            (e && e.getDataColorPickerPalettes() || []).forEach(function (e) {
              t.push({
                key: "ui",
                colors: e.colors
              });
            }), r.palettes = t;
          }
          return r.palettes;
        },
        getAuxiliaryData: function (e) {
          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "/qHyperCubeDef";
          if (!e.auxiliary && !/qAttrDimInfo/.test(e.field)) return Promise.resolve();
          var r = e.auxiliary || {},
            i = r.key;
          if ("measure" === e.fieldType) return o.getMeasure(i, n).catch(function () {});
          if ("dimension" === e.fieldType) {
            var a = "".concat(t, "/").concat(e.field).replace("qDimensionInfo", "qDimensions").replace("qAttrDimInfo", "qAttributeDimensions");
            return Promise.all([/qAttrDimInfo/.test(e.field) ? o.getAttributeDimension(a, n).catch(function () {}) : Promise.resolve(), i ? o.getDimensionColorMap(i, n).catch(function () {}) : Promise.resolve()]);
          }
          return Promise.resolve();
        },
        getAuxiliarySettings: function (e, o) {
          var i = this;
          return e.auxiliary || /qAttrDimInfo/.test(e.field) ? (this.palettes(), this.getAuxiliaryData(e, o).then(function (o) {
            if (!o) return {};
            if ("measure" === e.fieldType) {
              if (o.coloring && o.coloring.gradient) {
                var a = r.pic.field(e.field);
                return Ie(i, o.coloring.gradient, e, a);
              }
              return {};
            }
            if ("dimension" === e.fieldType) {
              var l = {
                  nil: e.nil,
                  others: e.others
                },
                u = o[0],
                c = o[1] ? o[1].colorMap : null;
              if (u) {
                var s = n.picasso.data("q")({
                  data: {
                    qDimensionInfo: [r.pic.field(e.field).raw(), r.pic.field(e.field).raw()],
                    qMeasureInfo: [],
                    qDataPages: u,
                    qInterColumnSortOrder: [0, 1],
                    qMode: "S"
                  }
                });
                l.legendDataset = s;
              }
              return c ? function (e, n, r, o) {
                var i = o.external,
                  a = o.field,
                  l = t$1({}, e);
                w$1(l, M$1(a, a.raw().qCardinal));
                var u = i.theme ? i.theme.getDataColorPalettes()[0] : null;
                return n.nul && (l.nil = r.resolveUIColor(n.nul)), n.oth && (l.others = r.resolveUIColor(n.oth)), n.usePal ? (l.palettes = {
                  categorical: n.pal
                }, u && !n.pal && (l.palettes.categorical = u.key, w$1(l, M$1(a)))) : !1 === n.autoFill && n.single ? l.range = [r.resolveUIColor(n.single)] : n.autoFill && (u && (l.palettes = {
                  categorical: u.key
                }), w$1(l, M$1(a))), n.colors && n.colors.length && (l.explicit = function (e, t, n) {
                  for (var r = {}, o = 0; o < e.length; o += 1) r[e[o].value] = e[o].baseColor;
                  var i = [];
                  return {
                    domain: function (e) {
                      var o = e.data,
                        a = [];
                      i = [];
                      for (var l = 0; l < o.items.length; l++) {
                        var u = o.items[l],
                          c = (u.text || u).label;
                        r[c] && -1 === a.indexOf(u.value) && (a.push(u.value), i.push(t.resolveUIColor(r[c])));
                      }
                      return a.push(-3, -2), i.push(n.others), i.push(n.nil), a;
                    },
                    range: function () {
                      return i;
                    }
                  };
                }(n.colors, r, l)), l;
              }(l, c, i, {
                external: n,
                field: r.pic.field(e.field)
              }) : l;
            }
            return {};
          })) : Promise.resolve();
        },
        resolveUIColor: function (e) {
          if (e.index < 0 || void 0 === e.index) return e.color;
          if (void 0 === r.uiPalette && (r.uiPalette = this.palettes().filter(function (e) {
            return "ui" === e.key;
          })[0] || !1), !r.uiPalette) return e.color;
          var t = "none" === r.uiPalette.colors[0] ? e.index : e.index - 1;
          return void 0 === r.uiPalette.colors[t] ? e.color : r.uiPalette.colors[t];
        },
        settings: function () {
          if (this.palettes(), !r.settings) {
            var e = {
                primary: "steelblue",
                others: "#aaa",
                nil: "#ddd"
              },
              o = n.theme;
            o && (e = t$1(t$1({}, e), o.getDataColorSpecials())), r.settings = w$1(e, je(this, r, n, e));
          }
          return r.settings;
        }
      };
    return i;
  }
  var He = function (e, t) {
      var n = e.fieldType,
        r = {};
      if (t) if ("measure" === n) {
        var o = t.coloring;
        o && (r.measureGradient = o.gradient);
      } else if ("dimension" === n) {
        var i = t[0],
          a = t[1];
        i && (r.legendDataPage = i), a && (r.dimValsData = a.colorMap);
      }
      return r;
    },
    Re = function (e) {
      throw e.isHandled = !0, e;
    },
    ze = function (e, t) {
      var n = t.layout,
        r = t.app;
      return n && n.snapshotData ? n.snapshotData.content && n.snapshotData.content.chartData && n.snapshotData.content.chartData.dimValsData ? Promise.resolve({
        colorMap: n.snapshotData.content.chartData.dimValsData
      }) : Promise.reject() : r && r.getObject ? r.getObject("ColorMapModel_".concat(e)).then(function (e) {
        return e.getLayout();
      }) : Promise.reject();
    },
    Ve = function (e, t) {
      var n = t.layout,
        r = t.app;
      return n && n.snapshotData ? n.snapshotData.content && n.snapshotData.content.chartData && n.snapshotData.content.chartData.measureGradient ? Promise.resolve({
        coloring: {
          gradient: n.snapshotData.content.chartData.measureGradient
        }
      }) : Promise.reject() : r && r.getMeasure ? r.getMeasure(e).then(function (e) {
        return e.getMeasure();
      }) : Promise.reject();
    },
    _e = function (e, t) {
      var n = t.layout,
        r = t.model,
        o = t.app;
      if (n && n.snapshotData) return n.snapshotData.content && n.snapshotData.content.chartData && n.snapshotData.content.chartData.legendDataPage ? Promise.resolve(n.snapshotData.content.chartData.legendDataPage) : Promise.reject();
      if (r && r.session && o) {
        return r.getHyperCubeData(e, [{
          qHeight: 100,
          qLeft: 0,
          qTop: 0,
          qWidth: 2
        }]).catch(Re);
      }
      return Promise.reject();
    };
  function Be(e) {
    var t = e.hc,
      n = e.source,
      r = e.coloring,
      o = {
        data: {
          extract: [{
            source: "dummy",
            field: 0,
            filter: function () {
              return o.expando = t.qDataPages[0] ? t.qDataPages[0].qArea.qTop : 0, !1;
            }
          }, {
            source: n,
            field: r.field,
            trackBy: r.valueAccessor,
            reduce: "first",
            props: {
              row: {
                reduce: function () {
                  return o.expando++;
                }
              },
              text: {
                value: function (e) {
                  return e.qText;
                },
                reduce: "first"
              }
            }
          }]
        },
        expando: 0
      };
    return o;
  }
  function Ye(e) {
    return function (t) {
      return "object" === r$3(t.datum[e]) ? t.datum[e].value : void 0;
    };
  }
  function $e(e) {
    return "object" === r$3(e.datum.isNull) ? e.datum.isNull.value : -2 === e.datum.value;
  }
  function Ue(e) {
    return -3 === e.datum.value;
  }
  var Ke = {
    TITLE: {
      COLOR: void 0,
      FONT_SIZE: "16px",
      FONT_FAMILY: "'Source Sans Pro', 'Arial', 'sans-serif'"
    },
    LABEL: {
      COLOR: void 0,
      FONT_SIZE: void 0,
      FONT_FAMILY: "'Source Sans Pro', 'Arial', 'sans-serif'"
    }
  };
  function Ge(e) {
    var t = e.theme,
      n = e.key,
      r = e.styleOverrides,
      o = {
        title: {
          color: Ke.TITLE.COLOR,
          fontSize: Ke.TITLE.FONT_SIZE,
          fontFamily: Ke.TITLE.FONT_FAMILY
        },
        label: {
          color: Ke.LABEL.COLOR,
          fontSize: Ke.LABEL.FONT_SIZE,
          fontFamily: Ke.LABEL.FONT_FAMILY
        }
      };
    if (!t && !r) return o;
    var i = r || {},
      a = i.title,
      l = i.label,
      u = function (e) {
        var t = e.theme,
          n = e.key;
        return function (e, r, o, i) {
          return void 0 !== e ? e : t ? t.getStyle(n, r, o) : i;
        };
      }({
        theme: t,
        key: n
      });
    return o.title.color = u(null == a ? void 0 : a.color, "legend.title", "color", Ke.TITLE.COLOR), o.title.fontSize = u(null == a ? void 0 : a.fontSize, "legend.title", "fontSize", Ke.TITLE.FONT_SIZE), o.title.fontFamily = u(null == a ? void 0 : a.fontFamily, "legend.title", "fontFamily", Ke.TITLE.FONT_FAMILY), o.label.color = u(null == l ? void 0 : l.color, "legend.label", "color", Ke.LABEL.COLOR), o.label.fontSize = u(null == l ? void 0 : l.fontSize, "legend.label", "fontSize", Ke.LABEL.FONT_SIZE), o.label.fontFamily = u(null == l ? void 0 : l.fontFamily, "legend.label", "fontFamily", Ke.LABEL.FONT_FAMILY), o;
  }
  var We = function (e, t, n) {
      var r = e && e.dock || void 0;
      if ("auto" !== r) return r || "right";
      if (t) {
        var o = t.element.getBoundingClientRect();
        if (o.height > o.width) return "bottom";
      }
      return n ? "left" : "right";
    },
    Xe = function (e, t, n) {
      return !(n.invalid || "color" === n.type || "measure" === n.mode && t.qMeasureInfo.length <= 1 || "dimension" === n.mode) && ("function" == typeof e.show ? e.show() : !1 !== e.show);
    };
  function Ze(e, t) {
    var n = e.styleReference,
      r = e.styleOverrides,
      o = e.chart,
      i = e.rtl,
      a = t.legendProps,
      l = t.coloring,
      u = t.theme,
      c = t.hc,
      s = Ge({
        theme: u,
        key: n,
        styleOverrides: r
      });
    return {
      layout: {
        minimumLayoutMode: "MEDIUM",
        dock: We(a, o, i)
      },
      show: "function" == typeof a.show ? function () {
        return Xe(a, c, l);
      } : Xe(a, c, l),
      renderer: "svg",
      mounted: function (e) {
        e.childNodes[0].style.pointerEvents = "none", e.style.overflow = "hidden";
      },
      settings: {
        title: {
          show: !1 !== a.showTitle,
          wordBreak: "break-word",
          maxLines: 2,
          lineHeight: 1.2,
          text: l.label || "",
          fill: s.title.color,
          fontSize: s.title.fontSize,
          fontFamily: s.title.fontFamily
        }
      }
    };
  }
  function Je(e, n, r) {
    return "categorical" === n.coloring.type ? function (e, n, r) {
      var o = Ze(e, n);
      if (!o.show) return !1;
      var i,
        a = e.key,
        l = e.styleReference,
        u = e.styleOverrides,
        c = e.viewState,
        s = e.rtl,
        f = e.settings,
        d = e.style,
        p = n.scaleKey,
        h = n.theme,
        m = n.scales,
        v = Ge({
          theme: h,
          key: l,
          styleOverrides: u
        }),
        y = o.layout.dock,
        g = "left" === y || "right" === y ? {
          maxLines: 2,
          wordBreak: "break-word"
        } : {},
        b = {
          up: "M13.6,11 L2.4,11 C2.28954305,11 2.2,10.9104569 2.2,10.8 C2.2,10.756726 2.21403557,10.7146192 2.24,10.68 L7.84,3.21333333 C7.90627417,3.12496777 8.03163444,3.10705916 8.12,3.17333333 C8.13516113,3.18470418 8.14862915,3.1981722 8.16,3.21333333 L13.76,10.68 C13.8262742,10.7683656 13.8083656,10.8937258 13.72,10.96 C13.6853808,10.9859644 13.643274,11 13.6,11 Z",
          down: "M2.4,4 L13.6,4 C13.7104569,4 13.8,4.08954305 13.8,4.2 C13.8,4.24327404 13.7859644,4.28538077 13.76,4.32 L8.16,11.7866667 C8.09372583,11.8750322 7.96836556,11.8929408 7.88,11.8266667 C7.86483887,11.8152958 7.85137085,11.8018278 7.84,11.7866667 L2.24,4.32 C2.17372583,4.23163444 2.19163444,4.10627417 2.28,4.04 C2.31461923,4.01403557 2.35672596,4 2.4,4 Z",
          left: "M11,2.4 L11,13.6 C11,13.7104569 10.9104569,13.8 10.8,13.8 C10.756726,13.8 10.7146192,13.7859644 10.68,13.76 L3.21333333,8.16 C3.12496777,8.09372583 3.10705916,7.96836556 3.17333333,7.88 C3.18470418,7.86483887 3.1981722,7.85137085 3.21333333,7.84 L10.68,2.24 C10.7683656,2.17372583 10.8937258,2.19163444 10.96,2.28 C10.9859644,2.31461923 11,2.35672596 11,2.4 Z",
          right: "M4,13.6 L4,2.4 C4,2.28954305 4.08954305,2.2 4.2,2.2 C4.24327404,2.2 4.28538077,2.21403557 4.32,2.24 L11.7866667,7.84 C11.8750322,7.90627417 11.8929408,8.03163444 11.8266667,8.12 C11.8152958,8.13516113 11.8018278,8.14862915 11.7866667,8.16 L4.32,13.76 C4.23163444,13.8262742 4.10627417,13.8083656 4.04,13.72 C4.01403557,13.6853808 4,13.643274 4,13.6 Z"
        };
      "dimension" === n.coloring.fieldType && (i = function (e) {
        return e.datum.value >= 0 || -3 === e.datum.value;
      });
      var x = "".concat(p, "Legend");
      return w$1(!0, o, {
        type: "legend-cat",
        key: "".concat(a, "-cat"),
        scale: x in m ? x : p,
        settings: {
          layout: {
            scrollOffset: function () {
              return c ? c.get("legendScrollOffset") : void 0;
            },
            size: -1 !== ["top", "bottom"].indexOf(o.layout.dock) ? 2 : 1,
            direction: s ? "rtl" : "ltr",
            horizontal: 20
          },
          item: {
            show: i,
            label: t$1({
              fill: v.label.color,
              fontSize: v.label.fontSize,
              fontFamily: v.label.fontFamily
            }, g)
          },
          navigation: {
            disabled: r,
            button: {
              content: function (e, t) {
                var n = t.direction;
                return e("i", {
                  style: {
                    "pointer-events": "none",
                    fontSize: "12px",
                    display: "inline-block",
                    fontStyle: "normal",
                    lineHeight: "0",
                    textAlign: "center",
                    textTransform: "none",
                    verticalAlign: "-0.125em",
                    textRendering: "optimizelegibility",
                    margin: "0px"
                  }
                }, [e("svg", {
                  xmlns: "http://www.w3.org/2000/svg",
                  width: "1em",
                  height: "1em",
                  viewBox: "0 0 16 16",
                  fill: "currentColor"
                }, [e("path", {
                  d: b[n]
                })])]);
              }
            }
          }
        },
        brush: {
          consume: [{
            context: "selection",
            data: ["", a],
            style: {
              inactive: {
                opacity: .3
              }
            }
          }]
        }
      }, {
        settings: f,
        style: d
      });
    }(e, n, r) : "continuous" === n.coloring.type && function (e, t) {
      var n,
        r = e.key,
        o = e.styleReference,
        i = e.styleOverrides,
        a = e.rtl,
        l = e.settings,
        u = e.style,
        c = t.scaleKey,
        s = t.theme,
        f = "".concat(c, "Range"),
        d = Ze(e, t);
      if (!d.show) return !1;
      var p = Ge({
          theme: s,
          key: o,
          styleOverrides: i
        }),
        h = d.layout.dock,
        m = "right" === h || "left" === h,
        v = null === (n = t.scales) || void 0 === n ? void 0 : n[f];
      return m && v && (v.invert = !0), w$1(!0, d, {
        type: "legend-seq",
        key: "".concat(r, "-seq"),
        settings: {
          fill: c,
          major: f,
          length: 1,
          tick: {
            fill: p.label.color,
            fontSize: p.label.fontSize,
            fontFamily: p.label.fontFamily
          },
          title: {
            anchor: !a || "top" !== d.layout.dock && "bottom" !== d.layout.dock ? void 0 : "right",
            padding: parseFloat(d.settings.title.fontSize) || 16
          }
        }
      }, {
        settings: l,
        style: u
      });
    }(e, n);
  }
  function Qe(e, t, n) {
    var r = [],
      o = [],
      i = Je(e, t, n && n.navigationDisabled);
    return r.push(i), i && "legend-cat" === i.type && (o.push(function (e) {
      var t = e.key,
        n = e.requireFailure,
        r = e.recognizeWith,
        o = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).actions;
      return {
        key: "event:tap-".concat(t),
        type: "Tap",
        requireFailure: n,
        recognizeWith: r,
        options: {
          event: "legendtap",
          interval: 10,
          pointers: 1,
          enable: function (e, n) {
            var r;
            if (!n) return !0;
            if (null != o && null !== (r = o.interact) && void 0 !== r && r.enabled && !o.interact.enabled()) return !1;
            if (!this.chart.componentsFromPoint({
              x: n.center.x,
              y: n.center.y
            }).some(function (e) {
              return e.key === "".concat(t, "-cat");
            })) return !1;
            var i = n.srcEvent.target;
            return !!(i && i.hasAttribute("data-action") && i.hasAttribute("data-component-key")) || !(!i || !i.childNodes[0] || "BUTTON" !== i.childNodes[0].nodeName);
          }
        },
        events: {
          legendtap: function (e) {
            e.preventDefault();
            var t = e.srcEvent.target;
            t && t.hasAttribute("data-action") && t.hasAttribute("data-component-key") && this.chart.component(t.getAttribute("data-component-key")).emit(t.getAttribute("data-action"));
          }
        }
      };
    }(e, n)), o.push(function () {
      var e,
        t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        n = t.eventName,
        r = t.key,
        o = t.requireFailure,
        i = t.recognizeWith,
        l = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).actions;
      return {
        key: "event:pan-".concat(r),
        type: "Pan",
        requireFailure: o,
        recognizeWith: i,
        options: {
          event: n,
          pointers: 1,
          threshold: 10,
          enable: function (e, t) {
            var o;
            return this.started === n || !t || !(null != l && null !== (o = l.interact) && void 0 !== o && o.enabled && !l.interact.enabled()) && this.chart.componentsFromPoint({
              x: t.center.x,
              y: t.center.y
            }).some(function (e) {
              return e.key === "".concat(r, "-cat");
            });
          }
        },
        events: (e = {}, a$1(e, "".concat(n, "start"), function (e) {
          e.preventDefault(), this.started !== n && (this.started = n, this.chart.component("".concat(r, "-cat")).emit("panstart", e));
        }), a$1(e, "".concat(n, "move"), function (e) {
          e.preventDefault(), this.chart.component("".concat(r, "-cat")).emit("panmove", e);
        }), a$1(e, "".concat(n, "end"), function (e) {
          e.preventDefault(), this.chart.component("".concat(r, "-cat")).emit("panend", e), this.started = !1;
        }), e)
      };
    }(e, n))), {
      interactions: o,
      components: r
    };
  }
  var et = function (e) {
    return "rgba(".concat([(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, ((4278190080 & e) >>> 24) / 255].join(","), ")");
  };
  function tt(e) {
    var n = function () {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          t = e.auto,
          n = Fe(e.resources).auto(t || function () {
            return {
              mode: "byDimension",
              persistent: !1,
              useDimColVal: !0,
              byDimDef: {
                activeDimensionIndex: 0,
                type: "expression",
                label: ""
              }
            };
          }).getDimensionColorMap(function (e, t) {
            var n = t.layout,
              r = t.app;
            return ze(e, {
              layout: n,
              app: r
            });
          }).getMeasure(function (e, t) {
            var n = t.layout,
              r = t.app;
            return Ve(e, {
              layout: n,
              app: r
            });
          }).getAttributeDimension(function (e, t) {
            var n = t.layout,
              r = t.model,
              o = t.app;
            return _e(e, {
              layout: n,
              model: r,
              app: o
            });
          });
        return n.getSnapshotData = He, n;
      }({
        resources: e
      }),
      r = {},
      o = {},
      i = function (e) {
        return o.settings || (e || console.warn("settings() called before auxiliarySettings()"), o.settings = n.settings()), o.settings;
      },
      l = {
        config: function (i) {
          if (r = t$1({}, i), o = {}, !r.key) throw new Error("Missing key");
          n.set(t$1(t$1({}, e), r));
        },
        auto: function (e) {
          return e ? (n.auto(e), l) : n.auto();
        },
        getAuxiliarySettings: function (e) {
          return o.auxiliarySettings ? Promise.resolve(o.auxiliarySettings) : n.getAuxiliarySettings(i(!0), e).then(function (e) {
            return o.auxiliarySettings = e || {}, o.settings = t$1(t$1({}, o.settings), o.auxiliarySettings), o.scales = void 0, o.color = void 0, o.auxiliarySettings;
          });
        },
        getAuxiliaryData: function () {
          return n.getAuxiliaryData(i());
        },
        getSnapshotData: function (e) {
          var t = i();
          return n.getAuxiliaryData(t, e).then(function (e) {
            return n.getSnapshotData(t, e);
          });
        },
        resolveUIColor: function (e) {
          return n.resolveUIColor(e);
        },
        settings: function () {
          var e = i();
          return {
            mode: e.mode,
            type: e.type,
            label: e.label,
            field: e.field,
            fieldType: e.fieldType,
            nil: e.nil,
            others: e.others,
            primary: e.primary
          };
        },
        settingsForMeasure: function (e) {
          var t,
            n = null === (t = i().measureOverrides) || void 0 === t ? void 0 : t[e];
          return n || this.settings();
        },
        isSelectionLocked: function (e) {
          var t = e.isMeasureSelectionLocked;
          return function (e, t) {
            var n = t.isMeasureSelectionLocked;
            return "field" !== e.mode || ("dimension" === e.fieldType ? e.isFieldLocked : "measure" !== e.fieldType || n);
          }(i(), {
            isMeasureSelectionLocked: t
          });
        },
        palettes: function () {
          return function () {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
              t = e.colorProps,
              n = e.coloring,
              r = e.theme,
              o = [];
            if (n && n.palettes && r) {
              var i = n.palettes.categorical || t.dimensionScheme,
                a = r.getDataColorPalettes().filter(function (e) {
                  return e.key === i;
                })[0] || r.getDataColorPalettes()[0];
              i && a && o.push({
                key: "categorical",
                colors: a.colors
              });
              var l = n.palettes.metric || t.measureScheme,
                u = r.getDataColorScales().filter(function (e) {
                  return e.key === l;
                })[0];
              if (u) {
                var s = u.colors[0] ? u.colors : [[]].concat(c$1(u.colors.slice(1)));
                s = Array.isArray(s[0]) ? s.map(function (e) {
                  return e.slice().reverse();
                }) : s.slice().reverse(), o.push({
                  key: "quant",
                  colors: s
                });
              }
            }
            return o;
          }({
            coloring: i(),
            colorProps: r.colorProps,
            theme: r.theme
          });
        },
        scales: function () {
          return o.scales = o.scales || function () {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
              n = e.hc,
              r = e.coloring,
              o = e.rtl,
              i = e.key,
              a = e.source,
              l = e.picasso,
              u = {},
              s = i;
            if (r) {
              var f = {
                override: !0,
                domain: r.explicit && "function" == typeof r.explicit.domain ? r.explicit.domain : [].concat(c$1((r.explicit || {}).domain || []), [-3, -2]),
                range: r.explicit && "function" == typeof r.explicit.range ? r.explicit.range : [].concat(c$1((r.explicit || {}).range || []), [r.others, r.nil])
              };
              if ("field" === r.mode) {
                if ("dimension" === r.fieldType) {
                  var d,
                    p = Be({
                      hc: n,
                      source: a,
                      coloring: r
                    }).data;
                  if (r.legendDataset) {
                    var h = 0,
                      m = {};
                    l.data("q")({
                      data: n
                    }).extract({
                      field: r.field,
                      trackBy: r.valueAccessor,
                      reduce: function (e) {
                        var t = e[0];
                        return m[t] = h++, e[0];
                      }
                    }), d = {
                      source: "attrDim",
                      extract: {
                        field: "qDimensionInfo/0",
                        filter: function (e) {
                          return e.qElemNumber >= 0;
                        },
                        props: {
                          row: {
                            value: function (e) {
                              return m[e.qElemNumber];
                            }
                          }
                        }
                      }
                    };
                  }
                  var v = {
                    data: p,
                    range: r.range,
                    domain: r.domain,
                    explicit: f,
                    type: "categorical-color",
                    label: function (e) {
                      return e.datum.text && e.datum.text.value ? e.datum.text.value : e.datum.label;
                    }
                  };
                  u[s] = v, d && (u["".concat(s, "Legend")] = t$1(t$1({}, v), {}, {
                    data: d
                  })), n && n.qHasOtherValues && d && ((d || v.data).amend = [{
                    label: n.qDimensionInfo[0].othersLabel,
                    source: {
                      key: "qHyperCube",
                      field: "qDimensionInfo/0"
                    },
                    row: {
                      value: -3
                    },
                    value: -3
                  }]);
                } else if ("measure" === r.fieldType) {
                  var y = {
                    data: {
                      field: r.field
                    },
                    min: r.min,
                    max: r.max
                  };
                  u[s] = w$1({}, y, {
                    type: "categorical" === r.type ? "threshold-color" : "sequential-color",
                    range: r.range,
                    domain: r.domain,
                    invert: r.reverse
                  }), "sequential-color" === u[s].type && (u["".concat(s, "Range")] = w$1({}, y, {
                    invert: !!o
                  }));
                } else if ("color" !== r.type) throw new Error("UNUSED FIELD");
              } else if ("dimension" === r.mode) {
                var g = {
                  data: n.qDimensionInfo.map(function (e, t) {
                    return t;
                  }),
                  label: function (e) {
                    return n.qDimensionInfo[e.datum.value].qFallbackTitle;
                  },
                  explicit: f,
                  type: "categorical-color"
                };
                u[s] = g;
              } else if ("measure" === r.mode) {
                var b = {
                  data: n.qMeasureInfo.map(function (e, t) {
                    return t;
                  }).filter(function (e) {
                    var t;
                    return !(null !== (t = r.explicit) && void 0 !== t && null !== (t = t.exclude) && void 0 !== t && t.includes(e));
                  }),
                  label: function (e) {
                    return n.qMeasureInfo[e.datum.value].qFallbackTitle;
                  },
                  explicit: f,
                  type: "categorical-color"
                };
                u[s] = b;
              }
            }
            return u;
          }({
            hc: r.hc,
            coloring: i(),
            key: r.key,
            source: r.source,
            picasso: e.picasso
          }), o.scales;
        },
        color: function () {
          return o.color = o.color || function (e) {
            var t = e.coloring,
              n = e.scales,
              r = e.key,
              o = Ye(r),
              i = Ye("".concat(r, "IsAnOther")),
              a = function (e, t) {
                var r = e.fieldType,
                  a = e.invalid,
                  l = e.mode,
                  u = e.nil,
                  c = e.others,
                  s = e.primary,
                  f = e.type;
                return a ? function (e) {
                  return Ue(e) || i(e) ? c : u;
                } : n[t] ? function (e) {
                  return Ue(e) ? c : $e(e) || -2 === o(e) && "dimension" === r || "NaN" === o(e) ? u : i(e) ? c : e.resources.scale(t)(o(e)) || c;
                } : "constant" === l ? function (e) {
                  return Ue(e) || i(e) ? c : $e(e) ? u : s;
                } : "color" === f ? function (e) {
                  return Ue(e) || i(e) ? c : $e(e) ? u : o(e) || c;
                } : null;
              },
              l = a(t, r);
            if (t.measureOverrides) {
              var u = Ye("".concat(r, "MeasureIdx")),
                c = t.measureOverrides.map(function (e) {
                  return e && a(e);
                });
              return function (e) {
                var t = u(e);
                return c[t] ? c[t](e) : l(e);
              };
            }
            return l;
          }({
            coloring: i(),
            scales: this.scales(),
            key: r.key
          }), o.color;
        },
        datumProps: function (e) {
          return function (e) {
            var t,
              n,
              r = e.hc,
              o = e.coloring,
              i = e.scales,
              l = e.key,
              u = e.addMeasureIx,
              c = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
              s = l,
              f = o.nil;
            "field" === o.mode && o.field ? t = o.field : i[l] && "field" === o.mode && (t = i[l].data.field || o.field), t ? (n = {
              field: t,
              reduce: "first"
            }, "color" === o.type && (n.value = function (e) {
              return "NaN" !== e.qNum ? et(e.qNum) : e.qText && $$1(e.qText) ? e.qText : f;
            })) : "dimension" === o.mode ? n = void 0 !== o.field ? o.field : r.qDimensionInfo.length - 1 : "measure" === o.mode && (n = c);
            var d = a$1({}, s, n);
            return r.qDimensionInfo.length > 1 && (d["".concat(s, "IsAnOther")] = {
              fields: r.qDimensionInfo.map(function (e, t) {
                return {
                  field: "qDimensionInfo/".concat(t)
                };
              }),
              value: function (e) {
                return -1 !== e.indexOf(-3);
              }
            }), u && (d["".concat(s, "MeasureIdx")] = c), d;
          }({
            coloring: this.settingsForMeasure(e),
            scales: this.scales(),
            key: r.key,
            hc: r.hc,
            addMeasureIx: i().measureOverrides
          }, e);
        },
        data: function () {
          var e = i(),
            t = {
              key: "dummy",
              data: [["field"], ["a"]]
            };
          return e.legendDataset ? [t, {
            type: "q",
            key: "attrDim",
            data: e.legendDataset.raw(),
            config: {
              localeInfo: r.localeInfo
            }
          }] : [t];
        },
        legend: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
            t = e.eventName,
            n = e.key,
            o = e.viewState,
            a = e.chart,
            l = e.rtl,
            u = e.styleReference,
            c = void 0 === u ? "object.legend" : u,
            s = e.styleOverrides,
            f = e.settings,
            d = void 0 === f ? {} : f,
            p = e.style,
            h = void 0 === p ? {} : p,
            m = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          return Qe({
            eventName: t,
            key: n,
            rtl: l,
            viewState: o,
            chart: a,
            styleReference: c,
            styleOverrides: s,
            settings: d,
            style: h
          }, {
            legendProps: r.legendProps,
            scaleKey: r.key,
            coloring: i(),
            theme: r.theme,
            hc: r.hc,
            scales: this.scales()
          }, m);
        }
      };
    return l;
  }
  var nt = function (e) {
    return e.baseColor || e.coloring && e.coloring.baseColor;
  };
  function rt(e) {
    var t = e.qHyperCube,
      n = t.qDimensionInfo,
      r = t.qMeasureInfo,
      o = n.some(nt),
      i = r.some(nt),
      a = e.color.useBaseColors;
    return "measure" === a && !i || "dimension" === a && !o ? "off" : a;
  }
  function ot(e) {
    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      r = t$1(t$1(t$1({}, e), n), {}, {
        colorProps: t$1(t$1({}, e.colorProps), n.colorProps || {})
      });
    return r;
  }
  var it = function (e) {
    return e.baseColor || e.coloring && e.coloring.baseColor;
  };
  function at$1(e) {
    var t,
      n = e.qHyperCube.qDimensionInfo.some(it),
      r = e.qHyperCube.qMeasureInfo.some(it),
      o = n ? "dimension" : void 0;
    return {
      mode: "primary",
      useBaseColors: null !== (t = null != o ? o : r ? "measure" : void 0) && void 0 !== t ? t : "off",
      paletteColor: null
    };
  }
  var lt = function () {};
  function ut(e) {
    var n,
      r,
      o,
      i,
      a = e.picasso,
      l = e.model,
      u = e.app,
      c = e.translator,
      s = e.layoutService,
      f = void 0 === s ? void 0 : s,
      d = e.createConfig,
      p = void 0 === d ? lt : d,
      h = e.config,
      m = void 0 === h ? {} : h,
      v = e.custom,
      y = void 0 === v ? {} : v,
      g = m.localeInfo,
      b = m.key,
      x = m.theme,
      q = void 0 === x ? void 0 : x,
      w = m.auto,
      M = void 0 === w ? void 0 : w,
      k = m.definitionPath,
      S = null == f || null === (n = f.getLayout) || void 0 === n ? void 0 : n.call(f),
      C = {
        theme: q,
        key: b,
        localeInfo: g,
        layout: S,
        hc: null == f || null === (r = f.getHyperCube) || void 0 === r ? void 0 : r.call(f),
        legendProps: null == f || null === (o = f.getLayoutValue) || void 0 === o ? void 0 : o.call(f, "legend"),
        colorProps: t$1(t$1({}, null == f || null === (i = f.getLayoutValue) || void 0 === i ? void 0 : i.call(f, "color")), {}, {
          useBaseColors: S ? rt(S) : void 0
        })
      },
      D = tt({
        picasso: a,
        model: l,
        app: u,
        translator: c,
        auto: M
      });
    !1 !== M && D.auto(function (e) {
      return M ? M({
        layout: e,
        defaultAuto: at$1
      }) : at$1(e);
    });
    var I = !1,
      O = {
        getColor: function () {
          return D.color();
        },
        getPaletteColor: function (e) {
          var t = e.index,
            n = e.color;
          return D.resolveUIColor({
            index: t,
            color: n
          });
        },
        getData: function () {
          return D.data();
        },
        getDatumProps: function (e) {
          return D.datumProps(e);
        },
        getSnapshotData: function () {
          return D.getSnapshotData(k);
        },
        getSettingsForMeasure: function (e) {
          return D.settingsForMeasure(e);
        },
        getSettings: function () {
          return D.settings();
        },
        getLegend: function (e, t) {
          return D.legend(e, t);
        },
        getScales: function () {
          return D.scales();
        },
        getPalettes: function () {
          return D.palettes();
        },
        isSelectionLocked: function (e) {
          var t = e.isMeasureSelectionLocked;
          return D.isSelectionLocked({
            isMeasureSelectionLocked: t
          });
        },
        isInitialized: function () {
          return I;
        },
        custom: t$1({}, y),
        initialize: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
            t = e.createConfig,
            n = void 0 === t ? p : t,
            r = n({
              getUseBaseColors: rt
            }),
            o = ot(C, r);
          D.config(o);
          var i = D.getAuxiliarySettings(k).then(function () {
            I = !0;
          });
          return i;
        }
      };
    return O;
  }
  function ct(e) {
    var t = e.chart,
      n = e.logicalSize;
    if (n) return n;
    var r = t ? t.element.getBoundingClientRect() : {};
    return {
      width: r.width,
      height: r.height
    };
  }
  var st = [{
    key: "FULL",
    size: {
      width: 550,
      height: 450
    }
  }, {
    key: "MEDIUM",
    size: {
      width: 400,
      height: 220
    }
  }, {
    key: "SMALL",
    size: {
      width: 300,
      height: 150
    }
  }, {
    key: "XSMALL",
    size: {
      width: 150,
      height: 75
    }
  }];
  function ft(e) {
    var t = e.width,
      n = e.height,
      r = st.filter(function (e) {
        return t >= e.size.width && n >= e.size.height;
      }).shift();
    return r ? r.key : "SPARK";
  }
  var dt = {
    left: "right",
    right: "left",
    top: "bottom",
    bottom: "top",
    near: "far",
    far: "near"
  };
  function pt(e) {
    var t = e.orientation,
      n = e.dock,
      r = e.btt,
      o = e.rtl,
      i = "horizontal" === t ? function (e) {
        return "bottom" === e || "near" === e ? "bottom" : "top";
      }(n) : function (e, t) {
        var n = "left" === e || "near" === e ? "left" : "right";
        return t ? dt[n] : n;
      }(n, o),
      a = function (e, t, n) {
        return "vertical" === e ? t ? "bottom" : "top" : n ? "right" : "left";
      }(t, r, o);
    return {
      current: i,
      opposite: dt[i],
      start: a,
      end: dt[a]
    };
  }
  function ht(e) {
    var n = e.chart,
      r = e.layoutService,
      o = e.config,
      i = void 0 === o ? {} : o,
      a = i.logicalSize,
      l = void 0 !== a && a,
      u = i.rtl,
      c = void 0 !== u && u,
      s = {
        chart: {
          size: void 0,
          mode: void 0
        },
        x: {
          dock: void 0,
          opposite: void 0,
          size: void 0
        },
        y: {
          dock: void 0,
          opposite: void 0,
          size: void 0
        }
      },
      f = {
        type: "x-y",
        config: t$1({}, i),
        meta: s,
        update: function (e) {
          s.chart.size = {
            width: e.width,
            height: e.height
          }, s.chart.mode = ft(e);
          var t = pt({
              orientation: "horizontal",
              dock: r.getLayoutValue("xAxis.dock"),
              btt: !1,
              rtl: c
            }),
            n = t.current,
            o = t.opposite;
          s.x.dock = n, s.x.opposite = o, s.x.size = e.width;
          var i = pt({
              orientation: "vertical",
              dock: r.getLayoutValue("yAxis.dock"),
              btt: !0,
              rtl: c
            }),
            a = i.current,
            l = i.opposite;
          s.y.dock = a, s.y.opposite = l, s.y.size = e.height;
        }
      };
    return f.update(ct({
      chart: n,
      logicalSize: l
    })), f;
  }
  var mt = "vertical",
    vt = "horizontal";
  function yt(e) {
    var n = e.chart,
      r = e.layoutService,
      o = e.config,
      i = void 0 === o ? {} : o,
      a = e.typeConfig,
      l = void 0 === a ? {} : a,
      u = i.logicalSize,
      c = void 0 !== u && u,
      s = i.rtl,
      f = void 0 !== s && s,
      d = l.fallback === mt ? mt : vt,
      p = !!l.invert,
      h = l.measureAxes || [{
        ref: "measureAxis",
        name: "minor"
      }],
      m = {
        chart: {
          orientation: void 0,
          size: void 0,
          mode: void 0
        },
        major: {
          orientation: void 0,
          dock: void 0,
          opposite: void 0,
          size: void 0
        }
      },
      v = {
        type: "major-minor",
        config: t$1({}, i),
        meta: m,
        update: function (e) {
          m.chart.orientation = r.getLayoutValue("orientation", d), m.chart.size = {
            width: e.width,
            height: e.height
          }, m.chart.mode = ft(e), m.major.orientation = function (e) {
            var t = e.layoutService,
              n = e.chartOrientation,
              r = e.invert;
            return t.meta.isContinuous ? vt : r ? n === mt ? vt : mt : n;
          }({
            layoutService: r,
            chartOrientation: m.chart.orientation,
            invert: p
          });
          var t = pt({
              orientation: m.major.orientation,
              dock: r.getLayoutValue("dimensionAxis.dock"),
              btt: !1,
              rtl: f
            }),
            n = t.current,
            o = t.opposite;
          m.major.dock = n, m.major.opposite = o, m.major.size = m.major.orientation === mt ? e.height : e.width, h.forEach(function (t) {
            var n = {};
            n.orientation = m.major.orientation === mt ? vt : mt;
            var o = pt({
                orientation: n.orientation,
                dock: r.getLayoutValue("".concat(t.ref, ".dock")),
                btt: !0,
                rtl: f
              }),
              i = o.current,
              a = o.opposite,
              l = o.start,
              u = o.end;
            n.dock = i, n.opposite = a, n.start = l, n.end = u, n.size = n.orientation === mt ? e.height : e.width, m[t.name] = n;
          });
        }
      };
    return v.update(ct({
      chart: n,
      logicalSize: c
    })), v;
  }
  function gt(e) {
    var t = e.chart,
      n = e.layoutService,
      r = e.config,
      o = void 0 === r ? {} : r,
      i = e.typeConfig,
      a = void 0 === i ? {} : i;
    return ("x-y" === a.type ? ht : yt)({
      chart: t,
      layoutService: n,
      config: o,
      typeConfig: a
    });
  }
  function bt(e, t, n) {
    if (void 0 === e || void 0 === t) return n;
    for (var r = t.split("."), o = e, i = 0; i < r.length; ++i) {
      var a = r[i];
      if (void 0 === o[a]) return n;
      o = o[a];
    }
    return o;
  }
  var xt = ["__proto__", "constructor"];
  function qt(e, t, n) {
    if (void 0 !== e && void 0 !== t) {
      var r = t.split("."),
        o = r[r.length - 1];
      if (!xt.some(function (e) {
        return r.includes(e);
      })) {
        for (var i = e, a = 0; a < r.length - 1; ++a) {
          var l = r[a];
          void 0 === i[l] && (i[l] = Number.isNaN(+r[a + 1]) ? {} : []), i = i[l];
        }
        void 0 !== n ? i[o] = n : delete i[o];
      }
    }
  }
  function wt() {
    var e = {};
    return {
      get: function (t) {
        return e[t];
      },
      set: function (t, n) {
        return e[t] = n, n;
      },
      has: function (t) {
        return t in e;
      },
      remove: function (t) {
        delete e[t];
      },
      empty: function () {
        e = {};
      }
    };
  }
  function Mt(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function (e) {
        return e;
      },
      n = wt();
    return function (r) {
      var o = t(r);
      return n.has(o) ? n.get(o) : n.set(o, e(r));
    };
  }
  function kt(e) {
    var n = t$1({}, e),
      r = {},
      o = {},
      i = !1,
      a = {
        get: function (e) {
          return n[e];
        },
        set: function (e, t) {
          var a = n[e];
          !i && r[e] ? n[e] = r[e](t, a) : n[e] = t, !i && o[e] && o[e](n[e], a);
        },
        preventSet: function (e, t) {
          i = !0, a.set(e, t), i = !1;
        },
        intercept: function (e, t) {
          r[e] = t;
        },
        onChanged: function (e, t) {
          o[e] = t;
        }
      };
    return a;
  }
  function St(e) {
    var t,
      n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 50;
    return function () {
      for (var r = this, o = arguments.length, i = new Array(o), a = 0; a < o; a++) i[a] = arguments[a];
      var l = function () {
        return e.apply(r, i);
      };
      clearTimeout(t), t = setTimeout(l, n);
    };
  }
  function Ct(e) {
    var t,
      n,
      r,
      o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 50,
      i = 0;
    return function () {
      t = this;
      for (var a = arguments.length, l = new Array(a), u = 0; u < a; u++) l[u] = arguments[u];
      n = l;
      var c = Date.now() - i,
        s = function () {
          i = Date.now(), r = 0, e.apply(t, n);
        };
      r || (c >= o ? s() : r = setTimeout(s, o - c));
    };
  }
  var Dt = {
      ERROR_CODES: [7005],
      DIMENSION: "qDimensionInfo",
      MEASURE: "qMeasureInfo"
    },
    It = function (e, t) {
      return e[t].reduce(function (e, t, n) {
        var r;
        return (r = t, Dt.ERROR_CODES.some(function (e) {
          var t;
          return e === (null === (t = r.qError) || void 0 === t ? void 0 : t.qErrorCode);
        })) ? e.filtered.push(n) : e.reduced.push(t), e;
      }, {
        reduced: [],
        filtered: []
      });
    };
  function Ot(e) {
    var t;
    return ((null == e || null === (t = e.qHyperCube) || void 0 === t ? void 0 : t.qDimensionInfo) || []).map(function (e) {
      var t,
        n = null === (t = e.qCardinalities) || void 0 === t ? void 0 : t.qHypercubeCardinal;
      if (n) return n;
      var r = e.qStateCounts || {},
        o = r.qLocked,
        i = void 0 === o ? 0 : o,
        a = r.qOption,
        l = void 0 === a ? 0 : a,
        u = r.qSelected;
      return i + l + (void 0 === u ? 0 : u);
    });
  }
  function Et(e) {
    switch (e.qHyperCube.qMode) {
      case "S":
        return function (e) {
          var t = e.qHyperCube.qSize;
          return {
            refs: {
              dataPages: "qHyperCube.qDataPages"
            },
            size: {
              x: t.qcx,
              y: t.qcy,
              dimensions: Ot(e)
            }
          };
        }(e);
      case "K":
        return function (e) {
          var t = Ot(e);
          return {
            refs: {
              dataPages: "qHyperCube.qStackedDataPages"
            },
            size: {
              x: e.qHyperCube.qSize.qcx,
              y: t[0],
              dimensions: t
            }
          };
        }(e);
      case "T":
        return function (e) {
          var t = Ot(e);
          return {
            refs: {
              dataPages: "qHyperCube.qTreeDataPages"
            },
            size: {
              x: e.qHyperCube.qSize.qcx,
              y: t[0],
              dimensions: t
            }
          };
        }(e);
      default:
        throw new Error("Mode not supported");
    }
  }
  function At(e) {
    var n = e.source,
      r = e.metaAdditionsFn,
      o = e.experimental,
      i = void 0 === o ? {
        filter: !1
      } : o,
      a = w$1(!0, {}, n),
      l = i.filter ? function (e) {
        var t = e.qHyperCube,
          n = It(t, Dt.DIMENSION),
          r = n.reduced,
          o = n.filtered;
        t[Dt.DIMENSION] = r;
        var i = It(t, Dt.MEASURE),
          a = i.reduced,
          l = i.filtered;
        return t[Dt.MEASURE] = a, {
          dimensions: o,
          measures: l
        };
      }(a) : {
        dimensions: [],
        measures: []
      },
      u = Et(a),
      c = function () {
        var e = function (e) {
          var n = e.layout,
            r = e.additionsFn,
            o = void 0 === r ? function () {
              return {};
            } : r,
            i = e.additionsProps,
            a = void 0 === i ? {} : i,
            l = n.qHyperCube,
            u = l.qDimensionInfo,
            c = l.qMeasureInfo,
            s = l.qMode,
            f = u.length,
            d = c.length,
            p = t$1({
              mode: {
                S: "S" === s,
                P: "P" === s,
                K: "K" === s,
                T: "T" === s
              },
              dimensionCount: f,
              measureCount: d,
              hasMultipleDimensions: f > 1,
              hasMultipleMeasures: d > 1,
              isOneDimensional: 1 === f,
              isTwoDimensional: 2 === f
            }, a);
          return t$1(t$1({}, p), o({
            layout: n,
            meta: p
          }));
        }({
          layout: a,
          additionsFn: r,
          additionsProps: {
            size: u.size
          }
        });
        return e.filteredFields = l, e;
      },
      s = {
        refs: t$1({}, u.refs),
        meta: c(),
        getLayout: function () {
          return a;
        },
        getLayoutValue: function (e, t) {
          return bt(a, e, t);
        },
        setLayoutValue: function (e, t) {
          qt(a, e, t), u = Et(a), s.meta = c();
        },
        getHyperCube: function () {
          return a.qHyperCube;
        },
        getHyperCubeValue: function (e, t) {
          return bt(a.qHyperCube, e, t);
        },
        setHyperCubeValue: function (e, t) {
          qt(a.qHyperCube, e, t), u = Et(a), s.meta = c();
        },
        getDataPages: function () {
          return bt(a, u.refs.dataPages);
        },
        setDataPages: function (e) {
          qt(a, u.refs.dataPages, e), s.meta = c();
        }
      };
    return s;
  }
  function Nt(e) {
    var t = e.originalArray,
      n = e.newArray,
      r = e.matchKey;
    return Array.isArray(t) && t.length ? (n.forEach(function (e) {
      var n = -1;
      t.some(function (t, o) {
        return t[r] && t[r] === e[r] && (n = o), n;
      }), n > -1 ? t[n] = e : t.push(e);
    }), t) : n;
  }
  function Lt(e) {
    var o = e.picassoInstance,
      a = e.plugins,
      l = e.pluginArgs,
      s = void 0 === l ? {} : l,
      f = {
        initialized: !1,
        definitions: []
      };
    return {
      initialize: function () {
        return i(n$1().mark(function e() {
          var l, u, d, p;
          return n$1().wrap(function (e) {
            for (;;) switch (e.prev = e.next) {
              case 0:
                if (!f.initialized) {
                  e.next = 2;
                  break;
                }
                return e.abrupt("return");
              case 2:
                return u = Promise.all(a.filter(function (e) {
                  return "custom-component" === e.info.type;
                }).map(function () {
                  var e = i(n$1().mark(function e(i) {
                    var a;
                    return n$1().wrap(function (e) {
                      for (;;) switch (e.prev = e.next) {
                        case 0:
                          if (i.info.componentName) {
                            e.next = 2;
                            break;
                          }
                          throw new Error("plugin-service: Custom component is missing componentName");
                        case 2:
                          return e.next = 4, i.fn(t$1({}, s));
                        case 4:
                          if ("object" === r$3(a = e.sent)) {
                            e.next = 7;
                            break;
                          }
                          throw new Error("plugin-service: Custom component needs to be an object");
                        case 7:
                          o.component(i.info.componentName, a);
                        case 8:
                        case "end":
                          return e.stop();
                      }
                    }, e);
                  }));
                  return function (t) {
                    return e.apply(this, arguments);
                  };
                }())), d = Promise.all(a.filter(function (e) {
                  return "component-definition" === e.info.type;
                }).map(function (e) {
                  return e.fn(t$1({}, s));
                })), e.next = 6, Promise.all([u, d]);
              case 6:
                p = e.sent, f.initialized = !0, (l = f.definitions).push.apply(l, c$1(p[1]));
              case 9:
              case "end":
                return e.stop();
            }
          }, e);
        }))();
      },
      extendComponents: function (e) {
        return f.initialized ? (f.definitions.filter(Boolean).forEach(function (t) {
          var n = u$1(e.filter(function (e) {
            return e.key && e.key === t.key;
          }), 1)[0];
          if (n) {
            var o = w$1(!0, {}, n.brush);
            w$1(!0, n, t), t.brush && (n.brush = function (e, t) {
              return "object" === r$3(e) && Object.keys(e).length ? (Array.isArray(t.consume) && (e.consume = Nt({
                originalArray: e.consume,
                newArray: t.consume,
                matchKey: "context"
              })), Array.isArray(t.trigger) && (e.trigger = Nt({
                originalArray: e.trigger,
                newArray: t.trigger,
                matchKey: "on"
              })), e) : t;
            }(o, t.brush));
          } else e.push(t);
        }), e) : e;
      }
    };
  }
  function Tt(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(e);
      t && (r = r.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable;
      })), n.push.apply(n, r);
    }
    return n;
  }
  function Pt(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = null != arguments[t] ? arguments[t] : {};
      t % 2 ? Tt(Object(n), !0).forEach(function (t) {
        jt(e, t, n[t]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Tt(Object(n)).forEach(function (t) {
        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
      });
    }
    return e;
  }
  function jt(e, t, n) {
    return (t = function (e) {
      var t = function (e, t) {
        if ("object" != typeof e || null === e) return e;
        var n = e[Symbol.toPrimitive];
        if (void 0 !== n) {
          var r = n.call(e, t || "default");
          if ("object" != typeof r) return r;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t ? String : Number)(e);
      }(e, "string");
      return "symbol" == typeof t ? t : String(t);
    }(t)) in e ? Object.defineProperty(e, t, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[t] = n, e;
  }
  var Ft = Object.prototype.hasOwnProperty,
    Ht = Object.prototype.toString,
    Rt = Object.defineProperty,
    zt = Object.getOwnPropertyDescriptor,
    Vt = function (e) {
      return "function" == typeof Array.isArray ? Array.isArray(e) : "[object Array]" === Ht.call(e);
    },
    _t = function (e) {
      if (!e || "[object Object]" !== Ht.call(e)) return !1;
      var t,
        n = Ft.call(e, "constructor"),
        r = e.constructor && e.constructor.prototype && Ft.call(e.constructor.prototype, "isPrototypeOf");
      if (e.constructor && !n && !r) return !1;
      for (t in e);
      return void 0 === t || Ft.call(e, t);
    },
    Bt = function (e, t) {
      Rt && "__proto__" === t.name ? Rt(e, t.name, {
        enumerable: !0,
        configurable: !0,
        value: t.newValue,
        writable: !0
      }) : e[t.name] = t.newValue;
    },
    Yt = function (e, t) {
      if ("__proto__" === t) {
        if (!Ft.call(e, t)) return;
        if (zt) return zt(e, t).value;
      }
      return e[t];
    },
    $t = function e() {
      var t,
        n,
        r,
        o,
        i,
        a,
        l = arguments[0],
        u = 1,
        c = arguments.length,
        s = !1;
      for ("boolean" == typeof l && (s = l, l = arguments[1] || {}, u = 2), (null == l || "object" != typeof l && "function" != typeof l) && (l = {}); u < c; ++u) if (null != (t = arguments[u])) for (n in t) r = Yt(l, n), l !== (o = Yt(t, n)) && (s && o && (_t(o) || (i = Vt(o))) ? (i ? (i = !1, a = r && Vt(r) ? r : []) : a = r && _t(r) ? r : {}, Bt(l, {
        name: n,
        newValue: e(s, a, o)
      })) : void 0 !== o && Bt(l, {
        name: n,
        newValue: o
      }));
      return l;
    };
  function Ut(e, t, n, r) {
    if (!e) return -1;
    const o = n.cache,
      i = e.origin ? e.origin() : null;
    i && (e = i);
    let a = o.fields.indexOf(e),
      l = -1,
      u = -1;
    if (-1 === a) for (let t = 0; t < o.wrappedFields.length; t++) if (u = o.wrappedFields[t].attrDims.map(e => e.instance).indexOf(e), l = o.wrappedFields[t].attrExps.map(e => e.instance).indexOf(e), -1 !== u || -1 !== l) {
      a = t;
      break;
    }
    if (Array.isArray(r) && r.some((e, t) => e !== t)) {
      const e = r.indexOf(a);
      -1 !== e && (a = e);
    }
    return a -= t.qArea.qLeft, a < 0 || a >= t.qArea.qWidth ? -1 : u >= 0 ? e => e[a].qAttrDims.qValues[u] : l >= 0 ? e => e[a].qAttrExps.qValues[l] : e => e[a];
  }
  function Kt(e, t, n) {
    let {
      key: r
    } = n;
    const o = {
      value: "function" == typeof e.value ? e.value(t) : void 0 !== e.value ? e.value : t
    };
    return o.label = "function" == typeof e.label ? e.label(t) : void 0 !== e.label ? String(e.label) : String(o.value), e.field && (o.source = {
      key: r,
      field: e.field.key()
    }), o;
  }
  function Gt(e) {
    let {
        cache: t,
        f: n,
        mainCell: r,
        p: o,
        prop: i,
        page: a,
        rowIdx: l,
        row: u,
        sourceKey: c,
        target: s,
        targetProp: f,
        columnOrder: d
      } = e,
      p = r;
    if (o.field && o.field !== n) {
      const e = Ut(o.field, a, {
        cache: t
      }, d);
      if (-1 === e) return;
      p = $t({
        qRow: l
      }, e(u));
    }
    s[f] = Kt(o, p, {
      key: c
    });
  }
  function Wt(e, t, n, r) {
    const o = Array.isArray(e) ? e : [e];
    let i = [];
    for (let e = 0; e < o.length; e++) if (void 0 !== o[e].field) {
      const a = t.raw(),
        l = t.key(),
        u = "object" == typeof o[e].field ? o[e].field : t.field(o[e].field),
        {
          props: c,
          main: s
        } = r.normalizeConfig(o[e], t),
        f = Object.keys(c),
        d = !!o[e].trackBy,
        p = typeof o[e].trackBy,
        h = {},
        m = [],
        v = [];
      for (let t = 0; t < a.qDataPages.length; t++) {
        const i = Ut(u, a.qDataPages[t], {
          cache: n
        }, a.qColumnOrder);
        if (-1 !== i) for (let y = 0; y < a.qDataPages[t].qMatrix.length; y++) {
          const g = a.qDataPages[t].qArea.qTop + y,
            b = $t({
              qRow: g
            }, i(a.qDataPages[t].qMatrix[y])),
            x = Kt(s, b, {
              key: l
            });
          if (!(s.filter && !s.filter(b))) {
            for (let e = 0; e < f.length; e++) {
              const r = c[f[e]];
              let o = r.fields || [r];
              r.fields && (x[f[e]] = []);
              for (let i = 0; i < o.length; i++) Gt({
                cache: n,
                f: u,
                mainCell: b,
                p: o[i],
                prop: f[e],
                props: c,
                page: a.qDataPages[t],
                rowIdx: g,
                row: a.qDataPages[t].qMatrix[y],
                sourceKey: l,
                target: r.fields ? x[f[e]] : x,
                targetProp: r.fields ? i : f[e],
                columnOrder: a.qColumnOrder
              });
              if (r.fields) {
                const t = x[f[e]].map(e => e.value),
                  n = x[f[e]].map(e => e.label);
                x[f[e]] = {
                  value: "function" == typeof r.value ? r.value(t) : void 0 !== r.value ? r.value : t,
                  label: "function" == typeof r.label ? r.label(n) : void 0 !== r.label ? String(r.label) : String(x[f[e]].value)
                };
              }
            }
            d && r.track({
              cfg: o[e],
              itemData: b,
              obj: x,
              target: m,
              tracker: h,
              trackType: p
            }), v.push(x);
          }
        }
      }
      const y = d ? r.collect(m, {
        main: s,
        propsArr: f,
        props: c
      }) : v;
      i = [...i, ...y];
    }
    return i;
  }
  function Xt(e) {
    var t = 0,
      n = e.children,
      r = n && n.length;
    if (r) for (; --r >= 0;) t += n[r].value;else t = 1;
    e.value = t;
  }
  function Zt(e, t) {
    e instanceof Map ? (e = [void 0, e], void 0 === t && (t = Qt)) : void 0 === t && (t = Jt);
    for (var n, r, o, i, a, l = new nn(e), u = [l]; n = u.pop();) if ((o = t(n.data)) && (a = (o = Array.from(o)).length)) for (n.children = o, i = a - 1; i >= 0; --i) u.push(r = o[i] = new nn(o[i])), r.parent = n, r.depth = n.depth + 1;
    return l.eachBefore(tn);
  }
  function Jt(e) {
    return e.children;
  }
  function Qt(e) {
    return Array.isArray(e) ? e[1] : null;
  }
  function en(e) {
    void 0 !== e.data.value && (e.value = e.data.value), e.data = e.data.data;
  }
  function tn(e) {
    var t = 0;
    do {
      e.height = t;
    } while ((e = e.parent) && e.height < ++t);
  }
  function nn(e) {
    this.data = e, this.depth = this.height = 0, this.parent = null;
  }
  function rn(e) {
    return null == e ? null : function (e) {
      if ("function" != typeof e) throw new Error();
      return e;
    }(e);
  }
  nn.prototype = Zt.prototype = {
    constructor: nn,
    count: function () {
      return this.eachAfter(Xt);
    },
    each: function (e, t) {
      let n = -1;
      for (const r of this) e.call(t, r, ++n, this);
      return this;
    },
    eachAfter: function (e, t) {
      for (var n, r, o, i = this, a = [i], l = [], u = -1; i = a.pop();) if (l.push(i), n = i.children) for (r = 0, o = n.length; r < o; ++r) a.push(n[r]);
      for (; i = l.pop();) e.call(t, i, ++u, this);
      return this;
    },
    eachBefore: function (e, t) {
      for (var n, r, o = this, i = [o], a = -1; o = i.pop();) if (e.call(t, o, ++a, this), n = o.children) for (r = n.length - 1; r >= 0; --r) i.push(n[r]);
      return this;
    },
    find: function (e, t) {
      let n = -1;
      for (const r of this) if (e.call(t, r, ++n, this)) return r;
    },
    sum: function (e) {
      return this.eachAfter(function (t) {
        for (var n = +e(t.data) || 0, r = t.children, o = r && r.length; --o >= 0;) n += r[o].value;
        t.value = n;
      });
    },
    sort: function (e) {
      return this.eachBefore(function (t) {
        t.children && t.children.sort(e);
      });
    },
    path: function (e) {
      for (var t = this, n = function (e, t) {
          if (e === t) return e;
          var n = e.ancestors(),
            r = t.ancestors(),
            o = null;
          e = n.pop(), t = r.pop();
          for (; e === t;) o = e, e = n.pop(), t = r.pop();
          return o;
        }(t, e), r = [t]; t !== n;) t = t.parent, r.push(t);
      for (var o = r.length; e !== n;) r.splice(o, 0, e), e = e.parent;
      return r;
    },
    ancestors: function () {
      for (var e = this, t = [e]; e = e.parent;) t.push(e);
      return t;
    },
    descendants: function () {
      return Array.from(this);
    },
    leaves: function () {
      var e = [];
      return this.eachBefore(function (t) {
        t.children || e.push(t);
      }), e;
    },
    links: function () {
      var e = this,
        t = [];
      return e.each(function (n) {
        n !== e && t.push({
          source: n.parent,
          target: n
        });
      }), t;
    },
    copy: function () {
      return Zt(this).eachBefore(en);
    },
    [Symbol.iterator]: function* () {
      var e,
        t,
        n,
        r,
        o = this,
        i = [o];
      do {
        for (e = i.reverse(), i = []; o = e.pop();) if (yield o, t = o.children) for (n = 0, r = t.length; n < r; ++n) i.push(t[n]);
      } while (i.length);
    }
  };
  var on = {
      depth: -1
    },
    an = {},
    ln = {};
  function un(e) {
    return e.id;
  }
  function cn(e) {
    return e.parentId;
  }
  function sn() {
    var e,
      t = un,
      n = cn;
    function r(r) {
      var o,
        i,
        a,
        l,
        u,
        c,
        s,
        f,
        d = Array.from(r),
        p = t,
        h = n,
        m = new Map();
      if (null != e) {
        const t = d.map((t, n) => function (e) {
            let t = (e = `${e}`).length;
            dn(e, t - 1) && !dn(e, t - 2) && (e = e.slice(0, -1));
            return "/" === e[0] ? e : `/${e}`;
          }(e(t, n, r))),
          n = t.map(fn),
          o = new Set(t).add("");
        for (const e of n) o.has(e) || (o.add(e), t.push(e), n.push(fn(e)), d.push(ln));
        p = (e, n) => t[n], h = (e, t) => n[t];
      }
      for (a = 0, o = d.length; a < o; ++a) i = d[a], c = d[a] = new nn(i), null != (s = p(i, a, r)) && (s += "") && (f = c.id = s, m.set(f, m.has(f) ? an : c)), null != (s = h(i, a, r)) && (s += "") && (c.parent = s);
      for (a = 0; a < o; ++a) if (s = (c = d[a]).parent) {
        if (!(u = m.get(s))) throw new Error("missing: " + s);
        if (u === an) throw new Error("ambiguous: " + s);
        u.children ? u.children.push(c) : u.children = [c], c.parent = u;
      } else {
        if (l) throw new Error("multiple roots");
        l = c;
      }
      if (!l) throw new Error("no root");
      if (null != e) {
        for (; l.data === ln && 1 === l.children.length;) l = l.children[0], --o;
        for (let e = d.length - 1; e >= 0 && (c = d[e], c.data === ln); --e) c.data = null;
      }
      if (l.parent = on, l.eachBefore(function (e) {
        e.depth = e.parent.depth + 1, --o;
      }).eachBefore(tn), l.parent = null, o > 0) throw new Error("cycle");
      return l;
    }
    return r.id = function (e) {
      return arguments.length ? (t = rn(e), r) : t;
    }, r.parentId = function (e) {
      return arguments.length ? (n = rn(e), r) : n;
    }, r.path = function (t) {
      return arguments.length ? (e = rn(t), r) : e;
    }, r;
  }
  function fn(e) {
    let t = e.length;
    if (t < 2) return "";
    for (; --t > 1 && !dn(e, t););
    return e.slice(0, t);
  }
  function dn(e, t) {
    if ("/" === e[t]) {
      let n = 0;
      for (; t > 0 && "\\" === e[--t];) ++n;
      if (0 == (1 & n)) return !0;
    }
    return !1;
  }
  function pn(e, t) {
    "/" === e.charAt(0) && (e = e.substring(1));
    const n = e.split("/");
    let r,
      o = t;
    for (let e = 0; e < n.length; e++) {
      if ("*" === n[e] && Array.isArray(o)) {
        const t = [];
        r = n.slice(e + 1).join("/");
        for (let e = 0; e < o.length; e++) {
          let n = pn(r, o[e]);
          Array.isArray(n) ? t.push(...n) : t.push(n);
        }
        return t;
      }
      if (!n[e] && Array.isArray(o)) {
        const t = new Array(o.length);
        r = n.slice(e + 1).join("/");
        for (let e = 0; e < o.length; e++) t[e] = pn(r, o[e]);
        return t;
      }
      n[e] in o && (o = o[n[e]]);
    }
    return o;
  }
  function hn(e, t, n) {
    let r = [];
    if (!e || !e.length) return r;
    if (t <= 0) {
      const t = n >= 0 ? [e[n]] : e;
      r = [...r, ...t];
    } else for (let o = 0; o < e.length; o++) e[o].children && e[o].children.length && (r = [...r, ...hn(e[o].children, t - 1, n)]);
    return r;
  }
  function mn(e, t, n) {
    if (e === t) return e => e;
    if (e > t) {
      const n = Math.max(0, Math.min(100, e - t));
      return e => {
        let t = e;
        for (let e = 0; e < n; ++e) t = t.parent;
        return t;
      };
    }
    if (t > e) {
      const r = Math.max(0, Math.min(100, t - e));
      return e => hn(e.children, r - 1, n);
    }
    return !1;
  }
  function vn(e, t) {
    let {
      cache: n
    } = t;
    if ("number" == typeof e) return n.fields[e];
    const r = n.allFields;
    if ("function" == typeof e) {
      for (let t = 0; t < r.length; t++) if (e(r[t])) return r[t];
      return !1;
    }
    if ("string" == typeof e) {
      for (let t = 0; t < r.length; t++) if (r[t].key() === e || r[t].title() === e) return r[t];
    } else if (e && -1 !== r.indexOf(e)) return e;
    throw Error("Field not found: ".concat(e));
  }
  const yn = /^qDimensionInfo(?:\/(\d+))?/,
    gn = /^\/?qMeasureInfo\/(\d+)/,
    bn = /\/qAttrExprInfo\/(\d+)/,
    xn = /\/qAttrDimInfo\/(\d+)/;
  function qn(e) {
    return (e.qColumnOrder && e.qColumnOrder.length ? e.qColumnOrder : e.qDimensionInfo.map((e, t) => t)).filter(t => t < e.qDimensionInfo.length);
  }
  function wn(e, t) {
    let {
      cube: n
    } = t;
    if (!e) return -1;
    let r = e.origin && e.origin() ? e.origin().key() : e.key(),
      o = !1,
      i = -1,
      a = -1,
      l = -1,
      u = -1,
      c = -1,
      s = -1,
      f = r;
    const d = n.qEffectiveInterColumnSortOrder,
      p = qn(n);
    return yn.test(f) && (o = !0, i = +yn.exec(f)[1], f = r.replace(yn, "")), gn.test(f) && ("K" === n.qMode ? c = +gn.exec(f)[1] : d && -1 !== d.indexOf(-1) ? (c = +gn.exec(f)[1], s = 0) : s = +gn.exec(f)[1], f = f.replace(gn, "")), f && (xn.exec(f) ? l = +xn.exec(f)[1] : bn.exec(f) && (a = +bn.exec(f)[1])), u = o ? "S" === n.qMode ? p[i] : d ? d.indexOf(i) : i : d && -1 !== d.indexOf(-1) ? d.indexOf(-1) : n.qDimensionInfo.length - ("K" === n.qMode ? 0 : 1), {
      fieldDepth: u + 1,
      pseudoMeasureIndex: c,
      measureIdx: s,
      attrDimIdx: l,
      attrIdx: a
    };
  }
  function Mn(e, t) {
    let n,
      r,
      o = mn(e.fieldDepth, t.fieldDepth, t.pseudoMeasureIndex);
    return n = t.measureIdx >= 0 ? e => e.data.qValues[t.measureIdx] : e => e.data, t.attrDimIdx >= 0 ? r = e => {
      var n;
      return null == e || null === (n = e.qAttrDims) || void 0 === n ? void 0 : n.qValues[t.attrDimIdx];
    } : t.attrIdx >= 0 && (r = e => {
      var n;
      return null == e || null === (n = e.qAttrExps) || void 0 === n ? void 0 : n.qValues[t.attrIdx];
    }), {
      nodeFn: o,
      attrFn: r,
      valueFn: n
    };
  }
  function kn(e, t, n) {
    let {
      key: r
    } = n;
    const o = {
      value: "function" == typeof e.value ? e.value(t) : void 0 !== e.value ? e.value : t
    };
    return o.label = "function" == typeof e.label ? e.label(t) : void 0 !== e.label ? String(e.label) : String(o.value), e.field && (o.source = {
      key: r,
      field: e.field.key()
    }), o;
  }
  function Sn(e) {
    let {
      propsArr: t,
      props: n,
      item: r,
      itemData: o,
      ret: i,
      sourceKey: a
    } = e;
    for (let e = 0; e < t.length; e++) {
      const l = n[t[e]],
        u = l.fields || [l];
      let c, s;
      l.fields && (c = [], s = []);
      for (let n = 0; n < u.length; n++) {
        const f = u[n];
        let d, p, h, m, v, y;
        if ("primitive" === f.type ? (h = f.value, y = String(f.value)) : ("function" == typeof f.value && (d = e => f.value(e, r)), "function" == typeof f.label && (p = e => f.label(e, r)), f.accessor ? (m = f.accessor(r), Array.isArray(m) ? (v = m.map(f.valueAccessor), f.attrAccessor && (v = v.map(f.attrAccessor)), d && (h = v.map(d), d = null), p && (y = v.map(p), p = null), h = f.reduce ? f.reduce(h) : h, y = f.reduceLabel ? f.reduceLabel(y, h) : String(h)) : (h = f.attrAccessor ? f.attrAccessor(f.valueAccessor(m)) : f.valueAccessor(m), y = h)) : (h = o, y = o)), l.fields) {
          const e = d ? d(h) : h;
          c.push(e), s.push(p && null != y ? p(y) : null != y ? y : String(e));
        } else {
          const n = d ? d(h) : h;
          i[t[e]] = {
            value: n,
            label: p ? p(y) : null != y ? y : String(n)
          }, f.field && (i[t[e]].source = {
            field: f.field.key(),
            key: a
          });
        }
      }
      c && (i[t[e]] = {
        value: "function" == typeof l.value ? l.value(c, r) : c,
        label: "function" == typeof l.label ? l.label(s, r) : s
      });
    }
  }
  const Cn = (e, t, n) => {
    const r = "K" === e.qMode ? "/qStackedDataPages/*/qData" : "/qTreeDataPages/*",
      o = "K" === e.qMode ? "qSubNodes" : "qNodes",
      i = pn(r, e);
    return i && i[0] ? (t.tree = Zt(i[0], n.children || (e => e[o])), t.tree) : null;
  };
  function Dn(e) {
    const t = e.raw().qDataPages.length ? e.raw().qDataPages[0].qMatrix : [],
      n = function (e) {
        const t = e.raw().qColumnOrder,
          n = e.fields();
        return t && t.length === n.length ? t : n.map((e, t) => t);
      }(e),
      r = e.fields(),
      o = e.fields().filter(e => "dimension" === e.type()).map(e => n.indexOf(r.indexOf(e))),
      i = e.fields().filter(e => "measure" === e.type()).map(e => n.indexOf(r.indexOf(e))),
      a = {
        __root: {
          __id: "__root",
          qValues: []
        }
      };
    for (let e = 0; e < t.length; e++) {
      const n = t[e];
      let r = "__root",
        u = !1;
      for (let e = 0; e < o.length; e++) {
        var l;
        const t = n[o[e]],
          i = "".concat(r, "__").concat(null !== (l = t.qElemNumber) && void 0 !== l ? l : t.qElemNo);
        a[i] || (a[i] = Pt({
          __id: i,
          __parent: r,
          qValues: []
        }, t), u = !0), r = i;
      }
      if (u) for (let e = 0; e < i.length; e++) {
        const t = n[i[e]];
        a[r].qValues.push(t);
      }
    }
    const u = Object.keys(a).map(e => a[e]);
    return sn().id(e => e.__id).parentId(e => e.__parent)(u);
  }
  const In = e => {
    let {
      propsArr: t,
      props: n,
      cube: r,
      cache: o,
      itemDepthObject: i,
      f: a
    } = e;
    for (let e = 0; e < t.length; e++) {
      const l = n[t[e]],
        u = l.fields ? l.fields : [l];
      for (let e = 0; e < u.length; e++) {
        const t = u[e];
        if (t.field !== a) {
          const e = Mn(i, wn(t.field, {
            cube: r,
            cache: o
          }));
          t.accessor = e.nodeFn, t.valueAccessor = e.valueFn, t.attrAccessor = e.attrFn;
        }
      }
    }
  };
  function On() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
      t = arguments.length > 1 ? arguments[1] : void 0,
      n = arguments.length > 2 ? arguments[2] : void 0,
      r = arguments.length > 3 ? arguments[3] : void 0;
    const o = t.raw(),
      i = t.key(),
      a = "S" === o.qMode ? Dn(t) : Cn(o, n, e);
    if (!a) return null;
    const l = a.height,
      u = [];
    for (let i = 0; i <= l; i++) {
      let a = null;
      if (i > 0) if ("S" === o.qMode) {
        let e = qn(o)[i - 1];
        a = n.fields[e];
      } else {
        let e = o.qEffectiveInterColumnSortOrder[i - 1];
        i > o.qEffectiveInterColumnSortOrder.length && (e = o.qDimensionInfo.length), a = n.fields[e];
      }
      const {
          props: l,
          main: c
        } = r.normalizeConfig(Pt(Pt({}, e), {}, {
          field: a ? a.key() : void 0
        }), t),
        s = Object.keys(l);
      u[i] = {
        propsArr: s,
        props: l,
        main: c
      };
      const f = a ? wn(a, {
        cube: o,
        cache: n
      }) : {
        fieldDepth: 0
      };
      In({
        propsArr: s,
        props: l,
        cube: o,
        cache: n,
        itemDepthObject: f,
        f: a
      });
    }
    const c = a.copy(),
      s = c.descendants(),
      f = a.descendants();
    for (let e = 0; e < f.length; e++) {
      const t = u[f[e].depth].propsArr,
        n = u[f[e].depth].props,
        r = u[f[e].depth].main,
        o = s[e],
        a = o.data,
        l = kn(r, a, {
          key: i
        });
      Sn({
        propsArr: t,
        props: n,
        item: o,
        itemData: a,
        ret: l,
        sourceKey: i,
        isTree: !0
      }), f[e].data = l;
    }
    return a;
  }
  function En(e, t, n, r) {
    const o = Array.isArray(e) ? e : [e];
    let i = [];
    for (let a = 0; a < o.length; a++) if (void 0 !== o[a].field) {
      const l = t.raw(),
        u = t.key();
      if (!Cn(l, n, e)) continue;
      const c = "object" == typeof o[a].field ? o[a].field : t.field(o[a].field),
        {
          props: s,
          main: f
        } = r.normalizeConfig(o[a], t),
        d = Object.keys(s),
        p = wn(c, {
          cube: l,
          cache: n
        }),
        {
          nodeFn: h,
          attrFn: m,
          valueFn: v
        } = Mn({
          fieldDepth: 0
        }, p);
      In({
        propsArr: d,
        props: s,
        cube: l,
        cache: n,
        itemDepthObject: p,
        f: c
      });
      const y = !!o[a].trackBy,
        g = typeof o[a].trackBy,
        b = {},
        x = [],
        q = h(n.tree),
        w = [];
      for (let e = 0; e < q.length; e++) {
        const t = q[e],
          n = m ? m(v(t)) : v(t);
        if (f.filter && !f.filter(n)) continue;
        const i = kn(f, n, {
          key: u
        });
        Sn({
          propsArr: d,
          props: s,
          item: t,
          itemData: n,
          ret: i,
          sourceKey: u
        }), y && r.track({
          cfg: o[a],
          itemData: n,
          obj: i,
          target: x,
          tracker: b,
          trackType: g
        }), w.push(i);
      }
      const M = y ? r.collect(x, {
        main: f,
        propsArr: d,
        props: s
      }) : w;
      i = [...i, ...M];
    }
    return i;
  }
  var An,
    Nn,
    Ln = (An = function (e) {
      /*! javascript-number-formatter - v1.1.11 - http://mottie.github.com/javascript-number-formatter/ * © ecava */
      e.exports = function (e, t) {
        if (!e || isNaN(+t)) return t;
        var n,
          r,
          o,
          i,
          a,
          l,
          u,
          c,
          s,
          f,
          d = e.length,
          p = e.search(/[0-9\-\+#]/),
          h = p > 0 ? e.substring(0, p) : "",
          m = e.split("").reverse().join(""),
          v = m.search(/[0-9\-\+#]/),
          y = d - v,
          g = e.substring(y, y + 1),
          b = y + ("." === g || "," === g ? 1 : 0),
          x = v > 0 ? e.substring(b, d) : "";
        if (n = (t = "-" === (e = e.substring(p, b)).charAt(0) ? -t : +t) < 0 ? t = -t : 0, o = (r = e.match(/[^\d\-\+#]/g)) && r[r.length - 1] || ".", i = r && r[1] && r[0] || ",", e = e.split(o), t = +(t = t.toFixed(e[1] && e[1].length)) + "", l = e[1] && e[1].lastIndexOf("0"), (!(c = t.split("."))[1] || c[1] && c[1].length <= l) && (t = (+t).toFixed(l + 1)), s = e[0].split(i), e[0] = s.join(""), (a = e[0] && e[0].indexOf("0")) > -1) for (; c[0].length < e[0].length - a;) c[0] = "0" + c[0];else 0 == +c[0] && (c[0] = "");
        if ((t = t.split("."))[0] = c[0], u = s[1] && s[s.length - 1].length) {
          for (m = "", y = (f = t[0]).length % u, d = f.length, b = 0; b < d; b++) m += f.charAt(b), !((b - y + 1) % u) && b < d - u && (m += i);
          t[0] = m;
        }
        return t[1] = e[1] && t[1] ? o + t[1] : "", "0" !== (r = t.join("")) && "" !== r || (n = !1), h + (n ? "-" : "") + r + x;
      };
    }, An(Nn = {
      exports: {}
    }, Nn.exports), Nn.exports);
  function Tn(e) {
    return e.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
  }
  const Pn = {
      3: "k",
      6: "M",
      9: "G",
      12: "T",
      15: "P",
      18: "E",
      21: "Z",
      24: "Y",
      "-3": "m",
      "-6": "μ",
      "-9": "n",
      "-12": "p",
      "-15": "f",
      "-18": "a",
      "-21": "z",
      "-24": "y"
    },
    jn = /%\)?$/,
    Fn = /^\(r(0[2-9]|[12]\d|3[0-6])\)/i,
    Hn = /^\(oct\)/i,
    Rn = /^\(dec\)/i,
    zn = /^\(hex\)/i,
    Vn = /^\(bin\)/i,
    _n = /^\(rom\)/i,
    Bn = /^(\(rom\)|\(bin\)|\(hex\)|\(dec\)|\(oct\)|\(r(0[2-9]|[12]\d|3[0-6])\))/i,
    Yn = /#|0/g;
  function $n(e, t, n, r) {
    return e = e.toString(t), n[1] === n[1].toUpperCase() && (e = e.toUpperCase()), e.length - e.indexOf(".") > 10 && (e = e.slice(0, e.indexOf(".") + 11)), e.replace(".", r || ".");
  }
  function Un(e, t, n) {
    let r;
    return Fn.test(t) ? e = $n(e, Number(/\d{2}/.exec(t)[0]), t, n) : Hn.test(t) ? e = $n(e, 8, t, n) : Rn.test(t) ? e = $n(e, 10, t, n) : zn.test(t) ? e = $n(e, 16, t, n) : Vn.test(t) ? e = $n(e, 2, t, n) : _n.test(t) && (r = "", e < 0 && (r = "-", e = -e), 0 === (e = Math.floor(e)) ? e = "0" : e <= 5e5 ? (e = function (e, t) {
      let n,
        r = "",
        o = Number(String(e).slice(-3)),
        i = (e - o) / 1e3,
        a = [0, 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900].reverse(),
        l = ["0", "I", "IV", "V", "IX", "X", "XL", "L", "XC", "C", "CD", "D", "CM"].reverse();
      for (; o > 0;) for (n = 0; n < a.length; n++) if (a[n] <= o) {
        r += l[n], o -= a[n];
        break;
      }
      for (n = 0; n < i; n++) r = "M".concat(r);
      return t[1] !== t[1].toUpperCase() && (r = r.toLowerCase()), r;
    }(e, t), e = r + e) : e = t + r + e.toExponential(0)), e;
  }
  function Kn(e, t, n) {
    const r = Tn(e);
    return n ? r : new RegExp(r || "", t);
  }
  function Gn(e, t, n, r) {
    let o,
      i,
      a,
      l,
      u,
      c,
      s,
      f,
      d,
      p = e.pattern;
    var h, m;
    r && (e.abbreviate = !0), h = t, (m = n) && (m = Tn(m)), h && (h = Tn(h)), d = new RegExp("(?:[#0]+".concat(h, ")?[#0]+(?:").concat(m, "[#0]+)?")), a = p.match(d), a = a ? a[0] : "", l = a ? p.substr(0, p.indexOf(a)) : p, u = a ? p.substring(p.indexOf(a) + a.length) : "", a || (a = p ? "#" : "##########"), t && t === n && (o = a.split(n), i = o.pop(), a = o.join("") + n + i, t = ""), c = t, t = /,/.test(n) ? "¤" : ",", c && (a = a.replace(Kn(c, "g"), t)), s = n, n = ".", s && (a = a.replace(Kn(s, "g"), n)), f = a.match(/#/g), f = f ? f.length : 0;
    const v = p.split(s);
    let y;
    v[1] && (y = v[1].match(Yn)), e.prefix = l || "", e.postfix = u || "", e.pattern = p, e.maxPrecision = y ? y.length : 2, e.percentage = jn.test(p), e.numericPattern = a || "", e.numericRegex = new RegExp("".concat(Kn(t, null, !0), "|").concat(Kn(n, null, !0)), "g"), e.groupTemp = c, e.decTemp = s, e.t = t, e.d = n, e.temp = f;
  }
  class Wn {
    constructor(e, t, n, r, o) {
      this.localeInfo = e, this.pattern = t, this.thousandDelimiter = n || ",", this.decimalDelimiter = r || ".", this.type = o || "numeric", this.patternSeparator = ";", this.abbreviations = function (e, t) {
        if (!e || !e.qNumericalAbbreviation) return Pn;
        const n = {};
        return e.qNumericalAbbreviation.split(t).forEach(e => {
          let t = e.split(":");
          2 === t.length && (n[t[0]] = t[1]);
        }), n;
      }(e, this.patternSeparator), this.prepare();
    }
    clone() {
      const e = new Wn(this.localeInfo, this.pattern, this.thousandDelimiter, this.decimalDelimiter, this.type);
      return e.subtype = this.subtype, e;
    }
    format(e, t, n, r) {
      return this.prepare(t, n, r), this.formatValue(e);
    }
    prepare(e, t, n) {
      let r;
      if (void 0 === e && (e = this.pattern), void 0 === t && (t = this.thousandDelimiter), void 0 === n && (n = this.decimalDelimiter), !e) return void (this._prepared = {
        pattern: !1
      });
      this._prepared = {
        positive: {
          d: n,
          t: t,
          abbreviate: !1,
          isFunctional: !1,
          prefix: "",
          postfix: ""
        },
        negative: {
          d: n,
          t: t,
          abbreviate: !1,
          isFunctional: !1,
          prefix: "",
          postfix: ""
        },
        zero: {
          d: n,
          t: t,
          abbreviate: !1,
          isFunctional: !1,
          prefix: "",
          postfix: ""
        }
      }, r = this._prepared, e = e.split(this.patternSeparator), r.positive.pattern = e[0], r.negative.pattern = e[1], r.zero.pattern = e[2], Bn.test(e[0]) && (r.positive.isFunctional = !0), e[1] ? Bn.test(e[1]) && (r.negative.isFunctional = !0) : r.negative = !1, e[2] ? Bn.test(e[2]) && (r.zero.isFunctional = !0) : r.zero = !1;
      const o = "U" === this.type;
      r.positive.isFunctional || Gn(r.positive, t, n, o), r.negative && !r.negative.isFunctional && Gn(r.negative, t, n, o), r.zero && !r.zero.isFunctional && Gn(r.zero, t, n, o);
    }
    formatValue(e) {
      let t,
        n,
        r,
        o,
        i,
        a,
        l,
        u,
        c,
        s = this._prepared,
        f = "",
        d = "",
        p = e;
      if (isNaN(e)) return "".concat(p);
      if (e = +e, !1 === s.pattern) return e.toString();
      if (0 === e && s.zero) return s = s.zero, s.pattern;
      if (e < 0 && s.negative ? (s = s.negative, e = -e) : s = s.positive, i = s.d, a = s.t, s.isFunctional) e = Un(e, s.pattern, i);else {
        if (s.percentage && (e *= 100), s.abbreviate) {
          const t = Object.keys(this.abbreviations).map(e => parseInt(e, 10)).sort((e, t) => e - t);
          let r,
            o,
            i = t[0];
          for (l = 0, n = Number(Number(e).toExponential().split("e")[1]); i <= n && l < t.length;) l++, i = t[l];
          l > 0 && (r = t[l - 1]), r && n > 0 && r > 0 ? o = r : (n < 0 && r < 0 || !r) && (i < 0 && i - n <= s.maxPrecision ? o = i : r <= n && !(i > 0 && -n <= s.maxPrecision) && (o = r)), o && (f = this.abbreviations[o], e /= 10 ** o);
        }
        if (r = Math.abs(e), t = s.temp, u = s.numericPattern, c = u.split(i)[1], "I" === this.type && (e = Math.round(e)), o = e, c || "#" !== u.slice(-1)[0]) {
          if (r >= 1e15 || r > 0 && r <= 1e-14) e = r ? r.toExponential(15).replace(/\.?0+(?=e)/, "") : "0";else {
            const t = Number(e.toFixed(Math.min(20, c ? c.length : 0)).split(".")[0]);
            let n = u.split(i)[0];
            if (n += i, e = Ln(n, t) || "0", c) {
              const t = Math.max(0, Math.min(14, c.length)),
                n = c.replace(/#+$/, "").length;
              let o = ("I" === this.type ? 0 : r % 1 + 1e-15).toFixed(t).slice(2).replace(/0+$/, "");
              for (l = o.length; l < n; l++) o += "0";
              o && (e += i + o);
            } else 0 === t && (o = 0);
          }
        } else if (r >= 10 ** t || r < 1 || r < 1e-4) 0 === e ? e = "0" : r < 1e-4 || r >= 1e20 ? (e = (e = o.toExponential(Math.max(1, Math.min(14, t)) - 1)).replace(/\.?0+(?=e)/, ""), d = "") : (e = e.toPrecision(Math.max(1, Math.min(14, t)))).indexOf(".") >= 0 && (e = (e = e.replace(e.indexOf("e") < 0 ? /0+$/ : /\.?0+(?=e)/, "")).replace(".", i));else {
          for (u += i, t = Math.max(0, Math.min(20, t - Math.ceil(Math.log(r) / Math.log(10)))), l = 0; l < t; l++) u += "#";
          e = Ln(u, e);
        }
        e = e.replace(s.numericRegex, e => e === a ? s.groupTemp : e === i ? s.decTemp : ""), o < 0 && !/^-/.test(e) && (e = "-".concat(e));
      }
      return s.prefix + e + d + f + s.postfix;
    }
    static getStaticFormatter() {
      return {
        prepare() {},
        formatValue: e => "".concat(e)
      };
    }
  }
  function Xn(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const {
      size: n = 5e3,
      multipleArguments: r = !1,
      toKey: o = e => e
    } = t;
    let i,
      a,
      l = Object.create(null),
      u = Object.create(null),
      c = 0,
      s = 0;
    return i = r ? function () {
      return a = o(...arguments), i.has(a) ? i.get(a) : i.set(a, e(...arguments));
    } : t => (a = o(t), i.has(a) ? i.get(a) : i.set(a, e(t))), i.set = (e, t) => (c >= n && (delete l[u[s]], delete u[s], c--, s++), l[e] = t, u[c] = e, c++, t), i.get = e => l[e], i.has = e => e in l, i.clear = () => {
      l = Object.create(null), u = Object.create(null), c = 0, s = 0;
    }, i.size = () => c, i;
  }
  function Zn(e, t, n, r, o) {
    const i = function () {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
        return new Wn(...t);
      }(o, e, t, n, r),
      a = Xn(i.formatValue.bind(i), {
        toKey: e => isNaN(e) ? e : +e
      });
    function l(e) {
      return a(e);
    }
    return l.format = function (e, t, n, r) {
      return a.clear(), i.format(t, e, n, r);
    }, l.pattern = function (e) {
      return e && (a.clear(), i.pattern = e, i.prepare()), i.pattern;
    }, l;
  }
  const Jn = "D",
    Qn = "T",
    er = "TS",
    tr = "IV",
    nr = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
    rr = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
    or = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    ir = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function ar(e, t) {
    for (let n = e.length; n < t; n++) e = "0".concat(e);
    return e;
  }
  function lr(e) {
    let t = e.toString().split(".");
    return t[1] ? (t = Number("0.".concat(t[1])), t) : 0;
  }
  function ur(e, t) {
    let n,
      r = function (e) {
        const t = e,
          n = 24 * lr(t),
          r = 60 * lr(n),
          o = 60 * lr(r),
          i = 1e3 * lr(o);
        return {
          d: Math.floor(t),
          h: Math.floor(n),
          m: Math.floor(r),
          s: Math.floor(o),
          f: Math.round(i)
        };
      }(e),
      o = r.d,
      i = r.h,
      a = r.m,
      l = r.s,
      u = r.f,
      c = 0;
    /w+|t+/gi.test(t) && (n = new Date(Date.UTC(1899, 11, 30 + Math.floor(e), 0, 0, Math.round(86400 * (e - Math.floor(e))))), isNaN(n.getTime()) && (n = null)), /D+/gi.test(t) || (i += 24 * o), /h+/gi.test(t) || (a += 60 * i), /m+/gi.test(t) || (l += 60 * a), /w+/gi.test(t) && (c = n ? n.getDay() - 1 : 0, c < 0 && (c = 6));
    let s = "";
    return n && (s = n.getUTCHours() >= 12 ? "pm" : "am"), {
      year: 0,
      month: 0,
      day: c,
      date: o,
      h: i,
      m: a,
      s: l,
      f: u,
      t: s
    };
  }
  class cr {
    constructor(e, t, n) {
      const r = e || {};
      if (r.qCalendarStrings || (r.qCalendarStrings = {
        qLongDayNames: nr,
        qDayNames: rr,
        qLongMonthNames: or,
        qMonthNames: ir
      }), this.localeInfo = r, this.locale_days = r.qCalendarStrings.qLongDayNames.slice(), this.locale_days_abbr = r.qCalendarStrings.qDayNames.slice(), this.locale_months = r.qCalendarStrings.qLongMonthNames.slice(), this.locale_months_abbr = r.qCalendarStrings.qMonthNames.slice(), !t) {
        t = {
          [Qn]: r.qTimeFmt || "hh:mm:ss",
          [Jn]: r.qDateFmt || "YYYY-MM-DD",
          [er]: r.qTimestampFmt || "YYYY-MM-DD hh:mm:ss"
        }[n];
      }
      this.pattern = t;
    }
    clone() {
      const e = new cr(this.localeInfo, this.pattern);
      return e.subtype = this.subtype, e;
    }
    format(e, t) {
      t || (t = this.pattern ? this.pattern : "YYYY-MM-DD hh:mm:ss"), t = t.replace(/\[.+]|\[|]/g, "");
      const n = /t+/gi.test(t);
      let r;
      e instanceof Date ? r = function (e, t) {
        let n = e.getUTCHours(),
          r = e.getUTCDay() - 1;
        return t && (n %= 12, n || (n = 12)), r < 0 && (r = 6), {
          year: e.getUTCFullYear(),
          month: e.getUTCMonth(),
          day: r,
          date: e.getUTCDate(),
          h: n,
          m: e.getUTCMinutes(),
          s: e.getUTCSeconds(),
          f: e.getUTCMilliseconds(),
          t: e.getUTCHours() >= 12 ? "pm" : "am"
        };
      }(e, n) : (e < 0 && (e = -e, t = "-".concat(t)), r = ur(e, t));
      const o = (i = this, a = r, {
        "Y+|y+": {
          Y: "".concat(Number("".concat(a.year).slice(-2))),
          YY: ar("".concat(a.year).slice(-2), 2),
          YYY: ar("".concat(a.year).slice(-3), 3),
          def: e => ar("".concat(a.year), e.length)
        },
        "M+": {
          M: a.month + 1,
          MM: ar("".concat(a.month + 1), 2),
          MMM: i.locale_months_abbr[a.month],
          def: i.locale_months[a.month]
        },
        "W+|w+": {
          W: a.day,
          WW: ar("".concat(a.day), 2),
          WWW: i.locale_days_abbr[a.day],
          def: i.locale_days[a.day]
        },
        "D+|d+": {
          D: a.date,
          def: e => ar("".concat(a.date), e.length)
        },
        "h+|H+": {
          h: a.h,
          def: e => ar("".concat(a.h), e.length)
        },
        "m+": {
          m: a.m,
          def: e => ar("".concat(a.m), e.length)
        },
        "s+|S+": {
          s: a.s,
          def: e => ar("".concat(a.s), e.length)
        },
        "f+|F+": {
          def(e) {
            let t = "".concat(a.f),
              n = e.length - t.length;
            if (n > 0) for (let e = 0; e < n; e++) t += "0";else n < 0 && (t = t.slice(0, e.length));
            return t;
          }
        },
        "t{1,2}|T{1,2}": {
          def(e) {
            let t = a.t;
            return e[0].toUpperCase() === e[0] && (t = t.toUpperCase()), t = t.slice(0, e.length), t;
          }
        }
      });
      var i, a;
      const l = [];
      for (const e in o) Object.prototype.hasOwnProperty.call(o, e) && l.push(e);
      const u = new RegExp(l.join("|"), "g");
      return t.replace(u, e => {
        let t, n, r;
        for (n in o) if (Object.prototype.hasOwnProperty.call(o, n) && (t = new RegExp(n), t.test(e))) break;
        if (!t) return "";
        for (const t in o[n]) if (t === e || t.toLowerCase() === e) {
          r = o[n][t], void 0 === r && (r = o[n][t.toLowerCase()]);
          break;
        }
        return void 0 === r && (r = o[n].def), "function" == typeof r && (r = r(e)), r;
      });
    }
  }
  function sr() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    return new cr(...t);
  }
  function fr(e) {
    return new Date(Date.UTC(1899, 11, 30 + Math.floor(e), 0, 0, 0, Math.round(864e5 * (e - Math.floor(e)))));
  }
  function dr(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "TS",
      n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
      r = sr(n, e, t),
      o = Xn(r.format.bind(r), {
        toKey: e => "object" == typeof e && "function" == typeof e.getTime ? e.getTime() : e
      });
    function i(e) {
      return t !== tr ? fr(e) : e;
    }
    function a(e) {
      return e = i(e), o(e);
    }
    return a.format = function (e, t) {
      return o.clear(), t = i(t), r.format(t, e);
    }, a.locale = function (n) {
      return r = sr(n, e, t), o = Xn(r.format.bind(r), {
        toKey: e => "object" == typeof e ? e.getTime() : e
      }), this;
    }, a.qtype = function (e) {
      return void 0 !== e && (t = e, o.clear()), t;
    }, a;
  }
  function pr(e, t) {
    if (e && e.qNumFormat && -1 !== ["D", "T", "TS", "IV"].indexOf(e.qNumFormat.qType)) return dr(e.qNumFormat.qFmt, e.qNumFormat.qType, t);
    let n = "#",
      r = t && void 0 !== t.qThousandSep ? t.qThousandSep : ",",
      o = t && void 0 !== t.qDecimalSep ? t.qDecimalSep : ".",
      i = "U",
      a = e && !!e.qIsAutoFormat;
    return e && e.qNumFormat ? (n = e.qNumFormat.qFmt || n, r = e.qNumFormat.qThou || r, o = e.qNumFormat.qDec || o, i = e.qNumFormat.qType || i, a = a && -1 === ["M"].indexOf(e.qNumFormat.qType)) : a = !0, (a || "U" === i) && (n = "#".concat(o, "##"), i = "U"), Zn(n, r, o, i, t);
  }
  function hr() {
    let e,
      {
        meta: t,
        id: n,
        key: r,
        localeInfo: o,
        fieldExtractor: i,
        value: a,
        type: l,
        sourceField: u
      } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const c = a || ("dimension" === l ? e => null == e ? void 0 : e.qElemNo : e => null == e ? void 0 : e.qValue),
      s = e => (null == e ? void 0 : e.qText) || "",
      f = "dimension" === l ? "first" : "avg",
      d = pr(t, o),
      p = "dimension" === l ? "first" : (e, t) => d(t),
      h = {
        id: () => n,
        key: () => r,
        raw: () => t,
        title: () => t.qFallbackTitle || t.label,
        type: () => l,
        origin: () => u,
        items: () => (e || (e = i(h)), e),
        min: () => t.qMin,
        max: () => t.qMax,
        value: c,
        label: s,
        reduce: f,
        reduceLabel: p,
        formatter: () => d,
        tags: () => t.qTags
      };
    return h;
  }
  function mr(e, t, n, r, o) {
    return (t[e] || []).map((t, i) => {
      const a = "".concat(r ? "".concat(r, "/") : "").concat(e, "/").concat(i),
        l = {
          instance: hr($t({
            id: "".concat(n ? "".concat(n, "/") : "").concat(a),
            key: a,
            meta: t
          }, o))
        };
      return l.attrDims = mr("qAttrDimInfo", t, n, a, $t({}, o, {
        value: e => null == e ? void 0 : e.qElemNo,
        type: "dimension"
      })), l.attrExps = mr("qAttrExprInfo", t, n, a, $t({}, o, {
        value: e => null == e ? void 0 : e.qNum,
        type: "measure"
      })), l.measures = mr("qMeasureInfo", t, n, a, $t({}, o, {
        value: e => null == e ? void 0 : e.qValue,
        type: "measure"
      })), l;
    });
  }
  function vr() {
    let {
      key: e,
      data: t,
      config: n = {}
    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const r = {
        fields: [],
        wrappedFields: [],
        allFields: [],
        virtualFields: []
      },
      o = t;
    if (!o) throw new Error('Missing "data" input');
    if (!o.qDimensionInfo) throw new Error('The "data" input is not recognized as a hypercube');
    const i = vr.util,
      a = {
        cache: r,
        cube: o,
        localeInfo: n.localeInfo,
        fieldExtractor: null,
        pages: null,
        hierarchy: () => null,
        virtualFields: n.virtualFields
      },
      l = {
        key: () => e,
        raw: () => o,
        field: e => vn(e, a),
        fields: () => r.fields.slice(),
        extract: e => a.extractor(e, l, r, i),
        hierarchy: e => a.hierarchy(e, l, r, i),
        _cache: () => r
      };
    "K" === o.qMode || "T" === o.qMode || !o.qMode && o.qNodesOnDim ? (a.extractor = En, a.hierarchy = On, a.pages = "K" === o.qMode ? o.qStackedDataPages : o.qTreeDataPages) : "S" === o.qMode ? (a.extractor = Wt, a.pages = o.qDataPages, a.hierarchy = On) : a.extractor = () => [], a.fieldExtractor = e => a.extractor({
      field: e
    }, l, r, i);
    const u = "S" === o.qMode ? e => e.qElemNumber : void 0,
      c = "S" === o.qMode ? e => e.qNum : void 0;
    r.wrappedFields.push(...mr("qDimensionInfo", o, e, "", $t({}, a, {
      value: u,
      type: "dimension"
    }))), r.wrappedFields.push(...mr("qMeasureInfo", o, e, "", $t({}, a, {
      value: c,
      type: "measure"
    }))), r.fields = r.wrappedFields.map(e => e.instance);
    const s = e => {
      e.forEach(e => {
        r.allFields.push(e.instance), s(e.measures), s(e.attrDims), s(e.attrExps);
      });
    };
    return s(r.wrappedFields), (n.virtualFields || []).forEach(t => {
      const n = l.field(t.from),
        o = hr(Pt({
          meta: n.raw(),
          id: "".concat(e, "/").concat(t.key),
          sourceField: n,
          fieldExtractor: e => a.extractor({
            field: e
          }, l, r, i),
          key: t.key,
          type: n.type(),
          localeInfo: a.localeInfo,
          value: n.value
        }, t.override || {}));
      r.virtualFields.push(o);
    }), r.allFields.push(...r.virtualFields), l;
  }
  const yr = [["qHyperCube", "qHyperCubeDef"], ["qTreeData", "qTreeDataDef"], ["qDimensionInfo", "qDimensions"], ["qMeasureInfo", "qMeasures"], ["qAttrDimInfo", "qAttributeDimensions"], ["qAttrExprInfo", "qAttributeExpressions"]],
    gr = /\/qDimensionInfo(?:\/(\d+))?/,
    br = /\/qMeasureInfo\/(\d+)/,
    xr = /\/qAttrDimInfo\/(\d+)(?:\/(\d+))?/,
    qr = /\/qAttrExprInfo\/(\d+)/,
    wr = /\/?qHyperCube/,
    Mr = /\/?qTreeData/,
    kr = e => "".concat(e.substr(0, e.indexOf("/qHyperCubeDef") + 14)),
    Sr = e => "".concat(e.substr(0, e.indexOf("/qTreeDataDef") + 13));
  function Cr(e, t) {
    let n = e,
      r = -1,
      o = -1,
      i = "",
      a = e => e;
    wr.test(e) ? (i = "".concat(n.substr(0, n.indexOf("qHyperCube") + 10)), a = kr) : Mr.test(e) && (i = "".concat(n.substr(0, n.indexOf("qTreeData") + 9)), a = Sr);
    let l = !0;
    if (gr.test(e) && (r = +gr.exec(e)[1]), br.test(e) && (o = +br.exec(e)[1]), xr.test(e)) {
      o = -1, r = 0;
      const e = +xr.exec(n)[2];
      isNaN(e) || (r = e, n = n.replace(/\/\d+$/, "")), l = !1;
    }
    if (qr.test(e)) {
      const e = o;
      if (t) {
        o = 0;
        const a = pn(i, t);
        o += (a.qMeasureInfo || []).length, r > -1 ? (o = a.qDimensionInfo.slice(0, r).reduce((e, t) => e + t.qAttrExprInfo.length, o), r = -1) : (o = a.qDimensionInfo.reduce((e, t) => e + t.qAttrExprInfo.length, o), o = a.qMeasureInfo.slice(0, e).reduce((e, t) => e + t.qAttrExprInfo.length, o)), o += +qr.exec(n)[1];
      } else r > -1 ? (r = -1, o = +qr.exec(n)[1]) : o += +qr.exec(n)[1] + 1;
    }
    return yr.forEach(e => {
      let [t, r] = e;
      n = n.replace(t, r);
    }), l && (n = a(n)), n && "/" !== n[0] && (n = "/".concat(n)), {
      measureIdx: o,
      dimensionIdx: r,
      path: n
    };
  }
  function Dr(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      n = arguments.length > 2 ? arguments[2] : void 0;
    const r = t.byCells,
      o = t.primarySource,
      i = [],
      a = {},
      l = e.isActive();
    let u = !1;
    if (e.brushes().forEach(e => {
      const t = Cr(e.id, n);
      if ("range" === e.type && t.measureIdx > -1 && t.dimensionIdx > -1) {
        const n = e.brush.ranges();
        n.length && (u = !0, a.multiRangeSelectTreeDataValues || (a.multiRangeSelectTreeDataValues = {
          path: t.path,
          ranges: []
        }), n.forEach(e => a.multiRangeSelectTreeDataValues.ranges.push({
          qMeasureIx: t.measureIdx,
          qDimensionIx: t.dimensionIdx,
          qRange: {
            qMin: e.min,
            qMax: e.max,
            qMinInclEq: !0,
            qMaxInclEq: !0
          }
        })));
      } else {
        if ("range" === e.type && t.measureIdx > -1) {
          const n = e.brush.ranges();
          n.length && (u = !0, a.rangeSelectHyperCubeValues || (a.rangeSelectHyperCubeValues = {
            path: t.path,
            ranges: []
          }), n.forEach(e => a.rangeSelectHyperCubeValues.ranges.push({
            qMeasureIx: t.measureIdx,
            qRange: {
              qMin: e.min,
              qMax: e.max,
              qMinInclEq: !0,
              qMaxInclEq: !0
            }
          })));
        }
        if ("range" === e.type && t.dimensionIdx > -1) {
          const n = e.brush.ranges();
          n.length && (u = !0, a.selectHyperCubeContinuousRange || (a.selectHyperCubeContinuousRange = {
            path: t.path,
            ranges: []
          }), n.forEach(e => a.selectHyperCubeContinuousRange.ranges.push({
            qDimIx: t.dimensionIdx,
            qRange: {
              qMin: e.min,
              qMax: e.max,
              qMinInclEq: !0,
              qMaxInclEq: !1
            }
          })));
        }
        if ("value" === e.type && t.dimensionIdx > -1) if (r) {
          if (n && n.qHyperCube && ("P" === n.qHyperCube.qMode || "T" === n.qHyperCube.qMode || "K" === n.qHyperCube.qMode)) {
            const r = n.qHyperCube,
              i = r.qNoOfLeftDims,
              l = r.qEffectiveInterColumnSortOrder.indexOf(t.dimensionIdx);
            if (a.selectPivotCells || (a.selectPivotCells = {
              path: t.path,
              cells: []
            }), e.id === o || !o) {
              const n = e.brush.values().map(e => +e).filter(e => !isNaN(e));
              (0 === i || l >= i) && i > -1 ? n.forEach(e => {
                a.selectPivotCells.cells.push({
                  qType: "T",
                  qCol: e,
                  qRow: l - i
                });
              }) : n.forEach(e => {
                a.selectPivotCells.cells.push({
                  qType: "L",
                  qCol: t.dimensionIdx,
                  qRow: e
                });
              }), u = !!a.selectPivotCells.cells.length;
            }
          } else a.selectHyperCubeCells || (a.selectHyperCubeCells = {
            path: t.path,
            cols: []
          }), a.selectHyperCubeCells.cols.push(t.dimensionIdx), e.id !== o && (o || a.selectHyperCubeCells.values) || (a.selectHyperCubeCells.values = e.brush.values().map(e => +e).filter(e => !isNaN(e)), u = !!a.selectHyperCubeCells.values.length);
        } else {
          const n = e.brush.values().map(e => +e).filter(e => !isNaN(e));
          u = !!n.length, i.push({
            params: [t.path, t.dimensionIdx, n, !1],
            method: "selectHyperCubeValues"
          });
        }
      }
    }), !u && l) return [{
      method: "resetMadeSelections",
      params: []
    }];
    var c;
    a.rangeSelectHyperCubeValues && i.push({
      method: "rangeSelectHyperCubeValues",
      params: [a.rangeSelectHyperCubeValues.path, a.rangeSelectHyperCubeValues.ranges, [], null === (c = t.orMode) || void 0 === c || c]
    });
    return a.selectHyperCubeContinuousRange && i.push({
      method: "selectHyperCubeContinuousRange",
      params: [a.selectHyperCubeContinuousRange.path, a.selectHyperCubeContinuousRange.ranges]
    }), a.selectHyperCubeCells && i.push({
      method: "selectHyperCubeCells",
      params: [a.selectHyperCubeCells.path, a.selectHyperCubeCells.values, a.selectHyperCubeCells.cols]
    }), a.selectPivotCells && i.push({
      method: "selectPivotCells",
      params: [a.selectPivotCells.path, a.selectPivotCells.cells]
    }), a.multiRangeSelectTreeDataValues && i.push({
      method: "multiRangeSelectTreeDataValues",
      params: [a.multiRangeSelectTreeDataValues.path, a.multiRangeSelectTreeDataValues.ranges]
    }), i;
  }
  function Ir(e) {
    vr.util = e.data("matrix").util, e.data("q", vr), e.formatter("q-number", Zn), e.formatter("q-time", dr);
  }
  function Or(e) {
    var t = bt(e.layout || {}, e.path.split("/").join("."));
    if (!t) return !1;
    var n = t.qIsOneAndOnlyOne;
    return void 0 !== n && n;
  }
  function Er(e) {
    var t,
      n,
      r,
      o = e.selections,
      i = e.picassoSelections,
      a = e.layout,
      l = {
        lockedDimensions: [],
        singleSelectDimensions: []
      };
    null != o && null !== (t = o.isModal) && void 0 !== t && t.call(o) && o.confirm(), i.layout(a);
    var u = (null !== (n = null == a ? void 0 : a.qHyperCube) && void 0 !== n ? n : {}).qDimensionInfo,
      c = void 0 === u ? [] : u;
    return l.lockedDimensions = c.map(function (e) {
      return !!e.qLocked;
    }), l.singleSelectDimensions = c.map(function (e, t) {
      return Or({
        layout: a,
        path: "qHyperCube/qDimensionInfo/".concat(t)
      });
    }), l.singleSelectIndex = function (e) {
      var t,
        n = ((null == e ? void 0 : e.qHyperCube) || {}).qDimensionInfo,
        r = void 0 === n ? [] : n;
      return null !== (t = r.map(function (e, t) {
        var n;
        return !(e.qLocked || (null === (n = e.qCardinalities) || void 0 === n ? void 0 : n.qHypercubeCardinal) <= 1) && t;
      }).filter(function (e) {
        return "number" == typeof e;
      })[0]) && void 0 !== t ? t : Math.max(r.length - 1, 0);
    }(a), l.canSelect = 0 === c.length || c.some(function (e) {
      return !e.qLocked;
    }), l.dimensionLocked = !(null === (r = c[0]) || void 0 === r || !r.qLocked), l;
  }
  function Ar() {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    if (null == e || !e.length) return !1;
    var t = e.filter(function (e) {
      return "object" === r$3(e.data) && Array.isArray(e.data.fields);
    }).every(function (e) {
      return e.data.fields.every(function (e) {
        var t = e.raw();
        return !(!t.qLocked && t.qCardinal);
      });
    });
    return t;
  }
  function Nr(e) {
    var t = e.brush,
      n = e.colorField,
      r = e.legendAlias,
      o = e.useLegendCube,
      i = void 0 !== o && o;
    !n || /qAttrDimInfo/.test(n) ? (t.removeKeyAlias("attrDim/qDimensionInfo/0"), r && t.removeKeyAlias(r), t.addKeyAlias("attrDim/qDimensionInfo/0", "qHyperCube/".concat(n))) : i && t.addKeyAlias(r, "qHyperCube/".concat(n));
  }
  Ir.qBrushHelper = Dr, Ir.selections = Dr;
  var Lr = "Enter",
    Tr = "Escape",
    Pr = "Esc",
    jr = "Shift";
  function Fr(e) {
    var t = e.brush,
      n = e.getConfig;
    return {
      interceptor: function (e) {
        var r = t.brushes(),
          o = n(),
          i = o.allowSimultaneous,
          a = o.layout,
          l = void 0 === a ? {} : a;
        r.forEach(function (n) {
          var r, o, a;
          ("range" === n.type || null !== (r = e[0]) && void 0 !== r && r.key && (null === (o = e[0]) || void 0 === o ? void 0 : o.key) !== n.id && 0 !== i.indexOf(null === (a = e[0]) || void 0 === a ? void 0 : a.key)) && t.clear([]);
        });
        var u = e.filter(function (e) {
          return -2 !== e.value;
        });
        if (u.length > 1) {
          var s = function (e) {
            var t = e.layout,
              n = void 0 === t ? {} : t,
              r = e.values,
              o = void 0 === r ? [] : r;
            if (null == o || !o.length) return [];
            var i = Array.from(new Set(o.map(function (e) {
                return e.key;
              }))),
              a = [];
            return i.forEach(function (e) {
              var t = Or({
                  layout: n,
                  path: e
                }),
                r = o.filter(function (t) {
                  return t.key === e;
                }),
                i = t ? [r.pop()] : r;
              a.push.apply(a, c$1(i));
            }), a.filter(Boolean);
          }({
            layout: l,
            values: u
          });
          return s;
        }
        return u;
      },
      rangeInterceptor: function (e) {
        var r = t.brushes(),
          o = n().allowSimultaneous;
        return r.filter(function (e) {
          return "value" === e.type;
        }).length ? (t.clear([]), e) : (r.forEach(function (n) {
          var r = n.id === e[0].key || o.includes(n.id) && o.includes(e[0].key);
          "range" !== n.type || r || t.clear([]);
        }), e);
      }
    };
  }
  var Hr = function e(t, n) {
      return n[t] ? e(t + 1, n) : t;
    },
    Rr = function (e, t) {
      var n = t.reduce(function (e, t) {
        return e[t] = !0, e;
      }, {});
      return e.reduce(function (e, t, r) {
        var o = Hr(r, n);
        return n[o] = !0, e[r] = o, e;
      }, {});
    };
  function zr() {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
      t = e.layout,
      n = e.filtered,
      r = void 0 === n ? {} : n,
      o = (null == t ? void 0 : t.qHyperCube) || {},
      i = o.qDimensionInfo,
      a = void 0 === i ? [] : i,
      l = o.qMeasureInfo,
      u = void 0 === l ? [] : l;
    return {
      dimensions: Rr(a, r.dimensions || []),
      measures: Rr(u, r.measures || [])
    };
  }
  var Vr = "selectHyperCubeValues",
    _r = "selectHyperCubeContinuousRange";
  function Br(e) {
    var t = e.selection,
      n = e.fieldMap,
      r = t.method,
      o = t.params;
    if (r === Vr) {
      var i = n.dimensions[o[1]];
      void 0 !== i && (o[1] = i);
    }
    r === _r && o[1].forEach(function (e) {
      var t = n.dimensions[e.qDimIx];
      void 0 !== t && (e.qDimIx = t);
    });
    return t;
  }
  var Yr = [],
    $r = 0,
    Ur = function (e) {
      var t = Yr.filter(function (e) {
        var t;
        return null === (t = e.selections) || void 0 === t ? void 0 : t.isActive();
      });
      t.length && (e.key === Lr ? t.forEach(function (e) {
        return e.selections.confirm();
      }) : e.key !== Tr && e.key !== Pr || t.forEach(function (e) {
        return e.selections.cancel();
      }));
    },
    Kr = function () {
      document.addEventListener("keyup", Ur);
    },
    Gr = function () {
      document.removeEventListener("keyup", Ur);
    },
    Wr = function (e, t) {
      Object.keys(t).forEach(function (n) {
        e.on(n, t[n]);
      });
    },
    Xr = function (e, t) {
      Object.keys(t).forEach(function (n) {
        e.removeListener(n, t[n]);
      });
    };
  function Zr(e, t, n) {
    if (t && void 0 !== n && "selectHyperCubeContinuousRange" === e.method) {
      var r = e.params;
      if (r && r[1] && r[1][0]) {
        var o = r[1][0],
          i = o.qDimIx,
          a = o.qRange;
        "undefined" !== i && a && !1 === a.qMaxInclEq && a.qMax >= n && (a.qMaxInclEq = !0);
      }
    }
  }
  function Jr(e) {
    var t = e.chart,
      n = e.document,
      r = e.selectionInfo,
      o = e.eventName,
      i = e.componentName,
      a = e.brushName,
      l = void 0 === a ? "selection" : a,
      u = e.emit,
      c = void 0 === u ? "rangeClear" : u,
      s = r.event === o,
      f = n.querySelector("[data-key='".concat(i, "-edge-0']"));
    if (s || !f) return !1;
    var d = t.component(i);
    return !!d && (d.emit(c), "string" == typeof l && t.brush(l).clear(), d);
  }
  function Qr(e) {
    var t = e.selectionInfo,
      n = e.chart,
      r = e.document,
      o = e.eventName,
      i = void 0 === o ? "discreteRange" : o,
      a = e.componentName,
      l = void 0 === a ? "discrete-range-brush" : a,
      u = e.cleared;
    return Jr({
      selectionInfo: t,
      chart: n,
      document: r,
      eventName: void 0 !== u && u ? void 0 : i,
      componentName: l,
      emit: "areaClear",
      brushName: e.brushName
    });
  }
  function eo(e) {
    var t = e.selectionInfo,
      n = e.chart,
      r = e.document,
      o = e.eventName,
      i = void 0 === o ? "continuousRange" : o,
      a = e.componentName,
      l = void 0 === a ? "continuous-range-brush" : a,
      u = e.cleared;
    return Jr({
      selectionInfo: t,
      chart: n,
      document: r,
      eventName: void 0 !== u && u ? void 0 : i,
      componentName: l,
      brushName: e.brushName
    });
  }
  function to(e) {
    var t = e.selectionInfo,
      n = e.chart,
      r = e.document,
      o = e.componentName,
      i = void 0 === o ? "minor-range-brush" : o,
      a = e.eventName,
      l = void 0 === a ? "minorRange" : a,
      u = e.cleared,
      c = void 0 !== u && u,
      s = e.brushName,
      f = Jr({
        selectionInfo: t,
        chart: n,
        document: r,
        eventName: c ? void 0 : l,
        componentName: i,
        brushName: void 0 !== s && s
      });
    if (f) {
      var d = f.settings.settings,
        p = d.scale,
        h = d.brush,
        m = n.scale(p).data().fields.map(function (e) {
          return e.id();
        }),
        v = n.brush(h),
        y = v.brushes().filter(function (e) {
          return "range" === e.type && m.some(function (t) {
            return t === e.id;
          });
        });
      v && y.length && y.forEach(function (e) {
        v.removeRanges(e.brush.ranges().map(function (t) {
          return {
            key: e.id,
            range: t
          };
        }));
      });
    }
  }
  function no(e) {
    var t = e.selectionInfo,
      n = e.chart,
      r = e.document,
      o = e.selections,
      i = e.eventName,
      a = void 0 === i ? "xAxis" : i,
      l = e.cleared;
    Jr({
      selectionInfo: t,
      chart: n,
      document: r,
      eventName: void 0 !== l && l ? void 0 : a,
      componentName: "".concat(a, "-range-brush"),
      emit: "areaClear",
      brushName: !1
    }) && o.clear();
  }
  function ro(e) {
    var t = e.chart,
      n = e.selectionInfo,
      r = e.selections,
      o = e.events,
      i = void 0 === o ? ["tap"] : o,
      a = e.brushNames,
      l = void 0 === a ? [] : a;
    if (n && i.includes(n.event)) {
      var u = n.currentComponent;
      n.previousComponent !== u && (r.clear(), l.forEach(function (e) {
        return t.brush(e).end();
      }));
    }
  }
  function oo(e) {
    var t = e.selectionInfo,
      n = e.chart,
      r = e.document,
      o = e.selections,
      i = e.eventName,
      a = void 0 === i ? "legendRange" : i,
      l = e.componentName,
      u = void 0 === l ? "legend-range-brush" : l,
      c = e.cleared,
      s = void 0 !== c && c,
      f = e.brushName;
    Jr({
      selectionInfo: t,
      chart: n,
      document: r,
      eventName: s ? void 0 : a,
      componentName: u,
      brushName: void 0 !== f && f
    }) && o.clear();
  }
  var io = ["chart", "document", "selections", "selectionInfo"],
    ao = function (e) {
      e.chart, e.document, e.selections, e.selectionInfo;
      var t = l$1(e, io);
      t.clearDiscrete(), t.clearContinuous(), t.clearMinor(), t.clearRange(), t.clearTap(), t.clearLegend();
    };
  function lo(e) {
    var n = e.selectionEvents,
      r = e.selections,
      o = e.selectionInfo,
      i = e.clear,
      a = e.chart,
      l = e.document,
      u = n.start,
      c = {
        selections: r,
        selectionInfo: o,
        chart: a,
        document: l
      },
      s = function (e) {
        return Object.assign(o, e || {});
      },
      f = function (e) {
        var n = e.event,
          r = e.components;
        return function () {
          return function (e) {
            var n = e.selectionInfo,
              r = void 0 === n ? {} : n,
              o = e.setSelectionInfo,
              i = e.clear,
              a = e.event,
              l = e.components,
              u = void 0 === l ? [] : l;
            o(t$1(t$1({}, r), {}, {
              event: a,
              components: u.map(function (e) {
                return e.key;
              }).filter(Boolean)
            })), i();
          }({
            event: n,
            components: r,
            clear: i,
            chart: a,
            selectionInfo: o,
            setSelectionInfo: s
          });
        };
      };
    return "function" == typeof u ? function (e) {
      var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
      u(t$1(t$1({
        defaultFunc: f({
          event: e,
          components: n
        }),
        setSelectionInfo: s,
        clear: i
      }, c), {}, {
        event: e,
        components: n
      }));
    } : function (e) {
      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
      f({
        event: e,
        components: t
      })();
    };
  }
  function uo(e) {
    var t,
      n = e.lasso;
    null != n && null !== (t = n.active) && void 0 !== t && t.call(n) && (null == n || n.action(!1));
  }
  function co(e) {
    var n,
      r = e.chart,
      o = e.selectionInfo,
      i = e.selectionActions,
      a = e.actions,
      l = void 0 === a ? {} : a,
      c = e.selections,
      s = e.selectionEvents;
    if (!1 === i || !1 === s) return function () {};
    var f = i.reset,
      d = void 0 === f ? uo : f,
      p = i.clear,
      h = !1 !== p && function (e) {
        var n = e.clear,
          r = void 0 === n ? ao : n,
          o = e.selections,
          i = e.selectionInfo,
          a = e.chart;
        return function () {
          var e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).cleared,
            n = {
              selections: o,
              selectionInfo: i,
              chart: a,
              document: document,
              cleared: e
            };
          return r(t$1({
            clearDiscrete: function () {
              var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              return Qr(t$1(t$1({}, n), e));
            },
            clearContinuous: function () {
              var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              return eo(t$1(t$1({}, n), e));
            },
            clearMinor: function () {
              var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              return to(t$1(t$1({}, n), e));
            },
            clearRange: function () {
              var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              return no(t$1(t$1({}, n), e));
            },
            clearTap: function () {
              var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              return ro(t$1(t$1({}, n), e));
            },
            clearLegend: function () {
              var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              return oo(t$1(t$1({}, n), e));
            }
          }, n));
        };
      }({
        clear: p,
        selections: c,
        selectionInfo: o,
        chart: r
      }),
      m = function (e) {
        var t = e.chart,
          n = e.actions,
          r = e.reset,
          o = e.clear,
          i = !1,
          a = {
            deactivated: function (e) {
              var t = (n || {}).lasso;
              r({
                e: e,
                lasso: void 0 !== t && t
              });
            },
            canceled: function (e) {
              var i = (n || {}).lasso;
              r({
                e: e,
                lasso: void 0 !== i && i
              }), o({
                e: e,
                chart: t,
                document: document
              });
            },
            cleared: function (e) {
              i || (i = !0, o({
                e: e,
                chart: t,
                document: document,
                cleared: !0
              }), i = !1);
            }
          };
        return !1 === r && delete a.deactivated, !1 === o && delete a.cleared, !1 === r && !1 === o && delete a.canceled, a;
      }({
        chart: r,
        clear: h,
        reset: d,
        actions: l
      }),
      v = {};
    Object.entries(m).forEach(function (e) {
      var t = u$1(e, 2),
        n = t[0],
        r = t[1];
      v[n] = function (e, t) {
        return t ? function (n) {
          return t({
            event: n,
            defaultFunc: e
          });
        } : e;
      }(r, s[n]);
    });
    var y = lo({
      selectionEvents: s,
      selections: c,
      selectionInfo: o,
      clear: h,
      chart: r,
      document: document
    });
    return null == l || null === (n = l.select) || void 0 === n || n.on("start", y), Object.entries(v).forEach(function (e) {
      var t = u$1(e, 2),
        n = t[0],
        r = t[1];
      null == c || c.on(n, r);
    }), function () {
      var e;
      null == l || null === (e = l.select) || void 0 === e || e.removeListener("start", y), Object.entries(v).forEach(function (e) {
        var t = u$1(e, 2),
          n = t[0],
          r = t[1];
        null == c || c.removeListener(n, r);
      });
    };
  }
  function so(e) {
    var t = e.chart,
      n = e.selectionActions,
      r = e.brush,
      o = e.actions,
      i = e.selectionInfo,
      a = e.selections,
      l = e.selectionEvents,
      c = function (e) {
        var t = e.brush,
          n = e.chart,
          r = e.selectionInfo,
          o = e.brushEvents,
          i = void 0 === o ? {} : o,
          a = Object.entries(i).map(function (e) {
            var o = u$1(e, 2),
              i = o[0],
              a = o[1],
              l = function () {
                return a({
                  chart: n,
                  selectionInfo: r
                });
              };
            return t.on(i, l), [i, l];
          });
        return function () {
          a.forEach(function (e) {
            var n = u$1(e, 2),
              r = n[0],
              o = n[1];
            t.removeListener(r, o);
          });
        };
      }({
        brush: r,
        chart: t,
        selectionInfo: i,
        brushEvents: e.brushEvents
      }),
      s = co({
        chart: t,
        selectionInfo: i,
        selectionActions: n,
        actions: o,
        selections: a,
        selectionEvents: l
      }),
      f = function (e) {
        var t = e.actions;
        if (null == t || !t.lasso) return function () {};
        var n = !1,
          r = function (e) {
            n || e.key !== jr || (t.lasso.action(!0), n = !0);
          },
          o = function (e) {
            e.key === jr && (t.lasso.action(!1), n = !1);
          };
        return document.addEventListener("keydown", r), document.addEventListener("keyup", o), function () {
          document.removeEventListener("keydown", r), document.removeEventListener("keyup", o);
        };
      }({
        actions: o
      });
    return function () {
      c(), s(), f();
    };
  }
  var fo = [{
    key: "qHyperCube/qDimensionInfo/0:numeric",
    includeMax: !1
  }];
  function po(e) {
    var t = e.chart,
      n = e.actions,
      r = e.selections,
      o = e.picassoQ,
      i = e.config,
      a = i.allowSimultaneous,
      l = void 0 !== a && a,
      s = i.majorScale,
      f = void 0 === s ? void 0 : s,
      d = i.selectionActions,
      p = void 0 === d ? {} : d,
      h = p.clear,
      m = p.reset,
      v = i.selectionEvents,
      y = void 0 === v ? {
        deactivated: void 0,
        canceled: void 0,
        cleared: void 0,
        start: void 0
      } : v,
      g = i.brushEvents,
      b = void 0 === g ? {} : g,
      x = i.brushName,
      q = void 0 === x ? "selection" : x,
      w = i.brushMaxListeners,
      M = void 0 === w ? 20 : w,
      k = i.brushRanges,
      S = void 0 !== k && k,
      C = i.interceptors,
      D = void 0 === C ? {} : C,
      I = i.selectionsFn,
      O = void 0 === I ? o.selections : I,
      E = t.brush(q);
    if ("number" == typeof M && E.setMaxListeners(M), S) {
      var A = !0 === S ? fo : S;
      E.configure({
        ranges: A
      });
    }
    var N = {
        canSelect: !0,
        getIsSelectionLocked: !1,
        isInnerDimensionLocked: !1,
        lockedDimensions: [],
        singleSelectIndex: 0,
        selectionInfo: {
          colorField: void 0,
          components: [],
          event: void 0,
          currentComponent: void 0,
          previousComponent: void 0
        }
      },
      L = function () {
        var e,
          t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          n = t.selections,
          r = t.brush,
          o = t.majorScale,
          i = t.actions,
          a = t.selectionsFn,
          l = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).path,
          u = void 0 === l ? "/qHyperCubeDef" : l;
        if (!n) return {
          layout: function () {},
          filteredFields: function () {},
          allowSimultaneous: function () {},
          release: function () {}
        };
        var c = ++$r,
          s = null,
          f = {
            dimensions: [],
            measures: []
          },
          d = [],
          p = {};
        n.on = n.on.bind(n), n.isActive = n.isActive.bind(n), n.addListener = n.addListener.bind(n), n.removeListener = n.removeListener.bind(n);
        var h = Fr({
            brush: r,
            getConfig: function () {
              return {
                layout: s,
                allowSimultaneous: d
              };
            }
          }),
          m = h.rangeInterceptor,
          v = h.interceptor;
        r.intercept("set-ranges", m), r.intercept("toggle-ranges", m), r.intercept("toggle-values", v), r.intercept("set-values", v), r.intercept("add-values", v), r.on("start", function () {
          return n.begin(u);
        });
        var y = {
          activate: function () {},
          deactivated: function () {
            return r.end();
          },
          cleared: function () {
            return r.clear();
          },
          canceled: function () {
            return r.end();
          }
        };
        Wr(n, y);
        var g = null == o || null === (e = o.max) || void 0 === e ? void 0 : e.call(o);
        return null != i && i.select ? (i.select.on("start", function () {
          var e;
          r.start(), "function" == typeof i.select.getBrushOptions && (p = (e = i.select).getBrushOptions.apply(e, arguments));
        }), i.select.on("end", function () {
          var e = a(r, p, s),
            t = zr({
              layout: s,
              filtered: f
            });
          e.forEach(function (e) {
            var r = Br({
              selection: e,
              fieldMap: t
            });
            Zr(r, i.select.brushSelectionIncludeMax, g), n.select(r);
          });
        })) : r.on("update", function () {
          var e = a(r, p, s),
            t = zr({
              layout: s,
              filtered: f
            });
          e.forEach(function (e) {
            n.select(Br({
              selection: e,
              fieldMap: t
            }));
          });
        }), 0 === Yr.length && Kr(), Yr.push({
          key: c,
          selections: n
        }), {
          layout: function (e) {
            s = e;
          },
          filteredFields: function (e) {
            f = e;
          },
          allowSimultaneous: function (e) {
            d = e;
          },
          release: function () {
            s = null;
            var e = Yr.indexOf(Yr.filter(function (e) {
              return e.key === c;
            })[0]);
            -1 !== e && Yr.splice(e, 1), Yr.length || Gr(), Xr(n, y);
          }
        };
      }({
        brush: E,
        majorScale: f,
        actions: n,
        selections: r,
        picassoQ: o,
        selectionsFn: O
      });
    !function (e) {
      var t = e.brush,
        n = e.interceptors,
        r = void 0 === n ? {} : n;
      Object.entries(r).forEach(function (e) {
        var n = u$1(e, 2),
          r = n[0],
          o = n[1];
        (Array.isArray(o) ? o : [o]).forEach(function (e) {
          t.intercept(r, e);
        });
      });
    }({
      brush: E,
      interceptors: D
    });
    var T = so({
      chart: t,
      brush: E,
      actions: n,
      selections: r,
      selectionInfo: N.selectionInfo,
      selectionActions: {
        clear: h,
        reset: m
      },
      selectionEvents: y,
      brushEvents: b
    });
    if (l) {
      var P = !0 === l ? c$1(Array(15)).map(function (e, t) {
        return "qHyperCube/qMeasureInfo/".concat(t);
      }) : l;
      L.allowSimultaneous(P);
    }
    return {
      unbindEvents: T,
      state: N,
      picassoSelections: L,
      brush: E
    };
  }
  var ho = ["colorField", "useLegendCube"];
  function mo(e) {
    var n = e.chart,
      r = e.selections,
      o = e.actions,
      i = void 0 !== o && o,
      a = e.config,
      u = void 0 === a ? {} : a,
      c = po({
        chart: n,
        actions: i,
        selections: r,
        picassoQ: Ir,
        config: u
      }),
      s = c.unbindEvents,
      f = c.state,
      d = c.picassoSelections,
      p = c.brush,
      h = u.custom,
      m = void 0 === h ? {} : h,
      v = u.legendAlias,
      y = void 0 === v ? void 0 : v,
      g = u.setBrushAliases,
      b = void 0 === g ? Nr : g;
    return {
      getIsDimensionLocked: function () {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        return f.lockedDimensions[e];
      },
      getIsSelectionLocked: function () {
        var e,
          t,
          n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        return null !== (e = null == r || null === (t = r.isLocked) || void 0 === t ? void 0 : t.call(r)) && void 0 !== e ? e : Ar(n);
      },
      getIsSingleSelect: function () {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : f.singleSelectIndex;
        return f.singleSelectDimensions[e];
      },
      getCanSelect: function () {
        return f.canSelect;
      },
      getSelectionInfo: function () {
        return f.selectionInfo;
      },
      setLayout: function (e) {
        var t = Er({
          selections: r,
          picassoSelections: d,
          layout: e
        });
        Object.assign(f, t);
      },
      setFilteredFields: function (e) {
        d.filteredFields(e);
      },
      setBrushAliases: function (e) {
        var n = e.colorField,
          r = e.useLegendCube,
          o = void 0 !== r && r,
          i = l$1(e, ho),
          a = t$1({
            useLegendCube: o,
            colorField: n,
            brush: p,
            legendAlias: y
          }, i);
        b(t$1(t$1({}, a), {}, {
          defaultFunc: function () {
            return Nr(a);
          }
        }));
      },
      destroy: function () {
        s(), d.release();
      },
      custom: t$1({}, m)
    };
  }
  var vo = "'Source Sans Pro', 'Arial', 'sans-serif'",
    yo = "#333333",
    go = "#595959",
    bo = "#737373",
    xo = "#cccccc",
    qo = "#e6e6e6";
  function wo(e) {
    var t = {};
    return [].concat(c$1(e), c$1([["", "", "color"], ["object", "", "fontFamily"], ["object", "axis.label.name", "color", go], ["object", "axis.label.name", "fontFamily", vo], ["object", "axis.label.name", "fontSize", "12px"], ["object", "axis.line.major", "color", xo], ["object", "axis.line.minor", "color", qo], ["object", "axis.title", "color"], ["object", "axis.title", "fontFamily", vo], ["object", "axis.title", "fontSize", "13px"], ["object", "grid.line.highContrast", "color", qo], ["object", "grid.line.major", "color", xo], ["object", "grid.line.minor", "color", qo], ["object", "label.value", "color", go], ["object", "label.value", "fontFamily", vo], ["object", "label.value", "fontSize", "12px"], [!1, "label.value", "darkColor", go], [!1, "label.value", "lightColor", qo], ["object", "outOfRange", "color", "#999"], ["object", "legend.title", "color", yo], ["object", "legend.title", "fontFamily", vo], ["object", "legend.title", "fontSize", "15px"], ["object", "legend.label", "color", go], ["object", "legend.label", "fontFamily", vo], ["object", "legend.label", "fontSize", "13px"], ["object", "referenceLine.label.name", "color", yo], ["object", "referenceLine.label.name", "fontFamily", vo], ["object", "referenceLine.label.name", "fontSize", "12px"], ["object", "referenceLine.outOfBounds", "color", qo], ["object", "referenceLine.outOfBounds", "fontFamily", vo], ["object", "referenceLine.outOfBounds", "fontSize", "12px"], ["object", "referenceLine.outOfBounds", "backgroundColor", bo, function (e) {
      return "transparent" === e ? bo : e;
    }]])).reduce(function (e, n) {
      var r = "".concat(n[0], "-").concat(n[1], "-").concat(n[2], "}");
      return t[r] || (t[r] = !0, e.push(n)), e;
    }, []).sort(function (e, t) {
      return (e[0].split ? e[0].split(".").length : 0) - (t[0].split ? t[0].split(".").length : 0);
    });
  }
  var Mo = function (e) {
    return e;
  };
  function ko(e) {
    var t = e.theme,
      n = e.id,
      r = e.transform,
      o = e.extend,
      i = e.matrix,
      a = {},
      l = r.reduce(function (e, t) {
        var n = u$1(t, 2),
          r = n[0],
          o = n[1];
        return e[r] = o, e;
      }, {});
    return i.forEach(function (e) {
      var r = u$1(e, 5),
        o = r[0],
        i = r[1],
        c = r[2],
        s = r[3],
        f = r[4],
        d = void 0 === f ? function (e) {
          return e;
        } : f,
        p = function (e) {
          var t = e.theme,
            n = e.base,
            r = e.path,
            o = e.attribute,
            i = e.defaultValue,
            a = void 0 === i ? void 0 : i;
          if (!t || !1 === n) return a;
          var l = t.getStyle(n, r, o);
          return void 0 === l ? a : l;
        }({
          theme: t,
          base: "object" === o && n ? "".concat("object", ".").concat(n) : o,
          path: i,
          attribute: c,
          defaultValue: s
        }),
        h = (l["".concat(i, ".").concat(c)] || Mo)(d(p));
      qt(a, [i, c].filter(Boolean).join("."), h);
    }), o.forEach(function (e) {
      var t = u$1(e, 2),
        n = t[0],
        r = t[1];
      qt(a, n, r);
    }), a;
  }
  function So(e) {
    var t = e.theme,
      n = e.config,
      r = void 0 === n ? {} : n,
      o = r.id,
      i = r.resolve,
      a = void 0 === i ? [] : i,
      l = r.transform,
      u = void 0 === l ? [] : l,
      c = r.extend,
      s = void 0 === c ? [] : c,
      f = {
        theme: t,
        matrix: wo(a),
        styles: void 0
      };
    return f.styles = ko({
      theme: t,
      id: o,
      transform: u,
      extend: s,
      matrix: f.matrix
    }), {
      getStyles: function () {
        return f.styles;
      },
      getTheme: function () {
        return f.theme;
      },
      setTheme: function (e) {
        f.theme = e, f.styles = ko({
          theme: e,
          id: o,
          transform: u,
          extend: s,
          matrix: f.matrix
        });
      }
    };
  }
  var Co = {
    NOOP: function () {},
    FALSE: function () {
      return !1;
    },
    ARRAY: function () {
      return [];
    },
    OBJECT: function () {
      return {};
    }
  };
  var Do = "chart-modules-tooltip",
    Io = "#".concat(Do);
  function Oo() {
    if (!document.querySelector(Io)) {
      var e = document.createElement("div");
      e.id = Do, e.style.overflow = "hidden", e.style.position = "fixed", e.style.pointerEvents = "none", e.style.left = "0px", e.style.top = "0px", e.style.width = "100%", e.style.height = "100%", e.style.zIndex = 1020, document.body.appendChild(e);
    }
  }
  function Eo(e) {
    return {
      show: !0,
      key: e.key,
      type: "tooltip",
      layout: {
        displayOrder: 3
      },
      beforeMount: function () {
        Oo();
      },
      beforeUpdate: function () {
        Oo();
      },
      destroyed: function () {
        var e;
        null != (e = document.querySelector(Io)) && e.parentElement && e.childElementCount < 1 && e.parentElement.removeChild(e);
      },
      settings: {
        appendTo: function () {
          return document.querySelector(Io);
        },
        direction: e.rtl ? "rtl" : "ltr",
        duration: e.duration
      },
      style: {
        arrow: {
          color: "#404040"
        },
        content: {
          display: "table",
          "border-spacing": "4px",
          background: "rgba(64, 64, 64, 0.9)",
          opacity: "1",
          fontSize: "13px",
          fontFamily: "'Source Sans Pro', 'Arial', 'sans-serif'",
          "empty-cells": "show"
        },
        cell: {
          "max-width": "180px",
          "word-break": "break-word",
          "word-wrap": "break-word",
          "overflow-wrap": "break-word",
          hyphens: "auto"
        }
      }
    };
  }
  var Ao = "position";
  var No = {
      bar: "rect",
      diamond: "path",
      point: "circle",
      square: "rect",
      triangle: "path",
      "n-polygon": "path",
      slice: "path"
    },
    Lo = function (e) {
      return e.data.value;
    },
    To = function (e) {
      var t,
        n = e.data;
      return null == n || null === (t = n.major) || void 0 === t ? void 0 : t.value;
    };
  function Po(e) {
    var t = e.chart,
      n = e.expando,
      r = e.nodes,
      o = e.collectConfig,
      i = e.collectibles,
      a = e.meta,
      l = o.from,
      s = {
        chart: t,
        expando: n,
        nodes: r,
        collectConfig: o,
        collectibles: i,
        meta: a
      };
    switch ("function" == typeof l ? "custom" : l) {
      case "single":
        return function (e) {
          var t = u$1(e.nodes, 1)[0];
          return ["container" === t.type && t.children[0] || t];
        }(s);
      case "position":
        return function (e) {
          var t = e.chart,
            n = e.collectibles,
            r = e.meta;
          return t.shapesAt(r.position.absolute, {
            components: n.map(function (e) {
              return {
                key: e.key
              };
            })
          });
        }(s);
      case "dimension":
        return function (e) {
          var t = e.chart,
            n = e.nodes,
            r = e.collectConfig,
            o = e.collectibles,
            i = u$1(n, 1)[0],
            a = r.filter,
            l = "function" == typeof a ? a : function () {
              return !0;
            },
            s = r.by,
            f = void 0 === s ? Lo : s;
          return o.reduce(function (e, n) {
            var r = n.major,
              o = void 0 === r ? To : r,
              a = No[n.type] || n.type;
            return e.push.apply(e, c$1(t.findShapes(a).filter(function (e) {
              return e.key === n.key && e.data && o({
                data: e.data
              }) === f({
                data: i.data
              });
            }))), e;
          }, []).filter(l);
        }(s);
      case "radius":
        return function (e) {
          var t = e.chart,
            n = e.nodes,
            r = e.collectConfig,
            o = e.collectibles,
            i = e.meta,
            a = u$1(n, 1)[0].localBounds,
            l = r.distance,
            c = r.filter,
            s = "function" == typeof c ? c : function () {
              return !0;
            },
            f = o.map(function (e) {
              return e.key;
            });
          return t.shapesAt({
            cx: i.position.absolute.x,
            cy: i.position.absolute.y,
            r: l || Math.max(a.width, a.height)
          }, {
            components: f.map(function (e) {
              return {
                key: e
              };
            })
          }).filter(s);
        }(s);
      case "custom":
        return function (e) {
          var t = e.chart,
            n = e.expando,
            r = e.nodes,
            o = e.collectConfig,
            i = e.meta;
          return o.from({
            chart: t,
            expando: n,
            nodes: r,
            meta: i
          });
        }(s);
      default:
        return [];
    }
  }
  var jo = Number.MAX_VALUE;
  function Fo(e) {
    var t = e.nodes.reduce(function (e, t) {
        var n = t.bounds;
        return e.xMin = Math.min(e.xMin, n.x, n.x + n.width), e.yMin = Math.min(e.yMin, n.y, n.y + n.height), e.xMax = Math.max(e.xMax, n.x, n.x + n.width), e.yMax = Math.max(e.yMax, n.y, n.y + n.height), e;
      }, {
        xMin: jo,
        xMax: -jo,
        yMin: jo,
        yMax: -jo
      }),
      n = t.xMin,
      r = t.xMax,
      o = t.yMin;
    return {
      x: n,
      y: o,
      width: r - n,
      height: t.yMax - o
    };
  }
  function Ho(e) {
    var t = e.chart,
      n = e.config,
      r = e.expando,
      o = e.placementConfig,
      i = e.hovered,
      a = e.collected,
      l = e.meta,
      s = function (e) {
        for (var t = e.chart, n = e.config, r = e.expando, o = e.placementConfig, i = e.hovered, a = e.collected, l = e.meta, s = u$1(i, 1)[0], f = Array.isArray(o) ? o : [o], d = {
            bounds: s.bounds,
            key: s.key
          }, p = Fo({
            nodes: a
          }), h = 0; h < f.length; h++) {
          var m = f[h];
          if ("function" == typeof m) {
            var v = m({
              chart: t,
              expando: r,
              hovered: i,
              collected: c$1(a),
              meta: l,
              collectedBounds: p,
              combineBounds: Fo
            });
            if (v) return v;
          }
          if ("trigger" === m) return d;
          if ("collectible" === m) {
            var y = n.main.placements.collectible;
            return {
              bounds: "function" == typeof y ? y({
                collected: c$1(a)
              }) : p,
              key: a[0].key
            };
          }
        }
        return d;
      }({
        chart: t,
        config: n,
        expando: r,
        placementConfig: o,
        hovered: i,
        collected: a,
        meta: l
      }),
      f = s.bounds,
      d = s.key,
      p = u$1(a, 1)[0].desc;
    return [{
      bounds: f,
      nodes: a,
      data: a.map(function (e) {
        return e.data;
      }),
      key: d,
      meta: l,
      desc: p
    }];
  }
  function Ro(e) {
    var t = e.chart,
      n = e.config,
      r = e.expando,
      o = e.internal,
      i = e.nodes;
    if (!i.length) return [];
    var a = u$1(i, 1)[0].key,
      l = n.main.collectibles;
    if (!l.length) return [];
    var c = n.main.triggers.find(function (e) {
        return -1 !== e.keys.indexOf(a);
      }) || {},
      s = c.collect,
      f = c.placement;
    if (!s || !s.from || !f) return [];
    var d = {
        triggerer: a,
        position: o.get(Ao)
      },
      p = (Po({
        chart: t,
        expando: r,
        nodes: i,
        collectConfig: s,
        collectibles: l,
        meta: d
      }) || []).map(function (e) {
        return e.children.length ? e.children[0] : e;
      });
    return p.length ? Ho({
      chart: t,
      config: n,
      expando: r,
      placementConfig: f,
      hovered: i,
      collected: p,
      meta: d
    }) : [];
  }
  var zo = "[־׀׃׆א-״߀-ߪߴ-ߵߺ-ࠕࠚࠤࠨ࠰-ࡘ࡞‏יִײַ-ﬨשׁ-ﭏ]",
    Vo = "[؈؋؍؛-ي٭-ٯٱ-ەۥ-ۦۮ-ۯۺ-܍ܐܒ-ܯݍ-ޥޱﭐ-ﴽﵐ-﷼ﹰ-ﻼ]",
    _o = new RegExp("[A-Za-zªµºÀ-ÖØ-öø-ʸʻ-ˁː-ˑˠ-ˤˮͰ-ͳͶ-ͽΆΈ-ϵϷ-҂Ҋ-։ः-हऻऽ-ीॉ-ौॎ-ॐक़-ॡ।-ॿং-হঽ-ীে-ৌৎ-ৡ০-ৱ৴-৺ਃ-ਹਾ-ੀਖ਼-੯ੲ-ੴઃ-હઽ-ીૉ-ૌૐ-ૡ૦-૯ଂ-ହଽ-ାୀେ-ୌୗ-ୡ୦-୷ஃ-ிு-ௌௐ-௲ఁ-ఽు-ౄౘ-ౡ౦-౯౿-ಹಽ-ೋೕ-ೡ೦-ീെ-ൌൎ-ൡ൦-ෆා-ෑෘ-ะา-ำเ-ๆ๏-ະາ-ຳຽ-ໆ໐-༗༚-༴༶༸༾-ཬཿ྅ྈ-ྌ྾-࿅࿇-ာေးျ-ြဿ-ၗၚ-ၝၡ-ၰၵ-ႁႃ-ႄႇ-ႌႎ-ႜ႞-ፚ፠-ᎏᎠ-Ᏼᐁ-ᙿᚁ-ᚚᚠ-ᜑᜠ-ᜱ᜵-ᝑᝠ-ᝰក-ាើ-ៅះ-ៈ។-៚ៜ០-៩᠐-ᢨᢪ-ᤜᤣ-ᤦᤩ-ᤱᤳ-ᤸ᥆-᧚ᨀ-ᨖᨙ-ᩕᩗᩡᩣ-ᩤᩭ-ᩲ᪀-᪭ᬄ-ᬳᬵᬻᬽ-ᭁᭃ-᭪᭴-᭼ᮂ-ᮡᮦ-ᮧ᮪-ᯥᯧᯪ-ᯬᯮ᯲-ᰫᰴ-ᰵ᰻-᱿᳓᳡ᳩ-ᳬᳮ-ᶿḀ-ᾼιῂ-ῌῐ-Ίῠ-Ῥῲ-ῼ‎ⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎ-⅏Ⅰ-ↈ⌶-⍺⎕⒜-ⓩ⚬⠀-⣿Ⰰ-ⳤⳫ-ⳮⴀ-⵰ⶀ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖゝ-ゟァ-ヺー-ㆺㇰ-㈜㈠-㉏㉠-㉻㉿-㊰㋀-㋋㋐-㍶㍻-㏝㏠-㏾㐀-䶵一-ꒌꓐ-ꘌꘐ-ꙮꚀ-ꛯ꛲-꛷Ꜣ-ꞇ꞉-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠤꠧ꠰-꠷ꡀ-ꡳꢀ-ꣃ꣎-꣙ꣲ-ꤥ꤮-ꥆꥒ-ꥼꦃ-ꦲꦴ-ꦵꦺ-ꦻꦽ-ꨨꨯ-ꨰꨳ-ꨴꩀ-ꩂꩄ-ꩋꩍ-ꪯꪱꪵ-ꪶꪹ-ꪽꫀꫂ-ꯤꯦ-ꯧꯩ-꯬꯰-ﬗＡ-Ｚａ-ｚｦ-ￜ]"),
    Bo = new RegExp(zo),
    Yo = new RegExp(Vo),
    $o = function (e) {
      return _o.test(e);
    },
    Uo = function (e) {
      return Bo.test(e) || Yo.test(e);
    };
  function Ko(e) {
    for (var t = e ? e.length : 0, n = 0; n < t; n++) {
      var r = e[n];
      if ($o(r)) return "ltr";
      if (Uo(r)) return "rtl";
    }
    return "ltr";
  }
  function Go(e) {
    var n = e.visibility;
    return {
      type: "divider",
      content: [{
        content: "",
        style: {
          "background-image": "linear-gradient(transparent 8px, rgba(255, 255, 255, 0.4) 8px, rgba(255, 255, 255, 0.4) 9.2px, transparent 9.2px)",
          height: "17px"
        },
        colspan: 2
      }],
      visibility: t$1(t$1({}, {
        count: !1
      }), n)
    };
  }
  function Wo(e) {
    var n = e.config,
      r = e.h,
      o = e.context,
      i = e.nodes,
      a = e.property,
      l = e.filter,
      c = e.visibility,
      s = e.fillColor,
      f = n.rtl,
      d = {
        type: "color",
        label: void 0,
        value: void 0,
        content: [],
        filter: l,
        visibility: t$1(t$1({}, {
          count: !0
        }), c)
      },
      p = n.getColorSettings();
    if ("color" === p.type || !p.fieldType) return d;
    var h = u$1(i, 1)[0];
    if (d.value = function (e) {
      var t = e.config,
        n = e.context,
        r = e.property,
        o = e.node,
        i = o.data[r];
      if (i) {
        if (-3 === o.data.value) return o.data.label;
        var a = n.resources.dataset(i.source.key).field(i.source.field).formatter(),
          l = i.value,
          u = i.label,
          c = t.getColorSettings();
        if (a && "measure" === c.fieldType) return Number.isNaN(+l) ? "-" : a(i.value);
        var s = u || l;
        return void 0 === s || Number.isNaN(s) || "NaN" === s ? "-" : s;
      }
    }({
      config: n,
      context: o,
      property: a,
      node: h
    }), void 0 === d.value) return d;
    d.label = function (e) {
      var t = e.config,
        n = e.context,
        r = e.property,
        o = e.node,
        i = t.getColorSettings();
      if (i.label) return i.label;
      var a = o.data[r];
      if (a && "color" !== i.type) {
        var l = n.resources.dataset,
          u = a.source,
          c = u.key,
          s = u.field;
        return l(c).field(s).title();
      }
    }({
      config: n,
      context: o,
      property: a,
      node: h
    });
    var m = null != s ? s : function (e) {
        var t = e.node.attrs;
        return (null == t ? void 0 : t.fill) || "#ddd";
      }({
        node: h
      }),
      v = r("div", {
        style: {
          display: "inline-block",
          width: 10,
          height: 10,
          "background-color": m,
          margin: "0 8px"
        }
      });
    return d.content.push({
      content: f ? [":", d.label] : [d.label, ":"],
      style: {
        "text-align": f ? "right" : "left",
        direction: Ko(d.label)
      }
    }, {
      content: f ? [d.value, v] : [v, d.value],
      style: {
        "text-align": f ? "left" : "right",
        "vertical-align": "middle",
        direction: Ko(d.value)
      }
    }), d;
  }
  function Xo(e) {
    var n = e.config,
      r = e.h,
      o = e.context,
      i = {
        section: function (e) {
          return function (e) {
            return {
              type: "section",
              content: e.content
            };
          }({
            content: e.content
          });
        },
        text: function (e) {
          var r = e.value,
            o = e.style,
            i = e.visibility;
          return function (e) {
            var n = e.config,
              r = e.value,
              o = e.style,
              i = void 0 === o ? {} : o,
              a = i.bold,
              l = void 0 !== a && a,
              u = i.italic,
              c = void 0 !== u && u,
              s = e.visibility;
            return {
              type: "text",
              content: [{
                content: r,
                style: {
                  "font-weight": l ? "bold" : "normal",
                  "font-style": c ? "italic" : "normal",
                  "text-align": n.rtl ? "right" : "left",
                  direction: Ko(r)
                },
                colspan: 2
              }],
              visibility: t$1(t$1({}, {
                count: !0
              }), s)
            };
          }({
            config: n,
            value: r,
            style: o,
            visibility: i
          });
        },
        measure: function (e) {
          var o = e.label,
            i = e.value,
            a = e.color,
            l = e.style,
            u = e.survive,
            c = e.visibility;
          return function (e) {
            var n,
              r,
              o,
              i,
              a = e.config,
              l = e.h,
              u = e.label,
              c = e.value,
              s = e.color,
              f = e.style,
              d = e.survive,
              p = e.visibility,
              h = a.rtl,
              m = l("div", {
                style: {
                  display: "inline-block",
                  width: 10,
                  height: 10,
                  "background-color": s,
                  margin: "0 8px"
                }
              });
            return {
              type: "measure",
              label: u,
              value: c,
              content: [{
                content: h ? [":", u] : [u, ":"],
                style: {
                  "text-align": h ? "right" : "left",
                  "font-weight": null != f && null !== (n = f.label) && void 0 !== n && n.bold ? "bold" : "normal",
                  "font-style": null != f && null !== (r = f.label) && void 0 !== r && r.italic ? "italic" : "normal",
                  direction: Ko(u)
                }
              }, {
                content: s ? h ? [c, m] : [m, c] : c,
                style: {
                  "text-align": h ? "left" : "right",
                  "vertical-align": "middle",
                  "font-weight": null != f && null !== (o = f.value) && void 0 !== o && o.bold ? "bold" : "normal",
                  "font-style": null != f && null !== (i = f.value) && void 0 !== i && i.italic ? "italic" : "normal",
                  direction: Ko(c)
                }
              }],
              survive: t$1(t$1({}, {
                color: !1,
                duplicate: !1
              }), d),
              visibility: t$1(t$1({}, {
                count: !0
              }), p)
            };
          }({
            config: n,
            h: r,
            label: o,
            value: i,
            color: a,
            style: l,
            survive: u,
            visibility: c
          });
        },
        divider: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
            t = e.visibility;
          return Go({
            visibility: t
          });
        },
        row: function (e) {
          return function (e) {
            var n = e.content,
              r = e.style,
              o = e.colspan,
              i = e.visibility;
            return {
              type: "row",
              content: [{
                content: n,
                style: r,
                colspan: o
              }],
              visibility: t$1(t$1({}, {
                count: !0
              }), i)
            };
          }({
            content: e.content,
            style: e.style,
            colspan: e.colspan,
            visibility: e.visibility
          });
        },
        raw: function (e) {
          return function (e) {
            var n = e.value,
              r = e.visibility;
            return {
              type: "raw",
              content: n,
              visibility: t$1(t$1({}, {
                count: !0
              }), r)
            };
          }({
            value: e.value,
            visibility: e.visibility
          });
        },
        color: function (e) {
          var t = e.nodes,
            i = e.property,
            a = e.filter,
            l = void 0 === a || a,
            u = e.visibility,
            c = e.fillColor;
          return Wo({
            config: n,
            h: r,
            context: o,
            nodes: t,
            property: i,
            filter: l,
            visibility: u,
            fillColor: c
          });
        }
      };
    return i;
  }
  function Zo(e) {
    var t = e.translator,
      n = e.config,
      r = e.context,
      o = e.templates,
      i = n.main.layout,
      a = i.rows,
      l = i.grouping,
      u = i.single,
      c = function (e) {
        var t = e.limit,
          n = e.grouping,
          r = e.single,
          o = {
            count: 0,
            overflow: 0,
            index: {
              started: void 0,
              group: void 0
            }
          };
        return {
          process: function (e) {
            var i = e.visibility,
              a = e.index;
            if (r && 0 !== a) return n ? (o.index.started !== a && o.index.group !== a && (o.overflow++, o.index.group = a), !1) : (o.overflow++, !1);
            if (o.count >= t) {
              if (!n) return o.overflow++, !1;
              if (o.index.started !== a) return o.index.group !== a && (o.overflow++, o.index.group = a), !1;
            }
            return i.count && o.count++, n && (o.index.started = a), !0;
          },
          overflow: function () {
            return o.overflow;
          }
        };
      }({
        limit: a,
        grouping: l,
        single: "function" == typeof u ? u({
          meta: r.node.meta,
          sections: o
        }) : u
      }),
      s = o.reduce(function (e, t, n) {
        var r = t.type,
          i = t.content;
        "section" === r && (void 0 === i ? [] : i).forEach(function (t) {
          c.process({
            visibility: t.visibility,
            index: n
          }) && e.push(t.content);
        });
        var a = n === o.length - 1;
        return "divider" !== r || a || c.process({
          visibility: t.visibility,
          index: n
        }) && e.push(t.content), e;
      }, []).filter(function (e) {
        return e.length;
      }),
      f = c.overflow();
    return f && s.push(function (e) {
      var t = e.translator,
        n = e.config,
        r = e.count,
        o = t ? t.get("Object.ChartTooltip.NMore", r) : "+".concat(r, " more"),
        i = Ko(o);
      return [{
        content: o,
        style: {
          "font-weight": "bold",
          "text-align": n.rtl ? "right" : "left",
          direction: i
        },
        colspan: 2
      }];
    }({
      translator: t,
      config: n,
      count: f
    })), s;
  }
  function Jo(e) {
    var n = e.chart,
      r = e.translator,
      o = e.config,
      i = e.expando,
      a = e.h,
      l = e.data,
      s = e.style,
      f = u$1(l, 1)[0],
      d = function (e) {
        var t = e.config,
          n = e.nodes.reduce(function (e, n) {
            var r = t.main.getGroupByValue({
              data: n.data
            });
            return e[r] || (e[r] = {
              sorting: Object.keys(e).length,
              items: []
            }), e[r].items.push(n), e;
          }, {});
        return Object.keys(n).map(function (e) {
          return n[e];
        }).sort(function (e, t) {
          return e.sorting - t.sorting;
        }).map(function (e) {
          return e.items;
        });
      }({
        config: o,
        nodes: f.node.nodes
      }),
      p = function (e) {
        var t = e.chart,
          n = e.config,
          r = e.expando,
          o = e.h,
          i = e.context,
          a = e.groups,
          l = i.node.meta,
          u = i.resources,
          s = u.dataset,
          f = u.formatter,
          d = Xo({
            config: n,
            h: o,
            context: i
          }),
          p = function (e) {
            var t = e.dataset;
            return {
              dataset: {
                title: function (e, n) {
                  return t(e).field(n).title();
                }
              }
            };
          }({
            dataset: s
          }),
          h = a.map(function (e) {
            var t = d.section({
              content: c$1((n.main.section({
                expando: r,
                h: o,
                nodes: e,
                dataset: s,
                formatter: f,
                meta: l,
                create: d,
                util: p
              }) || []).filter(function (e) {
                var t;
                return null === (t = e.content) || void 0 === t ? void 0 : t.length;
              })).filter(Boolean)
            });
            return t.content = function (e) {
              var t = e.config,
                n = e.content,
                r = n.find(function (e) {
                  return "color" === e.type && e.filter;
                }),
                o = r ? n.filter(function (e) {
                  return "measure" !== e.type || e.survive.color || e.label !== r.label || e.value !== r.value;
                }) : n;
              return t.main.showDuplicateMeasures ? o : o.reduce(function (e, t) {
                var n = t.type,
                  r = t.survive;
                if ("measure" !== n || r.duplicate) return e.filtered.push(t), e;
                var o = "".concat(t.label, "-").concat(t.value);
                return e.memory[o] || (e.memory[o] = !0, e.filtered.push(t)), e;
              }, {
                memory: {},
                filtered: []
              }).filtered;
            }({
              config: n,
              content: t.content
            }), t;
          });
        return n.main.sections({
          chart: t,
          expando: r,
          h: o,
          nodes: i.node.nodes,
          dataset: s,
          formatter: f,
          meta: l,
          create: d,
          util: p,
          sections: h
        }), h.filter(Boolean);
      }({
        chart: n,
        config: o,
        expando: i,
        h: a,
        context: f,
        groups: d
      }),
      h = Zo({
        translator: r,
        config: o,
        h: a,
        context: f,
        templates: p
      });
    return h.length ? function (e) {
      var n = e.h,
        r = e.style;
      return e.rows.map(function (e) {
        return n("tr", {}, e.map(function (e) {
          var o = {
            style: t$1(t$1({}, r.cell || {}), e.style || {}),
            class: e.class
          };
          return e.colspan && (o.colspan = e.colspan), n("td", o, e.content);
        }));
      });
    }({
      h: a,
      style: s,
      rows: h
    }) : function (e) {
      var t = e.h;
      return t("tr", {}, t("td", {
        style: {
          fontStyle: "italic",
          opacity: .75
        }
      }, "Empty"));
    }({
      h: a
    });
  }
  function Qo(e) {
    var t = e.chart,
      n = e.translator,
      r = e.config,
      o = e.expando,
      i = e.internal;
    if (!r.main.key) return !1;
    var a = wt(),
      l = Eo({
        key: r.main.key,
        rtl: r.rtl,
        duration: r.duration
      }),
      u = r.main.events.tooltip,
      c = u.afterShow,
      s = u.afterHide,
      f = function () {
        var e = a.get("collected");
        return {
          expando: o,
          nodes: e.nodes,
          meta: e.meta
        };
      };
    return w$1(!0, l, {
      settings: {
        filter: function (e) {
          return Ro({
            chart: t,
            config: r,
            expando: o,
            internal: i,
            nodes: e
          });
        },
        extract: function (e) {
          return a.set("collected", e.node), e;
        },
        content: function (e) {
          var i = e.h,
            a = e.data,
            l = e.style;
          return Jo({
            chart: t,
            translator: n,
            config: r,
            expando: o,
            h: i,
            data: a,
            style: l
          });
        },
        placement: function (e) {
          var t = e.nodes;
          return r.main.placement({
            meta: t[0].meta
          });
        },
        afterShow: function () {
          return c(f());
        },
        afterHide: function () {
          return s(f());
        }
      },
      style: {
        arrow: {
          color: r.style.background
        },
        content: r.style
      }
    });
  }
  function ei(e) {
    var n = e.config,
      r = n.legend.keys;
    if (!r.tooltip || !r.component) return !1;
    if ("categorical" !== n.getColorSettings().type) return !1;
    var o = Eo({
      key: r.tooltip,
      rtl: n.rtl,
      duration: n.duration
    });
    return w$1(!0, o, {
      settings: {
        filter: function (e) {
          return e.filter(function (e) {
            return e.data && e.key === r.component;
          });
        },
        extract: function (e) {
          return e;
        },
        content: function (e) {
          var n = e.h,
            r = e.data;
          return [n("tr", {}, [n("td", {
            style: t$1(t$1({}, e.style.cell || {}), {
              "font-weight": "bold",
              "text-align": "left"
            }),
            colspan: 2
          }, r[0].node.data.label)])];
        },
        placement: "pointer"
      },
      style: {
        arrow: {
          color: n.style.background
        },
        content: n.style
      }
    });
  }
  function ti(e) {
    var t = e.config.main.triggers.reduce(function (e, t) {
      return t.keys.forEach(function (n) {
        var r = t.distance || 0;
        e.distance[n] = r, e.distances.includes(r) || e.distances.push(r), e.key[n] = !0, e.keys[r] || (e.keys[r] = []), e.keys[r].push(n);
      }), e;
    }, {
      distance: {},
      distances: [],
      key: {},
      keys: {}
    });
    return function (e) {
      return e.components.filter(function (e) {
        return t.key[e.key];
      }).reduce(function (e, n) {
        e.any = !0, e.components.push(n.key);
        var r = t.distance[n.key];
        return 0 === r ? e.position.push(n.key) : (e.distances.includes(r) || (e.distances.push(r), e.distanceKeys[r] = []), e.distanceKeys[r].push(n.key)), e;
      }, {
        any: !1,
        components: [],
        position: [],
        distances: [],
        distanceKeys: {}
      });
    };
  }
  var ni = function () {
    return !0;
  };
  function ri(e) {
    var t = e.config.main.triggers.reduce(function (e, t) {
      var n = t.filter;
      return t.keys.forEach(function (t) {
        e[t] = "function" == typeof n ? n : ni;
      }), e;
    }, {});
    return function (e) {
      var n = t[e.key];
      return !n || n(e);
    };
  }
  function oi(e) {
    var t = e.chart,
      n = e.event,
      r = e.component,
      o = {
        absolute: {
          x: 0,
          y: 0
        },
        relative: {
          x: 0,
          y: 0
        }
      },
      i = t.element.getBoundingClientRect(),
      a = i.left,
      l = i.top;
    o.absolute.x = (void 0 === n.clientX ? Math.floor(n.srcEvent.clientX) : n.clientX) - a, o.absolute.y = (void 0 === n.clientY ? Math.floor(n.srcEvent.clientY) : n.clientY) - l;
    var u = t.component(r);
    if (u) {
      var c = u.rect.computedInner;
      o.relative.x = o.absolute.x - c.x, o.relative.y = o.absolute.y - c.y;
    }
    return o;
  }
  function ii(e) {
    var t = e.chart,
      n = e.filter,
      r = e.hits,
      o = e.position,
      i = [];
    if (r.position.length && i.push.apply(i, c$1(t.shapesAt(o.absolute, {
      components: r.position.map(function (e) {
        return {
          key: e
        };
      })
    }).filter(n))), !i.length && r.distances.length) {
      var a = [];
      r.distances.forEach(function (e) {
        a.push.apply(a, c$1(t.shapesAt({
          cx: o.absolute.x,
          cy: o.absolute.y,
          r: e
        }, {
          components: r.distanceKeys[e].map(function (e) {
            return {
              key: e
            };
          })
        }).filter(n)));
      }), a.length && i.push(function (e) {
        var t = e.nodes,
          n = e.origin,
          r = t.find(function (e) {
            return "path" === e.type;
          });
        if (r) return r;
        var o = function (e) {
          var t = Math.abs(n.x - (e.localBounds.x + e.localBounds.width / 2)),
            r = Math.abs(n.y - (e.localBounds.y + e.localBounds.height / 2));
          return Math.sqrt(t * t + r * r);
        };
        return t.slice(1).reduce(function (e, t) {
          var n = o(t);
          return n < e.distance && (e.distance = n, e.node = t), e;
        }, {
          node: t[0],
          distance: o(t[0])
        }).node;
      }({
        nodes: a,
        origin: o.relative
      }));
    }
    return i;
  }
  function ai(e) {
    var t = e.chart,
      n = e.config,
      r = e.expando,
      o = e.internal,
      i = e.facade,
      l = n.delay.tap,
      s = ti({
        config: n
      }),
      f = ri({
        config: n
      }),
      d = n.main.triggers.reduce(function (e, t) {
        return e.push.apply(e, c$1(t.keys)), e;
      }, []);
    return {
      key: "event:".concat("tooltipTap"),
      type: "Tap",
      options: {
        event: "tooltipTap",
        enable: function (e, r) {
          return !r || !!n.enable({
            event: r
          }) && t.componentsFromPoint({
            x: r.center.x,
            y: r.center.y
          }).filter(function (e) {
            return -1 !== d.indexOf(e.key);
          }).length > 0;
        }
      },
      recognizeWith: "tap",
      events: a$1({}, "tooltipTap", function (e) {
        if (e.preventDefault(), "mouse" !== e.pointerType && !n.main.suppress({
          event: e
        })) {
          var a = t.component(n.main.key);
          if (a && a.show) {
            var c = t.componentsFromPoint({
                x: e.center.x,
                y: e.center.y
              }),
              d = s({
                components: c
              });
            if (d.any) {
              var p = u$1(d.components, 1)[0],
                h = oi({
                  chart: t,
                  event: e,
                  component: p
                });
              o.set(Ao, h);
              var m = ii({
                chart: t,
                filter: f,
                hits: d,
                position: h
              });
              if (m.length) {
                var v = m[0].key;
                n.main.events.tooltip.beforeShow({
                  expando: r,
                  event: e,
                  collectNodes: function () {
                    return i.collectNodes({
                      nodes: m
                    });
                  },
                  meta: {
                    triggerer: v,
                    position: h
                  }
                }).then(function () {
                  a.emit("show", e, {
                    nodes: m,
                    delay: l
                  });
                }).catch(function () {});
              } else a.emit("hide");
            } else a.emit("hide");
          }
        }
      })
    };
  }
  function li(e) {
    var t = e.config,
      n = e.expando,
      r = e.internal,
      o = e.facade,
      i = t.main.events.tooltip.beforeShow,
      a = t.delay.hover,
      l = {
        ongoing: {},
        latest: void 0
      };
    return function (e) {
      var t = e.event,
        u = e.tooltip,
        c = e.nodes,
        s = function (e) {
          var t = e.nodes;
          return JSON.stringify(t.map(function (e) {
            var t;
            return {
              key: e.key,
              bounds: e.bounds,
              value: null === (t = e.data) || void 0 === t ? void 0 : t.value
            };
          }));
        }({
          nodes: c
        });
      if (!l.ongoing[s]) {
        l.ongoing[s] = !0, l.latest = s;
        var f = c[0].key;
        i({
          expando: n,
          event: t,
          collectNodes: function () {
            return o.collectNodes({
              nodes: c
            });
          },
          meta: {
            triggerer: f,
            position: r.get(Ao)
          }
        }).then(function () {
          s === l.latest && u.emit("show", t, {
            nodes: c,
            delay: a
          });
        }).catch(function () {
          u.emit("show");
        }).finally(function () {
          delete l.ongoing[s], s === l.latest && (l.latest = void 0);
        });
      }
    };
  }
  function ui(e) {
    var t = e.chart,
      n = e.config,
      r = e.expando,
      o = e.internal,
      i = e.facade,
      a = ti({
        config: n
      }),
      l = ri({
        config: n
      }),
      c = li({
        config: n,
        expando: r,
        internal: o,
        facade: i
      }),
      s = [n.main.key, n.legend.keys.tooltip].filter(Boolean),
      f = function () {
        s.forEach(function (e) {
          var n = t.component(e);
          null != n && n.show && n.emit("hide");
        });
      };
    return {
      type: "native",
      events: {
        mousemove: function (e) {
          if (n.enable({
            event: e
          }) && !n.main.suppress({
            event: e
          })) {
            var r = t.componentsFromPoint({
                x: e.clientX,
                y: e.clientY
              }),
              i = t.component(n.main.key);
            if (i && i.show) {
              var s = a({
                components: r
              });
              if (s.any) {
                var f = u$1(s.components, 1)[0],
                  d = oi({
                    chart: t,
                    event: e,
                    component: f
                  });
                o.set(Ao, d);
                var p = ii({
                  chart: t,
                  filter: l,
                  hits: s,
                  position: d
                });
                if (!p.length) return void i.emit("hide");
                c({
                  event: e,
                  tooltip: i,
                  nodes: p
                });
              } else i.emit("hide");
            }
            var h = n.legend;
            if (h.keys.tooltip && h.keys.component) {
              var m = t.component(h.keys.tooltip);
              m && m.show && (r.some(function (e) {
                return e.key === h.keys.component;
              }) ? m.emit("show", e) : m.emit("hide"));
            }
          }
        },
        mouseup: function (e) {
          2 === e.button && f();
        },
        mouseleave: function () {
          n.main.events.interaction.mouseleave({
            expando: r
          }), f();
        },
        wheel: function () {
          f();
        }
      }
    };
  }
  function ci(e) {
    var t = e.chart,
      n = e.config,
      r = e.expando,
      o = e.internal,
      i = function (e) {
        var t = e.chart,
          n = e.config,
          r = e.expando,
          o = e.internal;
        return {
          collectNodes: function (e) {
            var i = e.nodes,
              a = u$1(Ro({
                chart: t,
                config: n,
                expando: r,
                internal: o,
                nodes: i
              }), 1)[0];
            return (void 0 === a ? {
              nodes: []
            } : a).nodes;
          }
        };
      }({
        chart: t,
        config: n,
        expando: r,
        internal: o
      });
    return {
      gestures: [ai({
        chart: t,
        config: n,
        expando: r,
        internal: o,
        facade: i
      })],
      native: ui({
        chart: t,
        config: n,
        expando: r,
        internal: o,
        facade: i
      })
    };
  }
  function si(e) {
    var t = e.chart,
      n = e.translator,
      r = function (e) {
        var t = e.config;
        return w$1(!0, {}, {
          rtl: !1,
          enable: Co.FALSE,
          getColorSettings: Co.OBJECT,
          style: {
            fontSize: void 0,
            fontFamily: void 0,
            color: void 0,
            background: void 0
          },
          delay: {
            hover: 500,
            tap: 0
          },
          duration: 8e3,
          main: {
            key: void 0,
            suppress: Co.FALSE,
            getGroupByValue: Co.NOOP,
            collectibles: [],
            triggers: [],
            placement: function () {
              return {
                type: "bounds"
              };
            },
            placements: {
              collectible: "combine"
            },
            showDuplicateMeasures: !1,
            layout: {
              rows: 7,
              grouping: !1,
              single: !1
            },
            section: Co.ARRAY,
            sections: Co.NOOP,
            events: {
              tooltip: {
                beforeShow: function () {
                  return Promise.resolve();
                },
                afterShow: Co.NOOP,
                afterHide: Co.NOOP
              },
              interaction: {
                mouseleave: Co.NOOP
              }
            }
          },
          legend: {
            keys: {
              tooltip: void 0,
              component: void 0
            }
          }
        }, void 0 === t ? {} : t);
      }({
        config: e.config
      }),
      o = wt(),
      i = wt(),
      a = {
        components: void 0,
        interactions: void 0
      };
    return {
      getComponents: function () {
        return a.components || (a.components = function (e) {
          var t = e.chart,
            n = e.translator,
            r = e.config;
          return [Qo({
            chart: t,
            translator: n,
            config: r,
            expando: e.expando,
            internal: e.internal
          }), ei({
            config: r
          })].filter(Boolean);
        }({
          chart: t,
          translator: n,
          config: r,
          expando: o,
          internal: i
        })), a.components;
      },
      getInteractions: function () {
        return a.interactions || (a.interactions = ci({
          chart: t,
          config: r,
          expando: o,
          internal: i
        })), a.interactions;
      },
      expando: o
    };
  }
  var Hi = ["American Typewriter, serif", "Andalé Mono, monospace", "Arial Black, sans-serif", "Arial, sans-serif", "Bradley Hand, cursive", "Brush Script MT, cursive", "Comic Sans MS, cursive", "Courier, monospace", "Didot, serif", "Georgia, serif", "Impact, sans-serif", "Lucida Console, monospace", "Luminari, fantasy", "Monaco, monospace", "QlikView Sans, sans-serif", "Source Sans Pro, sans-serif", "Tahoma, sans-serif", "Times New Roman, serif", "Trebuchet MS, sans-serif", "Verdana, sans-serif"],
    Ri = ["Abril Fatface, serif", "Bangers, fantasy", "Bebas Neue, sans serif", "EB Garamond, serif", "Fredoka One, fantasy", "Graduate, fantasy", "Gravitas One, serif", "Indie Flower, fantasy", "Inter, sans-serif", "Lobster, fantasy", "Montserrat, sans-serif", "Nixie One, sans-serif", "Noto Sans, sans-serif", "Open Sans, sans-serif", "PT Serif, serif", "Pacifico, cursive", "Permanent Marker, fantasy", "QlikView Sans, sans-serif", "Raleway, sans-serif", "Rammetto One, fantasy", "Roboto, sans-serif", "Source Sans Pro, sans-serif", "Titan One, fantasy", "Yanone Kaffeesatz, sans-serif"];
  function zi(e) {
    return null != e && e.isEnabled("PS_20852_WYSIWYG_FONT_SUPPORT") ? Ri : Hi;
  }
  var Vi = function (e) {
    return {
      value: e,
      label: e.charAt(0).toUpperCase() + e.slice(1),
      groupHeader: !1,
      disabled: !1,
      styles: {
        fontFamily: e
      }
    };
  };
  function _i(e) {
    var t = e.theme,
      n = e.translator,
      r = e.defaultValue,
      o = e.flags,
      i = [],
      a = t.getStyle("", "", "fontFamilies");
    return Array.isArray(a) && a.length ? i.push.apply(i, c$1(new Set([r].concat(c$1(a.map(function (e) {
      return e.split(",").map(function (e) {
        return e.trim();
      }).map(function (e) {
        return e.replace(/\s+/g, " ").trim();
      }).filter(Boolean).join(", ");
    })))))) : i.push(r), [{
      value: "ThemeHeader",
      label: n.get("properties.themeFonts"),
      metaText: n.get("properties.theme"),
      groupHeader: !0
    }].concat(c$1(i.map(function (e) {
      return Vi(e);
    })), [{
      value: "DefaultHeader",
      label: n.get("properties.allFonts"),
      metaText: n.get("properties.default"),
      groupHeader: !0
    }], c$1(zi(o).map(function (e) {
      return Vi(e);
    })));
  }
  function Bi(e) {
    var t = e.theme,
      n = e.translator,
      r = e.id,
      o = e.path,
      i = e.flags,
      a = function () {
        return t.getStyle(r, o, "fontFamily");
      };
    return {
      getDefaultValue: function () {
        return a();
      },
      getOptions: function () {
        return _i({
          theme: t,
          translator: n,
          defaultValue: a(),
          flags: i
        });
      }
    };
  }
  var Yi = ["10px", "11px", "12px", "13px", "14px", "15px", "16px", "17px", "18px", "19px", "20px", "21px", "22px", "23px", "24px"],
    $i = function (e) {
      return {
        value: e,
        label: e,
        groupHeader: !1,
        disabled: !1
      };
    };
  function Ui(e) {
    var t = e.theme,
      n = e.translator,
      r = e.id,
      o = e.path,
      i = function () {
        return t.getStyle(r, o, "fontSize");
      };
    return {
      getDefaultValue: function () {
        return i();
      },
      getOptions: function () {
        return function (e) {
          var t = e.theme,
            n = e.translator,
            r = e.defaultValue,
            o = [],
            i = t.getStyle("", "", "fontSizes");
          return Array.isArray(i) && i.length ? o.push.apply(o, c$1(new Set([r].concat(c$1(i))))) : o.push(r), [{
            value: "ThemeHeader",
            label: n.get("properties.themeFontSizes"),
            metaText: n.get("properties.theme"),
            groupHeader: !0
          }].concat(c$1(o.map(function (e) {
            return $i(e);
          })), [{
            value: "DefaultHeader",
            label: n.get("properties.allFontSizes"),
            metaText: n.get("properties.default"),
            groupHeader: !0
          }], c$1(Yi.map(function (e) {
            return $i(e);
          })));
        }({
          theme: t,
          translator: n,
          defaultValue: i()
        });
      }
    };
  }
  function Ki(e) {
    var t = e.theme,
      n = e.translator,
      r = e.id,
      o = e.path;
    return {
      fontFamily: Bi({
        theme: t,
        translator: n,
        id: r,
        path: o,
        flags: e.flags
      }),
      fontSize: Ui({
        theme: t,
        translator: n,
        id: r,
        path: o
      })
    };
  }
  function Gi(e) {
    var t = e.theme,
      n = e.translator,
      r = e.config,
      o = void 0 === r ? {} : r,
      i = e.flags,
      a = function (e) {
        var t = e.config,
          n = void 0 === t ? {} : t,
          r = n.id,
          o = n.paths;
        return {
          id: void 0 === r ? "object" : "".concat("object", ".").concat(r),
          paths: Array.isArray(o) ? o : []
        };
      }({
        config: o
      }),
      l = a.id,
      u = a.paths,
      c = {};
    u.forEach(function (e) {
      for (var r = e.split("."), o = c, a = 0; a < r.length; a++) {
        var u = r[a];
        a === r.length - 1 ? o[u] = Ki({
          theme: t,
          translator: n,
          id: l,
          path: e,
          flags: i
        }) : void 0 === o[u] && (o[u] = {}), o = o[u];
      }
    });
    var s = function (e) {
      for (var t = e.split("."), n = c, r = 0; r < t.length; r++) {
        var o = t[r];
        if (void 0 === n[o]) throw new Error("font-resolver: Path '".concat(e, "' could not be resolved."));
        n = n[o];
      }
      return n;
    };
    return c.getDefaultValue = function (e) {
      return s(e).getDefaultValue();
    }, c.getOptions = function (e) {
      return s(e).getOptions();
    }, c;
  }

  var PATHS = {
    dataRelatedPropertiesPaths: ['qHyperCube.qGrandTotalRow', 'qHyperCube.qHasOtherValues', 'qHyperCube.qSize', 'qHyperCube.qDimensionInfo[].qAttrDimInfo', 'qHyperCube.qDimensionInfo[].qCardinalities', 'qHyperCube.qDimensionInfo[].qMax', 'qHyperCube.qDimensionInfo[].qMin', 'qHyperCube.qDimensionInfo[].qStateCounts', 'qHyperCube.qMeasureInfo[].qApprMaxGlyphCount', 'qHyperCube.qMeasureInfo[].qAttrExprInfo', 'qHyperCube.qMeasureInfo[].qMax', 'qHyperCube.qMeasureInfo[].qMin', 'qHyperCube.qMeasureInfo[].qTrendLines', 'qHyperCube.qTreeNodesOnDim', 'qSelectionInfo']
  };

  /* Purpose of properties-handler.js
  Chart animations should run when and only when chart data have changed. So in general, we should disable animations if a property
  like show/hide axis label or chart orientation has changed since the data remain the same.
  However, some special properties like qMin/qMax change when the data in the layout (qAxisData, qDataPages, qStackedDataPages,
  or qTreeDataPages) change. These data-related properties, listed in paths.js, should be ignored by the animation disabling logic
  to ensure chart animations still run when data change. */

  /* Purpose of extractProperties function
  We collect "data-independent" properties from layout. Animations will be disabled when these properties change.
  At the same time, we ignore data (qAxisData, qDataPages, qStackedDataPages, or qTreeDataPages) and "data-related" properties
  from layout, since changes to them should not trigger disabling animations.
   */

  function extractProperties(layout) {
    // Destructuring to improve performance when data are large
    const {
      qHyperCube,
      ...restOfLayout
    } = layout;
    const {
      qAxisData,
      qDataPages,
      qStackedDataPages,
      qTreeDataPages,
      ...restOfCube
    } = qHyperCube;
    const properties = extend$7(true, {}, {
      ...restOfLayout,
      qHyperCube: {
        ...restOfCube,
        qAxisData: null,
        qDataPages: null,
        qStackedDataPages: null,
        qTreeDataPages: null
      }
    });
    const {
      dataRelatedPropertiesPaths: ignoredPaths
    } = PATHS;
    ignoredPaths.forEach(path => {
      const subPaths = path.split('[');
      if (subPaths.length === 1) {
        if (bt(properties, path) !== undefined) {
          qt(properties, path, null);
        }
      } else {
        const arrayPath = subPaths[0];
        const propPath = subPaths[1].split('].')[1];
        const array = bt(properties, arrayPath, []);
        array.forEach(element => {
          if (bt(element, propPath) !== undefined) {
            qt(element, propPath, null);
          }
        });
      }
    });
    return properties;
  }
  function cacheProperties({
    viewCache,
    layout
  }) {
    const properties = extractProperties(layout);
    viewCache.set('dataIndependentProperties', JSON.stringify(properties));
  }
  function propertiesHaveChanged({
    viewCache,
    layout
  }) {
    const properties = extractProperties(layout);
    return viewCache.get('dataIndependentProperties') !== JSON.stringify(properties);
  }

  var animations = {
    axes: {
      trackBy: trackByAxes,
      compensateForLayoutChanges: compensateAxesForLayoutChanges
    },
    bars: {
      trackBy: trackByBars,
      compensateForLayoutChanges: compensateBarsForLayoutChanges
    },
    barOobs: {
      compensateForLayoutChanges: compensateBarOobsForLayoutChanges
    },
    labels: {
      trackBy: trackByLabels,
      compensateForLayoutChanges: compensateLabelsForLayoutChanges,
      linkData: linkDataForLabels
    },
    lines: {
      trackBy: trackByLines,
      compensateForLayoutChanges: compensateLinesForLayoutChanges
    },
    lineOobs: {
      compensateForLayoutChanges: compensateLineOobsForLayoutChanges
    },
    points: {
      trackBy: trackByPoints,
      compensateForLayoutChanges: compensatePointsForLayoutChanges
    },
    refLineLabels: {
      trackBy: trackByRefLineLabels,
      compensateForLayoutChanges: compensateRefLineLabelsForLayoutChanges
    },
    shadowBars: {
      trackBy: trackByShadowBars
    },
    cacheProperties,
    propertiesHaveChanged,
    nonUpdatingNode: {
      trackBy: trackByNonUpdatingNode
    }
  };

  const {
    getInputValue,
    extractInfoFromInputValue,
    resolveValue
  } = refLineHelper;
  var refLineResolver = {
    resolveValue,
    resolveInnerValues: ({
      refLineLayout,
      refLineModel,
      layoutService
    }) => {
      if (layoutService.meta.isGroupedByDimension) {
        const inputValue = getInputValue({
          refLineLayout,
          layoutService
        });
        return extractInfoFromInputValue(inputValue, refLineModel, 'innerValues');
      }
      return undefined;
    },
    resolveNumInnerValues: ({
      refLineLayout,
      refLineModel,
      layoutService
    }) => {
      if (layoutService.meta.mode.K) {
        return 0;
      }
      const inputValue = getInputValue({
        refLineLayout,
        layoutService
      });
      return extractInfoFromInputValue(inputValue, refLineModel, 'numInnerValues') || 0;
    },
    resolveValueText: ({
      refLineLayout,
      refLineModel,
      layoutService
    }) => {
      const {
        dimensionValuesInfo
      } = refLineModel;
      const {
        canBeContinuous
      } = layoutService.meta;
      const inputValue = getInputValue({
        refLineLayout,
        layoutService
      });
      if (dimensionValuesInfo[inputValue]) {
        return canBeContinuous ? dimensionValuesInfo[inputValue].qText : inputValue;
      }
      return inputValue;
    },
    resolveValueInfo: ({
      refLineLayout,
      refLineModel,
      layoutService
    }) => {
      const inputValue = getInputValue({
        refLineLayout,
        layoutService
      });
      const {
        dimensionRefLineInfo
      } = refLineModel;
      return dimensionRefLineInfo[inputValue];
    }
  };

  const refLine$1 = ({
    isDimension,
    refLineLayout,
    refLineModel,
    layoutService,
    colorModel,
    dockService,
    chart,
    scale,
    axis,
    invert,
    component,
    isContinuous
  }) => {
    var _refLineLayout$style, _refLineLayout$style2;
    const settings = {
      dir: axis,
      line: {
        strokeWidth: (refLineLayout === null || refLineLayout === void 0 || (_refLineLayout$style = refLineLayout.style) === null || _refLineLayout$style === void 0 ? void 0 : _refLineLayout$style.lineThickness) || 2,
        strokeDasharray: refLineLayout === null || refLineLayout === void 0 || (_refLineLayout$style2 = refLineLayout.style) === null || _refLineLayout$style2 === void 0 ? void 0 : _refLineLayout$style2.lineType,
        stroke: colorModel.resolveUIColor(refLineLayout.paletteColor || {
          index: refLineLayout.color
        })
      }
    };
    if (!isDimension || layoutService.meta.isContinuous) {
      settings.scale = scale;
      settings.value = refLineLayout.refLineExpr.value;
    } else {
      settings.valueInfo = refLineResolver.resolveValueInfo({
        refLineLayout,
        refLineModel,
        layoutService
      });
      settings.value = () => {
        var _chart$component;
        const position = refLineHelper.getScaledPosition({
          scale: chart.scale(scale),
          value: refLineResolver.resolveValue({
            refLineLayout,
            refLineModel,
            layoutService
          }),
          valueInfo: settings.valueInfo,
          size: (_chart$component = chart.component(component)) === null || _chart$component === void 0 ? void 0 : _chart$component.rect[dockService.meta.major.orientation === 'horizontal' ? 'width' : 'height'],
          align: refLineLayout.align,
          invert,
          layoutService,
          isContinuous
        });
        return Number.isNaN(position) ? undefined : position;
      };
    }
    return settings;
  };

  function createRefLines({
    isDimension,
    refLineModel = {},
    layoutService,
    colorModel,
    dockService,
    animationsEnabled,
    chart,
    scale,
    axis,
    rtl,
    key,
    mainComponentKey,
    path,
    minimumLayoutMode
  }) {
    const getRefLines = () => {
      if (isDimension) {
        return refLineModel.dimensionRefLines;
      }
      return path ? refLineModel.query.getRefLines(path) : refLineModel.measureRefLines;
    };
    const refLines = getRefLines();
    if (!refLines.length) {
      return false;
    }
    const setting = {
      key,
      type: 'ref-line',
      layout: {
        minimumLayoutMode
      },
      lines: {
        y: [],
        x: []
      },
      style: {
        oob: {
          show: false
        }
      },
      preferredSize() {
        return {
          size: 0,
          edgeBleed: {
            left: 1,
            right: 1,
            top: 1,
            bottom: 1
          }
        };
      },
      animations: {
        enabled: animationsEnabled,
        trackBy: animations.lines.trackBy,
        compensateForLayoutChanges: animations.lines.compensateForLayoutChanges
      }
    };
    const invert = !!(isDimension && dockService.meta.major.orientation === 'horizontal' && rtl);
    const isContinuous = isDimension ? layoutService.meta.isContinuous : true;
    refLines.forEach(refLineLayout => {
      setting.lines[axis].push(refLine$1({
        isDimension,
        refLineLayout,
        refLineModel,
        layoutService,
        colorModel,
        dockService,
        chart,
        scale,
        axis,
        invert,
        component: mainComponentKey,
        isContinuous
      }));
    });
    return setting;
  }

  const defaultStyle = {
    referenceLine: {
      label: {
        name: {
          fontFamily: 'Source Sans Pro, sans-serif',
          fontSize: '12px'
        }
      },
      outOfBounds: {
        backgroundColor: '#737373',
        color: '#e6e6e6',
        fontFamily: 'Source Sans Pro, sans-serif',
        fontSize: '10px'
      }
    }
  };
  const getDefinition = ({
    isDimension,
    layoutService,
    animationsEnabled,
    style,
    labels,
    scale,
    formatter,
    dock,
    key,
    rtl,
    theme,
    isContinuous,
    localeInfo
  }) => ({
    key,
    type: 'reference-line-labels',
    renderer: 'svg',
    labels,
    formatter,
    scale,
    layoutService,
    layout: {
      dock,
      rtl
    },
    theme,
    isContinuous,
    isDimension,
    localeInfo,
    style: {
      label: {
        fontFamily: style.referenceLine.label.name.fontFamily,
        fontSize: style.referenceLine.label.name.fontSize,
        padding: {
          top: 2,
          bottom: 2,
          left: rtl ? 2 : 4,
          right: rtl ? 4 : 2
        },
        background: {
          padding: {
            top: 1,
            bottom: 1,
            left: 2,
            right: 2
          }
        },
        maxWidth: 100,
        gap: dock === 'left' || dock === 'right' ? 10 : 16
      },
      oob: {
        size: 8,
        fill: style.referenceLine.outOfBounds.backgroundColor,
        text: {
          fontFamily: style.referenceLine.outOfBounds.fontFamily,
          fontSize: style.referenceLine.outOfBounds.fontSize,
          fill: style.referenceLine.outOfBounds.color,
          background: {
            fill: style.referenceLine.outOfBounds.backgroundColor
          }
        }
      }
    },
    animations: {
      enabled: animationsEnabled,
      trackBy: animations.refLineLabels.trackBy,
      compensateForLayoutChanges: animations.refLineLabels.compensateForLayoutChanges
    }
  });
  const createLabels = ({
    refLineLayout,
    refLineModel,
    layoutService,
    colorModel,
    scale,
    theme,
    isContinuous
  }) => {
    const fill = colorModel.resolveUIColor(refLineLayout.paletteColor || {
      index: refLineLayout.color
    });
    const settings = {
      align: refLineLayout.align,
      text: refLineLayout.label,
      fill: refLineLayout.coloredBackground ? theme.getContrastingColorTo(fill) : fill,
      showValue: refLineLayout.showValue !== false,
      showLabel: refLineLayout.showLabel !== false,
      inputValue: refLineLayout.refLineExpr.value,
      inputValueLabel: refLineLayout.refLineExpr.label
    };
    if (refLineLayout.coloredBackground) {
      settings.background = {
        fill
      };
    }
    if (isContinuous) {
      settings.scale = scale;
      settings.value = refLineLayout.refLineExpr.value;
    } else {
      settings.value = () => refLineResolver.resolveValue({
        refLineLayout,
        refLineModel,
        layoutService
      });
      settings.valueText = () => refLineResolver.resolveValueText({
        refLineLayout,
        refLineModel,
        layoutService
      });
      settings.valueInfo = () => refLineResolver.resolveValueInfo({
        refLineLayout,
        refLineModel,
        layoutService
      });
    }
    return settings;
  };
  function createRefLineLabels({
    isDimension,
    refLineModel = {},
    layoutService,
    colorModel,
    animationsEnabled,
    dock,
    scale,
    style,
    formatter,
    theme,
    localeInfo,
    rtl,
    key,
    path
  }) {
    const getRefLineLabels = () => {
      if (isDimension) {
        return refLineModel.dimensionRefLineLabels;
      }
      return path ? refLineModel.query.getRefLineLabels(path) : refLineModel.measureRefLineLabels;
    };
    const refLineLabels = getRefLineLabels();
    if (!refLineLabels.length) {
      return [];
    }
    const refLineLabelDefs = [];
    const isContinuous = isDimension ? layoutService.meta.isContinuous : true;
    const labels = refLineLabels.map(refLineLayout => createLabels({
      refLineLayout,
      refLineModel,
      layoutService,
      colorModel,
      scale,
      theme,
      isContinuous
    }));
    refLineLabelDefs.push(getDefinition({
      isDimension,
      rtl,
      style: extend$7(true, defaultStyle, style),
      dock,
      key,
      labels,
      scale,
      formatter,
      layoutService,
      animationsEnabled,
      theme,
      isContinuous,
      localeInfo
    }));
    return refLineLabelDefs;
  }

  function createRefLineModel({
    layoutService,
    discreteModel
  }) {
    const {
      isContinuous,
      canBeContinuous,
      isGroupedByDimension
    } = layoutService.meta;
    const layout = layoutService.getLayout();
    const isKMode = layout.qHyperCube.qMode === 'K';
    const isDimensionless = isType.dimensionless(layout);
    const measureRefLines = refLineHelper.getMeasureRefLines(layout);
    const dimensionRefLines = refLineHelper.getDimensionRefLines(layout, isDimensionless);
    const measureRefLineLabels = refLineHelper.getMeasureRefLineLabels(layout);
    const dimensionRefLineLabels = refLineHelper.getDimensionRefLineLabels(layout, isDimensionless);
    let dimensionValuesInfo = {};
    let dimensionRefLineInfo = {};
    const isOutOfRange = inputValue => {
      if (canBeContinuous) {
        const dimInfo = layoutService.getLayoutValue('qHyperCube.qDimensionInfo.0');
        const {
          qMin,
          qMax
        } = dimInfo;
        return refLineHelper.isOutOfRange({
          value: inputValue,
          qMin,
          qMax
        });
      }
      return false;
    };
    const isOutOfDataPagesOrCalculated = inputValue => {
      if (!dimensionRefLineInfo[inputValue]) {
        return false;
      }
      if (!isContinuous && isGroupedByDimension) {
        const valueInfo = dimensionRefLineInfo[inputValue];
        const label = {
          valueInfo
        };
        const path = layoutService.getHyperCubeValue('qMode') === 'S' ? 'qDataPages.0' : 'qStackedDataPages.0';
        const dataPages = layoutService.getHyperCubeValue(path);
        return refLineHelper.isOutOfDataPages({
          label,
          dataPages
        });
      }
      return true;
    };
    const shouldRunUpdate = () => {
      if (!dimensionRefLines || !dimensionRefLines.length) {
        return false;
      }
      return !dimensionRefLines.every(refLineLayout => {
        const inputValue = refLineHelper.getInputValue({
          refLineLayout,
          layoutService
        });
        return isOutOfRange(inputValue) || isOutOfDataPagesOrCalculated(inputValue);
      });
    };
    const model = {
      isKMode,
      canBeContinuous,
      measureRefLines,
      dimensionRefLines,
      measureRefLineLabels,
      dimensionRefLineLabels,
      dimensionRefLineInfo,
      dimensionValuesInfo,
      query: {
        getRefLines: path => refLineHelper.getRefLines(layout, path),
        getRefLineLabels: path => refLineHelper.getRefLineLabels(layout, path)
      },
      update: () => {
        dimensionRefLineInfo = model.dimensionRefLineInfo;
        if (shouldRunUpdate()) {
          dimensionValuesInfo = refLineHelper.getDimensionValuesInfo({
            layout,
            canBeContinuous,
            discreteModel,
            layoutService
          });
          model.dimensionValuesInfo = dimensionValuesInfo;
          dimensionRefLines.forEach(refLineLayout => {
            const inputValue = refLineHelper.getInputValue({
              refLineLayout,
              layoutService
            });
            if (dimensionValuesInfo[inputValue]) {
              if (dimensionRefLineInfo[inputValue]) {
                dimensionRefLineInfo[inputValue].innerValues = dimensionValuesInfo[inputValue].innerValues;
                dimensionRefLineInfo[inputValue].minOrder = Math.min(dimensionRefLineInfo[inputValue].minOrder, dimensionValuesInfo[inputValue].minOrder);
                dimensionRefLineInfo[inputValue].maxOrder = Math.max(dimensionRefLineInfo[inputValue].maxOrder, dimensionValuesInfo[inputValue].maxOrder);
                dimensionRefLineInfo[inputValue].isMinOrderOk = dimensionRefLineInfo[inputValue].isMinOrderOk || dimensionValuesInfo[inputValue].isMinOrderOk;
                dimensionRefLineInfo[inputValue].isMaxOrderOk = dimensionRefLineInfo[inputValue].isMaxOrderOk || dimensionValuesInfo[inputValue].isMaxOrderOk;
              } else {
                dimensionRefLineInfo[inputValue] = {
                  id: dimensionValuesInfo[inputValue].id,
                  qText: dimensionValuesInfo[inputValue].qText,
                  innerValues: dimensionValuesInfo[inputValue].innerValues,
                  minOrder: dimensionValuesInfo[inputValue].minOrder,
                  maxOrder: dimensionValuesInfo[inputValue].maxOrder,
                  isMinOrderOk: dimensionValuesInfo[inputValue].isMinOrderOk,
                  isMaxOrderOk: dimensionValuesInfo[inputValue].isMaxOrderOk
                };
              }
              dimensionRefLineInfo[inputValue].numInnerValues = (dimensionRefLineInfo[inputValue].maxOrder || 0) - (dimensionRefLineInfo[inputValue].minOrder || 0) + 1;
            }
          });
        }
      }
    };
    model.update();
    return model;
  }

  const saveSoftProperties = (model, prevEffectiveProperties, effectiveProperties) => {
    if (!model) {
      return Promise.resolve();
    }
    let patches = JSONPatch.generate(prevEffectiveProperties, effectiveProperties);
    extend$7(true, prevEffectiveProperties, effectiveProperties);
    if (patches && patches.length) {
      patches = patches.map(p => ({
        qOp: p.op,
        qValue: JSON.stringify(p.value),
        qPath: p.path
      }));
      return model.applyPatches(patches, true);
    }
    return Promise.resolve();
  };

  const canSetProperties = layout => {
    var _layout$qMeta;
    return !!(layout && !layout.qHasSoftPatches && !layout.qExtendsId && (((_layout$qMeta = layout.qMeta) === null || _layout$qMeta === void 0 ? void 0 : _layout$qMeta.privileges) || []).indexOf('update') > -1);
  };

  function getTextRenderer(flags) {
    if (!(flags !== null && flags !== void 0 && flags.isEnabled('IM_4962_SVG_CHART_LABELS'))) {
      return undefined;
    }
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ? undefined : 'svg';
  }

  /* eslint-disable no-param-reassign */
  function getAttributeExpressionIndexes({
    properties,
    filtered
  }) {
    const {
      qMeasures: measures
    } = properties.qHyperCubeDef || [];
    const {
      current,
      target
    } = measures.reduce((result, measure, index) => {
      var _measure$qAttributeEx;
      if (((_measure$qAttributeEx = measure.qAttributeExpressions[0]) === null || _measure$qAttributeEx === void 0 ? void 0 : _measure$qAttributeEx.id) === 'colorByExpression') {
        result.current = index;
      }
      if (result.target === undefined && !filtered.includes(index)) {
        result.target = index;
      }
      return result;
    }, {
      current: undefined,
      target: undefined
    });
    return {
      current,
      target
    };
  }

  function patchColoring({
    properties,
    layoutService
  }) {
    const {
      filteredFields
    } = layoutService.meta;
    const hasFilteredMeasure = filteredFields.measures.length > 0;
    if (!hasFilteredMeasure) {
      return;
    }
    const {
      mode
    } = properties.color || {};
    if (mode === 'byExpression') {
      var _layout$qHyperCube$qM;
      const layout = layoutService.getLayout();
      if (((_layout$qHyperCube$qM = layout.qHyperCube.qMeasureInfo) === null || _layout$qHyperCube$qM === void 0 || (_layout$qHyperCube$qM = _layout$qHyperCube$qM[0]) === null || _layout$qHyperCube$qM === void 0 || (_layout$qHyperCube$qM = _layout$qHyperCube$qM.qAttrExprInfo) === null || _layout$qHyperCube$qM === void 0 || (_layout$qHyperCube$qM = _layout$qHyperCube$qM[0]) === null || _layout$qHyperCube$qM === void 0 ? void 0 : _layout$qHyperCube$qM.id) === 'colorByExpression') {
        return;
      }
      const {
        current,
        target
      } = getAttributeExpressionIndexes({
        properties,
        filtered: filteredFields.measures
      });
      if (current === undefined) {
        return;
      }
      const attributeExpression = properties.qHyperCubeDef.qMeasures[current].qAttributeExpressions[0];
      properties.qHyperCubeDef.qMeasures[current].qAttributeExpressions.splice(0, 1);
      properties.qHyperCubeDef.qMeasures[target].qAttributeExpressions.splice(0, 0, attributeExpression);
    }
  }

  /* eslint-disable import/prefer-default-export */
  const attributeExpression = {
    ref: null,
    refFn: data => {
      var _data$qHyperCubeDef$q;
      const index = (_data$qHyperCubeDef$q = data.qHyperCubeDef.qMeasures) === null || _data$qHyperCubeDef$q === void 0 ? void 0 : _data$qHyperCubeDef$q.findIndex(m => {
        var _m$qAttributeExpressi;
        return ((_m$qAttributeExpressi = m.qAttributeExpressions) === null || _m$qAttributeExpressi === void 0 || (_m$qAttributeExpressi = _m$qAttributeExpressi[0]) === null || _m$qAttributeExpressi === void 0 ? void 0 : _m$qAttributeExpressi.id) === 'colorByExpression';
      });
      return `qHyperCubeDef.qMeasures.${index === -1 ? 0 : index}.qAttributeExpressions.0.qExpression`;
    },
    change(itemData) {
      var _itemData$qHyperCubeD;
      const index = (_itemData$qHyperCubeD = itemData.qHyperCubeDef) === null || _itemData$qHyperCubeD === void 0 || (_itemData$qHyperCubeD = _itemData$qHyperCubeD.qMeasures) === null || _itemData$qHyperCubeD === void 0 ? void 0 : _itemData$qHyperCubeD.findIndex(m => {
        var _m$qAttributeExpressi2;
        return ((_m$qAttributeExpressi2 = m.qAttributeExpressions) === null || _m$qAttributeExpressi2 === void 0 || (_m$qAttributeExpressi2 = _m$qAttributeExpressi2[0]) === null || _m$qAttributeExpressi2 === void 0 ? void 0 : _m$qAttributeExpressi2.id) === 'colorByExpression';
      });
      const attributes = util$2.getValue(itemData, `qHyperCubeDef.qMeasures.${index === -1 ? 0 : index}.qAttributeExpressions.0`);
      const color = util$2.getValue(itemData, 'color');
      if (attributes) {
        attributes.id = 'colorByExpression';
        if (color) {
          color.colorExpression = attributes.qExpression;
        }
      }
    }
  };

  const OPTIONS = {
    MINI_CHART: {
      value: 'miniChart',
      translation: 'properties.scrollbar.miniChart'
    },
    BAR: {
      value: 'bar',
      translation: 'properties.scrollbar.bar'
    },
    NONE: {
      value: 'none',
      translation: 'properties.scrollbar.none'
    }
  };
  var SCROLLBARS = {
    OPTIONS,
    DEFAULT: OPTIONS.MINI_CHART
  };

  /* eslint-disable no-param-reassign */
  function scrollbarAdapter({
    properties
  }) {
    const {
      scrollbar,
      dimensionAxis,
      preferContinuousAxis,
      showMiniChartForContinuousAxis
    } = properties;
    if (scrollbar || showMiniChartForContinuousAxis !== false) {
      return;
    }
    const {
      continuousAuto
    } = dimensionAxis;
    if (continuousAuto || !continuousAuto && preferContinuousAxis) {
      properties.scrollbar = SCROLLBARS.OPTIONS.NONE.value;
    }
  }

  function createCacheVisualization({
    layoutService,
    discrete
  }) {
    return ({
      h,
      rect,
      orientation,
      minThumbSize
    }) => {
      const page = discrete.query.getCurrentDataPage();
      const items = layoutService.meta.size.y;
      const isHorizontal = orientation === 'horizontal';
      const maxSize = rect[isHorizontal ? 'width' : 'height'];
      let distance = page.qArea.qTop / items * maxSize;
      let size = page.qArea.qHeight / items * maxSize;
      if (size < minThumbSize) {
        const offset = (minThumbSize - size) / 2;
        const overflow = Math.max(0, 0 - (distance - offset)) - Math.max(0, distance + size + offset - maxSize);
        distance = distance - offset + overflow;
        size = minThumbSize;
      }
      return h('div', {
        style: {
          position: 'absolute',
          right: 0,
          bottom: 0,
          background: 'red',
          opacity: 0.2,
          ...(isHorizontal ? {
            top: 0,
            left: distance,
            width: size
          } : {
            top: distance,
            left: 0,
            height: size
          })
        }
      });
    };
  }

  function fromZoom(viewState, viewCache) {
    const z = viewState.get('zoom');
    const min = viewCache.get('continuousMin');
    const max = viewCache.get('continuousMax');
    const start = (z.min - min) / (max - min);
    const end = (z.max - min) / (max - min);
    return [start, end];
  }
  function fromViewRange(viewState) {
    return viewState.get('viewRange');
  }
  function getRange({
    layoutService,
    viewState,
    viewCache
  }) {
    return layoutService.meta.isContinuous ? fromZoom(viewState, viewCache) : fromViewRange(viewState);
  }

  const construct = type => ({
    miniChart: type === SCROLLBARS.OPTIONS.MINI_CHART.value,
    bar: type === SCROLLBARS.OPTIONS.BAR.value,
    none: type === SCROLLBARS.OPTIONS.NONE.value
  });
  const resolvePreferred = ({
    layoutService
  }) => {
    const scrollbar = layoutService.getLayoutValue('scrollbar');
    if (scrollbar) {
      return construct(scrollbar);
    }
    const legacy = layoutService.getLayoutValue('showMiniChartForContinuousAxis');
    if (legacy === undefined) {
      return construct(SCROLLBARS.DEFAULT.value);
    }
    const auto = layoutService.getLayoutValue('dimensionAxis.continuousAuto');
    const preferContinuous = layoutService.getLayoutValue('preferContinuousAxis');
    const none = !legacy && (auto || !auto && preferContinuous);
    return construct(none ? SCROLLBARS.OPTIONS.NONE.value : SCROLLBARS.OPTIONS.MINI_CHART.value);
  };
  function resolveScrollbar({
    layoutService,
    override = undefined
  }) {
    const resolved = resolvePreferred({
      layoutService
    });
    if (override && override.predicate({
      layoutService,
      scrollbar: resolved
    })) {
      resolved.miniChart = override.value === SCROLLBARS.OPTIONS.MINI_CHART.value;
      resolved.bar = override.value === SCROLLBARS.OPTIONS.BAR.value;
      resolved.none = override.value === SCROLLBARS.OPTIONS.NONE.value;
    }
    return resolved;
  }

  function createScrollbarDefinition({
    layoutService,
    dockService,
    discrete,
    continuousDataModel,
    viewState,
    viewCache,
    themeService,
    rtl,
    scrollbarOverride,
    visualizeCache = false,
    deviceType
  }) {
    const scrollbar = resolveScrollbar({
      layoutService,
      override: scrollbarOverride
    });
    if (scrollbar.none) {
      return false;
    }
    const {
      orientation
    } = dockService.meta.major;
    const definition = {
      key: 'scrollbar',
      type: 'scrollbar',
      layout: {
        dock: orientation === 'horizontal' ? dockService.meta.minor.start : dockService.meta.minor.end,
        minimumLayoutMode: 'XSMALL'
      },
      show: () => layoutService.meta.isContinuous ? continuousDataModel.getDimensionCardinality() > 1 : discrete.query.getCanScroll(),
      settings: {
        orientation,
        rtl,
        isContinuous: layoutService.meta.isContinuous,
        range: () => getRange({
          layoutService,
          viewState,
          viewCache
        })
      }
    };
    if (scrollbar.bar) {
      definition.settings.style = 'slim';
      definition.settings.size = {
        area: deviceType === 'touch' ? {
          max: 16,
          min: 16
        } : {
          max: 8,
          min: 8
        }
      };
      if (!layoutService.meta.isContinuous) {
        definition.settings.size.thumb = {
          min: 4
        };
      }
    }
    const styles = themeService.getStyles();
    if (styles.color) {
      definition.style = {
        standard: {
          thumb: {
            'border-color': styles.color,
            opacity: 0.4
          },
          before: {
            background: styles.color,
            opacity: 0.1
          },
          after: {
            background: styles.color,
            opacity: 0.1
          }
        }
      };
    }
    if (layoutService.meta.isDiscrete && visualizeCache) {
      definition.settings.injections = () => [createCacheVisualization({
        layoutService,
        discrete
      })];
    }
    return definition;
  }

  function createGetScrollbarEvent({
    componentKey,
    chart,
    viewState,
    viewCache,
    layoutService,
    dockService,
    rtl
  }) {
    return e => {
      const {
        x,
        y
      } = e.center;
      const rect = chart.element.getBoundingClientRect();
      const scrollbar = chart.component(componentKey);
      const horizontal = dockService.meta.major.orientation === 'horizontal';
      const physical = horizontal ? x - rect.left - scrollbar.rect.computedInner.x : y - rect.top - scrollbar.rect.computedInner.y;
      const size = horizontal ? scrollbar.rect.computedInner.width : scrollbar.rect.computedInner.height;
      const invert = horizontal && rtl;
      const pixel = invert ? size - physical : physical;
      const relative = Math.max(0, Math.min(pixel / size, 1));
      const [start, end] = getRange({
        layoutService,
        viewState,
        viewCache
      });
      const beforeThumb = relative < start;
      const afterThumb = relative > end;
      const onThumb = !beforeThumb && !afterThumb;
      return {
        pixel,
        relative,
        thumb: onThumb ? pixel - start * size : 0,
        beforeThumb,
        afterThumb,
        onThumb
      };
    };
  }

  function createGetScrollbarModel({
    componentKey,
    chart,
    viewState,
    viewCache,
    layoutService,
    dockService
  }) {
    return () => {
      const scrollbar = chart.component(componentKey);
      const {
        orientation
      } = dockService.meta.major;
      const {
        width,
        height
      } = scrollbar.rect.computedInner;
      const isHorizontal = orientation === 'horizontal';
      const size = isHorizontal ? width : height;
      const [start, end] = getRange({
        layoutService,
        viewState,
        viewCache
      });
      return {
        size,
        thumbSize: (end - start) * size
      };
    };
  }

  function createTap$1({
    componentKey,
    chart,
    actions,
    viewState,
    viewCache,
    layoutService,
    dockService,
    discrete,
    rtl
  }) {
    const getEvent = createGetScrollbarEvent({
      componentKey,
      chart,
      viewState,
      viewCache,
      layoutService,
      dockService,
      rtl
    });
    const getModel = createGetScrollbarModel({
      componentKey,
      chart,
      viewState,
      viewCache,
      layoutService,
      dockService
    });
    return {
      type: 'Tap',
      options: {
        event: 'scrollbarTap',
        enable(r, e) {
          if (!e) {
            return true;
          }
          if (!actions.scroll.enabled()) {
            return false;
          }
          return chart.componentsFromPoint({
            x: e.center.x,
            y: e.center.y
          }).some(c => c.key === componentKey);
        }
      },
      events: {
        scrollbarTap(e) {
          e.preventDefault();
          const event = getEvent(e);
          if (layoutService.meta.isContinuous) {
            const z = viewState.get('zoom');
            const span = z.max - z.min;
            const min = viewCache.get('continuousMin');
            const max = viewCache.get('continuousMax');
            const c = min + (max - min) * event.relative;
            viewState.set('zoom', {
              min: Math.min(c - span / 2, max - span),
              max: Math.max(c + span / 2, min + span)
            });
          } else {
            const model = getModel();
            const distance = event.pixel - model.thumbSize / 2;
            const relative = Math.max(0, distance / model.size);
            discrete.command.scrollTo(relative);
          }
          chart.component(componentKey).emit('render');
        }
      }
    };
  }

  const ATTRIBUTE_NAME = 'data-scrollbar-handle';
  function getAttribute({
    e
  }) {
    const event = e.srcEvent || e;
    return event.srcElement.getAttribute(ATTRIBUTE_NAME) || '';
  }

  const EVENT_NAME$1 = 'scrollbarResize';
  const isClick = e => {
    const [changed] = e.changedPointers;
    return changed && (changed.type === 'pointerdown' || changed.type === 'mousedown');
  };
  function createResize({
    componentKey,
    chart,
    actions,
    viewState,
    viewCache,
    layoutService,
    dockService,
    rtl
  }) {
    const getEvent = createGetScrollbarEvent({
      componentKey,
      chart,
      viewState,
      viewCache,
      layoutService,
      dockService,
      rtl
    });
    return {
      type: 'Pan',
      key: `event:${EVENT_NAME$1}`,
      options: {
        event: EVENT_NAME$1,
        threshold: 0,
        enable(r, e) {
          if (!layoutService.meta.isContinuous || !actions.scroll.enabled()) {
            return false;
          }
          if (!e) {
            return true;
          }
          this[EVENT_NAME$1] = this[EVENT_NAME$1] || {};
          if (isClick(e) && getAttribute({
            e
          })) {
            this[EVENT_NAME$1].panningEvent = e.srcEvent;
          }
          return !!this[EVENT_NAME$1].panningEvent;
        }
      },
      events: {
        [`${EVENT_NAME$1}start`](e) {
          e.preventDefault();
          this[EVENT_NAME$1] = this[EVENT_NAME$1] || {};
          if (this[EVENT_NAME$1].panningEvent) {
            chart.component(componentKey).emit('dragStart', this[EVENT_NAME$1].panningEvent);
          }
        },
        [`${EVENT_NAME$1}move`](e) {
          e.preventDefault();
          this[EVENT_NAME$1] = this[EVENT_NAME$1] || {};
          if (!this[EVENT_NAME$1].panningEvent) {
            return;
          }
          const z = viewState.get('zoom');
          const continuousMin = viewCache.get('continuousMin');
          const continuousMax = viewCache.get('continuousMax');
          const minimiumZoomSpan = viewCache.get('minimiumZoomSpan');
          const event = getEvent(e);
          const updated = (continuousMax - continuousMin) * event.relative + continuousMin;
          const type = getAttribute({
            e: this[EVENT_NAME$1].panningEvent
          });
          let min = type === 'start' ? Math.min(updated, z.max) : z.min;
          let max = type === 'end' ? Math.max(updated, z.min) : z.max;
          if (min === max) {
            min -= type === 'start' ? minimiumZoomSpan : 0;
            max += type === 'end' ? minimiumZoomSpan : 0;
          }
          viewState.set('zoom', {
            min,
            max
          });
          chart.component(componentKey).emit('render');
        },
        [`${EVENT_NAME$1}end`](e) {
          e.preventDefault();
          this[EVENT_NAME$1] = this[EVENT_NAME$1] || {};
          delete this[EVENT_NAME$1].panningEvent;
          chart.component(componentKey).emit('dragEnd');
        },
        [`${EVENT_NAME$1}cancel`](e) {
          e.preventDefault();
          this[EVENT_NAME$1] = this[EVENT_NAME$1] || {};
          delete this[EVENT_NAME$1].panningEvent;
          chart.component(componentKey).emit('dragEnd');
        }
      }
    };
  }

  const EVENT_NAME = 'scrollbarPan';
  function createPan$1({
    componentKey,
    chart,
    actions,
    viewState,
    viewCache,
    layoutService,
    dockService,
    discrete,
    rtl
  }) {
    const getEvent = createGetScrollbarEvent({
      componentKey,
      chart,
      viewState,
      viewCache,
      layoutService,
      dockService,
      rtl
    });
    const getModel = createGetScrollbarModel({
      componentKey,
      chart,
      viewState,
      viewCache,
      layoutService,
      dockService
    });
    return {
      type: 'Pan',
      key: `event:${EVENT_NAME}`,
      options: {
        event: EVENT_NAME,
        threshold: 0,
        enable(r, e) {
          this[EVENT_NAME] = this[EVENT_NAME] || {};
          if (!e || this[EVENT_NAME].isPanning) {
            return true;
          }
          if (!actions.scroll.enabled()) {
            return false;
          }
          if (e && e.target !== chart.element) {
            return false;
          }
          return chart.componentsFromPoint({
            x: e.center.x,
            y: e.center.y
          }).some(c => c.key === componentKey);
        }
      },
      events: {
        [`${EVENT_NAME}start`](e) {
          e.preventDefault();
          const event = getEvent(e);
          this[EVENT_NAME] = this[EVENT_NAME] || {};
          this[EVENT_NAME].isPanning = true;
          chart.component(componentKey).emit('lockState');
          if (layoutService.meta.isContinuous) {
            const z = viewState.get('zoom');
            const span = z.max - z.min;
            const min = viewCache.get('continuousMin');
            const max = viewCache.get('continuousMax');
            const c = min + (max - min) * event.relative;

            // If not over scrollbar, re-position scroll bar at pointer
            if (c < z.min) {
              viewState.set('zoom', {
                min: Math.min(c, max - span),
                max: Math.max(c + span, min + span)
              });
            } else if (c > z.max) {
              viewState.set('zoom', {
                min: Math.min(c - span, max - span),
                max: Math.max(c, min + span)
              });
            }
            this[EVENT_NAME].relative = event.relative;
            this[EVENT_NAME].zoom = viewState.get('zoom');
            this[EVENT_NAME].zoom.span = this[EVENT_NAME].zoom.max - this[EVENT_NAME].zoom.min;
            this[EVENT_NAME].zoom.fullSpan = max - min;
          } else if (event.onThumb) {
            this[EVENT_NAME].offset = event.thumb;
          } else {
            const model = getModel();
            this[EVENT_NAME].offset = event.beforeThumb ? 0 : model.thumbSize;
          }
        },
        [`${EVENT_NAME}move`](e) {
          e.preventDefault();
          const event = getEvent(e);
          this[EVENT_NAME] = this[EVENT_NAME] || {};
          if (layoutService.meta.isContinuous) {
            const diff = event.relative - this[EVENT_NAME].relative;
            const {
              fullSpan,
              span,
              min,
              max
            } = this[EVENT_NAME].zoom;
            const continuousMin = viewCache.get('continuousMin');
            const continuousMax = viewCache.get('continuousMax');
            viewState.set('zoom', {
              min: Math.min(min + diff * fullSpan, continuousMax - span),
              max: Math.max(max + diff * fullSpan, continuousMin + span)
            });
          } else {
            const distance = event.pixel - (this[EVENT_NAME].offset || 0);
            const model = getModel();
            const relative = Math.max(0, distance / model.size);
            discrete.command.scrollTo(relative);
          }
          chart.component(componentKey).emit('render');
        },
        [`${EVENT_NAME}end`](e) {
          e.preventDefault();
          this[EVENT_NAME] = this[EVENT_NAME] || {};
          this[EVENT_NAME].isPanning = false;
          chart.component(componentKey).emit('unlockState');
        },
        [`${EVENT_NAME}cancel`](e) {
          e.preventDefault();
          this[EVENT_NAME] = this[EVENT_NAME] || {};
          this[EVENT_NAME].isPanning = false;
          chart.component(componentKey).emit('unlockState');
        }
      }
    };
  }

  function createGestures({
    componentKey,
    chart,
    actions,
    viewState,
    viewCache,
    layoutService,
    dockService,
    discrete,
    rtl
  }) {
    return [createTap$1({
      componentKey,
      chart,
      actions,
      viewState,
      viewCache,
      layoutService,
      dockService,
      discrete,
      rtl
    }), createResize({
      componentKey,
      chart,
      actions,
      viewState,
      viewCache,
      layoutService,
      dockService,
      rtl
    }), createPan$1({
      componentKey,
      chart,
      actions,
      viewState,
      viewCache,
      layoutService,
      dockService,
      discrete,
      rtl
    })];
  }

  function createNative$1({
    componentKey,
    chart,
    actions,
    layoutService
  }) {
    const onNativeEvent = (emitName, e) => {
      if (!layoutService.meta.isContinuous) {
        return;
      }
      const scrollbar = chart.component(componentKey);
      if (scrollbar && scrollbar.emit && actions.scroll.enabled()) {
        scrollbar.emit(emitName, e);
      }
    };
    return {
      type: 'native',
      events: {
        mousemove: e => onNativeEvent('hover', e),
        mouseleave: () => onNativeEvent('leave')
      }
    };
  }

  function createScrollbarInteractions({
    componentKey,
    chart,
    actions,
    viewState,
    viewCache,
    layoutService,
    dockService,
    discrete,
    rtl
  }) {
    return {
      gestures: [...createGestures({
        componentKey,
        chart,
        actions,
        viewState,
        viewCache,
        layoutService,
        dockService,
        discrete,
        rtl
      })],
      native: createNative$1({
        componentKey,
        chart,
        actions,
        layoutService
      })
    };
  }

  function elements({
    h,
    size,
    start,
    end,
    properties,
    startHandleActive,
    endHandleActive,
    style,
    continuous,
    invert,
    injections
  }) {
    const physical = {
      before: {
        [properties.end]: size - start
      },
      after: {
        [properties.start]: end
      },
      startHandle: {
        left: -3
      },
      startHandleBorder: {
        left: 1
      },
      endHandle: {
        right: -3,
        left: 'auto'
      },
      endHandleBorder: {
        left: 3
      }
    };
    const before = h('div', {
      style: {
        ...style.before,
        ...(invert ? physical.after : physical.before)
      },
      class: 'scrollbar--before'
    });
    const after = h('div', {
      style: {
        ...style.after,
        ...(invert ? physical.before : physical.after)
      },
      class: 'scrollbar--after'
    });
    const thumbChildren = [];
    if (continuous) {
      const startHandle = h('div', {
        style: {
          ...style.startHandle,
          ...(invert ? physical.endHandle : physical.startHandle)
        },
        class: 'scrollbar--start-handle',
        [ATTRIBUTE_NAME]: 'start'
      }, startHandleActive ? h('div', {
        style: {
          ...style.startHandleBorder,
          ...(invert ? physical.endHandleBorder : physical.startHandleBorder)
        }
      }) : undefined);
      thumbChildren.push(startHandle);
      const endHandle = h('div', {
        style: {
          ...style.endHandle,
          ...(invert ? physical.startHandle : physical.endHandle)
        },
        class: 'scrollbar--end-handle',
        [ATTRIBUTE_NAME]: 'end'
      }, endHandleActive ? h('div', {
        style: {
          ...style.endHandleBorder,
          ...(invert ? physical.startHandleBorder : physical.endHandleBorder)
        }
      }) : undefined);
      thumbChildren.push(endHandle);
    }
    const thumb = h('div', {
      style: {
        ...style.thumb,
        [properties.start]: start,
        [properties.end]: size - end
      },
      class: 'scrollbar--thumb'
    }, thumbChildren);
    const container = h('div', {
      style: {
        ...style.container
      }
    }, [before, thumb, after, ...injections]);
    return container;
  }

  const BACKGROUND$1 = {
    background: 'rgba(0, 0, 0, 0.1)'
  };
  const HANDLE$2 = {
    top: -1,
    bottom: -1,
    width: 6
  };
  const HANDLE_BORDER$2 = {
    width: 2,
    background: '#595959'
  };
  var standard = {
    before: BACKGROUND$1,
    after: BACKGROUND$1,
    thumb: {
      background: 'transparent',
      border: '1px solid rgba(68, 68, 68, 0.4)'
    },
    startHandle: HANDLE$2,
    endHandle: HANDLE$2,
    startHandleBorder: HANDLE_BORDER$2,
    endHandleBorder: HANDLE_BORDER$2
  };

  const BACKGROUND = {
    background: 'rgba(0, 0, 0, 0.1)'
  };
  const HANDLE$1 = {
    top: -1,
    bottom: -1,
    width: 6
  };
  const HANDLE_BORDER$1 = {
    width: 2,
    background: '#595959'
  };
  var slim = {
    before: BACKGROUND,
    after: BACKGROUND,
    thumb: {
      background: '#B0AFAE',
      border: 'transparent'
    },
    startHandle: HANDLE$1,
    endHandle: HANDLE$1,
    startHandleBorder: HANDLE_BORDER$1,
    endHandleBorder: HANDLE_BORDER$1
  };

  const BASE$1 = {
    position: 'absolute',
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    boxSizing: 'border-box'
  };
  const HANDLE = {
    pointerEvents: 'initial'
  };
  const HANDLE_BORDER = {
    pointerEvents: 'none'
  };
  function resolveStyle({
    id,
    style
  }) {
    const defaultStyle = id === 'slim' ? slim : standard;
    return {
      container: {
        ...BASE$1
      },
      before: {
        ...BASE$1,
        ...defaultStyle.before,
        ...style.before
      },
      after: {
        ...BASE$1,
        ...defaultStyle.after,
        ...style.after
      },
      thumb: {
        ...BASE$1,
        ...defaultStyle.thumb,
        ...style.thumb
      },
      startHandle: {
        ...BASE$1,
        ...HANDLE,
        ...defaultStyle.startHandle
      },
      endHandle: {
        ...BASE$1,
        ...HANDLE,
        ...defaultStyle.endHandle
      },
      startHandleBorder: {
        ...BASE$1,
        ...HANDLE_BORDER,
        ...defaultStyle.startHandleBorder
      },
      endHandleBorder: {
        ...BASE$1,
        ...HANDLE_BORDER,
        ...defaultStyle.endHandleBorder
      }
    };
  }

  const CURSOR = {
    RESIZE: 'ew-resize',
    DEFAULT: 'default'
  };
  function args() {
    const {
      rect
    } = this;
    const {
      settings
    } = this.settings;
    const horizontal = settings.orientation === 'horizontal';
    const size = horizontal ? rect.computedInner.width : rect.computedInner.height;
    const range = settings.range();
    const invert = horizontal && settings.rtl;
    return {
      size,
      start: (invert ? 1 - range[1] : range[0]) * size,
      end: (invert ? 1 - range[0] : range[1]) * size
    };
  }
  function cursor() {
    const resizing = this.state.hover.start || this.state.hover.end || this.state.drag.start || this.state.drag.end;
    this.renderer.element().ownerDocument.body.style.cursor = resizing ? CURSOR.RESIZE : CURSOR.DEFAULT;
  }
  function adjust(size, start, end) {
    const {
      min
    } = this.settings.settings.size.thumb;
    if (end - start < min) {
      const offset = (min - (end - start)) / 2;
      const overflow = Math.max(0, 0 - (start - offset)) - Math.max(0, end + offset - size);
      return {
        size,
        start: start - offset + overflow,
        end: end + offset + overflow
      };
    }
    return {
      size,
      start,
      end
    };
  }
  function inScrollbar(event) {
    const element = (event.srcEvent || event).srcElement;
    return this.renderer.element().contains(element);
  }
  function render$d() {
    const {
      size,
      start,
      end
    } = args.call(this);
    this.renderer.render(this.elements(this.h, adjust.call(this, size, start, end)));
  }
  function getStyle() {
    const {
      state,
      settings,
      style
    } = this;
    const key = settings.settings.style;
    if (!state.style[key]) {
      state.style[key] = resolveStyle({
        id: settings.settings.style,
        style: style[key]
      });
    }
    return state.style[key];
  }
  function getInitialState() {
    return {
      style: {},
      locked: false,
      hover: {
        start: false,
        end: false,
        reset() {
          this.start = false;
          this.end = false;
        },
        isPristine() {
          return !this.start && !this.end;
        }
      },
      drag: {
        start: false,
        end: false,
        reset() {
          this.start = false;
          this.end = false;
        }
      }
    };
  }
  var scrollbarComponent$1 = {
    require: ['renderer'],
    defaultSettings: {
      settings: {
        style: 'standard',
        size: {
          area: {
            min: 30,
            max: 40,
            ratio: 1 / 8
          },
          thumb: {
            min: 4
          }
        },
        orientation: 'horizontal',
        rtl: false,
        isContinuous: false,
        range: () => [0, 1],
        injections: () => []
      },
      style: {
        standard: {
          before: {},
          thumb: {},
          after: {}
        },
        slim: {
          before: {},
          thumb: {},
          after: {}
        }
      }
    },
    renderer: 'dom',
    on: {
      render() {
        render$d.call(this);
      },
      lockState() {
        this.state.locked = true;
      },
      unlockState() {
        this.state.locked = false;
      },
      hover(e) {
        if (this.state.locked || this.state.drag.start || this.state.drag.end || !inScrollbar.call(this, e) && this.state.hover.isPristine()) {
          return;
        }
        this.state.hover.reset();
        const type = getAttribute({
          e
        });
        if (type) {
          this.state.hover[type] = true;
        }
        cursor.call(this);
        render$d.call(this);
      },
      leave() {
        if (this.state.locked) {
          return;
        }
        this.state.hover.reset();
        cursor.call(this);
        render$d.call(this);
      },
      dragStart(e) {
        if (this.state.locked) {
          return;
        }
        this.state.drag.reset();
        const type = getAttribute({
          e
        });
        if (type) {
          this.state.drag[type] = true;
        }
        cursor.call(this);
      },
      dragEnd() {
        if (this.state.locked) {
          return;
        }
        this.state.drag.reset();
        cursor.call(this);
        render$d.call(this);
      }
    },
    preferredSize({
      outer
    }) {
      const {
        min,
        max,
        ratio
      } = this.settings.settings.size.area;
      const dimension = this.settings.settings.orientation === 'horizontal' ? 'height' : 'width';
      return Math.max(min, Math.min(max, outer[dimension] * ratio));
    },
    created() {
      this.state = getInitialState();
    },
    render(h) {
      this.h = h;
      const {
        size,
        start,
        end
      } = args.call(this);
      return this.elements(h, adjust.call(this, size, start, end));
    },
    properties() {
      return this.settings.settings.orientation === 'horizontal' ? {
        start: 'left',
        end: 'right'
      } : {
        start: 'top',
        end: 'bottom'
      };
    },
    elements(h, {
      size,
      start,
      end
    }) {
      const {
        settings
      } = this.settings;
      const injections = settings.injections().map(injection => injection({
        h,
        rect: this.rect,
        orientation: settings.orientation,
        minThumbSize: settings.size.thumb.min
      }));
      return elements({
        h,
        size,
        start,
        end,
        properties: this.properties(),
        startHandleActive: this.state.hover.start || this.state.drag.start,
        endHandleActive: this.state.hover.end || this.state.drag.end,
        style: getStyle.call(this),
        continuous: settings.isContinuous,
        invert: settings.orientation === 'horizontal' && settings.rtl,
        injections
      });
    }
  };

  const clearDynamicScripts = properties => {
    var _properties$qHyperCub;
    if ((_properties$qHyperCub = properties.qHyperCubeDef.qDynamicScript) !== null && _properties$qHyperCub !== void 0 && _properties$qHyperCub.length) {
      // eslint-disable-next-line no-param-reassign
      properties.qHyperCubeDef.qDynamicScript = [];
    }
  };

  const KEYS$1 = {
    FORECAST: 'forecast',
    FORECAST_LOWER: 'forecast_lower',
    FORECAST_UPPER: 'forecast_upper'
  };
  const IDS = Object.keys(KEYS$1).map(key => KEYS$1[key]);
  var CONSTANTS = {
    ATTRIBUTE: {
      KEYS: KEYS$1,
      IDS
    },
    STEPS: {
      NUM_STEPS: 3,
      STEP_SIZE_MULTIPLIER: 1,
      STEP_SIZE: {
        SECONDS: 'seconds',
        MINUTES: 'minutes',
        HOURS: 'hours',
        DAYS: 'days',
        WEEKS: 'weeks',
        MONTHS: 'months',
        YEARS: 'years',
        NUMBER: 'number'
      }
    },
    DEFAULT_METHOD: 'ssa_forecast'
  };

  /* eslint-disable no-param-reassign */
  const {
    ATTRIBUTE: ATTRIBUTE$2
  } = CONSTANTS;
  const disableForecast = properties => {
    if (properties !== null && properties !== void 0 && properties.qHyperCubeDef) {
      let havingForeCast = false;
      properties.qHyperCubeDef.qMeasures.forEach(measure => {
        var _measure$qDef$forecas;
        if ((_measure$qDef$forecas = measure.qDef.forecast) !== null && _measure$qDef$forecas !== void 0 && _measure$qDef$forecas.enabled) {
          havingForeCast = true;
          measure.qDef.forecast.enabled = false;
          if (measure.qAttributeExpressions) {
            measure.qAttributeExpressions = measure.qAttributeExpressions.filter(att => ATTRIBUTE$2.IDS.indexOf(att.id) < 0);
          }
        }
      });
      if (havingForeCast) {
        clearDynamicScripts(properties);
      }
    }
  };

  const getForecastMeasures$1 = properties => {
    var _properties$qHyperCub, _properties$qHyperCub2;
    const forecastMeasures = ((properties === null || properties === void 0 || (_properties$qHyperCub = properties.qHyperCubeDef) === null || _properties$qHyperCub === void 0 ? void 0 : _properties$qHyperCub.qMeasures) || []).concat((properties === null || properties === void 0 || (_properties$qHyperCub2 = properties.qHyperCubeDef) === null || _properties$qHyperCub2 === void 0 || (_properties$qHyperCub2 = _properties$qHyperCub2.qLayoutExclude) === null || _properties$qHyperCub2 === void 0 || (_properties$qHyperCub2 = _properties$qHyperCub2.qHyperCubeDef) === null || _properties$qHyperCub2 === void 0 ? void 0 : _properties$qHyperCub2.qMeasures) || []).filter(m => {
      var _m$qDef$forecast;
      return (_m$qDef$forecast = m.qDef.forecast) === null || _m$qDef$forecast === void 0 ? void 0 : _m$qDef$forecast.enabled;
    });
    return forecastMeasures;
  };

  const disallowMeasureForecast = (measure, {
    properties
  }) => {
    var _measure$qDef$forecas;
    return getForecastMeasures$1(properties).length === 1 && !((_measure$qDef$forecas = measure.qDef.forecast) !== null && _measure$qDef$forecas !== void 0 && _measure$qDef$forecas.enabled);
  };

  const disallowMeasureForecastSoft = (measure, layout, {
    effectiveProperties
  }) => {
    var _measure$qDef$forecas;
    return getForecastMeasures$1(effectiveProperties).length === 1 && !((_measure$qDef$forecas = measure.qDef.forecast) !== null && _measure$qDef$forecas !== void 0 && _measure$qDef$forecas.enabled);
  };

  function hasConditionalData(properties) {
    const {
      qDimensions = [],
      qMeasures = []
    } = (properties === null || properties === void 0 ? void 0 : properties.qHyperCubeDef) || {};
    const predicate = i => {
      var _i$qCalcCondition;
      return (_i$qCalcCondition = i.qCalcCondition) === null || _i$qCalcCondition === void 0 || (_i$qCalcCondition = _i$qCalcCondition.qCond) === null || _i$qCalcCondition === void 0 ? void 0 : _i$qCalcCondition.qv;
    };
    const hasCondition = qDimensions.some(predicate) || qMeasures.some(predicate);
    return hasCondition;
  }

  const isContinuous$3 = (layout, properties, auto = false) => {
    var _properties$dimension;
    if (!timeUtils.canBeContinuous(layout)) {
      return false;
    }
    if (properties !== null && properties !== void 0 && (_properties$dimension = properties.dimensionAxis) !== null && _properties$dimension !== void 0 && _properties$dimension.continuousAuto) {
      return typeof auto === 'function' ? auto() : auto;
    }
    return !!(properties !== null && properties !== void 0 && properties.preferContinuousAxis);
  };

  const hasOneDimAndMeasures = properties => {
    const {
      qDimensions,
      qMeasures
    } = (properties === null || properties === void 0 ? void 0 : properties.qHyperCubeDef) || {};
    return (qDimensions === null || qDimensions === void 0 ? void 0 : qDimensions.length) === 1 && (qMeasures === null || qMeasures === void 0 ? void 0 : qMeasures.length) >= 1;
  };

  const isStackedByMeasures = properties => {
    const {
      qMeasures
    } = (properties === null || properties === void 0 ? void 0 : properties.qHyperCubeDef) || {};
    const isArea = !!((properties === null || properties === void 0 ? void 0 : properties.lineType) === 'area');
    const isStacked = isArea && properties.stackedArea && (qMeasures === null || qMeasures === void 0 ? void 0 : qMeasures.length) > 1;
    return isStacked;
  };

  const isForecastAllowed = (measure, handler, args) => {
    const properties = handler === null || handler === void 0 ? void 0 : handler.properties;
    if (hasConditionalData(properties)) {
      return false;
    }
    if (hasOneDimAndMeasures(properties)) {
      var _layout$qHyperCube$qD;
      if (!(args !== null && args !== void 0 && args.layout)) {
        return false;
      }
      if (isStackedByMeasures(properties)) {
        return false;
      }
      const {
        layout
      } = args;
      const isDrilldown = ((_layout$qHyperCube$qD = layout.qHyperCube.qDimensionInfo[0]) === null || _layout$qHyperCube$qD === void 0 ? void 0 : _layout$qHyperCube$qD.qGrouping) === 'H';
      if (isDrilldown) {
        return false;
      }
      const isHCModifierEnabled = layout.qHyperCube.isHCEnabled;
      return isContinuous$3(layout, properties, () => timeUtils.isTime(true, layout)) && !isHCModifierEnabled;
    }
    return false;
  };

  const isForecastAllowedSoft = (measure, layout, args) => {
    return isForecastAllowed(measure, args, args);
  };

  const isSameDimension = (handler, args) => {
    const {
      properties
    } = handler;
    const {
      layout
    } = args;
    return properties.qHyperCubeDef.qDimensions[0].qDef.cId === layout.qHyperCube.qDimensionInfo[0].cId;
  };

  const isForecastEnabled = (measure, handler, args) => {
    var _measure$qDef$forecas;
    return ((_measure$qDef$forecas = measure.qDef.forecast) === null || _measure$qDef$forecas === void 0 ? void 0 : _measure$qDef$forecas.enabled) && isForecastAllowed(measure, handler, args) && isSameDimension(handler, args);
  };

  const isForecastEnabledSoft = (measure, handler, args) => {
    var _measure$qDef$forecas;
    return ((_measure$qDef$forecas = measure.qDef.forecast) === null || _measure$qDef$forecas === void 0 ? void 0 : _measure$qDef$forecas.enabled) && isForecastAllowed(measure, args, args) && isSameDimension(args, args);
  };

  const {
    STEPS: STEPS$4
  } = CONSTANTS;
  const timeParameter = (size, unit) => {
    if (unit === STEPS$4.STEP_SIZE.NUMBER) {
      return `${size}`;
    }
    return `${size} ${unit}`;
  };

  const {
    STEPS: STEPS$3
  } = CONSTANTS;
  const ssaForecast = {
    getScript: ({
      confidence = 0.95,
      measureIx,
      attrIx,
      steps = STEPS$3.NUM_STEPS,
      stepSize = STEPS$3.STEP_SIZE.DAYS,
      stepSizeMultiplier = 1,
      interpolateNanValues = true
    }) => {
      return attrIx < 1 ? '' : `add load
        "Time Stamp" as #hc1.dimension.1,
        Forecast as #hc1.measure.${measureIx}.attribute.${attrIx},
        "Lower Uncertainty" as #hc1.measure.${measureIx}.attribute.${attrIx + 1},
        "Upper Uncertainty" as #hc1.measure.${measureIx}.attribute.${attrIx + 2}
        Extension qlikml.ScriptEval('
          {
            "RequestType": "ssa_forecast",
            "ReturnType": "forecast_and_last",
            "ConfidenceLevel": ${confidence},
            "Horizon": "${timeParameter(steps * stepSizeMultiplier, stepSize)}",
            "TimeStep": "${timeParameter(stepSizeMultiplier, stepSize)}",
            "InterpolateNanValues": "${interpolateNanValues}",
            "ShouldCache": "false"
          }', HC1{#hc1.dimension.1, #hc1.measure.${measureIx}});`;
    }
  };

  const {
    STEPS: STEPS$2
  } = CONSTANTS;
  const olsForecast = {
    getScript: ({
      confidence = 0.95,
      measureIx,
      attrIx,
      steps = STEPS$2.NUM_STEPS,
      stepSize = STEPS$2.STEP_SIZE.DAYS,
      stepSizeMultiplier = 1,
      interpolateNanValues = true
    }) => {
      return attrIx < 1 ? '' : `add load
        "Time Stamp" as #hc1.dimension.1,
        Forecast as #hc1.measure.${measureIx}.attribute.${attrIx}
        Extension qlikml.ScriptEval('
          {
            "RequestType": "ols_forecast",
            "ReturnType": "forecast",
            "ConfidenceLevel": ${confidence},
            "Horizon": "${timeParameter(steps * stepSizeMultiplier, stepSize)}",
            "TimeStep": "${timeParameter(stepSizeMultiplier, stepSize)}",
            "InterpolateNanValues": "${interpolateNanValues}",
            "ShouldCache": "false"
          }', HC1{#hc1.dimension.1, #hc1.measure.${measureIx}});`;
    }
  };

  const getAttributeIndex = (measure, attributeId) => {
    const {
      qAttributeExpressions = []
    } = measure;
    for (let i = 0; i < qAttributeExpressions.length; i++) {
      if (qAttributeExpressions[i].id === attributeId) return i;
    }
    return -1;
  };

  const DEFAULT_METHOD$2 = 'ssa_forecast';
  const {
    ATTRIBUTE: ATTRIBUTE$1
  } = CONSTANTS;
  const METHODS = {
    ssa_forecast: ssaForecast,
    ols_forecast: olsForecast
  };
  const getDynamicScript = ({
    measure,
    index,
    steps,
    stepSize,
    stepSizeMultiplier,
    interpolateNanValues
  }) => {
    const {
      method,
      confidence
    } = measure.qDef.forecast || {};
    const currentMethod = method || DEFAULT_METHOD$2;
    const attrIx = getAttributeIndex(measure, ATTRIBUTE$1.KEYS.FORECAST) + 1;
    const measureIx = index + 1;
    return METHODS[currentMethod].getScript({
      confidence,
      measureIx,
      attrIx,
      steps,
      stepSize,
      stepSizeMultiplier,
      interpolateNanValues
    });
  };

  const areEqualArrays = (array1, array2) => {
    if (array1) {
      if (array2) {
        if (array1.length === array2.length) {
          for (let i = 0; i < array1.length; i++) {
            if (array1[i] !== array2[i]) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      return false;
    }
    return !array2;
  };

  const {
    ATTRIBUTE
  } = CONSTANTS;
  const updateForecastProperties = (properties, args) => {
    var _properties$qHyperCub, _properties$qHyperCub2;
    const isHCEnabled = properties === null || properties === void 0 || (_properties$qHyperCub = properties.qHyperCubeDef) === null || _properties$qHyperCub === void 0 ? void 0 : _properties$qHyperCub.isHCEnabled;
    if (isHCEnabled) {
      // do not change dynamic script is when user create dynamic script are used.
      return false;
    }
    const scripts = [];
    const {
      steps,
      stepSize,
      stepSizeMultiplier
    } = ((_properties$qHyperCub2 = properties.qHyperCubeDef.qDimensions[0]) === null || _properties$qHyperCub2 === void 0 || (_properties$qHyperCub2 = _properties$qHyperCub2.qDef) === null || _properties$qHyperCub2 === void 0 ? void 0 : _properties$qHyperCub2.forecast) || {};
    for (let index = 0; index < properties.qHyperCubeDef.qMeasures.length; ++index) {
      const measure = properties.qHyperCubeDef.qMeasures[index];
      const otherAttrExps = measure.qAttributeExpressions ? measure.qAttributeExpressions.filter(att => ATTRIBUTE.IDS.indexOf(att.id) < 0) : measure.qAttributeExpressions;
      if (isForecastEnabled(measure, {
        properties
      }, args)) {
        var _args$layout;
        measure.qAttributeExpressions = [...(otherAttrExps || []), {
          id: ATTRIBUTE.KEYS.FORECAST,
          qExpression: ''
        }, {
          id: ATTRIBUTE.KEYS.FORECAST_LOWER,
          qExpression: ''
        }, {
          id: ATTRIBUTE.KEYS.FORECAST_UPPER,
          qExpression: ''
        }];
        const interpolateNanValues = ((_args$layout = args.layout) === null || _args$layout === void 0 ? void 0 : _args$layout.nullMode) !== 'zero';
        scripts.push(getDynamicScript({
          measure,
          index,
          steps,
          stepSize,
          stepSizeMultiplier,
          interpolateNanValues
        }));
      } else {
        measure.qAttributeExpressions = otherAttrExps;
      }
    }
    const hasChange = !areEqualArrays(properties.qHyperCubeDef.qDynamicScript, scripts);
    properties.qHyperCubeDef.qDynamicScript = scripts; // eslint-disable-line no-param-reassign
    return hasChange;
  };

  const checkToUpdateProperties = ({
    enabledForecast,
    properties,
    layout
  }) => {
    var _properties$qHyperCub, _properties$qHyperCub2;
    // do not reset qDynamicScript when user has added custom qDynamicScript.
    if (properties !== null && properties !== void 0 && (_properties$qHyperCub = properties.qHyperCubeDef) !== null && _properties$qHyperCub !== void 0 && _properties$qHyperCub.isHCEnabled) {
      return false;
    }
    if (enabledForecast) {
      return updateForecastProperties(properties, {
        layout
      });
    }
    if (properties !== null && properties !== void 0 && (_properties$qHyperCub2 = properties.qHyperCubeDef) !== null && _properties$qHyperCub2 !== void 0 && (_properties$qHyperCub2 = _properties$qHyperCub2.qDynamicScript) !== null && _properties$qHyperCub2 !== void 0 && _properties$qHyperCub2.length) {
      disableForecast(properties);
      // eslint-disable-next-line no-param-reassign
      properties.qHyperCubeDef.qDynamicScript = [];
      return true;
    }
    return false;
  };

  const isMethodActive = (measure, handler, args, method) => {
    var _measure$qDef$forecas;
    return method !== undefined && ((_measure$qDef$forecas = measure.qDef.forecast) === null || _measure$qDef$forecas === void 0 ? void 0 : _measure$qDef$forecas.method) === method && isForecastEnabled(measure, handler, args);
  };

  const translations = {
    FORECAST: 'properties.forecast.label',
    FORECAST_STEPS: 'properties.forecast.steps',
    METHOD: 'properties.forecast.method.label',
    SSA: 'properties.forecast.method.ssa',
    OLS: 'properties.forecast.method.ols',
    MEASURE_DISCLAIMER: 'properties.forecast.measureDisclaimer',
    STEP_SIZE: {
      TITLE: 'properties.forecast.stepSize.label',
      SECONDS: 'properties.forecast.stepUnit.seconds',
      MINUTES: 'properties.forecast.stepUnit.minutes',
      HOURS: 'properties.forecast.stepUnit.hours',
      DAYS: 'properties.forecast.stepUnit.days',
      WEEKS: 'properties.forecast.stepUnit.weeks',
      MONTHS: 'properties.forecast.stepUnit.months',
      YEARS: 'properties.forecast.stepUnit.years',
      NUMBER: 'properties.forecast.stepUnit.number'
    },
    CONFIDENCE: {
      SHOW: 'properties.forecast.showConfidence',
      LEVEL: 'properties.forecast.confidence'
    }
  };

  const show$3 = (data, handler, args) => handler.properties.qHyperCubeDef.qMeasures.some(measure => isForecastEnabled(measure, handler, args));

  const globalChange$1 = (properties, handler, args) => {
    updateForecastProperties(properties, args);
    return properties;
  };

  const {
    STEPS: STEPS$1
  } = CONSTANTS;
  function createForecastDimensionProperties() {
    const props = {
      type: 'items',
      translation: translations.FORECAST,
      items: {
        steps: {
          translation: translations.FORECAST_STEPS,
          type: 'integer',
          defaultValue: STEPS$1.NUM_STEPS,
          schemaIgnore: true,
          show: show$3,
          ref: 'qDef.forecast.steps',
          min: 1,
          rollbackInvalid: true,
          globalChange: globalChange$1
        },
        stepSize: {
          translation: translations.STEP_SIZE.TITLE,
          type: 'number',
          defaultValue: STEPS$1.STEP_SIZE_MULTIPLIER,
          schemaIgnore: true,
          show: show$3,
          ref: 'qDef.forecast.stepSizeMultiplier',
          min: Number.EPSILON,
          rollbackInvalid: true
        },
        unit: {
          type: 'string',
          component: 'dropdown',
          ref: 'qDef.forecast.stepSize',
          show: show$3,
          options: [{
            value: STEPS$1.STEP_SIZE.SECONDS,
            translation: translations.STEP_SIZE.SECONDS
          }, {
            value: STEPS$1.STEP_SIZE.MINUTES,
            translation: translations.STEP_SIZE.MINUTES
          }, {
            value: STEPS$1.STEP_SIZE.HOURS,
            translation: translations.STEP_SIZE.HOURS
          }, {
            value: STEPS$1.STEP_SIZE.DAYS,
            translation: translations.STEP_SIZE.DAYS
          }, {
            value: STEPS$1.STEP_SIZE.WEEKS,
            translation: translations.STEP_SIZE.WEEKS
          }, {
            value: STEPS$1.STEP_SIZE.MONTHS,
            translation: translations.STEP_SIZE.MONTHS
          }, {
            value: STEPS$1.STEP_SIZE.YEARS,
            translation: translations.STEP_SIZE.YEARS
          }, {
            value: STEPS$1.STEP_SIZE.NUMBER,
            translation: translations.STEP_SIZE.NUMBER
          }],
          defaultValue: STEPS$1.STEP_SIZE.DAYS
        }
      }
    };
    return props;
  }

  const show$2 = (data, handler, args) => {
    var _data$qDef$forecast;
    return ((_data$qDef$forecast = data.qDef.forecast) === null || _data$qDef$forecast === void 0 ? void 0 : _data$qDef$forecast.method) === 'ssa_forecast' && isForecastEnabled(data, handler, args);
  };

  const showConfidence = forecast => (forecast === null || forecast === void 0 ? void 0 : forecast.method) === 'ssa_forecast' && (forecast === null || forecast === void 0 ? void 0 : forecast.showConfidence);

  const METHOD = 'ssa_forecast';
  const show$1 = (data, handler, args) => !!(showConfidence(data.qDef.forecast) && isMethodActive(data, handler, args, METHOD));

  function createSsaProperties() {
    const props = {
      showConfidenceLevel: {
        translation: translations.CONFIDENCE.SHOW,
        type: 'boolean',
        ref: 'qDef.forecast.showConfidence',
        component: 'switch',
        defaultValue: true,
        options: [{
          value: true,
          translation: 'properties.on'
        }, {
          value: false,
          translation: 'properties.off'
        }],
        show: show$2,
        readOnly: disallowMeasureForecast
      },
      ssaConfidenceLevel: {
        translation: translations.CONFIDENCE.LEVEL,
        type: 'number',
        ref: 'qDef.forecast.confidence',
        defaultValue: 0.95,
        min: 0.00001,
        max: 0.99999,
        rollbackInvalid: true,
        show: show$1
      }
    };
    return props;
  }

  /* eslint-disable no-param-reassign */

  const {
    DEFAULT_METHOD: DEFAULT_METHOD$1
  } = CONSTANTS;
  function createForecastMeasureProperties() {
    const ssaProperties = createSsaProperties();
    const method = {
      translation: translations.METHOD,
      type: 'string',
      ref: 'qDef.forecast.method',
      component: 'dropdown',
      defaultValue: DEFAULT_METHOD$1,
      options: [{
        value: 'ssa_forecast',
        translation: translations.SSA
      }, {
        value: 'ols_forecast',
        translation: translations.OLS
      }],
      show: isForecastEnabled
    };
    const paletteColor = {
      translation: 'properties.color',
      type: 'object',
      ref: 'qDef.forecast.paletteColor',
      component: 'color-picker',
      defaultValue: () => ({
        index: 0,
        color: 'none'
      }),
      dualOutput: true,
      disableNone: false,
      show: isForecastEnabled
    };
    const lineThickness = {
      translation: 'LayerStyleEditor.style.lineThickness',
      type: 'number',
      ref: 'qDef.forecast.lineThickness',
      component: 'slider',
      defaultValue: 1,
      expression: 'optional',
      min: 1,
      max: 5,
      step: 1,
      show: isForecastEnabled
    };
    const lineType = {
      translation: 'LayerStyleEditor.style.lineType',
      type: 'string',
      ref: 'qDef.forecast.lineType',
      component: 'dropdown',
      defaultValue: 'dashed',
      expression: 'optional',
      options: [{
        value: 'solid',
        translation: 'LayerStyleEditor.style.solid'
      }, {
        value: 'dashed',
        translation: 'LayerStyleEditor.style.dashed'
      }],
      styleMeasure: true,
      show: isForecastEnabled
    };
    const lineCurve = {
      translation: 'LayerStyleEditor.style.lineCurve',
      type: 'string',
      ref: 'qDef.forecast.lineCurve',
      component: 'dropdown',
      defaultValue: 'linear',
      expression: 'optional',
      options: [{
        value: 'linear',
        translation: 'LayerStyleEditor.style.linear'
      }, {
        value: 'monotone',
        translation: 'LayerStyleEditor.style.monotone'
      }],
      styleMeasure: true,
      show: isForecastEnabled
    };
    const disclaimer = {
      translation: translations.MEASURE_DISCLAIMER,
      component: 'text',
      show: disallowMeasureForecast
    };
    function fillInDefaults(forecast) {
      if (!forecast) {
        return;
      }
      if (forecast.method === undefined) {
        forecast.method = method.defaultValue;
      }
      if (forecast.paletteColor === undefined) {
        forecast.paletteColor = paletteColor.defaultValue();
      }
      if (forecast.lineThickness === undefined) {
        forecast.lineThickness = lineThickness.defaultValue;
      }
      if (forecast.lineType === undefined) {
        forecast.lineType = lineType.defaultValue;
      }
      if (forecast.showConfidence === undefined) {
        forecast.showConfidence = ssaProperties.showConfidenceLevel.defaultValue;
      }
    }
    const enabled = {
      translation: translations.FORECAST,
      type: 'boolean',
      ref: 'qDef.forecast.enabled',
      component: 'switch',
      defaultValue: false,
      options: [{
        value: true,
        translation: 'properties.on'
      }, {
        value: false,
        translation: 'properties.off'
      }],
      show: isForecastAllowed,
      readOnly: disallowMeasureForecast,
      change: data => {
        fillInDefaults(data.qDef.forecast);
      }
    };
    const props = {
      type: 'items',
      translation: translations.FORECAST,
      items: {
        enabled,
        method,
        paletteColor,
        lineThickness,
        lineType,
        lineCurve,
        ...ssaProperties,
        disclaimer
      }
    };
    return props;
  }

  const show = (data, layout, args) => {
    var _layout$qHyperCube;
    return !hasConditionalData(args.properties) && ((_layout$qHyperCube = layout.qHyperCube) === null || _layout$qHyperCube === void 0 ? void 0 : _layout$qHyperCube.qMeasureInfo.some(measure => {
      var _measure$forecast;
      return measure === null || measure === void 0 || (_measure$forecast = measure.forecast) === null || _measure$forecast === void 0 ? void 0 : _measure$forecast.enabled;
    }));
  };

  const globalChange = (properties, handler, args) => {
    updateForecastProperties(properties, args);
    return properties;
  };

  const {
    STEPS
  } = CONSTANTS;
  function createForecastDimensionSoftProperties() {
    const props = {
      type: 'items',
      translation: translations.FORECAST,
      items: {
        steps: {
          translation: translations.FORECAST_STEPS,
          type: 'integer',
          defaultValue: STEPS.NUM_STEPS,
          schemaIgnore: true,
          show,
          ref: 'qDef.forecast.steps',
          min: 1,
          rollbackInvalid: true,
          globalChange
        },
        stepSize: {
          translation: translations.STEP_SIZE.TITLE,
          type: 'number',
          defaultValue: STEPS.STEP_SIZE_MULTIPLIER,
          schemaIgnore: true,
          show,
          ref: 'qDef.forecast.stepSizeMultiplier',
          min: Number.EPSILON,
          rollbackInvalid: true
        },
        unit: {
          type: 'string',
          component: 'dropdown',
          ref: 'qDef.forecast.stepSize',
          show,
          options: [{
            value: STEPS.STEP_SIZE.SECONDS,
            translation: translations.STEP_SIZE.SECONDS
          }, {
            value: STEPS.STEP_SIZE.MINUTES,
            translation: translations.STEP_SIZE.MINUTES
          }, {
            value: STEPS.STEP_SIZE.HOURS,
            translation: translations.STEP_SIZE.HOURS
          }, {
            value: STEPS.STEP_SIZE.DAYS,
            translation: translations.STEP_SIZE.DAYS
          }, {
            value: STEPS.STEP_SIZE.WEEKS,
            translation: translations.STEP_SIZE.WEEKS
          }, {
            value: STEPS.STEP_SIZE.MONTHS,
            translation: translations.STEP_SIZE.MONTHS
          }, {
            value: STEPS.STEP_SIZE.YEARS,
            translation: translations.STEP_SIZE.YEARS
          }, {
            value: STEPS.STEP_SIZE.NUMBER,
            translation: translations.STEP_SIZE.NUMBER
          }],
          defaultValue: STEPS.STEP_SIZE.DAYS
        }
      }
    };
    return props;
  }

  /* eslint-disable no-param-reassign */

  const {
    DEFAULT_METHOD
  } = CONSTANTS;
  function createForecastMeasureSoftProperties() {
    const method = {
      translation: translations.METHOD,
      type: 'string',
      ref: 'qDef.forecast.method',
      component: 'dropdown',
      defaultValue: DEFAULT_METHOD,
      options: [{
        value: 'ssa_forecast',
        translation: translations.SSA
      }, {
        value: 'ols_forecast',
        translation: translations.OLS
      }],
      show: isForecastEnabledSoft
    };
    const enabled = {
      translation: translations.FORECAST,
      type: 'boolean',
      ref: 'qDef.forecast.enabled',
      component: 'switch',
      defaultValue: false,
      options: [{
        value: true,
        translation: 'properties.on'
      }, {
        value: false,
        translation: 'properties.off'
      }],
      show: isForecastAllowedSoft,
      readOnly: disallowMeasureForecastSoft
    };
    const disclaimer = {
      translation: translations.MEASURE_DISCLAIMER,
      component: 'text',
      show: disallowMeasureForecastSoft
    };
    const props = {
      type: 'items',
      translation: translations.FORECAST,
      items: {
        enabled,
        method,
        disclaimer
      }
    };
    return props;
  }

  var conversion$1 = {exports: {}};

  (function (module, exports) {
    !function (e, r) {
      module.exports = r();
    }(self, () => (() => {
      var e = {
          229: e => {

            var r = Object.prototype.hasOwnProperty,
              n = Object.prototype.toString,
              t = Object.defineProperty,
              i = Object.getOwnPropertyDescriptor,
              o = function (e) {
                return "function" == typeof Array.isArray ? Array.isArray(e) : "[object Array]" === n.call(e);
              },
              a = function (e) {
                if (!e || "[object Object]" !== n.call(e)) return !1;
                var t,
                  i = r.call(e, "constructor"),
                  o = e.constructor && e.constructor.prototype && r.call(e.constructor.prototype, "isPrototypeOf");
                if (e.constructor && !i && !o) return !1;
                for (t in e);
                return void 0 === t || r.call(e, t);
              },
              s = function (e, r) {
                t && "__proto__" === r.name ? t(e, r.name, {
                  enumerable: !0,
                  configurable: !0,
                  value: r.newValue,
                  writable: !0
                }) : e[r.name] = r.newValue;
              },
              u = function (e, n) {
                if ("__proto__" === n) {
                  if (!r.call(e, n)) return;
                  if (i) return i(e, n).value;
                }
                return e[n];
              };
            e.exports = function e() {
              var r,
                n,
                t,
                i,
                l,
                c,
                p = arguments[0],
                f = 1,
                m = arguments.length,
                d = !1;
              for ("boolean" == typeof p && (d = p, p = arguments[1] || {}, f = 2), (null == p || "object" != typeof p && "function" != typeof p) && (p = {}); f < m; ++f) if (null != (r = arguments[f])) for (n in r) t = u(p, n), p !== (i = u(r, n)) && (d && i && (a(i) || (l = o(i))) ? (l ? (l = !1, c = t && o(t) ? t : []) : c = t && a(t) ? t : {}, s(p, {
                name: n,
                newValue: e(d, c, i)
              })) : void 0 !== i && s(p, {
                name: n,
                newValue: i
              }));
              return p;
            };
          },
          645: (e, r) => {
            (() => {

              var e = {
                  229: e => {
                    var r = Object.prototype.hasOwnProperty,
                      n = Object.prototype.toString,
                      t = Object.defineProperty,
                      i = Object.getOwnPropertyDescriptor,
                      o = function (e) {
                        return "function" == typeof Array.isArray ? Array.isArray(e) : "[object Array]" === n.call(e);
                      },
                      a = function (e) {
                        if (!e || "[object Object]" !== n.call(e)) return !1;
                        var t,
                          i = r.call(e, "constructor"),
                          o = e.constructor && e.constructor.prototype && r.call(e.constructor.prototype, "isPrototypeOf");
                        if (e.constructor && !i && !o) return !1;
                        for (t in e);
                        return void 0 === t || r.call(e, t);
                      },
                      s = function (e, r) {
                        t && "__proto__" === r.name ? t(e, r.name, {
                          enumerable: !0,
                          configurable: !0,
                          value: r.newValue,
                          writable: !0
                        }) : e[r.name] = r.newValue;
                      },
                      u = function (e, n) {
                        if ("__proto__" === n) {
                          if (!r.call(e, n)) return;
                          if (i) return i(e, n).value;
                        }
                        return e[n];
                      };
                    e.exports = function e() {
                      var r,
                        n,
                        t,
                        i,
                        l,
                        c,
                        p = arguments[0],
                        f = 1,
                        m = arguments.length,
                        d = !1;
                      for ("boolean" == typeof p && (d = p, p = arguments[1] || {}, f = 2), (null == p || "object" != typeof p && "function" != typeof p) && (p = {}); f < m; ++f) if (null != (r = arguments[f])) for (n in r) t = u(p, n), p !== (i = u(r, n)) && (d && i && (a(i) || (l = o(i))) ? (l ? (l = !1, c = t && o(t) ? t : []) : c = t && a(t) ? t : {}, s(p, {
                        name: n,
                        newValue: e(d, c, i)
                      })) : void 0 !== i && s(p, {
                        name: n,
                        newValue: i
                      }));
                      return p;
                    };
                  }
                },
                n = {};
              function t(r) {
                var i = n[r];
                if (void 0 !== i) return i.exports;
                var o = n[r] = {
                  exports: {}
                };
                return e[r](o, o.exports, t), o.exports;
              }
              t.n = e => {
                var r = e && e.__esModule ? () => e.default : () => e;
                return t.d(r, {
                  a: r
                }), r;
              }, t.d = (e, r) => {
                for (var n in r) t.o(r, n) && !t.o(e, n) && Object.defineProperty(e, n, {
                  enumerable: !0,
                  get: r[n]
                });
              }, t.o = (e, r) => Object.prototype.hasOwnProperty.call(e, r), t.r = e => {
                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                  value: "Module"
                }), Object.defineProperty(e, "__esModule", {
                  value: !0
                });
              };
              var i = {};
              (() => {
                t.r(i), t.d(i, {
                  default: () => Fe
                });
                var e = t(229),
                  r = t.n(e);
                const n = function (e, r, n) {
                    if (!r) return !1;
                    var t,
                      i = r.split("."),
                      o = i[i.length - 1],
                      a = e;
                    for (t = 0; t < i.length - 1; ++t) void 0 === a[i[t]] && (a[i[t]] = Number.isNaN(+i[t + 1]) ? {} : []), a = a[i[t]];
                    if (void 0 !== n) {
                      var s = a[o];
                      return a[o] = n, {
                        updated: n,
                        previous: s
                      };
                    }
                    return delete a[o], !1;
                  },
                  o = function (e, r, n) {
                    var t,
                      i = r.split("."),
                      o = e;
                    if (void 0 === o) return n;
                    for (t = 0; t < i.length; ++t) {
                      if (void 0 === o[i[t]]) return n;
                      o = o[i[t]];
                    }
                    return o;
                  },
                  a = {
                    EXPRESSIONS: {
                      observed: "",
                      trend: "STL_Trend",
                      seasonal: "STL_Seasonal",
                      residual: "STL_Residual"
                    },
                    OPTIONS: [{
                      value: "observed",
                      translation: "cao.trendDecomposition.parameters.decomposition.observed"
                    }, {
                      value: "trend",
                      translation: "cao.trendDecomposition.parameters.decomposition.trend"
                    }, {
                      value: "seasonal",
                      translation: "cao.trendDecomposition.parameters.decomposition.seasonal"
                    }, {
                      value: "residual",
                      translation: "cao.trendDecomposition.parameters.decomposition.residual"
                    }]
                  };
                var s = "".concat(" ", "(").concat("　"),
                  u = "".concat("　", ")").concat(" ");
                function l(e) {
                  return s + e + u;
                }
                function c(e) {
                  var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                  if (e.qLibraryId) {
                    var n = function (e, r) {
                      if (!r) return null;
                      var n, t;
                      for (n = 0; n < r.length; n++) if ((t = r[n]).qInfo.qId === e) return t;
                      return null;
                    }(e.qLibraryId, r.dimensionList);
                    return n && n.qData.info[0].qTags.indexOf("$numeric") > -1;
                  }
                  var t = function (e, r) {
                    if (!r) return null;
                    var n,
                      t,
                      i = function (e) {
                        var r = e.trim();
                        "=" === r.charAt(0) && (r = (r = r.substring(1)).trim());
                        var n = r.length - 1;
                        return "[" === r.charAt(0) && "]" === r.charAt(n) && (r = (r = r.substring(1, n)).trim()), r;
                      }(e);
                    for (n = 0; n < r.length; n++) {
                      if ((t = r[n]).qName === i) return t;
                      if (t.qDerivedFieldData) for (var o = 0; o < t.qDerivedFieldData.qDerivedFieldLists.length; ++o) for (var a = t.qDerivedFieldData.qDerivedFieldLists[o], s = 0; s < a.qFieldDefs.length; ++s) {
                        var u = a.qFieldDefs[s];
                        if (u.qName === i) return u;
                      }
                    }
                    return null;
                  }(e.qDef.qFieldDefs[0], r.fieldList);
                  return t && t.qTags.indexOf("$numeric") > -1;
                }
                function p(e) {
                  return !(!e.fullAccumulation && !e.fullRange);
                }
                function f(e, r) {
                  var n = e.crossAllDimensions;
                  return 2 === r && n ? "RowNo(Total)" : "RowNo()";
                }
                function m(e) {
                  var r = function (e) {
                      return e ? (e = function (e) {
                        return e.replace(/\/\*[^]*?\*\//g, "");
                      }(e = function (e) {
                        return e.replace(/\/\/(.*)$/gm, "");
                      }(e))).trim() : "";
                    }(e),
                    n = r.trim();
                  return "=" === n.substring(0, 1) ? n.substring(1).trim() : n;
                }
                function d() {
                  return "[$(=Replace(GetObjectField(".concat(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, "),']',']]'))]");
                }
                function y(e, r) {
                  var n = e.crossAllDimensions;
                  return 2 === r && n ? "Above(Total " : "Above(";
                }
                function q(e) {
                  return void 0 === e ? ")" : ", 0, ".concat(e, ")");
                }
                function b(e) {
                  return "Replace(Replace(".concat(e, ",'''',''''''),'$','$''&''')");
                }
                function v(e, r) {
                  return e ? "".concat(r, '={">=$(=Min(').concat(r, "))<=$(=Max(").concat(r, '))"}') : "".concat(r, '={"=Only({1}').concat(r, ")>='$(=").concat(b("MinString(".concat(r, ")")), ")' and Only({1}").concat(r, ")<='$(=").concat(b("MaxString(".concat(r, ")")), ")'\"}");
                }
                function D(e) {
                  var r = e.modifier,
                    n = void 0 === r ? {} : r,
                    t = e.dimensions,
                    i = e.dimensionAndFieldList,
                    o = e.funcComp,
                    a = void 0 === o ? "Sum" : o,
                    s = e.valueComp,
                    u = void 0 === s ? "0" : s;
                  if (!n.showExcludedValues) return "";
                  if (t && 1 === t.length) {
                    var l = v(c(t[0], i), d(0));
                    return "".concat(a, "({1<").concat(l, ">}").concat(u, ")");
                  }
                  if (t && 2 === t.length) {
                    var p = c(t[0], i),
                      f = c(t[1], i),
                      m = d(0),
                      y = d(1),
                      q = v(p, m),
                      b = v(f, y);
                    return "".concat(a, "({1<").concat(q, ",").concat(b, ">}").concat(u, ")");
                  }
                  return "".concat(a, "({1}").concat(u, ")");
                }
                function g(e) {
                  return "".concat(e, "(");
                }
                function h(e) {
                  var r = e.properties,
                    n = e.layout;
                  return o(r, "qHyperCubeDef.qDimensions", o(n, "qHyperCube.qDimensionInfo", [])).length;
                }
                const x = {
                  isFullRange: p,
                  getNumDimensions: h,
                  getExpressionWithExcludedComp: function (e) {
                    var r = e.expression,
                      n = e.modifier,
                      t = e.dimensions,
                      i = e.dimensionAndFieldList,
                      o = e.treatMissingAsNull,
                      a = l(m(r));
                    if (!n.showExcludedValues) return a;
                    var s = D({
                        modifier: n,
                        dimensions: t,
                        dimensionAndFieldList: i
                      }),
                      u = o ? "" : ", 0";
                    if (t && 1 === t.length) {
                      var c = d(0);
                      return "If(Count(".concat(c, ") > 0, ").concat(a, " + ").concat(s).concat(u, ")");
                    }
                    if (t && 2 === t.length) {
                      var p = d(0),
                        f = d(1);
                      return "If(Count(".concat(p, ") * Count(").concat(f, ") > 0, ").concat(a, " + ").concat(s).concat(u, ")");
                    }
                    return a;
                  },
                  getRowNoComp: f,
                  getNumStepComp: function (e, r) {
                    if (!p(e)) {
                      var n = e.steps;
                      return "number" != typeof n || Number.isNaN(n) ? 6 : n;
                    }
                    return f(e, r);
                  },
                  getAboveCompPrefix: y,
                  getAboveCompSuffix: q,
                  getAboveComp: function (e, r, n, t) {
                    return y(e, r) + n + q(t);
                  },
                  getFunctionPrefix: g,
                  getFunctionSuffix: function () {
                    return ")";
                  },
                  getRangeComp: function (e, r) {
                    return g(e) + r + ")";
                  },
                  getAggrComp: function (e, r, n) {
                    return "Aggr(".concat(e, ", ").concat(r, ", ").concat(n, ")");
                  },
                  getExcludedComp: D,
                  needDimension: function (e) {
                    var r = e.modifier,
                      n = e.properties,
                      t = e.layout,
                      i = function (e) {
                        return void 0 === e.primaryDimension ? e.accumulationDimension : e.primaryDimension;
                      }(r);
                    return 0 === i && 2 === h({
                      properties: n,
                      layout: t
                    });
                  },
                  getDimComp: function (e, r) {
                    var n = function (e) {
                        return e[arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0].qDef.qSortCriterias[0];
                      }(e, r),
                      t = d(r);
                    if (!n.qSortByExpression && !n.qSortByNumeric && !n.qSortByAscii) return t;
                    var i = ["Descending", "Ascending"],
                      o = n.qSortByNumeric ? "(Numeric, ".concat(i[(n.qSortByNumeric + 1) / 2], ")") : "",
                      a = n.qSortByAscii ? "(Text, ".concat(i[(n.qSortByAscii + 1) / 2], ")") : "";
                    return n.qSortByNumeric && n.qSortByAscii ? "(".concat(t, ", ").concat(o, ", ").concat(a, ")") : n.qSortByNumeric ? "(".concat(t, ", ").concat(o, ")") : n.qSortByAscii ? "(".concat(t, ", ").concat(a, ")") : t;
                  },
                  simplifyExpression: m,
                  extractInputExpression: function (e) {
                    var r = e.outputExpression;
                    if (e.modifier) {
                      var n = r.indexOf(s);
                      if (-1 !== n) {
                        var t = r.indexOf(u);
                        if (-1 !== t) return r.substring(n + s.length, t);
                      }
                    }
                  },
                  initModifier: function (e, r) {
                    Object.keys(r).forEach(function (n) {
                      void 0 === e[n] && (e[n] = r[n]);
                    });
                  },
                  isNumeric: c,
                  isApplicable: function (e) {
                    var r = e.properties,
                      n = e.layout,
                      t = e.minDimensions,
                      i = void 0 === t ? 1 : t,
                      o = e.maxDimensions,
                      a = void 0 === o ? 2 : o;
                    if (!r && !n) return !0;
                    var s = h({
                      properties: r,
                      layout: n
                    });
                    return s >= i && s <= a;
                  },
                  getExpressionWithMarkers: l,
                  canExtract: function (e) {
                    var r = e.indexOf(s),
                      n = e.indexOf(u);
                    return r > -1 && n > -1 && r < n;
                  },
                  getDimDefWithWrapper: d,
                  getFieldWithWrapper: function (e) {
                    var r = e ? e.replace(/]/g, "]]") : e;
                    return "[".concat(r, "]");
                  },
                  generateTSDExpression: function (e, r, n) {
                    var t = r || e.outputExpression;
                    if (e.base && e.base.qDef && (t = r !== e.base.qDef ? r : e.base.qDef), "observed" !== e.decomposition) {
                      var i = n.qHyperCubeDef.qMeasures.find(function (r) {
                        return r.qDef.base && r.qDef.base.qLibraryId && e.base && e.base.qLibraryId ? r.qDef.base.qLibraryId === e.base.qLibraryId : null;
                      });
                      i && r !== i.qDef.qLabel && (t = i.qLibraryId || i.qDef.base.qLibraryId ? "[".concat(i.qDef.qLabel, "]") : i.qDef.base.qDef);
                      var o = function (e) {
                        var r = a.OPTIONS.find(function (r) {
                          return r.value === e.decomposition;
                        });
                        return r ? a.EXPRESSIONS[r.value] : "";
                      }(e);
                      t = t.startsWith("=") ? t.substr(1) : t, t = "".concat(o, "(").concat(t, ", ").concat(e.steps, ")");
                    }
                    return t;
                  },
                  getDecomposition: function (e) {
                    var r = "observed";
                    return Object.values(a.EXPRESSIONS).find(function (n) {
                      var t = e.qDef.base.qDef.toLowerCase() || e.qDef.qDef.toLowerCase();
                      return a.EXPRESSIONS[n] && t.includes(a.EXPRESSIONS[n].toLowerCase()) && (r = n), n;
                    }), r;
                  }
                };
                function A(e, r) {
                  (null == r || r > e.length) && (r = e.length);
                  for (var n = 0, t = new Array(r); n < r; n++) t[n] = e[n];
                  return t;
                }
                function E(e) {
                  return E = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                    return typeof e;
                  } : function (e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                  }, E(e);
                }
                var C = r().bind(null, !0),
                  I = {},
                  S = Array.isArray;
                function M(e) {
                  return null != e && !Array.isArray(e) && "object" === E(e);
                }
                function L(e) {
                  return void 0 === e;
                }
                function O(e, r) {
                  return "function" == typeof e[r] || "$$" === r.substring(0, 2) || "_" === r.substring(0, 1);
                }
                function F(e, r) {
                  var n,
                    t = r.substring(1).split("/").slice(0, -1);
                  return t.forEach(function (r, i) {
                    if (i !== t.length) {
                      n = +r;
                      var o = Number.isNaN(n) ? {} : [];
                      e[n || r] = L(e[n || r]) ? o : e[r], e = e[n || r];
                    }
                  }), e;
                }
                function P(e, r) {
                  var n = !0;
                  if (M(e) && M(r)) return Object.keys(e).length === Object.keys(r).length && (Object.keys(e).forEach(function (t) {
                    P(e[t], r[t]) || (n = !1);
                  }), n);
                  if (S(e) && S(r)) {
                    if (e.length !== r.length) return !1;
                    for (var t = 0, i = e.length; t < i; t += 1) if (!P(e[t], r[t])) return !1;
                    return !0;
                  }
                  return e === r;
                }
                I.generate = function (e, r, n) {
                  n = n || "";
                  var t = [];
                  return Object.keys(r).forEach(function (i) {
                    var o = function (e) {
                        return e ? C({}, {
                          val: e
                        }).val : e;
                      }(r[i]),
                      a = e[i],
                      s = "".concat(n, "/").concat(i);
                    P(o, a) || O(r, i) || (L(a) ? t.push({
                      op: "add",
                      path: s,
                      value: o
                    }) : M(o) && M(a) ? t = t.concat(I.generate(a, o, s)) : S(o) && S(a) ? t = t.concat(function (e, r, n) {
                      var t = [],
                        i = e.slice(),
                        o = -1;
                      function a(e, r, n) {
                        if (e[n] && L(e[n].qInfo)) return null;
                        if (e[n] && e[n].qInfo.qId === r) return n;
                        for (var t = 0, i = e.length; t < i; t += 1) if (e[t] && e[t].qInfo.qId === r) return t;
                        return -1;
                      }
                      if (P(r, i)) return t;
                      if (!L(r[0]) && L(r[0].qInfo)) return t.push({
                        op: "replace",
                        path: n,
                        value: r
                      }), t;
                      for (var s = i.length - 1; s >= 0; s -= 1) -1 === (o = a(r, i[s].qInfo && i[s].qInfo.qId, s)) ? (t.push({
                        op: "remove",
                        path: "".concat(n, "/").concat(s)
                      }), i.splice(s, 1)) : t = t.concat(I.generate(i[s], r[o], "".concat(n, "/").concat(s)));
                      for (var u = 0, l = r.length; u < l; u += 1) -1 === (o = a(i, r[u].qInfo && r[u].qInfo.qId)) ? (t.push({
                        op: "add",
                        path: "".concat(n, "/").concat(u),
                        value: r[u]
                      }), i.splice(u, 0, r[u])) : o !== u && (t.push({
                        op: "move",
                        path: "".concat(n, "/").concat(u),
                        from: "".concat(n, "/").concat(o)
                      }), i.splice(u, 0, i.splice(o, 1)[0]));
                      return t;
                    }(a, o, s)) : t.push({
                      op: "replace",
                      path: "".concat(n, "/").concat(i),
                      value: o
                    }));
                  }), Object.keys(e).forEach(function (i) {
                    L(r[i]) && !O(e, i) && t.push({
                      op: "remove",
                      path: "".concat(n, "/").concat(i)
                    });
                  }), t;
                }, I.apply = function (e, r) {
                  r.forEach(function (r) {
                    var n,
                      t,
                      i = F(e, r.path),
                      o = r.path.split("/").splice(-1)[0],
                      a = o && Number.isNaN(+o) ? i[o] : i[+o] || i,
                      s = r.from ? r.from.split("/").splice(-1)[0] : null;
                    if ("/" === r.path && (i = null, a = e), "add" === r.op || "replace" === r.op) {
                      if (S(i)) "-" === o && (o = i.length), i.splice(+o, "add" === r.op ? 0 : 1, r.value);else if (S(a) && S(r.value)) {
                        var u,
                          l = r.value.slice();
                        a.length = 0, (u = a).push.apply(u, function (e) {
                          if (Array.isArray(e)) return A(e);
                        }(t = l) || function (e) {
                          if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e);
                        }(t) || function (e, r) {
                          if (e) {
                            if ("string" == typeof e) return A(e, r);
                            var n = Object.prototype.toString.call(e).slice(8, -1);
                            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? A(e, r) : void 0;
                          }
                        }(t) || function () {
                          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                        }());
                      } else if (M(a) && M(r.value)) n = a, Object.keys(n).forEach(function (e) {
                        Object.getOwnPropertyDescriptor(n, e).configurable && !O(n, e) && delete n[e];
                      }), C(a, r.value);else {
                        if (!i) throw new Error("Patchee is not an object we can patch");
                        i[o] = r.value;
                      }
                    } else if ("move" === r.op) {
                      var c = F(e, r.from);
                      S(i) ? i.splice(+o, 0, c.splice(+s, 1)[0]) : (i[o] = c[s], delete c[s]);
                    } else "remove" === r.op && (S(i) ? i.splice(+o, 1) : delete i[o]);
                  });
                }, I.clone = function (e) {
                  return C({}, e);
                }, I.createPatch = function (e, r, n) {
                  var t = {
                    op: e.toLowerCase(),
                    path: n
                  };
                  return "move" === t.op ? t.from = r : void 0 !== r && (t.value = r), t;
                }, I.updateObject = function (e, r) {
                  Object.keys(e).length ? I.apply(e, I.generate(e, r)) : C(e, r);
                };
                const V = I,
                  N = function (e, n, t) {
                    if (!e) return Promise.resolve();
                    var i = V.generate(n, t);
                    return r()(!0, n, t), i && i.length ? (i = i.map(function (e) {
                      return {
                        qOp: e.op,
                        qValue: JSON.stringify(e.value),
                        qPath: e.path
                      };
                    }), e.applyPatches(i, !0)) : Promise.resolve();
                  };
                var w = "accumulation";
                function H(e, r) {
                  var n = o(e, r);
                  if (n) for (var t = 0; t < n.length; t++) if (n[t].type === w) return n[t];
                }
                function T(e, r) {
                  var n = function (e, r) {
                    var n = o(e, r);
                    if (!n) return -1;
                    for (var t = 0; t < n.length; t++) if (n[t].type === w) return t;
                    return -1;
                  }(e, r);
                  return n > -1 ? "".concat(r, ".").concat(n) : r;
                }
                var j = {
                  type: "accumulation",
                  disabled: !1,
                  accumulationDimension: 0,
                  crossAllDimensions: !1,
                  showExcludedValues: !0,
                  fullAccumulation: !1,
                  steps: 6,
                  outputExpression: ""
                };
                const R = {
                  translationKey: "properties.modifier.accumulation",
                  needDimension: x.needDimension,
                  isApplicable: function (e) {
                    var r = e.properties,
                      n = e.layout;
                    return x.isApplicable({
                      properties: r,
                      layout: n,
                      minDimensions: 1,
                      maxDimensions: 2
                    });
                  },
                  generateExpression: function (e) {
                    var r = e.expression,
                      n = e.modifier,
                      t = e.properties,
                      i = e.layout,
                      a = e.numDimensions,
                      s = e.dimensionAndFieldList;
                    if (!n) return r;
                    var u = a;
                    void 0 === u && (u = x.getNumDimensions({
                      properties: t,
                      layout: i
                    }));
                    var l = o(t, "qHyperCubeDef.qDimensions", []),
                      c = x.getExpressionWithExcludedComp({
                        expression: r,
                        modifier: n,
                        dimensions: l,
                        dimensionAndFieldList: s
                      }),
                      p = x.getNumStepComp(n, u),
                      f = x.getAboveComp(n, u, c, p),
                      m = x.getRangeComp("RangeSum", f);
                    if (x.needDimension({
                      modifier: n,
                      properties: t,
                      layout: i
                    })) {
                      var d = x.getDimComp(l, 1),
                        y = x.getDimComp(l, 0),
                        q = x.getAggrComp(m, d, y);
                      m = n.showExcludedValues ? x.getExcludedComp({
                        modifier: n,
                        dimensions: l,
                        dimensionAndFieldList: s,
                        valueComp: q
                      }) : q;
                    }
                    return m;
                  },
                  extractInputExpression: x.extractInputExpression,
                  initModifier: function (e) {
                    x.initModifier(e, j);
                  },
                  enableTotalsFunction: function () {
                    return !1;
                  },
                  propertyPanelDef: function (e) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                      n = {
                        type: "items",
                        items: {
                          disclaimer: {
                            component: "text",
                            translation: r.disclaimer || "properties.modifier.accumulation.disclaimer",
                            show: function (e, r) {
                              return !x.isApplicable({
                                properties: r.properties
                              });
                            }
                          },
                          settings: {
                            type: "items",
                            items: {
                              primaryDimension: {
                                refFn: function (r) {
                                  return "".concat(T(r, e), ".accumulationDimension");
                                },
                                type: "integer",
                                translation: r.primaryDimension || "properties.modifier.primaryDimension",
                                title: {
                                  translation: r.primaryDimensionTooltip || "properties.modifier.accumulation.primaryDimension.tooltip"
                                },
                                component: "dropdown",
                                schemaIgnore: !0,
                                defaultValue: 1,
                                options: function (e, r) {
                                  return r.layout.qHyperCube.qDimensionInfo.map(function (e, r) {
                                    return {
                                      value: r,
                                      label: e.qGroupFallbackTitles[0]
                                    };
                                  });
                                },
                                show: function (e, r) {
                                  return r.layout.qHyperCube.qDimensionInfo.length > 1;
                                }
                              },
                              crossAllDimensions: {
                                refFn: function (r) {
                                  return "".concat(T(r, e), ".crossAllDimensions");
                                },
                                type: "boolean",
                                translation: r.crossAllDimensions || "properties.modifier.crossAllDimensions",
                                title: {
                                  translation: r.crossAllDimensionsTooltip || "properties.modifier.accumulation.crossAllDimensions.tooltip"
                                },
                                schemaIgnore: !0,
                                defaultValue: !1,
                                show: function (e, r) {
                                  return r.layout.qHyperCube.qDimensionInfo.length > 1;
                                }
                              },
                              fullRange: {
                                refFn: function (r) {
                                  return "".concat(T(r, e), ".fullAccumulation");
                                },
                                type: "boolean",
                                translation: r.range || "properties.modifier.range",
                                component: "dropdown",
                                schemaIgnore: !0,
                                defaultValue: !1,
                                options: [{
                                  value: !0,
                                  translation: r.rangeFull || "properties.modifier.range.full"
                                }, {
                                  value: !1,
                                  translation: r.rangeCustom || "properties.modifier.range.custom"
                                }]
                              },
                              steps: {
                                refFn: function (r) {
                                  return "".concat(T(r, e), ".steps");
                                },
                                type: "integer",
                                translation: r.rangeSteps || "properties.modifier.range.steps",
                                schemaIgnore: !0,
                                defaultValue: 6,
                                change: function (r) {
                                  var n = H(r, e);
                                  if (n) {
                                    var t = n.steps;
                                    n.steps = "number" != typeof t || Number.isNaN(t) ? 6 : Math.abs(t);
                                  }
                                },
                                show: function (r) {
                                  var n = H(r, e);
                                  return n && !n.fullAccumulation;
                                }
                              },
                              showExcludedValues: {
                                refFn: function (r) {
                                  return "".concat(T(r, e), ".showExcludedValues");
                                },
                                type: "boolean",
                                translation: r.showExcludedValues || "properties.modifier.showExcludedValues",
                                schemaIgnore: !0,
                                defaultValue: !0
                              }
                            },
                            show: function (e, r) {
                              return x.isApplicable({
                                properties: r.properties
                              });
                            }
                          }
                        },
                        show: function (r, n, t) {
                          var i = t.ext.support.modifiers;
                          if (!Array.isArray(i) || -1 === i.indexOf(w)) return !1;
                          var o = H(r, e);
                          return o && !o.disabled;
                        }
                      };
                    return n;
                  }
                };
                var _ = "movingAverage";
                function B(e, r) {
                  var n = o(e, r);
                  if (n) for (var t = 0; t < n.length; t++) if (n[t].type === _) return n[t];
                }
                function k(e, r) {
                  var n = function (e, r) {
                    var n = o(e, r);
                    if (!n) return -1;
                    for (var t = 0; t < n.length; t++) if (n[t].type === _) return t;
                    return -1;
                  }(e, r);
                  return n > -1 ? "".concat(r, ".").concat(n) : r;
                }
                var W = {
                  type: "movingAverage",
                  disabled: !1,
                  primaryDimension: 0,
                  crossAllDimensions: !1,
                  showExcludedValues: !0,
                  fullRange: !1,
                  steps: 6,
                  outputExpression: "",
                  nullSuppression: !1
                };
                const $ = {
                  translationKey: "properties.modifier.movingAverage",
                  needDimension: x.needDimension,
                  isApplicable: function (e) {
                    var r = e.properties,
                      n = e.layout;
                    return x.isApplicable({
                      properties: r,
                      layout: n,
                      minDimensions: 1,
                      maxDimensions: 2
                    });
                  },
                  generateExpression: function (e) {
                    var r,
                      n = e.expression,
                      t = e.modifier,
                      i = e.properties,
                      a = e.layout,
                      s = e.numDimensions,
                      u = e.dimensionAndFieldList;
                    if (!t) return n;
                    var l = s;
                    void 0 === l && (l = x.getNumDimensions({
                      properties: i,
                      layout: a
                    }));
                    var c = o(i, "qHyperCubeDef.qDimensions", []),
                      p = t.showExcludedValues && t.nullSuppression,
                      f = x.getExpressionWithExcludedComp({
                        expression: n,
                        modifier: t,
                        dimensions: c,
                        dimensionAndFieldList: u,
                        treatMissingAsNull: p
                      }),
                      m = x.getNumStepComp(t, l),
                      d = x.getAboveComp(t, l, f, m);
                    if (t.nullSuppression) r = x.getRangeComp("RangeAvg", d);else {
                      var y = x.getRangeComp("RangeSum", d),
                        q = function (e, r) {
                          var n = x.getRowNoComp(e, r);
                          if (!x.isFullRange(e)) {
                            var t = e.steps,
                              i = "number" != typeof t || Number.isNaN(t) ? 6 : t;
                            return "RangeMin(".concat(i, ", ").concat(n, ")");
                          }
                          return n;
                        }(t, l);
                      r = "".concat(y, " / ").concat(q);
                    }
                    var b = r;
                    if (x.needDimension({
                      modifier: t,
                      properties: i,
                      layout: a
                    })) {
                      var v = x.getDimComp(c, 1),
                        D = x.getDimComp(c, 0),
                        g = x.getAggrComp(b, v, D);
                      b = t.showExcludedValues ? x.getExcludedComp({
                        modifier: t,
                        dimensions: c,
                        dimensionAndFieldList: u,
                        funcComp: "Only",
                        valueComp: g
                      }) : g;
                    }
                    return b;
                  },
                  extractInputExpression: x.extractInputExpression,
                  initModifier: function (e) {
                    x.initModifier(e, W);
                  },
                  enableTotalsFunction: function () {
                    return !1;
                  },
                  propertyPanelDef: function (e) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                      n = {
                        type: "items",
                        items: {
                          disclaimer: {
                            component: "text",
                            translation: r.disclaimer || "properties.modifier.movingAverage.disclaimer",
                            show: function (e, r) {
                              return !x.isApplicable({
                                properties: r.properties
                              });
                            }
                          },
                          settings: {
                            type: "items",
                            items: {
                              primaryDimension: {
                                refFn: function (r) {
                                  return "".concat(k(r, e), ".primaryDimension");
                                },
                                type: "integer",
                                translation: r.primaryDimension || "properties.modifier.primaryDimension",
                                title: {
                                  translation: r.primaryDimensionTooltip || "properties.modifier.movingAverage.primaryDimension.tooltip"
                                },
                                component: "dropdown",
                                schemaIgnore: !0,
                                defaultValue: 1,
                                options: function (e, r) {
                                  return r.layout.qHyperCube.qDimensionInfo.map(function (e, r) {
                                    return {
                                      value: r,
                                      label: e.qGroupFallbackTitles[0]
                                    };
                                  });
                                },
                                show: function (e, r) {
                                  return r.layout.qHyperCube.qDimensionInfo.length > 1;
                                }
                              },
                              crossAllDimensions: {
                                refFn: function (r) {
                                  return "".concat(k(r, e), ".crossAllDimensions");
                                },
                                type: "boolean",
                                translation: r.crossAllDimensions || "properties.modifier.crossAllDimensions",
                                title: {
                                  translation: r.crossAllDimensionsTooltip || "properties.modifier.movingAverage.crossAllDimensions.tooltip"
                                },
                                schemaIgnore: !0,
                                defaultValue: !1,
                                show: function (e, r) {
                                  return r.layout.qHyperCube.qDimensionInfo.length > 1;
                                }
                              },
                              fullRange: {
                                refFn: function (r) {
                                  return "".concat(k(r, e), ".fullRange");
                                },
                                type: "boolean",
                                translation: r.range || "properties.modifier.range",
                                component: "dropdown",
                                schemaIgnore: !0,
                                defaultValue: !1,
                                options: [{
                                  value: !0,
                                  translation: r.rangeFull || "properties.modifier.range.full"
                                }, {
                                  value: !1,
                                  translation: r.rangeCustom || "properties.modifier.range.custom"
                                }]
                              },
                              steps: {
                                refFn: function (r) {
                                  return "".concat(k(r, e), ".steps");
                                },
                                type: "integer",
                                translation: r.rangeSteps || "properties.modifier.range.steps",
                                schemaIgnore: !0,
                                defaultValue: 6,
                                change: function (r) {
                                  var n = B(r, e);
                                  if (n) {
                                    var t = n.steps;
                                    n.steps = "number" != typeof t || Number.isNaN(t) ? 6 : Math.abs(t);
                                  }
                                },
                                show: function (r) {
                                  var n = B(r, e);
                                  return n && !n.fullRange;
                                }
                              },
                              showExcludedValues: {
                                refFn: function (r) {
                                  return "".concat(k(r, e), ".showExcludedValues");
                                },
                                type: "boolean",
                                translation: r.showExcludedValues || "properties.modifier.showExcludedValues",
                                schemaIgnore: !0,
                                defaultValue: !0
                              },
                              nullSuppression: {
                                refFn: function (r) {
                                  return "".concat(k(r, e), ".nullSuppression");
                                },
                                type: "boolean",
                                translation: r.showNull || "properties.dimensions.showNull",
                                schemaIgnore: !0,
                                defaultValue: !1,
                                inverted: !0
                              }
                            },
                            show: function (e, r) {
                              return x.isApplicable({
                                properties: r.properties
                              });
                            }
                          }
                        },
                        show: function (r, n, t) {
                          var i = t.ext.support.modifiers;
                          if (!Array.isArray(i) || -1 === i.indexOf(_)) return !1;
                          var o = B(r, e);
                          return o && !o.disabled;
                        }
                      };
                    return n;
                  }
                };
                var U = "timeSeriesDecomposition";
                function G(e, r) {
                  var n = o(e, r);
                  if (n) for (var t = 0; t < n.length; t++) if (n[t].type === U) return n[t];
                }
                function z(e, r) {
                  var n = function (e, r) {
                    var n = o(e, r);
                    if (!n) return -1;
                    for (var t = 0; t < n.length; t++) if (n[t].type === U) return t;
                    return -1;
                  }(e, r);
                  return n > -1 ? "".concat(r, ".").concat(n) : r;
                }
                var Y = {
                  type: "timeSeriesDecomposition",
                  disabled: !1,
                  decomposition: "",
                  steps: 2,
                  outputExpression: ""
                };
                const J = {
                  translationKey: "properties.modifier.timeSeriesDecomposition",
                  needDimension: x.needDimension,
                  isApplicable: function (e) {
                    var r = e.properties,
                      n = e.layout;
                    return x.isApplicable({
                      properties: r,
                      layout: n,
                      minDimensions: 1,
                      maxDimensions: 2
                    });
                  },
                  generateExpression: function (e) {
                    var r = e.expression,
                      n = e.modifier,
                      t = e.properties;
                    return n ? x.generateTSDExpression(n, r, t) : r;
                  },
                  extractInputExpression: x.extractInputExpression,
                  initModifier: function (e, r) {
                    x.initModifier(e, Y), "" === e.decomposition && r && (e.decomposition = x.getDecomposition(r));
                  },
                  propertyPanelDef: function (e) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                      n = {
                        type: "items",
                        items: {
                          disclaimer: {
                            component: "text",
                            translation: r.timeSeriesDecomposition || "properties.modifier.timeSeriesDecomposition",
                            show: function (e, r) {
                              return !x.isApplicable({
                                properties: r.properties
                              });
                            }
                          },
                          settings: {
                            type: "items",
                            items: {
                              decomposition: {
                                refFn: function (r) {
                                  return "".concat(z(r, e), ".decomposition");
                                },
                                type: "string",
                                translation: r.modifierTrendDecompositionDecomposition || "properties.modifier.trendDecomposition.decomposition",
                                component: "dropdown",
                                schemaIgnore: !0,
                                defaultValue: r.trendDecompositionParametersDecompositionObserved || "cao.trendDecomposition.parameters.decomposition.observed",
                                options: a.OPTIONS
                              },
                              steps: {
                                refFn: function (r) {
                                  return "".concat(z(r, e), ".steps");
                                },
                                type: "integer",
                                translation: r.modifierTimeSeriesDecompositionPeriods || "properties.modifier.timeSeriesDecomposition.periods",
                                schemaIgnore: !0,
                                defaultValue: 2,
                                change: function (r, n) {
                                  var t = G(r, e);
                                  if (t) {
                                    var i = t.steps;
                                    t.steps = "number" != typeof i || Number.isNaN(i) ? 2 : Math.abs(i), n.properties.qHyperCubeDef.qMeasures = n.properties.qHyperCubeDef.qMeasures.map(function (e) {
                                      return e.qDef.modifiers.map(function (e) {
                                        return "timeSeriesDecomposition" === e.type ? e.steps = i : e.steps = e.steps, e;
                                      }), e;
                                    });
                                  }
                                },
                                show: function (r) {
                                  var n = G(r, e);
                                  return n && !n.fullRange;
                                }
                              }
                            },
                            show: function (e, r) {
                              return x.isApplicable({
                                properties: r.properties
                              });
                            }
                          }
                        },
                        show: function (r, n, t) {
                          var i = t.ext.support.modifiers;
                          if (!Array.isArray(i) || -1 === i.indexOf(U)) return !1;
                          var o = G(r, e);
                          return o && !o.disabled;
                        }
                      };
                    return n;
                  }
                };
                var K = "difference";
                function X(e, r) {
                  var n = o(e, r);
                  if (n) for (var t = 0; t < n.length; t++) if (n[t].type === K) return n[t];
                }
                function Q(e, r) {
                  var n = function (e, r) {
                    var n = o(e, r);
                    if (!n) return -1;
                    for (var t = 0; t < n.length; t++) if (n[t].type === K) return t;
                    return -1;
                  }(e, r);
                  return n > -1 ? "".concat(r, ".").concat(n) : r;
                }
                var Z = {
                  type: "difference",
                  disabled: !1,
                  primaryDimension: 0,
                  crossAllDimensions: !1,
                  showExcludedValues: !0,
                  outputExpression: ""
                };
                const ee = {
                  translationKey: "properties.modifier.difference",
                  needDimension: x.needDimension,
                  isApplicable: function (e) {
                    var r = e.properties,
                      n = e.layout;
                    return x.isApplicable({
                      properties: r,
                      layout: n,
                      minDimensions: 1,
                      maxDimensions: 2
                    });
                  },
                  extractInputExpression: x.extractInputExpression,
                  generateExpression: function (e) {
                    var r = e.expression,
                      n = e.modifier,
                      t = e.properties,
                      i = e.layout,
                      a = e.numDimensions,
                      s = e.dimensionAndFieldList;
                    if (!n) return r;
                    var u = a;
                    void 0 === u && (u = x.getNumDimensions({
                      properties: t,
                      layout: i
                    }));
                    var l = o(t, "qHyperCubeDef.qDimensions", []),
                      c = x.getExpressionWithExcludedComp({
                        expression: r,
                        modifier: n,
                        dimensions: l,
                        dimensionAndFieldList: s
                      }),
                      p = x.getAboveComp(n, u, c),
                      f = "".concat(c, " - ").concat(p);
                    if (x.needDimension({
                      modifier: n,
                      properties: t,
                      layout: i
                    })) {
                      var m = x.getDimComp(l, 1),
                        d = x.getDimComp(l, 0),
                        y = x.getAggrComp(f, m, d);
                      f = n.showExcludedValues ? x.getExcludedComp({
                        modifier: n,
                        dimensions: l,
                        dimensionAndFieldList: s,
                        funcComp: "Only",
                        valueComp: y
                      }) : y;
                    }
                    return f;
                  },
                  initModifier: function (e) {
                    Object.keys(Z).forEach(function (r) {
                      void 0 === e[r] && (e[r] = Z[r]);
                    });
                  },
                  enableTotalsFunction: function () {
                    return !1;
                  },
                  propertyPanelDef: function (e) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                      n = {
                        type: "items",
                        items: {
                          disclaimer: {
                            component: "text",
                            translation: r.disclaimer || "properties.modifier.difference.disclaimer",
                            show: function (e, r) {
                              return !x.isApplicable({
                                properties: r.properties
                              });
                            }
                          },
                          settings: {
                            type: "items",
                            items: {
                              primaryDimension: {
                                refFn: function (r) {
                                  return "".concat(Q(r, e), ".primaryDimension");
                                },
                                type: "integer",
                                translation: r.primaryDimension || "properties.modifier.primaryDimension",
                                title: {
                                  translation: r.primaryDimensionTooltip || "properties.modifier.difference.primaryDimension.tooltip"
                                },
                                component: "dropdown",
                                schemaIgnore: !0,
                                defaultValue: 1,
                                options: function (e, r) {
                                  return r.layout.qHyperCube.qDimensionInfo.map(function (e, r) {
                                    return {
                                      value: r,
                                      label: e.qGroupFallbackTitles[0]
                                    };
                                  });
                                },
                                show: function (e, r) {
                                  return r.layout.qHyperCube.qDimensionInfo.length > 1;
                                }
                              },
                              crossAllDimensions: {
                                refFn: function (r) {
                                  return "".concat(Q(r, e), ".crossAllDimensions");
                                },
                                type: "boolean",
                                translation: r.crossAllDimensions || "properties.modifier.crossAllDimensions",
                                title: {
                                  translation: r.crossAllDimensionsTooltip || "properties.modifier.difference.crossAllDimensions.tooltip"
                                },
                                schemaIgnore: !0,
                                defaultValue: !1,
                                show: function (e, r) {
                                  return r.layout.qHyperCube.qDimensionInfo.length > 1;
                                }
                              },
                              showExcludedValues: {
                                refFn: function (r) {
                                  return "".concat(Q(r, e), ".showExcludedValues");
                                },
                                type: "boolean",
                                translation: r.showExcludedValues || "properties.modifier.showExcludedValues",
                                schemaIgnore: !0,
                                defaultValue: !0
                              }
                            },
                            show: function (e, r) {
                              return x.isApplicable({
                                properties: r.properties
                              });
                            }
                          }
                        },
                        show: function (r, n, t) {
                          var i = t.ext.support.modifiers;
                          if (!Array.isArray(i) || -1 === i.indexOf(K)) return !1;
                          var o = X(r, e);
                          return o && !o.disabled;
                        }
                      };
                    return n;
                  }
                };
                var re = "normalization";
                function ne(e, r) {
                  var n = o(e, r);
                  if (n) for (var t = 0; t < n.length; t++) if (n[t].type === re) return n[t];
                }
                function te(e, r) {
                  var n = function (e, r) {
                    var n = o(e, r);
                    if (!n) return -1;
                    for (var t = 0; t < n.length; t++) if (n[t].type === re) return t;
                    return -1;
                  }(e, r);
                  return n > -1 ? "".concat(r, ".").concat(n) : r;
                }
                function ie(e, r) {
                  for (var n = 0; n < e.length; n++) if (e[n].value === r) return n;
                  return -1;
                }
                var oe = {
                  type: "normalization",
                  disabled: !1,
                  primaryDimension: 0,
                  outputExpression: "",
                  dimensionalScope: 2,
                  selectionScope: 2
                };
                function ae(e) {
                  return 2 === e ? "{1}" : "";
                }
                function se(e, r, n) {
                  return 1 === e ? "{$<".concat(x.getFieldWithWrapper(r), "={'").concat(n, "'}>}") : "";
                }
                function ue(e, r) {
                  return 0 === e && r > 1 || 2 === e ? "Total" : "";
                }
                function le(e, r, n) {
                  return 0 === e && r > 1 ? "<".concat(x.getDimDefWithWrapper(n), ">") : "";
                }
                const ce = {
                  translationKey: "properties.modifier.normalization",
                  needDimension: function () {
                    return !0;
                  },
                  isApplicable: function (e) {
                    var r = e.properties,
                      n = e.layout;
                    return x.isApplicable({
                      properties: r,
                      layout: n,
                      minDimensions: 1,
                      maxDimensions: 2
                    });
                  },
                  extractInputExpression: x.extractInputExpression,
                  generateExpression: function (e) {
                    var r = e.expression,
                      n = e.modifier,
                      t = e.properties,
                      i = e.layout,
                      a = e.numDimensions,
                      s = e.dimensionAndFieldList;
                    if (!n) return r;
                    var u = a;
                    void 0 === u && (u = x.getNumDimensions({
                      properties: t,
                      layout: i
                    }));
                    var l = o(t, "qHyperCubeDef.qDimensions", []),
                      c = x.getExpressionWithExcludedComp({
                        expression: r,
                        modifier: n,
                        dimensions: l,
                        dimensionAndFieldList: s
                      }),
                      p = n.selectionScope,
                      f = n.dimensionalScope;
                    return function (e, r, n, t, i, o, a) {
                      var s = ae(r),
                        u = se(r, n, t),
                        l = "" === s && "" === u ? "" : s || u,
                        c = ue(i, o),
                        p = le(i, o, a),
                        f = function (e) {
                          for (var r = [], n = 0; n < e; n++) r[n] = x.getDimDefWithWrapper(n);
                          return r.join(", ");
                        }(o);
                      return "".concat(e, "/ Sum(").concat(l, " ").concat(c).concat(p, " Aggr(").concat(l, " ").concat(e, ", ").concat(f, "))");
                    }(c, p, n.field, n.value, f, u, n.primaryDimension);
                  },
                  initModifier: function (e) {
                    Object.keys(oe).forEach(function (r) {
                      void 0 === e[r] && (e[r] = oe[r]);
                    });
                  },
                  updateModifier: function (e, r) {
                    1 === (r.qDimensions ? r.qDimensions.length : 0) && 0 === e.dimensionalScope && (e.dimensionalScope = 2);
                  },
                  enableTotalsFunction: function () {
                    return !0;
                  },
                  propertyPanelDef: function (e) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                      n = {
                        type: "items",
                        items: {
                          disclaimer: {
                            component: "text",
                            translation: r.disclaimer || "properties.modifier.normalization.disclaimer",
                            show: function (e, r) {
                              return !x.isApplicable({
                                properties: r.properties
                              });
                            }
                          },
                          settings: {
                            type: "items",
                            items: {
                              selectionScope: {
                                refFn: function (r) {
                                  return "".concat(te(r, e), ".selectionScope");
                                },
                                type: "string",
                                translation: r.modifierSelectionScope || "properties.modifier.selectionScope",
                                title: {
                                  translation: r.modifierSelectionScopeTooltip || "properties.modifier.selectionScope.tooltip"
                                },
                                component: "dropdown",
                                schemaIgnore: !0,
                                defaultValue: 2,
                                options: function (n) {
                                  return function (e, r, n) {
                                    var t = [{
                                      value: 0,
                                      translation: r.selectionScopeCurrentSelection || "properties.modifier.selectionScope.currentSelection"
                                    }, {
                                      value: 1,
                                      translation: r.selectionScopeSpecificValue || "properties.modifier.selectionScope.selectAField"
                                    }, {
                                      value: 2,
                                      translation: r.selectionScopeTotal || "properties.modifier.selectionScope.total"
                                    }];
                                    return t = function (e, r, n) {
                                      if (1 === e) {
                                        var t = ie(r, 0);
                                        r.splice(t, 1);
                                      }
                                      return r;
                                    }(ne(e, n).dimensionalScope, t), t;
                                  }(n, r, e);
                                }
                              },
                              field: {
                                refFn: function (r) {
                                  return "".concat(te(r, e), ".field");
                                },
                                type: "string",
                                component: "expression-with-dropdown",
                                translation: "Common.Field",
                                defaultValue: "",
                                dropdownOnly: !0,
                                options: function (e, r, n) {
                                  return n.app.getFieldList().then(function (e) {
                                    return e.map(function (e) {
                                      return {
                                        label: e.qName,
                                        value: e.qName
                                      };
                                    });
                                  });
                                },
                                show: function (r) {
                                  return 1 === ne(r, e).selectionScope;
                                }
                              },
                              value: {
                                refFn: function (r) {
                                  return "".concat(te(r, e), ".value");
                                },
                                type: "string",
                                ref: "value",
                                component: "string",
                                translation: "properties.value",
                                expression: "optional",
                                show: function (r) {
                                  return 1 === ne(r, e).selectionScope;
                                }
                              },
                              dimensionalScope: {
                                refFn: function (r) {
                                  return "".concat(te(r, e), ".dimensionalScope");
                                },
                                type: "string",
                                translation: r.modifierDimensionalScope || "properties.modifier.dimensionalScope",
                                title: {
                                  translation: r.modifierDimensionalScopeTooltip || "properties.modifier.dimensionalScope.tooltip"
                                },
                                component: "dropdown",
                                schemaIgnore: !0,
                                defaultValue: 2,
                                supportTooltip: !0,
                                options: function (n, t) {
                                  return function (e, r, n, t) {
                                    var i = r.layout.qHyperCube.qDimensionInfo.length,
                                      o = [{
                                        value: 0,
                                        translation: n.dimensionalScopeOneDimension || "properties.modifier.dimensionalScope.respectOneDimension",
                                        tooltipTranslation: n.dimensionalScopeOneDimensionTooltip || "properties.modifier.dimensionalScope.respectOneDimension.tooltip"
                                      }, {
                                        value: 1,
                                        translation: n.dimensionalScopeAllDimensions || "properties.modifier.dimensionalScope.".concat(2 === i ? "respectAllDimensions" : "respectDimension"),
                                        tooltipTranslation: n.dimensionalScopeAllDimensionsTooltip || "properties.modifier.dimensionalScope.".concat(2 === i ? "respectAllDimensions" : "respectDimension", ".tooltip")
                                      }, {
                                        value: 2,
                                        translation: n.dimensionalScopeDisregardAllDimensions || "properties.modifier.dimensionalScope.".concat(2 === i ? "disregardAllDimensions" : "disregardDimension"),
                                        tooltipTranslation: n.dimensionalScopeDisregardAllDimensionsTooltip || "properties.modifier.dimensionalScope.".concat(2 === i ? "disregardAllDimensions" : "disregardDimension", ".tooltip")
                                      }];
                                    return o = function (e, r, n) {
                                      if (e < 2) {
                                        var t = ie(r, 0);
                                        r.splice(t, 1);
                                      }
                                      return r;
                                    }(i, o), o = function (e, r, n) {
                                      if (0 === e) {
                                        var t = ie(r, 1);
                                        r.splice(t, 1);
                                      }
                                      return r;
                                    }(ne(e, t).selectionScope, o), o;
                                  }(n, t, r, e);
                                }
                              },
                              primaryDimension: {
                                refFn: function (r) {
                                  return "".concat(te(r, e), ".primaryDimension");
                                },
                                type: "integer",
                                translation: r.primaryDimension || "properties.modifier.primaryDimension",
                                title: {
                                  translation: r.primaryDimensionTooltip || "properties.modifier.normalization.primaryDimension.tooltip"
                                },
                                component: "dropdown",
                                schemaIgnore: !0,
                                defaultValue: 1,
                                options: function (e, r) {
                                  return r.layout.qHyperCube.qDimensionInfo.map(function (e, r) {
                                    return {
                                      value: r,
                                      label: e.qGroupFallbackTitles[0]
                                    };
                                  });
                                },
                                show: function (r, n) {
                                  return 0 === (ne(r, e).dimensionalScope || 0) && n.layout.qHyperCube.qDimensionInfo.length > 1;
                                }
                              }
                            },
                            show: function (e, r) {
                              return x.isApplicable({
                                properties: r.properties
                              });
                            }
                          }
                        },
                        show: function (r, n, t) {
                          var i = t.ext.support.modifiers;
                          if (!Array.isArray(i) || -1 === i.indexOf(re)) return !1;
                          var o = ne(r, e);
                          return o && !o.disabled;
                        }
                      };
                    return n;
                  },
                  getDisregardSelectionComp: ae,
                  getFieldSelectionComp: se,
                  getTotalComp: ue,
                  getSelectedDimComp: le
                };
                var pe = "qDef.base",
                  fe = "qDef.qDef",
                  me = "qDef.base.qDef",
                  de = "qLibraryId",
                  ye = "qDef.base.qLibraryId";
                const qe = {
                  getExpression: function (e) {
                    var r = o(e, me);
                    return void 0 !== r ? r : o(e, fe);
                  },
                  getExpressionRef: function (e) {
                    return void 0 !== o(e, me) ? me : fe;
                  },
                  getLibraryIdRef: function (e) {
                    return o(e, ye) ? ye : de;
                  },
                  getLibraryId: function (e) {
                    return o(e, ye) || o(e, de);
                  },
                  getLabelRef: function (e) {
                    return o(e, pe) ? "qDef.base.qLabel" : "qDef.qLabel";
                  },
                  getLabelExpressionRef: function (e) {
                    return o(e, pe) ? "qDef.base.qLabelExpression" : "qDef.qLabelExpression";
                  }
                };
                var be = "qDef.qDef",
                  ve = "qDef.base.qDef",
                  De = "qLibraryId",
                  ge = "qDef.base.qLibraryId",
                  he = "qDef.qLabel",
                  xe = "qDef.qLabelExpression",
                  Ae = "qDef.base.qLabel",
                  Ee = "qDef.base.qLabelExpression",
                  Ce = "qDef.qAggrFunc",
                  Ie = "qDef.base.qAggrFunc",
                  Se = {
                    initBase: function (e, r) {
                      (r || Se.isValid(e)) && (n(e, ve, o(e, be)), n(e, ge, o(e, De)), n(e, Ae, o(e, he)), n(e, Ee, o(e, xe)));
                    },
                    restoreBase: function (e) {
                      Se.isValid(e) && (n(e, be, o(e, ve)), n(e, De, o(e, ge)), n(e, he, o(e, Ae)), n(e, xe, o(e, Ee)), o(e, Ce) && o(e, Ie) && n(e, Ce, o(e, Ie)), delete e.qDef.base);
                    },
                    isValid: function (e) {
                      var r = o(e, ve),
                        n = o(e, ge);
                      return void 0 !== r || void 0 !== n;
                    }
                  };
                const Me = Se;
                function Le(e) {
                  return Le = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                    return typeof e;
                  } : function (e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                  }, Le(e);
                }
                var Oe = {
                  accumulation: R,
                  movingAverage: $,
                  difference: ee,
                  normalization: ce,
                  timeSeriesDecomposition: J
                };
                const Fe = {
                  modifiers: Oe,
                  apply: Ve,
                  applyModifiers: Ne,
                  cleanUpMeasure: we,
                  destroy: function (e) {
                    e && Pe[e.id] && Pe[e.id].masterItemSubscriber && (Pe[e.id].masterItemSubscriber && Pe[e.id].masterItemSubscriber.unsubscribe(), delete Pe[e.id]);
                  },
                  hasActiveModifiers: He,
                  getActiveModifier: Te,
                  initBase: Me.initBase,
                  isSupportedModifiers: function (e) {
                    return Array.isArray(e) && e.some(function (e) {
                      return Oe[e];
                    });
                  },
                  isApplicableSupportedModifiers: function (e) {
                    var r = e.modifierTypes,
                      n = e.properties,
                      t = e.layout;
                    return Array.isArray(r) && r.some(function (e) {
                      return Oe[e] && Oe[e].isApplicable({
                        properties: n,
                        layout: t
                      });
                    });
                  },
                  measureBase: qe,
                  limitedSorting: function (e) {
                    var r = e.measures,
                      n = e.properties,
                      t = e.layout,
                      i = !1,
                      o = !1;
                    return r.forEach(function (e) {
                      var r = _e(e);
                      ze({
                        modifiers: r,
                        properties: n,
                        layout: t
                      }) && (i = !0, o = o || Qe({
                        modifiers: r,
                        properties: n,
                        layout: t
                      }));
                    }), i && !o;
                  },
                  ifEnableTotalsFunction: je
                };
                var Pe = {};
                function Ve() {
                  var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    n = e.model,
                    t = e.properties,
                    i = e.isSnapshot,
                    a = void 0 !== i && i,
                    s = e.masterItem,
                    u = !1;
                  Pe[n.id] = Pe[n.id] || {
                    isFirstTime: !0
                  };
                  var l = Pe[n.id].isFirstTime;
                  if (Pe[n.id].isFirstTime = !1, t && "object" === Le(t)) return Ne({
                    model: n,
                    properties: t
                  });
                  var c = n ? n.layout : void 0,
                    p = o(c, "qSelectionInfo.qInSelections");
                  if (a || p) return Promise.resolve(u);
                  var f = o(c, "qHyperCube.qMeasureInfo"),
                    m = Pe[n.id].lastReloadTime;
                  if (Pe[n.id].lastReloadTime = o(n, "app.layout.qLastReloadTime"), He({
                    measures: f,
                    layout: c
                  })) {
                    var d = function (e) {
                      var r = e.measures,
                        n = e.layout,
                        t = e.lastReloadTime;
                      return o(e.model, "app.layout.qLastReloadTime") !== t && function (e) {
                        var r = e.measures,
                          n = e.properties,
                          t = e.layout;
                        return !!Array.isArray(r) && r.some(function (e) {
                          return Ge({
                            measure: e,
                            properties: n,
                            layout: t
                          });
                        });
                      }({
                        measures: r,
                        layout: n
                      });
                    }({
                      measures: f,
                      layout: c,
                      model: n,
                      lastReloadTime: m
                    });
                    return d || function (e) {
                      var r = e.measures,
                        n = e.layout,
                        t = e.masterItem,
                        i = e.isFirstTime;
                      return !!Array.isArray(r) && (i || t || r.some(function (e) {
                        return function (e) {
                          var r = e.measure,
                            n = e.layout;
                          return ze({
                            modifiers: _e(r),
                            layout: n
                          }) ? !r.base : !!r.base;
                        }({
                          measure: e,
                          layout: n
                        });
                      }));
                    }({
                      measures: f,
                      layout: c,
                      masterItem: s,
                      isFirstTime: l
                    }) ? n.getEffectiveProperties().then(function (e) {
                      var t = r()(!0, {}, e);
                      ke(t);
                      var i = Ze(t);
                      return Ye({
                        model: n
                      }).then(function (r) {
                        return Je({
                          libraryIds: i,
                          model: n
                        }).then(function (i) {
                          return d && function (e) {
                            var r = e.properties;
                            Re(r).forEach(function (e) {
                              return function (e) {
                                var r = e.measure;
                                if (Ge({
                                  measure: r,
                                  properties: e.properties
                                })) {
                                  var n = 0,
                                    t = r.qDef.modifiers;
                                  Array.isArray(t) && t.forEach(function (e) {
                                    if ("object" === Le(e) && !e.disabled) {
                                      if (n++, "object" !== Le(Oe[e.type])) throw new Error('Modifier "'.concat(e.type, '" is not available'));
                                      if (n > 1) throw new Error("More than 1 modifier on a measure! (not yet supported)");
                                      var t = Oe[e.type].extractInputExpression({
                                        outputExpression: r.qDef.qDef,
                                        modifier: e
                                      });
                                      void 0 !== t && $e(r) && x.simplifyExpression(r.qDef.base.qDef) !== x.simplifyExpression(t) && (r.qDef.base.qDef = t);
                                    }
                                  });
                                }
                              }({
                                measure: e,
                                properties: r
                              });
                            });
                          }({
                            properties: t
                          }), Ne({
                            model: n,
                            oldProperties: e,
                            properties: t,
                            runUpdateIfChange: !0,
                            masterItem: s,
                            libraryItemsProps: i,
                            dimensionAndFieldList: r
                          });
                        });
                      });
                    }) : Promise.resolve(u);
                  }
                  return function (e) {
                    return !!Array.isArray(e) && e.some(function (e) {
                      return "object" === Le(e.base);
                    });
                  }(f) ? n.getEffectiveProperties().then(function (e) {
                    return function (e) {
                      var n = e.model,
                        t = e.properties,
                        i = Ze(t);
                      return er({
                        model: n,
                        libraryIds: i
                      }).then(function () {
                        var e = r()(!0, {}, t);
                        return Re(t).forEach(function (e) {
                          return we(e);
                        }), Xe({
                          oldProperties: e,
                          newProperties: t,
                          model: n
                        });
                      });
                    }({
                      model: n,
                      properties: e
                    });
                  }) : Promise.resolve(u);
                }
                function Ne(e) {
                  var n = e.model,
                    t = e.oldProperties,
                    i = e.properties,
                    a = e.measures,
                    s = e.runUpdateIfChange,
                    u = void 0 !== s && s,
                    l = e.masterItem,
                    c = e.libraryItemsProps,
                    p = e.dimensionAndFieldList;
                  void 0 === t && (t = u ? r()(!0, {}, i) : i), ke(i);
                  var f = Ze(i);
                  return er({
                    model: n,
                    libraryIds: f,
                    masterItem: l
                  }).then(function () {
                    return function (e) {
                      var n = e.measures,
                        t = e.properties,
                        i = e.model,
                        a = e.libraryItemsProps,
                        s = e.dimensionAndFieldList;
                      if (n || (n = Re(t)), !n.length) return Promise.resolve();
                      if (!He({
                        measures: n,
                        properties: t
                      })) return n.forEach(function (e) {
                        return we(e);
                      }), Promise.resolve();
                      var u = a ? void 0 : Ze(t);
                      return Ye({
                        model: i,
                        dimensionAndFieldList: s
                      }).then(function (e) {
                        return Je({
                          libraryIds: u,
                          model: i,
                          libraryItemsProps: a
                        }).then(function (i) {
                          n.forEach(function (n) {
                            ze({
                              modifiers: n.qDef.modifiers,
                              properties: t
                            }) ? (function (e) {
                              var n = e.measure,
                                t = e.properties,
                                i = e.libraryItemsProps,
                                a = e.dimensionAndFieldList,
                                s = 0;
                              Me.isValid(n) || Me.initBase(n, !0);
                              var u = n.qDef,
                                l = u.modifiers,
                                c = u.base;
                              Array.isArray(l) && l.forEach(function (e) {
                                if ("object" === Le(e) && !e.disabled) {
                                  if (s++, "object" !== Le(Oe[e.type])) throw new Error('Modifier "'.concat(e.type, '" is not available'));
                                  if (s > 1) throw new Error("More than 1 modifier on a measure! (not yet supported)");
                                  Oe[e.type].initModifier(e, n);
                                  var u = n.qLibraryId || c && c.qLibraryId;
                                  u ? function (e) {
                                    var n = e.measure,
                                      t = e.modifier,
                                      i = e.properties,
                                      o = e.dimensionAndFieldList,
                                      a = e.libraryItemsProps[e.libraryId],
                                      s = a.qMeasure.qDef,
                                      u = "" === s ? s : Oe[t.type].generateExpression({
                                        expression: s,
                                        modifier: t,
                                        properties: i,
                                        dimensionAndFieldList: o
                                      });
                                    t.outputExpression = u, n.qDef.qDef = t.outputExpression, (n.qDef.qLabel || a.qMeasure.qLabel) && (n.qDef.qLabel = a.qMeasure.qLabel), (n.qDef.qLabelExpression || a.qMeasure.qLabelExpression) && (n.qDef.qLabelExpression = a.qMeasure.qLabelExpression), n.qDef.quarantine && n.qDef.quarantine.qNumFormat && a.qMeasure.qNumFormat && (n.qDef.qNumFormat = a.qMeasure.qNumFormat, n.qDef.isCustomFormatted = a.qMeasure.isCustomFormatted), delete n.qLibraryId, n.qDef.coloring = a.qMeasure.coloring, t.base = r()(!0, {}, n.qDef.base);
                                  }({
                                    measure: n,
                                    modifier: e,
                                    libraryId: u,
                                    properties: t,
                                    libraryItemsProps: i,
                                    dimensionAndFieldList: a
                                  }) : function (e) {
                                    var n = e.measure,
                                      t = e.modifier,
                                      i = e.properties,
                                      o = e.dimensionAndFieldList;
                                    "function" == typeof Oe[t.type].updateModifier && Oe[t.type].updateModifier(t, i.qHyperCubeDef);
                                    var a = qe.getExpression(n),
                                      s = "" === a ? a : Oe[t.type].generateExpression({
                                        expression: a,
                                        modifier: t,
                                        properties: i,
                                        dimensionAndFieldList: o
                                      });
                                    t.outputExpression = s, n.qDef.qDef = t.outputExpression, n.qDef.base.qLabelExpression ? n.qDef.qLabelExpression = n.qDef.base.qLabelExpression : n.qDef.qLabel = n.qDef.base.qLabel || a, t.base = r()(!0, {}, n.qDef.base);
                                  }({
                                    measure: n,
                                    modifier: e,
                                    properties: t,
                                    dimensionAndFieldList: a
                                  }), function (e) {
                                    var r = o(e, "qDef.qAggrFunc");
                                    "Expr" !== r || je(e) ? "None" !== r ? delete e.qDef.base.qAggrFunc : "None" === r && je(e) && "Expr" === e.qDef.base.qAggrFunc && (e.qDef.qAggrFunc = "Expr", delete e.qDef.base.qAggrFunc) : (e.qDef.qAggrFunc = "None", e.qDef.base.qAggrFunc = "Expr");
                                  }(n);
                                }
                              });
                            }({
                              measure: n,
                              properties: t,
                              libraryItemsProps: i,
                              dimensionAndFieldList: e
                            }), We(n)) : we(n);
                          });
                        });
                      });
                    }({
                      measures: a,
                      properties: i,
                      model: n,
                      libraryItemsProps: c,
                      dimensionAndFieldList: p
                    }).then(function () {
                      return u ? Xe({
                        oldProperties: t,
                        newProperties: i,
                        model: n
                      }) : Promise.resolve(!1);
                    });
                  });
                }
                function we(e) {
                  !function (e) {
                    var r = _e(e);
                    return Array.isArray(r) && r.some(function (e) {
                      return "object" === Le(e) && !e.disabled && !Oe[e.type];
                    });
                  }(e) ? Me.restoreBase(e) : delete e.qDef.base, e.qDef.coloring && delete e.qDef.coloring, We(e);
                }
                function He(e) {
                  var r = e.measures,
                    n = e.properties,
                    t = e.layout;
                  return !!Array.isArray(r) && r.some(function (e) {
                    return ze({
                      modifiers: _e(e),
                      properties: n,
                      layout: t
                    });
                  });
                }
                function Te(e) {
                  var r = _e(e);
                  if (Array.isArray(r)) for (var n = 0; n < r.length; n++) {
                    var t = r[n];
                    if (Oe[t.type] && !t.disabled) return t;
                  }
                }
                function je(e) {
                  var r = Te(e);
                  return !r || Oe[r.type].enableTotalsFunction(e);
                }
                function Re(e) {
                  return o(e, "qHyperCubeDef.qMeasures", []).concat(o(e, "qHyperCubeDef.qLayoutExclude.qHyperCubeDef.qMeasures", []));
                }
                function _e(e) {
                  return e.modifiers || e.qDef && e.qDef.modifiers;
                }
                function Be(e) {
                  return o(e, "outputExpression.qValueExpression.qExpr") || o(e, "outputExpression");
                }
                function ke(e) {
                  Re(e).forEach(function (e) {
                    return function (e) {
                      var n = Te(e);
                      n && (void 0 !== n.outputExpression && Be(n) !== e.qDef.qDef ? delete e.qDef.base : !Me.isValid(e) && n.base && (e.qDef.base = r()(!0, {}, n.base)));
                    }(e);
                  });
                }
                function We(e) {
                  var r = _e(e);
                  Array.isArray(r) && r.forEach(function (r) {
                    "object" === Le(r) && (r.disabled || !Oe[r.type] && Be(r) !== e.qDef.qDef) && (r.disabled = !0, delete r.base);
                  });
                }
                function $e(e) {
                  return e.base || e.qDef && e.qDef.base;
                }
                function Ue(e) {
                  var r = $e(e);
                  return e.qLibraryId || r && r.qLibraryId;
                }
                function Ge(e) {
                  var r = e.measure,
                    n = e.properties,
                    t = e.layout;
                  return !Ue(r) && ze({
                    modifiers: _e(r),
                    properties: n,
                    layout: t
                  });
                }
                function ze(e) {
                  var r = e.modifiers,
                    n = e.properties,
                    t = e.layout,
                    i = {};
                  return Array.isArray(r) && r.some(function (e) {
                    return !("object" !== Le(e) || e.disabled || !Oe[e.type]) && (void 0 === i[e.type] && (i[e.type] = Oe[e.type].isApplicable({
                      properties: n,
                      layout: t
                    })), i[e.type]);
                  });
                }
                function Ye(e) {
                  var r = e.model,
                    n = e.dimensionAndFieldList;
                  if (n) return Promise.resolve(n);
                  var t = [],
                    i = {},
                    o = r.app.getDimensionList().then(function (e) {
                      i.dimensionList = e;
                    });
                  t.push(o);
                  var a = r.app.getFieldList().then(function (e) {
                    i.fieldList = e;
                  });
                  return t.push(a), Promise.all(t).then(function () {
                    return i;
                  });
                }
                function Je(e) {
                  var r = e.libraryIds,
                    n = e.model,
                    t = e.libraryItemsProps;
                  if (t) return Promise.resolve(t);
                  var i = r.measureLibraryIds,
                    o = r.dimensionLibraryIds,
                    a = {},
                    s = [];
                  return i.forEach(function (e) {
                    var r = n.app.getMeasure(e).then(function (r) {
                      return r.getProperties().then(function (r) {
                        a[e] = r;
                      });
                    });
                    s.push(r);
                  }), o.forEach(function (e) {
                    var r = n.app.getDimension(e).then(function (r) {
                      return r.getProperties().then(function (r) {
                        a[e] = r;
                      });
                    });
                    s.push(r);
                  }), Promise.all(s).then(function () {
                    return a;
                  });
                }
                function Ke(e, r) {
                  if ("" !== r || -1 === ["qFmt", "qDec", "qThou"].indexOf(e)) return r;
                }
                function Xe(e) {
                  var r = e.oldProperties,
                    n = e.newProperties,
                    t = e.model,
                    i = JSON.stringify(o(r, "qHyperCubeDef.qMeasures"), Ke) !== JSON.stringify(o(n, "qHyperCubeDef.qMeasures"), Ke) || JSON.stringify(o(r, "qHyperCubeDef.qLayoutExclude.qHyperCubeDef.qMeasures"), Ke) !== JSON.stringify(o(n, "qHyperCubeDef.qLayoutExclude.qHyperCubeDef.qMeasures"), Ke);
                  return i ? function (e) {
                    var r = e.model,
                      n = e.oldProperties,
                      t = e.newProperties,
                      i = r.layout;
                    return i && !i.qHasSoftPatches && !i.qExtendsId && o(i, "qMeta.privileges", []).indexOf("update") > -1 ? r.setProperties(t) : N(r, n, t);
                  }({
                    model: t,
                    oldProperties: r,
                    newProperties: n
                  }).then(function () {
                    return i;
                  }) : Promise.resolve(i);
                }
                function Qe(e) {
                  var r = e.modifiers,
                    n = e.properties,
                    t = e.layout;
                  return Array.isArray(r) && r.some(function (e) {
                    return "object" === Le(e) && !e.disabled && Oe[e.type] && Oe[e.type].needDimension({
                      modifier: e,
                      properties: n,
                      layout: t
                    });
                  });
                }
                function Ze(e) {
                  var r = Re(e),
                    n = [],
                    t = [],
                    i = !1;
                  return r.forEach(function (r) {
                    var t = _e(r);
                    if (ze({
                      modifiers: t,
                      properties: e
                    })) {
                      var o = Ue(r);
                      o && n.push(o), i = i || Qe({
                        modifiers: t,
                        properties: e
                      });
                    }
                  }), o(e, "qHyperCubeDef.qDimensions", []).forEach(function (e) {
                    var r = e.qLibraryId;
                    r && t.push(r);
                  }), {
                    measureLibraryIds: n,
                    dimensionLibraryIds: t
                  };
                }
                function er(e) {
                  var r = e.model,
                    n = e.libraryIds;
                  return !e.masterItem && n && (n.measureLibraryIds.length || n.dimensionLibraryIds.length) ? (Pe[r.id].masterItemSubscriber = Pe[r.id].masterItemSubscriber || function (e) {
                    var r = e.model,
                      n = e.callback,
                      t = {},
                      i = {},
                      a = {},
                      s = {
                        dimension: ["qDim.qFieldDefs"],
                        measure: ["qMeasure.qDef", "qMeasure.qLabel", "qMeasure.qLabelExpression", "qMeasure.coloring", "qMeasure.qNumFormat", "qMeasure.isCustomFormatted"]
                      };
                    function u(e) {
                      var r = {},
                        n = o(e, "qInfo.qType");
                      return n && s[n] && s[n].forEach(function (n) {
                        r[n] = o(e, n);
                      }), JSON.stringify(r);
                    }
                    function l(e) {
                      var r = e.qInfo.qId;
                      if (t[r]) {
                        var i = u(e);
                        t[r].properties !== i && (t[r].properties = i, "function" == typeof n && t[r].enabled && n(e)), t[r].enabled = !0;
                      }
                    }
                    function c(e, n) {
                      return r.app[n](e).then(function (r) {
                        t[e] = {
                          listener: r.layoutSubscribe(l),
                          enabled: !1,
                          properties: u(r.layout)
                        };
                      });
                    }
                    return {
                      subscribe: function (e) {
                        var n = e.measureLibraryIds,
                          o = e.dimensionLibraryIds,
                          s = [];
                        return function (e) {
                          var r = e.dimensionLibraryIds;
                          i = {}, e.measureLibraryIds.forEach(function (e) {
                            i[e] = !0;
                          }), a = {}, r.forEach(function (e) {
                            a[e] = !0;
                          });
                        }({
                          measureLibraryIds: n,
                          dimensionLibraryIds: o
                        }), Object.keys(t).forEach(function (e) {
                          i[e] || a[e] || (t[e].listener.dispose(), delete t[e]);
                        }), r.app && (Object.keys(i).forEach(function (e) {
                          i[e] && !t[e] && s.push(c(e, "getMeasure"));
                        }), Object.keys(a).forEach(function (e) {
                          a[e] && !t[e] && s.push(c(e, "getDimension"));
                        })), Promise.all(s);
                      },
                      unsubscribe: function () {
                        Object.keys(t).forEach(function (e) {
                          t[e].listener.dispose();
                        }), t = {};
                      }
                    };
                  }({
                    model: r,
                    callback: function (e) {
                      return Ve({
                        model: r,
                        masterItem: e
                      }).then(function () {
                        return r.app.clearUndoBuffer();
                      });
                    }
                  }), Pe[r.id].masterItemSubscriber.subscribe(n)) : Promise.resolve();
                }
              })(), r.default = i.default, Object.defineProperty(r, "__esModule", {
                value: !0
              });
            })();
          }
        },
        r = {};
      function n(t) {
        var i = r[t];
        if (void 0 !== i) return i.exports;
        var o = r[t] = {
          exports: {}
        };
        return e[t](o, o.exports, n), o.exports;
      }
      n.n = e => {
        var r = e && e.__esModule ? () => e.default : () => e;
        return n.d(r, {
          a: r
        }), r;
      }, n.d = (e, r) => {
        for (var t in r) n.o(r, t) && !n.o(e, t) && Object.defineProperty(e, t, {
          enumerable: !0,
          get: r[t]
        });
      }, n.o = (e, r) => Object.prototype.hasOwnProperty.call(e, r);
      var t = {};
      return (() => {

        function e(r) {
          var n,
            t = r;
          return t > 9 ? (n = 65 + t - 10) > 90 && (n += 6) : t = "".concat(t).charCodeAt(0), [48, 111, 79, 105, 73, 108].indexOf(n) > -1 ? e(t + 1) : String.fromCharCode(n);
        }
        function r(n) {
          var t = e(n % 62),
            i = Math.floor(n / 62);
          return i > 0 ? r(i) + t : t;
        }
        function i(e) {
          return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
            return typeof e;
          } : function (e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
          }, i(e);
        }
        n.d(t, {
          default: () => ke
        });
        const o = {
          getValue: function (e, r, n) {
            if (null == e || null == r) return n;
            for (var t = r.split("."), i = e, o = 0; o < t.length; ++o) {
              var a = t[o];
              if ("" !== a) {
                if (void 0 === i[a] || null === i[a]) return n;
                i = i[a];
              }
            }
            return i;
          },
          setValue: function (e, r, n) {
            if (null != e && null != r) {
              for (var t = r.split("."), i = t[t.length - 1], o = e, a = 0; a < t.length - 1; ++a) {
                var s = t[a];
                void 0 !== o[s] && null !== o[s] || (o[s] = Number.isNaN(+t[a + 1]) ? {} : []), o = o[s];
              }
              void 0 !== n ? o[i] = n : delete o[i];
            }
          },
          isEmpty: function (e) {
            return 0 === Object.keys(e).length && e.constructor === Object;
          },
          isAtomicValue: function (e) {
            return /boolean|number|string/.test(i(e));
          },
          generateId: function () {
            return r(Math.round(99e11 * Math.random() + 1e11)).replace(/\W/g, "");
          }
        };
        function a(e) {
          return function (e) {
            if (Array.isArray(e)) return s(e);
          }(e) || function (e) {
            if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e);
          }(e) || function (e, r) {
            if (e) {
              if ("string" == typeof e) return s(e, r);
              var n = Object.prototype.toString.call(e).slice(8, -1);
              return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? s(e, r) : void 0;
            }
          }(e) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function s(e, r) {
          (null == r || r > e.length) && (r = e.length);
          for (var n = 0, t = new Array(r); n < r; n++) t[n] = e[n];
          return t;
        }
        function u(e) {
          return function (e) {
            if (Array.isArray(e)) return l(e);
          }(e) || function (e) {
            if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e);
          }(e) || function (e, r) {
            if (e) {
              if ("string" == typeof e) return l(e, r);
              var n = Object.prototype.toString.call(e).slice(8, -1);
              return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? l(e, r) : void 0;
            }
          }(e) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function l(e, r) {
          (null == r || r > e.length) && (r = e.length);
          for (var n = 0, t = new Array(r); n < r; n++) t[n] = e[n];
          return t;
        }
        function c(e, r, n) {
          if (e) {
            for (var t = 0; t < e.length; t++) if (e[t][r] === n) return t;
            return -1;
          }
          return -1;
        }
        const p = {
          isOrderedSubset: function (e, r) {
            if (!(e && r && e.length && r.length)) return !1;
            var n = e.indexOf(r[0]);
            if (-1 !== n) {
              for (var t = 0; t < r.length; t++) {
                var i = e.indexOf(r[t]);
                if (n > i) return !1;
                n = i;
              }
              return !0;
            }
            return !1;
          },
          indexAdded: function (e, r) {
            var n;
            for (n = 0; n < e.length; ++n) e[n] >= 0 && e[n] >= r && ++e[n];
            e.push(r);
          },
          indexRemoved: function (e, r) {
            var n,
              t = 0;
            for (n = 0; n < e.length; ++n) e[n] > r ? --e[n] : e[n] === r && (t = n);
            return e.splice(t, 1), t;
          },
          findItemByPropertyValue: function (e, r, n) {
            if (e) {
              for (var t = 0; t < e.length; t++) if (e[t][r] === n) return e[t];
              return null;
            }
            return null;
          },
          findIndexByPropertyValue: c
        };
        var f = n(645),
          m = n.n(f);
        const d = function (e) {
            var r,
              n = e.exportFormat,
              t = e.qHyperCubeDef,
              i = n.data[0];
            (r = i.dimensions).push.apply(r, a(t.qDimensions));
            var s,
              u = o.getValue(t, "qLayoutExclude.qHyperCubeDef.qDimensions");
            u && (s = i.excludedDimensions).push.apply(s, a(u));
          },
          y = function (e) {
            var r,
              n = e.exportFormat,
              t = e.qHyperCubeDef,
              i = n.data[0];
            (r = i.measures).push.apply(r, u(t.qMeasures));
            var a,
              s = o.getValue(t, "qLayoutExclude.qHyperCubeDef.qMeasures");
            s && (a = i.excludedMeasures).push.apply(a, u(s));
          },
          q = function (e) {
            var r = e.exportFormat,
              n = e.qHyperCubeDef,
              t = r.data[0];
            n.qInterColumnSortOrder || (n.qInterColumnSortOrder = []), t.interColumnSortOrder = n.qInterColumnSortOrder.concat();
            var i = o.getValue(n, "qLayoutExclude.qHyperCubeDef.qInterColumnSortOrder");
            i && p.isOrderedSubset(i, t.interColumnSortOrder) && (t.interColumnSortOrder = i.concat());
          },
          b = function (e) {
            var r = e.exportFormat,
              n = e.properties;
            Object.keys(n).forEach(function (e) {
              r.properties[e] = n[e];
            });
          },
          v = function (e) {
            var r = e.exportFormat,
              n = e.properties;
            n.qLayoutExclude || (n.qLayoutExclude = {}), n.qLayoutExclude.disabled && (Object.keys(n.qLayoutExclude.disabled).forEach(function (e) {
              r.properties.hasOwnProperty(e) || (r.properties[e] = n.qLayoutExclude.disabled[e]);
            }), delete n.qLayoutExclude.disabled), n.qLayoutExclude.changed && (function (e) {
              Object.keys(e.qLayoutExclude.changed).forEach(function (r) {
                e.qLayoutExclude.changed[r].to === o.getValue(e, r) && o.setValue(e, r, e.qLayoutExclude.changed[r].from);
              });
            }(n), delete n.qLayoutExclude.changed), n.qLayoutExclude.quarantine && !o.isEmpty(n.qLayoutExclude.quarantine) || delete n.qLayoutExclude;
          },
          D = function (e) {
            e.forEach(function (e) {
              m().cleanUpMeasure(e), e.qDef.modifiers && (e.store = {
                modifiers: e.qDef.modifiers
              }, delete e.qDef.modifiers);
            });
          };
        function g(e, r, n) {
          var t,
            i,
            a = o.getValue(e, r);
          if (!o.isAtomicValue(a)) try {
            if ((i = (i = (t = JSON.stringify(a)).match(/:\{/g)) ? i.length : 0) > 2) return;
            a = JSON.parse(t);
          } catch (e) {
            return;
          }
          o.getValue(e, "qLayoutExclude.quarantine") || o.setValue(e, "qLayoutExclude.quarantine", {});
          var s = o.getValue(e, "qLayoutExclude.quarantine");
          s[n] || (s[n] = {}), s[n][r] = a;
        }
        var h = n(229),
          x = n.n(h);
        function A(e, r) {
          var n = x()(!0, {}, r, e);
          return o.getValue(n, "qOtherTotalSpec.qOtherCounted") || o.setValue(n, "qOtherTotalSpec.qOtherCounted", {
            qv: "10"
          }), o.getValue(n, "qOtherTotalSpec.qOtherLimit") || o.setValue(n, "qOtherTotalSpec.qOtherLimit", {
            qv: "0"
          }), n.hasOwnProperty("othersLabel") || (n.othersLabel = "Others"), n;
        }
        function E(e, r) {
          return x()(!0, {}, r, e);
        }
        function C(e, r, n) {
          return "function" == typeof e ? e(r) : Number.isNaN(+e) ? n : e;
        }
        var I = Math.pow(2, 53) - 1;
        function S(e, r) {
          (null == r || r > e.length) && (r = e.length);
          for (var n = 0, t = new Array(r); n < r; n++) t[n] = e[n];
          return t;
        }
        function M(e, r) {
          (null == r || r > e.length) && (r = e.length);
          for (var n = 0, t = new Array(r); n < r; n++) t[n] = e[n];
          return t;
        }
        const L = function (e, r, n) {
            var t = "masterobject" === o.getValue(r, "properties.qInfo.qType") ? "masterobject" : o.getValue(n, "qInfo.qType");
            o.setValue(e, "qInfo.qType", t), e.visualization = n.visualization;
          },
          O = function (e, r, n) {
            r.hasOwnProperty(e) && (n[e] = r[e]);
          },
          F = function (e, r, n, t) {
            r.hasOwnProperty(e) ? n[e] = r[e] : n[e] = t;
          },
          P = function () {
            return {
              qDef: {
                autoSort: !0,
                cId: "",
                othersLabel: "Others"
              },
              qLibraryId: "",
              qNullSuppression: !1,
              qOtherLabel: "Others",
              qOtherTotalSpec: {
                qOtherLimitMode: "OTHER_GE_LIMIT",
                qOtherMode: "OTHER_OFF",
                qOtherSortMode: "OTHER_SORT_DESCENDING",
                qSuppressOther: !1
              }
            };
          },
          V = function () {
            return {
              qDef: {
                autoSort: !0,
                cId: "",
                numFormatFromTemplate: !0
              },
              qLibraryId: "",
              qTrendLines: []
            };
          },
          N = function (e) {
            var r,
              n = e.exportFormat,
              t = e.maxDimensions,
              i = e.minDimensions,
              o = e.newHyperCubeDef,
              a = e.defaultDimension,
              s = n.data[0];
            for (r = 0; r < s.dimensions.length; ++r) {
              var u = A(s.dimensions[r], a);
              o.qDimensions.length < t ? o.qDimensions.push(u) : o.qLayoutExclude.qHyperCubeDef.qDimensions.push(u);
            }
            for (r = 0; r < s.excludedDimensions.length; ++r) {
              var l = A(s.excludedDimensions[r], a);
              o.qDimensions.length < i ? o.qDimensions.push(l) : o.qLayoutExclude.qHyperCubeDef.qDimensions.push(l);
            }
          },
          w = function (e) {
            var r,
              n = e.exportFormat,
              t = e.maxMeasures,
              i = e.minMeasures,
              o = e.newHyperCubeDef,
              a = e.defaultMeasure,
              s = n.data[0];
            for (r = 0; r < s.measures.length; ++r) {
              var u = E(s.measures[r], a);
              o.qMeasures.length < t ? o.qMeasures.push(u) : o.qLayoutExclude.qHyperCubeDef.qMeasures.push(u);
            }
            for (r = 0; r < s.excludedMeasures.length; ++r) {
              var l = E(s.excludedMeasures[r], a);
              o.qMeasures.length < i ? o.qMeasures.push(l) : o.qLayoutExclude.qHyperCubeDef.qMeasures.push(l);
            }
          },
          H = function (e) {
            var r = e.exportFormat,
              n = e.dataDefinition,
              t = void 0 === n ? {} : n,
              i = r.data[0],
              o = t.dimensions || {
                max: 0
              },
              a = t.measures || {
                max: 0
              },
              s = C(a.max, i.dimensions.length, I),
              u = C(a.min, i.dimensions.length, 0);
            return {
              maxDimensions: C(o.max, s, I),
              minDimensions: C(o.min, u, 0),
              maxMeasures: s,
              minMeasures: u
            };
          },
          T = function (e) {
            var r = e.exportFormat,
              n = e.newHyperCubeDef,
              t = r.data[0],
              i = n.qDimensions.length + n.qMeasures.length;
            n.qInterColumnSortOrder = t.interColumnSortOrder.concat();
            var o = n.qInterColumnSortOrder.length;
            if (o !== i) for (n.qLayoutExclude && (n.qLayoutExclude.qHyperCubeDef.qInterColumnSortOrder = t.interColumnSortOrder.concat()); o !== i;) o < i ? (p.indexAdded(n.qInterColumnSortOrder, o), ++o) : (--o, p.indexRemoved(n.qInterColumnSortOrder, o));
          },
          j = function (e) {
            var r = e.exportFormat,
              n = e.initialProperties,
              t = e.hypercubePath,
              i = {
                qLayoutExclude: {
                  disabled: {},
                  quarantine: {}
                }
              };
            return Object.keys(r.properties).forEach(function (e) {
              "qLayoutExclude" === e ? r.properties[e].quarantine && (i.qLayoutExclude.quarantine = x()(!0, {}, r.properties[e].quarantine)) : "qHyperCubeDef" === e && t ? o.setValue(i, "".concat(t, ".qHyperCubeDef"), r.properties.qHyperCubeDef) : n.hasOwnProperty(e) || -1 !== ["qMetaDef", "descriptionExpression", "labelExpression"].indexOf(e) || function (e, r) {
                return "components" === r && Array.isArray(e[r]) && e[r].some(function (e) {
                  return "general" === e.key;
                });
              }(r.properties, e) ? i[e] = r.properties[e] : i.qLayoutExclude.disabled[e] = r.properties[e];
            }), null === (i = x()(!0, {}, n, i)).components && (i.components = []), i;
          },
          R = function (e) {
            var r = e.exportFormat,
              n = e.maxDimensions,
              t = e.minDimensions,
              i = e.maxMeasures,
              o = e.minMeasures,
              a = r.data[0];
            return a.dimensions.length > n && n > 0 || a.measures.length > i && i > 0 || a.excludedDimensions.length > 0 && a.dimensions.length + a.excludedDimensions.length > t || a.excludedMeasures.length > 0 && a.measures.length + a.excludedMeasures.length > o || !i && a.measures.length > 0 || !n && a.dimensions.length > 0;
          },
          _ = function (e) {
            var r = e.exportFormat,
              n = e.maxDimensions,
              t = e.minDimensions,
              i = e.maxMeasures,
              o = e.minMeasures,
              a = e.newHyperCubeDef,
              s = r.data[0];
            a.qLayoutExclude || (a.qLayoutExclude = {}), a.qLayoutExclude.qHyperCubeDef || (a.qLayoutExclude.qHyperCubeDef = {}), (s.dimensions.length > n && n > 0 || s.excludedDimensions && s.excludedDimensions.length && s.dimensions.length + s.excludedDimensions.length > t) && (a.qLayoutExclude.qHyperCubeDef.qDimensions || (a.qLayoutExclude.qHyperCubeDef.qDimensions = [])), (s.measures.length > i && i > 0 || s.excludedMeasures && s.excludedMeasures.length && s.measures.length + s.excludedMeasures.length > o) && (a.qLayoutExclude.qHyperCubeDef.qMeasures || (a.qLayoutExclude.qHyperCubeDef.qMeasures = [])), !i && s.measures.length && (a.qLayoutExclude.qHyperCubeDef.qMeasures || (a.qLayoutExclude.qHyperCubeDef.qMeasures = [])), !n && s.dimensions.length && (a.qLayoutExclude.qHyperCubeDef.qDimensions || (a.qLayoutExclude.qHyperCubeDef.qDimensions = []));
          },
          B = function (e) {
            var r,
              n = e.newProperties,
              t = e.dataDefinition,
              i = e.hypercubePath;
            if (t.dimensions && "function" == typeof t.dimensions.added) {
              var a = o.getValue(n, i || "").qHyperCubeDef,
                s = function (e) {
                  if (Array.isArray(e)) return S(e);
                }(r = a.qDimensions) || function (e) {
                  if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e);
                }(r) || function (e, r) {
                  if (e) {
                    if ("string" == typeof e) return S(e, r);
                    var n = Object.prototype.toString.call(e).slice(8, -1);
                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? S(e, r) : void 0;
                  }
                }(r) || function () {
                  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }();
              a.qDimensions = [], s.forEach(function (e) {
                a.qDimensions.push(e), t.dimensions.added(e, n);
              });
            }
          },
          k = function (e) {
            var r,
              n = e.newProperties,
              t = e.dataDefinition,
              i = e.hypercubePath;
            if (t.measures && "function" == typeof t.measures.added) {
              var a = o.getValue(n, i || "").qHyperCubeDef,
                s = function (e) {
                  if (Array.isArray(e)) return M(e);
                }(r = a.qMeasures) || function (e) {
                  if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e);
                }(r) || function (e, r) {
                  if (e) {
                    if ("string" == typeof e) return M(e, r);
                    var n = Object.prototype.toString.call(e).slice(8, -1);
                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? M(e, r) : void 0;
                  }
                }(r) || function () {
                  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }();
              a.qMeasures = [], s.forEach(function (e) {
                a.qMeasures.push(e), t.measures.added(e, n);
              });
            }
          },
          W = function (e) {
            var r = e.measures,
              n = e.modifierTypes;
            r && n && m().isSupportedModifiers(n) && r.forEach(function (e) {
              e.store && e.store.modifiers && (e.qDef.modifiers = e.store.modifiers), delete e.store;
            });
          };
        function $(e, r) {
          var n = o.getValue(e, "qLayoutExclude.quarantine", {})[r];
          return !!n && (Object.keys(n).forEach(function (r) {
            o.setValue(e, r, n[r]);
          }), delete e.qLayoutExclude.quarantine[r], !0);
        }
        const U = {
          exportProperties: function (e) {
            var r = e.propertyTree,
              n = e.hypercubePath,
              t = e.viewDataMode,
              i = function () {
                for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, r = {
                    data: [],
                    properties: {}
                  }, n = 0; n < e; ++n) r.data.push({
                  dimensions: [],
                  measures: [],
                  excludedDimensions: [],
                  excludedMeasures: [],
                  interColumnSortOrder: []
                });
                return r;
              }(),
              a = r.qProperty,
              s = o.getValue(a, n || ""),
              u = s.qHyperCubeDef;
            return u.qInterColumnSortOrder || (u.qInterColumnSortOrder = []), d({
              exportFormat: i,
              qHyperCubeDef: u
            }), y({
              exportFormat: i,
              qHyperCubeDef: u
            }), q({
              exportFormat: i,
              qHyperCubeDef: u
            }), delete u.qLayoutExclude, b({
              exportFormat: i,
              properties: a
            }), n && (i.properties.qHyperCubeDef = u, delete s.qHyperCubeDef), v({
              exportFormat: i,
              properties: a
            }), t || D(i.properties.qHyperCubeDef.qMeasures), Array.isArray(i.properties.filters) && (g(i.properties, "filters", "storedFilters"), delete i.properties.filters), i.properties.qHyperCubeDef.qContextSetExpression && (g(i.properties, "qHyperCubeDef.qContextSetExpression", "storedFilters"), i.properties.qHyperCubeDef.qContextSetExpression = ""), i.properties.qHyperCubeDef.qDynamicScript && i.properties.qHyperCubeDef.qDynamicScript.length && (g(i.properties, "qHyperCubeDef.qDynamicScript", "dynamicScript"), i.properties.qHyperCubeDef.qDynamicScript = []), i;
          },
          importProperties: function (e) {
            var r = e.exportFormat,
              n = e.initialProperties,
              t = void 0 === n ? {} : n,
              i = e.dataDefinition,
              a = void 0 === i ? {} : i,
              s = e.defaultPropertyValues,
              u = void 0 === s ? {} : s,
              l = e.hypercubePath,
              c = e.extension,
              p = e.supportedFilters,
              f = void 0 === p || p,
              m = e.isHCModifierSupported,
              d = void 0 === m || m,
              y = {
                qChildren: []
              },
              q = j({
                exportFormat: r,
                initialProperties: t,
                hypercubePath: l
              }),
              b = o.getValue(t, l || "").qHyperCubeDef,
              v = o.getValue(q, l || "").qHyperCubeDef,
              D = H({
                exportFormat: r,
                dataDefinition: a
              }),
              g = D.maxDimensions,
              h = D.minDimensions,
              x = D.maxMeasures,
              A = D.minMeasures,
              E = u.defaultDimension,
              C = void 0 === E ? P() : E,
              I = u.defaultMeasure,
              S = void 0 === I ? V() : I;
            v.qDimensions.length = 0, v.qMeasures.length = 0, R({
              exportFormat: r,
              maxDimensions: g,
              minDimensions: h,
              maxMeasures: x,
              minMeasures: A
            }) && _({
              exportFormat: r,
              maxDimensions: g,
              minDimensions: h,
              maxMeasures: x,
              minMeasures: A,
              newHyperCubeDef: v
            }), N({
              exportFormat: r,
              maxDimensions: g,
              minDimensions: h,
              newHyperCubeDef: v,
              defaultDimension: C
            }), w({
              exportFormat: r,
              maxMeasures: x,
              minMeasures: A,
              newHyperCubeDef: v,
              defaultMeasure: S
            }), B({
              newProperties: q,
              dataDefinition: a,
              hypercubePath: l
            }), k({
              newProperties: q,
              dataDefinition: a,
              hypercubePath: l
            }), T({
              exportFormat: r,
              newHyperCubeDef: v
            }), O("qMaxStackedCells", b, v), O("qNoOfLeftDims", b, v), F("qInitialDataFetch", b, v, [{
              qTop: 0,
              qLeft: 0,
              qWidth: 0,
              qHeight: 0
            }]), F("qMode", b, v, "S"), F("qReductionMode", b, v, "N"), F("qSortbyYValue", b, v), F("qIndentMode", b, v), F("qShowTotalsAbove", b, v), L(q, r, t), y.qProperty = q;
            var M = o.getValue(c || {}, "support.modifiers");
            return W({
              measures: v.qMeasures,
              modifierTypes: M
            }), f && $(y.qProperty, "storedFilters"), "S" === v.qMode && d && $(y.qProperty, "dynamicScript"), y;
          }
        };
        var G = {
          cellBackgroundColor: !0,
          cellForegroundColor: !0,
          colorByAlternative: !0,
          colorByExpression: !0,
          tooltip: !0,
          urlLabel: !0,
          url: !0
        };
        function z(e, r, n, t) {
          r = r || [];
          var i = c(e, t, n),
            o = c(r, t, n);
          if (-1 !== i && -1 === o) {
            var a = e.splice(i, 1);
            r.push(a[0]);
          }
          return r;
        }
        function Y(e, r) {
          return e.length !== r;
        }
        const J = {
            create: function (e, r) {
              if (!e || !G[e]) throw new Error("Attribute Expressions Util: ID required");
              var n = {};
              return r && Object.keys(r).forEach(function (e) {
                n[e] = r[e];
              }), n.id = e, n.qAttribute = !0, n;
            },
            moveByIdFromGroup: function (e, r, n, t, i) {
              n = n || "qAttributeExpressions", i = i || "id";
              for (var o = 0; o < e.length; o++) {
                var a = e[o][n],
                  s = r.length;
                if (z(a, r, t, i), Y(r, s)) return r;
              }
              return r;
            },
            IDMAP: {
              CELL_BACKGROUND_COLOR: "cellBackgroundColor",
              CELL_FOREGROUND_COLOR: "cellForegroundColor",
              COLOR_BY_ALTERNATIVE: "colorByAlternative",
              COLOR_BY_EXPRESSION: "colorByExpression",
              TOOLTIP: "tooltip",
              CELL_LINK_LABEL: "urlLabel",
              CELL_LINK_URL: "url"
            }
          },
          K = {
            getNumDimensions: function (e) {
              return o.getValue(e, "qHyperCubeDef.qDimensions.length", 0);
            },
            getNumMeasures: function (e) {
              return o.getValue(e, "qHyperCubeDef.qMeasures.length", 0);
            },
            wrapFieldName: function (e) {
              return e.split(" ").length > 1 && "=" !== e[0] && "[" !== e[0] ? "[".concat(e, "]") : e;
            },
            getItemLabel: function (e) {
              return e.label || e.name;
            }
          },
          X = {
            colorModeOptions: {
              primary: function () {
                return !0;
              },
              dimension: function (e) {
                return K.getNumDimensions(e) > 0 && K.getNumMeasures(e) <= 1;
              },
              multiColor: function (e) {
                return K.getNumMeasures(e) > 1;
              },
              measure: function (e) {
                return K.getNumDimensions(e) > 0;
              },
              expression: function (e) {
                return K.getNumMeasures(e) >= 1;
              }
            }
          },
          Q = {
            colorModeOptions: {
              primary: function () {
                return !0;
              },
              dimension: function () {
                return !0;
              },
              multiColor: function () {
                return !1;
              },
              measure: function () {
                return !0;
              },
              expression: function (e) {
                return K.getNumMeasures(e) >= 1;
              }
            }
          };
        var Z = {
          scatterplot: Q,
          "sn-scatter-plot": Q,
          piechart: {
            colorModeOptions: {
              primary: function () {
                return !0;
              },
              dimension: function () {
                return !0;
              },
              multiColor: function () {
                return !1;
              },
              measure: function () {
                return !0;
              },
              expression: function (e) {
                return K.getNumMeasures(e) >= 1;
              }
            }
          },
          linechart: {
            colorModeOptions: {
              primary: function () {
                return !0;
              },
              dimension: function (e) {
                return K.getNumDimensions(e) > 1;
              },
              multiColor: function (e) {
                return K.getNumMeasures(e) > 1;
              },
              measure: function (e) {
                return K.getNumDimensions(e) <= 1;
              },
              expression: function (e) {
                return K.getNumMeasures(e) >= 1;
              }
            }
          },
          map: {
            colorModeOptions: {
              primary: function () {
                return !0;
              },
              dimension: function (e) {
                return K.getNumDimensions(e) >= 1;
              },
              multiColor: function (e) {
                return K.getNumMeasures(e) > 1;
              },
              measure: function (e) {
                return K.getNumDimensions(e) >= 1;
              },
              expression: function (e) {
                return K.getNumDimensions(e) >= 1;
              }
            }
          },
          distributionplot: {
            colorModeOptions: {
              primary: function () {
                return !0;
              },
              dimension: function () {
                return !0;
              },
              multiColor: function () {
                return !1;
              },
              measure: function () {
                return !0;
              },
              expression: function (e) {
                return K.getNumDimensions(e) >= 1;
              }
            }
          }
        };
        function ee(e, r, n) {
          if (Array.isArray(e[r])) {
            var t = p.findIndexByPropertyValue(e[r], "id", n);
            t >= 0 && e[r].splice(t, 1);
          } else e[r] = [];
        }
        function re(e, r) {
          var n = J.IDMAP.COLOR_BY_ALTERNATIVE;
          e.forEach(function (e) {
            ee(e, "qAttributeDimensions", n), ee(e, "qAttributeExpressions", n);
          }), r.forEach(function (e) {
            ee(e, "qAttributeDimensions", n), ee(e, "qAttributeExpressions", n);
          });
        }
        function ne(e, r) {
          if (r) {
            var n = "=" === r.charAt(0);
            e.color.altLabel = n ? {
              qStringExpression: {
                qExpr: r.substr(1)
              }
            } : r;
          }
        }
        function te(e) {
          var r = e.properties,
            n = e.isDimension,
            t = e.dimensions,
            i = e.excludedDimensions,
            a = e.measures,
            s = e.label;
          re(t, i);
          var u = t[t.length - 1];
          if (u) {
            var l = n ? o.getValue(r, "color.byDimDef") : o.getValue(r, "color.byMeasureDef"),
              c = o.getValue(r, "color.formatting.qNumFormat"),
              f = o.getValue(r, "color.formatting.isCustomFormatted");
            if (l) {
              var m = J.create(J.IDMAP.COLOR_BY_ALTERNATIVE);
              switch (l.type) {
                case "expression":
                  !function (e) {
                    var r = e.attributeExpression,
                      n = e.label,
                      t = e.item,
                      i = e.isDimension,
                      o = e.qNumFormat,
                      a = e.isCustomFormatted;
                    r.label = n || t.label, i ? r.qDef = t.key : (r.qExpression = t.key, o && (r.qNumFormat = o, r.isCustomFormatted = a)), r.matchMeasure = t.activeMeasureIndex, r.label && "=" === r.label.charAt(0) && (r.labelExpRef = "color.altLabel");
                  }({
                    attributeExpression: m,
                    label: s,
                    item: l,
                    isDimension: n,
                    qNumFormat: c,
                    isCustomFormatted: f
                  });
                  break;
                case "libraryItem":
                  !function (e) {
                    var r = e.attributeExpression,
                      n = e.measures,
                      t = e.item,
                      i = e.qNumFormat,
                      o = e.isCustomFormatted;
                    e.isDimension || (r.matchMeasure = p.findIndexByPropertyValue(n, "qLibraryId", t.key), i && (r.qNumFormat = i, r.isCustomFormatted = o)), void 0 !== t.expression ? r.qExpression = t.expression : r.qLibraryId = t.key, r.colorMapRef = t.key;
                  }({
                    attributeExpression: m,
                    measures: a,
                    item: l,
                    isDimension: n,
                    qNumFormat: c,
                    isCustomFormatted: f
                  });
              }
              n ? (m.qSortBy = {
                qSortByAscii: 1
              }, u.qAttributeDimensions.push(m)) : u.qAttributeExpressions.push(m);
            }
          }
        }
        function ie(e, r, n, t) {
          var i,
            o,
            a,
            s = {};
          switch (e) {
            case "dimension":
              n.qLibraryId ? (s.type = "dimension", s.name = n.qLibraryId, s.id = n.qLibraryId) : (s.type = "field", r ? (s.name = n.label || n.qDef, s.id = n.qDef) : (s.name = n.qDef.qFieldDefs[0], s.label = (a = n.qDef).qLabelExpression ? a.qLabelExpression : a.qFieldLabels && a.qFieldLabels[0] ? a.qFieldLabels[0] : a.qFieldDefs[0]));
              break;
            case "measure":
              i = function (e, r) {
                return r ? e.qLibraryId : m().measureBase.getLibraryId(e);
              }(n, r), i ? (s.type = "measure", s.name = i, s.id = i, o = function (e, r) {
                return m().hasActiveModifiers({
                  measures: [e]
                }) && r ? e.qDef.qDef : void 0;
              }(n, t), o && (s.expression = o)) : (s.type = "expression", r ? (s.name = n.label || n.qExpression, s.id = n.qExpression) : (s.name = n.qDef.qDef, s.label = function (e) {
                var r = e.qDef;
                return r.qLabelExpression ? r.qLabelExpression : r.qLabel ? r.qLabel : r.qDef;
              }(n)));
              break;
            default:
              throw new Error('columnType should be "dimension" or "measure"');
          }
          return s;
        }
        const oe = {
          useMasterNumberFormat: function (e) {
            e.quarantine = {
              qNumFormat: e.qNumFormat || {},
              isCustomFormatted: e.isCustomFormatted || !1
            }, e.qNumFormat = null, e.isCustomFormatted = void 0;
          }
        };
        function ae(e, r, n, t) {
          var i = n ? "expression" : r.type,
            o = e.color,
            a = o.mode,
            s = K.getItemLabel(r);
          switch (ne(e, s || ""), i) {
            case "field":
              a = "byDimension", o.byDimDef = {
                label: r.label || K.wrapFieldName(r.name),
                key: K.wrapFieldName(r.name),
                type: "expression",
                activeDimensionIndex: r.activeDimensionIndex
              };
              break;
            case "expression":
              a = "byMeasure", o.byMeasureDef = {
                label: n || s,
                key: n || r.name,
                type: "expression",
                activeMeasureIndex: r.activeMeasureIndex
              };
              break;
            case "dimension":
              a = "byDimension", o.byDimDef = {
                label: r.name,
                key: r.id,
                type: "libraryItem",
                activeDimensionIndex: r.activeDimensionIndex
              };
              break;
            case "measure":
              a = "byMeasure", o.byMeasureDef = {
                label: r.name,
                key: r.id,
                expression: r.expression,
                type: "libraryItem",
                activeMeasureIndex: r.activeMeasureIndex
              }, o.formatting && oe.useMasterNumberFormat(o.formatting);
          }
          t || (o.auto = !1, o.mode = a);
        }
        function se(e, r) {
          var n = o.getValue(e, "".concat(r, "qDimensions"), []),
            t = o.getValue(e, "".concat(r, "qMeasures"), []),
            i = o.getValue(e, "".concat(r, "qLayoutExclude.qHyperCubeDef.qDimensions"), []),
            a = o.getValue(e, "color.byDimDef");
          if (a && ne(e, a.label), function (e) {
            return !!(e && e.activeDimensionIndex > -1);
          }(a)) !function (e, r) {
            var n = o.getValue(e, "".concat(r, "qDimensions"), []),
              t = o.getValue(e, "color.byDimDef");
            t.activeDimensionIndex = Math.min(t.activeDimensionIndex, n.length - 1);
            var i = ie("dimension", !1, n[t.activeDimensionIndex]);
            i.activeDimensionIndex = t.activeDimensionIndex, ae(e, i);
          }(e, r);else if (function (e) {
            return !e || !e.key;
          }(a) && function (e, r) {
            var n = o.getValue(e, "".concat(r, "qDimensions"), []),
              t = n[function (e, r, n) {
                var t = o.getValue(r, "visualization"),
                  i = n.split("."),
                  a = Number(i[1]),
                  s = o.getValue(r, "layers.".concat(a, ".type"));
                return 2 === e.length && "map" === t && "point" === s;
              }(n, e, r) ? 0 : n.length - 1],
              i = J.IDMAP.COLOR_BY_ALTERNATIVE,
              a = p.findItemByPropertyValue(t.qAttributeDimensions, "id", i);
            return ae(e, ie("dimension", !!a, a || t)), !!a;
          }(e, r)) return;
          te({
            properties: e,
            isDimension: !0,
            dimensions: n,
            excludedDimensions: i,
            measures: t,
            label: o.getValue(e, "color.byDimDef.label")
          });
        }
        const ue = function (e, r, n) {
            o.setValue(e, r, n), o.isAtomicValue(n) && function (e, r, n) {
              var t = e.qLayoutExclude;
              t && (t.changed || (t.changed = {}), t.changed[r] = {
                from: o.getValue(e, r),
                to: n
              });
            }(e, r, n);
          },
          le = function (e, r) {
            var n = {
              primary: !0
            };
            if (e) {
              var t = (Z[r] || X).colorModeOptions || X.colorModeOptions;
              n.byDimension = t.dimension(e), n.byMeasure = t.measure(e), n.byMultiple = t.multiColor(e), n.byExpression = t.expression(e);
            }
            return n;
          },
          ce = function (e) {
            var r = e.canColorBy,
              n = e.autoColor,
              t = e.colorMode,
              i = e.dimensions;
            return !(r[t] && !n && ("byDimension" !== t && "byMeasure" !== t || !i.length));
          },
          pe = function (e, r) {
            var n,
              t = o.getValue(e, "color.mode"),
              i = o.getValue(e, "color.auto"),
              a = o.getValue(e, "".concat(r, "qDimensions"), []),
              s = o.getValue(e, "".concat(r, "qMeasures"), []),
              u = o.getValue(e, "".concat(r, "qLayoutExclude.qHyperCubeDef.qDimensions"), []);
            i ? re(a, u) : !(n = {
              auto: i,
              colorMode: t,
              dimensions: a
            }).auto && "byDimension" === n.colorMode && n.dimensions.length > 0 ? se(e, r) : function (e) {
              var r = e.auto,
                n = e.colorMode,
                t = e.dimensions,
                i = e.measures,
                a = e.properties,
                s = o.getValue(a, "visualization");
              return !(r || "byMeasure" !== n || !t.length || "map" !== s && !i.length);
            }({
              auto: i,
              colorMode: t,
              dimensions: a,
              measures: s,
              properties: e
            }) ? function (e, r) {
              var n = o.getValue(e, "".concat(r, "qDimensions"), []),
                t = o.getValue(e, "".concat(r, "qMeasures"), []),
                i = o.getValue(e, "".concat(r, "qLayoutExclude.qHyperCubeDef.qDimensions"), []),
                a = o.getValue(e, "color.byMeasureDef");
              if (a && ne(e, a.label), function (e) {
                return !!(e && e.activeMeasureIndex > -1);
              }(a)) !function (e, r) {
                var n = o.getValue(e, "".concat(r, "qMeasures"), []),
                  t = o.getValue(e, "color.byMeasureDef");
                if (t.activeMeasureIndex = Math.min(t.activeMeasureIndex, n.length - 1), t.activeMeasureIndex > -1) {
                  var i = ie("measure", !1, n[t.activeMeasureIndex], !0);
                  i.activeMeasureIndex = t.activeMeasureIndex, ae(e, i);
                }
              }(e, r);else if (function (e, r) {
                return (!e || !e.key) && r.length > 0;
              }(a, t) && function (e, r) {
                var n = o.getValue(e, "".concat(r, "qDimensions"), []),
                  t = o.getValue(e, "".concat(r, "qMeasures"), []),
                  i = n[n.length - 1],
                  a = J.IDMAP.COLOR_BY_ALTERNATIVE,
                  s = p.findItemByPropertyValue(i.qAttributeExpressions, "id", a);
                return ae(e, ie("measure", !!s, s || t[0])), !!s;
              }(e, r)) return;
              te({
                properties: e,
                isDimension: !1,
                dimensions: n,
                excludedDimensions: i,
                measures: t,
                label: o.getValue(e, "color.byMeasureDef.label")
              });
            }(e, r) : function (e, r) {
              var n = o.getValue(e, "color.mode"),
                t = o.getValue(e, "".concat(r, "qDimensions"), []),
                i = o.getValue(e, "".concat(r, "qMeasures"), []),
                a = o.getValue(e, "".concat(r, "qLayoutExclude.qHyperCubeDef.qDimensions"), []);
              "byMultiple" === n && i.length < 2 && o.setValue(e, "color.mode", "primary"), re(t, a);
            }(e, r);
          },
          fe = function (e) {
            e.forEach(function (e) {
              e.qOtherTotalSpec && "qTotalMode" in e.qOtherTotalSpec && delete e.qOtherTotalSpec.qTotalMode;
            });
          },
          me = function (e) {
            var r = e.shouldUpdateColorBy,
              n = e.properties,
              t = o.getValue(n, "qHyperCubeDef.qMeasures", []),
              i = o.getValue(n, "color.mode", "");
            return !r && "byExpression" === i && t.length > 0;
          },
          de = function (e) {
            var r = o.getValue(e, "qHyperCubeDef.qMeasures.0.qAttributeExpressions", []),
              n = o.getValue(e, "color.colorExpression", "");
            r.splice(0, 0, {
              qExpression: n,
              id: "colorByExpression"
            }), o.setValue(e, "qHyperCubeDef.qMeasures.0.qAttributeExpressions", r);
          },
          ye = function (e) {
            o.setValue(e, "color.mode", "primary"), o.setValue(e, "color.auto", !0);
          },
          qe = function (e) {
            var r = o.getValue(e, "qHyperCubeDef.qDimensions", []),
              n = o.getValue(e, "color.persistent", !1);
            return r.length > 1 && !n;
          },
          be = {
            exportProperties: function (e) {
              var r = e.propertyTree,
                n = e.hypercubePath,
                t = e.viewDataMode,
                i = U.exportProperties({
                  propertyTree: r,
                  hypercubePath: n,
                  viewDataMode: t
                }),
                o = i.data[0],
                a = o.dimensions.concat(o.excludedDimensions),
                s = o.measures.concat(o.excludedMeasures),
                u = J.IDMAP,
                l = u.COLOR_BY_ALTERNATIVE,
                c = u.COLOR_BY_EXPRESSION;
              return J.moveByIdFromGroup(a, [], "qAttributeDimensions", l), J.moveByIdFromGroup(a, [], "qAttributeExpressions", l), J.moveByIdFromGroup(s, [], "qAttributeExpressions", c), i;
            },
            importProperties: function (e) {
              var r = e.exportFormat,
                n = e.initialProperties,
                t = e.dataDefinition,
                i = e.defaultPropertyValues,
                a = e.hypercubePath,
                s = e.extension,
                u = e.supportedFilters,
                l = e.isHCModifierSupported,
                c = U.importProperties({
                  exportFormat: r,
                  initialProperties: n,
                  dataDefinition: t,
                  defaultPropertyValues: i,
                  hypercubePath: a,
                  extension: s,
                  supportedFilters: u,
                  isHCModifierSupported: l
                }),
                p = c.qProperty,
                f = o.getValue(p, "visualization"),
                m = o.getValue(p, "qHyperCubeDef.qDimensions", []),
                d = o.getValue(p, "color.mode", ""),
                y = o.getValue(p, "color.auto", ""),
                q = le(p, f),
                b = ce({
                  canColorBy: q,
                  autoColor: y,
                  colorMode: d,
                  dimensions: m
                });
              return q[d] ? me({
                shouldUpdateColorBy: b,
                properties: p
              }) && de(p) : ye(p), b && pe(p, "qHyperCubeDef."), qe(p) && ue(p, "color.persistent", !0), fe(m), c;
            }
          };
        var ve = ["bar", "marker", "line"];
        const De = function (e) {
            var r = e.initialProperties,
              n = e.properties;
            r.measureAxis && void 0 === r.measureAxis.autoMinMax ? $(n, "unsupportedAutoMinMax") || x()(n.measureAxis, r.measureAxis) : $(n, "supportedAutoMinMax") || x()(n.measureAxis, r.measureAxis);
          },
          ge = function (e) {
            var r,
              n = e.exportFormat,
              t = e.initialProperties,
              i = e.properties,
              o = e.measureType,
              a = i.qHyperCubeDef,
              s = i.measureAxis;
            if (function (e) {
              var r = e.initialProperties;
              return !(!e.exportFormat.properties.measureAxes || r.measureAxes || !r.measureAxis || void 0 === r.measureAxis.autoMinMax);
            }({
              exportFormat: n,
              initialProperties: t
            })) {
              var u = function (e) {
                var r = [];
                return e.qMeasures.length > 0 && e.qMeasures.forEach(function (e) {
                  if (e.qDef.series) {
                    var n = e.qDef.series,
                      t = n.type,
                      i = n.axis;
                    r[i] || (r[i] = {
                      axis: i,
                      type: {
                        line: 0,
                        marker: 0,
                        bar: 0,
                        total: 0
                      }
                    }), ve.includes(t) && r[i].type[t]++, r[i].type.total++;
                  }
                }), r;
              }(a);
              u.length ? (o && (r = u.filter(function (e) {
                return e.type[o] > 0;
              }).sort(function (e, r) {
                return r.type[o] - e.type[o];
              })), r && r.length || (r = u.sort(function (e, r) {
                return r.type.total - e.type.total;
              })), r && r[0] && x()(s, n.properties.measureAxes[r[0].axis])) : x()(s, n.properties.measureAxes[0]);
            }
          },
          he = function (e) {
            if (e.qDimensions.length > 1) {
              var r = e.qInterColumnSortOrder.indexOf(0);
              if (0 !== r) {
                var n = e.qInterColumnSortOrder[0];
                e.qInterColumnSortOrder[0] = 0, e.qInterColumnSortOrder[r] = n;
              }
            }
          },
          xe = {
            exportProperties: function (e) {
              var r = e.propertyTree,
                n = e.hypercubePath,
                t = e.viewDataMode,
                i = e.supportedAutoMinMax,
                o = void 0 === i || i,
                a = be.exportProperties({
                  propertyTree: r,
                  hypercubePath: n,
                  viewDataMode: t
                }),
                s = a.properties;
              return o ? (g(s, "measureAxis.min", "supportedAutoMinMax"), g(s, "measureAxis.max", "supportedAutoMinMax")) : (g(s, "measureAxis.min", "unsupportedAutoMinMax"), g(s, "measureAxis.max", "unsupportedAutoMinMax")), a;
            },
            importProperties: function (e) {
              var r = e.exportFormat,
                n = e.initialProperties,
                t = e.dataDefinition,
                i = e.defaultPropertyValues,
                o = e.hypercubePath,
                a = e.measureType,
                s = e.extension,
                u = e.supportedFilters,
                l = e.isHCModifierSupported,
                c = be.importProperties({
                  exportFormat: r,
                  initialProperties: n,
                  dataDefinition: t,
                  defaultPropertyValues: i,
                  hypercubePath: o,
                  extension: s,
                  supportedFilters: u,
                  isHCModifierSupported: l
                }),
                p = c.qProperty;
              return De({
                initialProperties: n,
                properties: p
              }), ge({
                exportFormat: r,
                initialProperties: n,
                properties: p,
                measureType: a
              }), he(p.qHyperCubeDef), p.qHyperCubeDef.qColumnOrder = [], p.qHyperCubeDef.columnOrder = [], c;
            }
          };
        function Ae(e, r, n) {
          return "qLayoutExclude.quarantine.".concat(e, ".").concat(r, ".").concat(n);
        }
        function Ee(e) {
          var r = e.properties,
            n = e.arrayPath,
            t = e.quarantineName,
            i = e.arrayName,
            a = e.itemPath;
          o.getValue(r, n, []).forEach(function (e) {
            return function (e) {
              var r = e.properties,
                n = e.quarantineName,
                t = e.arrayName,
                i = e.item,
                a = e.itemPath,
                s = o.getValue(i, a);
              if (void 0 !== s) {
                var u = o.getValue(i, "qDef.cId");
                u || (u = o.generateId(), o.setValue(i, "qDef.cId", u));
                var l = Ae(n, t, u);
                o.setValue(r, l, s), o.setValue(i, a, void 0);
              }
            }({
              properties: r,
              quarantineName: t,
              arrayName: i,
              item: e,
              itemPath: a
            });
          });
        }
        function Ce(e) {
          var r = e.properties,
            n = e.arrayPath,
            t = e.quarantineName,
            i = e.arrayName,
            a = e.itemPath;
          o.getValue(r, n, []).forEach(function (e) {
            return function (e) {
              var r = e.properties,
                n = e.quarantineName,
                t = e.arrayName,
                i = e.item,
                a = e.itemPath,
                s = o.getValue(i, "qDef.cId");
              if (s) {
                var u = Ae(n, t, s),
                  l = o.getValue(r, u);
                void 0 !== l && (o.setValue(i, a, l), o.setValue(r, u, void 0));
              }
            }({
              properties: r,
              quarantineName: t,
              arrayName: i,
              item: e,
              itemPath: a
            });
          });
        }
        var Ie = "qHyperCubeDef.qMeasures",
          Se = "conditionalColoring",
          Me = "measures",
          Le = "qDef.conditionalColoring";
        const Oe = {
          quarantine: function (e) {
            Ee({
              properties: e,
              arrayPath: Ie,
              quarantineName: Se,
              arrayName: Me,
              itemPath: Le
            });
          },
          unquarantine: function (e) {
            Ce({
              properties: e,
              arrayPath: Ie,
              itemPath: Le,
              arrayName: Me,
              quarantineName: Se
            });
          }
        };
        var Fe = "qHyperCubeDef.qMeasures",
          Pe = "measures",
          Ve = "qHyperCubeDef.qDimensions",
          Ne = "dimensions",
          we = "qHyperCubeDef.qLayoutExclude.qHyperCubeDef.qMeasures",
          He = "alternativeMeasures",
          Te = "qHyperCubeDef.qLayoutExclude.qHyperCubeDef.qDimensions",
          je = "alternativeDimensions",
          Re = "qCalcCondition",
          _e = "conditionalShowHide";
        const Be = {
            quarantine: function (e) {
              Ee({
                properties: e,
                arrayPath: Fe,
                quarantineName: _e,
                arrayName: Pe,
                itemPath: Re
              }), Ee({
                properties: e,
                arrayPath: Ve,
                quarantineName: _e,
                arrayName: Ne,
                itemPath: Re
              });
            },
            unquarantine: function (e) {
              Ce({
                properties: e,
                arrayPath: Fe,
                quarantineName: _e,
                arrayName: Pe,
                itemPath: Re
              }), Ce({
                properties: e,
                arrayPath: Ve,
                quarantineName: _e,
                arrayName: Ne,
                itemPath: Re
              });
            },
            quarantineAlternative: function (e) {
              Ee({
                properties: e,
                arrayPath: we,
                quarantineName: _e,
                arrayName: He,
                itemPath: Re
              }), Ee({
                properties: e,
                arrayPath: Te,
                quarantineName: _e,
                arrayName: je,
                itemPath: Re
              });
            },
            unquarantineAlternative: function (e) {
              Ce({
                properties: e,
                arrayPath: we,
                quarantineName: _e,
                arrayName: He,
                itemPath: Re
              }), Ce({
                properties: e,
                arrayPath: Te,
                quarantineName: _e,
                arrayName: je,
                itemPath: Re
              });
            }
          },
          ke = {
            hypercube: U,
            colorChart: be,
            axisChart: xe,
            quarantineProperty: g,
            unquarantineProperty: $,
            quarantineArrayProp: Ee,
            unquarantineArrayProp: Ce,
            conditionalColoring: Oe,
            conditionalShow: Be
          };
      })(), t.default;
    })());
  })(conversion$1);
  var conversionExports = conversion$1.exports;
  var conversion = /*@__PURE__*/getDefaultExportFromCjs(conversionExports);

  function average({
    dimValue,
    qTrendLine
  }) {
    return {
      x: dimValue,
      y: qTrendLine.qCoeff[0]
    };
  }

  function linear$2({
    dimValue,
    value,
    qTrendLine
  }) {
    return {
      x: dimValue,
      y: qTrendLine.qCoeff[1] * value + qTrendLine.qCoeff[0]
    };
  }

  var TYPES$1 = {
    AVERAGE: 'AVERAGE',
    LINEAR: 'LINEAR',
    POLYNOMIAL2: 'POLYNOMIAL2',
    POLYNOMIAL3: 'POLYNOMIAL3',
    POLYNOMIAL4: 'POLYNOMIAL4',
    EXPONENTIAL: 'EXPONENTIAL',
    LOG: 'LOG',
    POWER: 'POWER'
  };

  function polynomial({
    dimValue,
    value,
    qTrendLine
  }) {
    const {
      qType,
      qCoeff
    } = qTrendLine;
    const datum = {
      x: dimValue,
      y: qCoeff[2] * value ** 2 + qCoeff[1] * value + qCoeff[0]
    };
    switch (qType) {
      default:
      case TYPES$1.POLYNOMIAL2:
        return datum;
      case TYPES$1.POLYNOMIAL3:
        datum.y += qCoeff[3] * value ** 3;
        return datum;
      case TYPES$1.POLYNOMIAL4:
        datum.y += qCoeff[4] * value ** 4 + qCoeff[3] * value ** 3;
        return datum;
    }
  }

  function exponential$1({
    dimValue,
    value,
    qTrendLine
  }) {
    return {
      x: dimValue,
      y: Math.exp(qTrendLine.qCoeff[0] + value * qTrendLine.qCoeff[1])
    };
  }

  function log({
    dimValue,
    value,
    qTrendLine
  }) {
    return {
      x: dimValue,
      y: qTrendLine.qCoeff[1] + qTrendLine.qCoeff[0] * Math.log(value)
    };
  }

  function power({
    dimValue,
    value,
    qTrendLine
  }) {
    return {
      x: dimValue,
      y: 10 ** (qTrendLine.qCoeff[0] + qTrendLine.qCoeff[1] * Math.log(value) * Math.LOG10E)
    };
  }

  var calculators = {
    average,
    linear: linear$2,
    polynomial2: polynomial,
    polynomial3: polynomial,
    polynomial4: polynomial,
    exponential: exponential$1,
    log,
    power
  };

  const MAX_SIZE = 500; // Limit max size for finding min/max values to improve performance

  function findMinMaxBySize(size, qTrendLine) {
    const calculator = calculators[qTrendLine.qType.toLowerCase()];
    const interval = Math.max(1, size / MAX_SIZE);
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0; i < size; i += interval) {
      const {
        y
      } = calculator({
        dimValue: null,
        value: i + 1,
        qTrendLine
      });
      min = Math.min(y, min);
      max = Math.max(y, max);
    }
    return {
      min,
      max
    };
  }

  function create$J(layoutService) {
    return {
      generate: (qTrendLine, layerId, measureIndex) => {
        const data = [];
        const page = layoutService.getDataPages()[0];
        const dataNodes = page.qMatrix;
        const start = page.qArea.qTop;
        const calculator = calculators[qTrendLine.qType.toLowerCase()];
        for (let i = 0; i < dataNodes.length; i++) {
          const node = dataNodes[i][0];
          const value = i + start + 1;
          const datum = calculator({
            dimValue: node.qElemNumber,
            value,
            qTrendLine
          });
          datum.layerId = layerId;
          datum.measureIndex = measureIndex;
          datum.dimValue = node.qText;
          data.push(datum);
        }
        return data;
      },
      calculate: (qTrendLine, value, dimValue) => {
        const calculator = calculators[qTrendLine.qType.toLowerCase()];
        return calculator({
          dimValue,
          value,
          qTrendLine
        });
      },
      findMinMax: findMinMaxBySize
    };
  }

  function create$I(layoutService) {
    return {
      generate: (qTrendLine, layerId, measureIndex) => {
        const data = [];
        const page = layoutService.getDataPages()[0];
        const dataNodes = page.qData[0].qSubNodes;
        const start = page.qArea.qTop;
        const calculator = calculators[qTrendLine.qType.toLowerCase()];
        for (let i = 0; i < dataNodes.length; i++) {
          const node = dataNodes[i];
          const dimValue = node.qElemNo;
          const value = i + start + 1;
          const datum = calculator({
            dimValue,
            value,
            qTrendLine
          });
          datum.layerId = layerId;
          datum.measureIndex = measureIndex;
          datum.dimValue = node.qText;
          data.push(datum);
        }
        return data;
      },
      findMinMax: findMinMaxBySize
    };
  }

  const NUMBER_OF_DATA_POINTS = 100;
  function getCalulator(qTrendLine) {
    return calculators[qTrendLine.qType.toLowerCase()];
  }
  function create$H(layoutService, viewState) {
    return {
      generate: (qTrendLine, layerId, measureIndex) => {
        const data = [];
        const calculator = getCalulator(qTrendLine);
        const {
          min,
          max
        } = viewState.get('zoom');
        const interval = (max - min) / NUMBER_OF_DATA_POINTS;
        if (interval > 0) {
          const addDatum = value => {
            const datum = calculator({
              dimValue: value,
              value,
              qTrendLine
            });
            datum.layerId = layerId;
            datum.measureIndex = measureIndex;
            datum.dimValue = value;
            data.push(datum);
          };
          let lastValue = min;
          for (let value = min; value <= max; value += interval) {
            addDatum(value);
            lastValue = value;
          }

          // Handle floating point precision
          if (lastValue !== max) {
            addDatum(max);
          }
        }
        return data;
      },
      calculate: (qTrendLine, value) => {
        const calculator = getCalulator(qTrendLine);
        return calculator({
          dimValue: value,
          value,
          qTrendLine
        });
      },
      findMinMax(size, qTrendLine) {
        const ys = this.generate(qTrendLine).map(({
          y
        }) => y);
        return {
          min: Math.min(...ys),
          max: Math.max(...ys)
        };
      }
    };
  }

  function create$G(layoutService, viewState) {
    if (layoutService.meta.isContinuous) {
      return create$H(layoutService, viewState);
    }
    if (layoutService.meta.mode.K) {
      return create$I(layoutService);
    }
    return create$J(layoutService);
  }

  function makeDarker(c) {
    const color = hcl$1(c);
    color.l -= 5;
    return color.toString();
  }
  function makeBrighter(c) {
    const color = hcl$1(c);
    if (color.l < 30) {
      color.l += 15;
    } else if (color.l < 50) {
      color.l += 10;
    } else {
      color.l += 5;
    }
    return color.toString();
  }

  var TRANSLATIONS = {
    TYPES: {
      AVERAGE: 'properties.trendlines.types.average',
      LINEAR: 'properties.trendlines.types.linear',
      POLYNOMIAL2: 'properties.trendlines.types.polynomial2',
      POLYNOMIAL3: 'properties.trendlines.types.polynomial3',
      POLYNOMIAL4: 'properties.trendlines.types.polynomial4',
      EXPONENTIAL: 'properties.trendlines.types.exponential',
      LOG: 'properties.trendlines.types.logarithmic',
      POWER: 'properties.trendlines.types.power'
    },
    STYLE: {
      DASHED: 'properties.trendlines.style.dashed'
    },
    TYPE: 'properties.trendlines.type',
    HEADER: 'properties.trendlines',
    ADD_BUTTON: 'properties.trendlines.button.add'
  };

  var DEFAULT_PALETTE_COLOR = {
    color: '#f93f17',
    index: 9
  };

  const {
    isDark
  } = commonColor;
  const NOOP_DATA = {
    x: NaN,
    y: NaN,
    layerId: NaN,
    measureIndex: NaN
  };
  const create$F = ({
    layoutService,
    viewState,
    colorModel,
    chart,
    env,
    keys: {
      colorScale: colorScaleKey
    },
    isEnabled = () => false
  }) => {
    const {
      translator
    } = env;
    const data = [NOOP_DATA];
    const qTrendLines = [];
    const measureIndices = [];
    const dataGenerator = create$G(layoutService, viewState);
    layoutService.getLayoutValue('qHyperCube.qMeasureInfo', []).forEach((measure, measureIndex) => {
      if (Array.isArray(measure.qTrendLines)) {
        qTrendLines.push(...measure.qTrendLines);
        measureIndices.push(...measure.qTrendLines.map(() => measureIndex));
      }
    });
    const memoizedGetStroke = Mt(index => {
      const {
        style
      } = qTrendLines[index] || {};
      const colorSettings = colorModel.settings();
      if (style.autoColor) {
        if (colorSettings.mode === 'measure') {
          const measureIndex = measureIndices[index];
          const color = chart.scale(colorScaleKey)(measureIndex);
          return isDark(color) ? makeBrighter(color) : makeDarker(color);
        }
        return colorModel.resolveUIColor(DEFAULT_PALETTE_COLOR);
      }
      if (style.paletteColor) {
        return colorModel.resolveUIColor(style.paletteColor);
      }
      return 'none';
    });
    return {
      query: {
        hasTrendLines: () => !!qTrendLines.length && isEnabled(),
        getData: () => data,
        getStroke: memoizedGetStroke,
        getLineDash: index => {
          const {
            style
          } = qTrendLines[index] || {};
          return style.lineDash;
        },
        getLabel: index => (qTrendLines[index] || {}).label,
        // TODO handle label as an expression
        getType: index => {
          const {
            qType
          } = qTrendLines[index] || {};
          return translator.get(TRANSLATIONS.TYPES[qType]);
        },
        getMinMax: () => {
          let min = Infinity;
          let max = -Infinity;
          qTrendLines.forEach(qTrendLine => {
            const minMax = dataGenerator.findMinMax(layoutService.meta.size.y, qTrendLine);
            min = Math.min(minMax.min, min);
            max = Math.max(minMax.max, max);
          });
          return {
            min,
            max
          };
        },
        getCalculatedValue: (index, value, dimValue) => {
          const qTrendLine = qTrendLines[index];
          return dataGenerator.calculate(qTrendLine, value, dimValue);
        }
      },
      command: {
        update: () => {
          data.length = 0;
          qTrendLines.forEach((qTrendLine, index) => {
            const generatedData = dataGenerator.generate(qTrendLine, index, measureIndices[index]);
            data.push(...generatedData);
          });
        }
      }
    };
  };

  var data = {
    source: 'trend',
    extract: {
      field: 'x',
      props: {
        minor: {
          field: 'y'
        },
        layer: {
          field: 'layerId'
        },
        measureIndex: {
          field: 'measureIndex'
        },
        dimValue: {
          field: 'dimValue'
        }
      }
    }
  };

  const create$E = ({
    meta
  }) => {
    if (meta.isContinuous) {
      return ({
        scale,
        datum
      }) => scale(datum.value);
    }
    if (meta.isGroupedByMeasure) {
      return ({
        scale,
        datum
      }) => {
        const key = [datum.value, datum.measureIndex.value];
        return scale(key) + scale.bandwidth() / 2;
      };
    }
    return ({
      scale,
      datum
    }) => scale(datum.value) + scale.bandwidth() / 2;
  };

  const POINT_SIZE = 8;
  const create$D = ({
    majorScale,
    minorScale,
    tooltipOverlay = 'trend-lines-tooltip-overlay'
  }, {
    layoutService,
    dockService
  }) => {
    const majorFn = create$E(layoutService);
    const isHorizontal = dockService.meta.major.orientation === 'horizontal';
    const majorScaleDef = {
      scale: majorScale,
      fn: majorFn
    };
    const minorScaleDef = {
      scale: minorScale,
      ref: 'minor'
    };
    const x = isHorizontal ? majorScaleDef : minorScaleDef;
    const y = isHorizontal ? minorScaleDef : majorScaleDef;
    return {
      key: tooltipOverlay,
      type: 'point',
      layout: {
        dock: 'center'
      },
      data,
      settings: {
        x,
        y,
        opacity: 0.0,
        size: 1,
        sizeLimits: {
          maxPx: POINT_SIZE,
          minPx: POINT_SIZE
        }
      }
    };
  };

  const create$C = ({
    majorScale,
    minorScale
  }, {
    trendLineModel,
    layoutService,
    dockService,
    animationsEnabled
  }) => {
    const majorFn = create$E(layoutService);
    return {
      key: 'trend-lines',
      type: 'line',
      layout: {
        dock: 'center'
      },
      data,
      settings: {
        connect: true,
        orientation: dockService.meta.major.orientation,
        coordinates: {
          major: {
            scale: majorScale,
            fn: majorFn
          },
          minor: {
            scale: minorScale
          },
          layerId: {
            ref: 'layer'
          }
        },
        layers: {
          curve: 'monotone',
          line: {
            strokeWidth: 2,
            stroke: ({
              datum
            }) => trendLineModel.query.getStroke(datum.layer.value),
            strokeDasharray: ({
              datum
            }) => trendLineModel.query.getLineDash(datum.layer.value)
          }
        }
      },
      animations: {
        enabled: animationsEnabled,
        trackBy: animations.nonUpdatingNode.trackBy,
        compensateForLayoutChanges: animations.lines.compensateForLayoutChanges
      }
    };
  };

  const trendLines = (keys, {
    layoutService,
    trendLineModel,
    dockService,
    animationsEnabled
  }) => {
    if (!trendLineModel.query.hasTrendLines()) {
      return [];
    }
    const lineComponent = create$C(keys, {
      trendLineModel,
      layoutService,
      dockService,
      animationsEnabled
    });
    const tooltipOverlayComponent = create$D(keys, {
      layoutService,
      dockService
    });
    return [lineComponent, tooltipOverlayComponent];
  };

  function create$B(keys, trendLineModel) {
    const {
      getLabel,
      getType,
      getLineDash,
      getStroke
    } = trendLineModel.query;
    return ({
      node,
      resources
    }) => {
      const icon = {
        type: 'icon',
        style: {
          stroke: getStroke(node.data.layer.value),
          'min-width': '16px',
          'vertical-align': 'middle',
          'stroke-dasharray': getLineDash(node.data.layer.value)
        }
      };
      const nameAndType = {
        content: [{
          content: getLabel(node.data.layer.value),
          style: {
            'font-weight': 'bold'
          }
        }, {
          content: getType(node.data.layer.value)
        }],
        style: {
          'min-width': '136px'
        }
      };
      const title = node.data.dimValue.label;
      const value = {
        content: resources.formatter(keys.formatter)(node.data.minor.value)
      };
      return {
        title,
        row: [icon, nameAndType, value]
      };
    };
  }

  const ICON_SIZE = 16;
  const MAX_NUMBER_OF_ITEMS = 2;
  function renderIcon(h) {
    const line = h('line', {
      x1: '0px',
      y1: `${ICON_SIZE}px`,
      x2: `${ICON_SIZE}px`,
      y2: '0px',
      'stroke-width': '3px'
    });
    return h('svg', {
      xlms: 'http://www.w3.org/2000/svg',
      width: '1em',
      height: '1em',
      viewBox: `0 0 ${ICON_SIZE} ${ICON_SIZE}`
    }, line);
  }
  function renderMore(h, translator, rtl, count) {
    const content = translator ? translator.get('Object.ChartTooltip.NMore', count) : `+${count} more`;
    const direction = rtlUtils.detectTextDirection(content);
    const separator = h('tr', {}, h('td', {
      style: {
        'background-image': 'linear-gradient(transparent 8px, rgba(255, 255, 255, 0.4) 8px, rgba(255, 255, 255, 0.4) 9.2px, transparent 9.2px)',
        height: '17px'
      },
      colspan: 3
    }, ''));
    const more = h('tr', {}, h('td', {
      style: {
        'font-weight': 'bold',
        'text-align': rtl ? 'right' : 'left',
        direction
      },
      colspan: 3
    }, content));
    return [separator, more];
  }
  function renderCell(h, cell) {
    if (Array.isArray(cell.content)) {
      return h('div', {
        style: {
          display: 'flex',
          'flex-direction': 'column'
        }
      }, cell.content.map(c => h('span', {
        style: c.style,
        direction: rtlUtils.detectTextDirection(c.content)
      }, c.content)));
    }
    if (cell.type === 'icon') {
      return renderIcon(h);
    }
    return cell.content;
  }
  function renderRow(inputRow, {
    h,
    style
  }) {
    return inputRow.map(cell => {
      const attributes = {
        style: {
          direction: typeof cell.content === 'string' ? rtlUtils.detectTextDirection(cell.content) : undefined,
          ...(style.cell || {}),
          ...(cell.style || {})
        },
        class: cell.class
      };
      if (cell.colspan) {
        attributes.colspan = cell.colspan;
      }
      const cellContent = renderCell(h, cell);
      return h('td', attributes, cellContent);
    });
  }
  function renderTitle(h, groupTitle) {
    const titleCell = h('td', {
      colspan: 3,
      style: {
        'font-weight': 'bold'
      },
      direction: rtlUtils.detectTextDirection(groupTitle)
    }, groupTitle);
    return h('tr', {}, titleCell);
  }
  function create$A(translator, rtl) {
    return ({
      h,
      data,
      style
    }) => {
      const groupTitle = data[0].title;

      // Given the space between each node is really small. There is a chance that some nodes
      // are from a different inner dimension. Filter to select only those that match the first.
      const group = data.filter(datum => datum.title === groupTitle);
      const titleRow = renderTitle(h, groupTitle);
      const rows = [titleRow];
      group.slice(0, MAX_NUMBER_OF_ITEMS).forEach(datum => {
        rows.push(h('tr', {}, renderRow(datum.row, {
          h,
          style
        })));
      });
      if (data.length > MAX_NUMBER_OF_ITEMS) {
        const count = data.length - MAX_NUMBER_OF_ITEMS;
        rows.push(...renderMore(h, translator, rtl, count));
      }
      return rows;
    };
  }

  function trendLinesTooltip(keys, {
    trendLineModel,
    translator
  }, context = {}) {
    if (!trendLineModel.query.hasTrendLines()) {
      return false;
    }
    const {
      rtl
    } = context;
    const base = tooltip({
      key: keys.tooltip,
      rtl
    });
    return extend$7(true, base, {
      settings: {
        extract: create$B(keys, trendLineModel),
        content: create$A(translator, rtl),
        placement: 'pointer',
        direction: context.rtl ? 'rtl' : 'ltr'
      }
    });
  }

  function eventToLocalPoint$1(event, chart) {
    const bounds = chart.element.getBoundingClientRect();
    return {
      x: (event.center ? event.center.x : event.clientX) - bounds.left,
      y: (event.center ? event.center.y : event.clientY) - bounds.top
    };
  }
  function localPointToDatum(p, tooltip, viewState, rtl) {
    const px = p.x - tooltip.rect.computed.x;
    let ratio = px / tooltip.rect.computed.width;
    ratio = rtl ? 1 - ratio : ratio;
    const {
      min,
      max
    } = viewState.get('zoom');
    const range = max - min;
    const datum = min + range * ratio;
    return datum;
  }
  function pointToCircle(p) {
    return {
      cx: p.x,
      cy: p.y,
      r: 3
    };
  }
  function create$z(keys, {
    chart,
    viewState,
    trendLineModel,
    layoutService,
    rtl
  }) {
    const {
      isContinuous
    } = layoutService.meta;
    const isOverTooltip = event => chart.componentsFromPoint({
      x: event.center ? event.center.x : event.clientX,
      y: event.center ? event.center.y : event.clientY
    }).some(comp => comp.key === keys.tooltipOverlay);
    let shapesAtConfig = {
      components: [{
        key: keys.tooltipOverlay
      }],
      propagation: 'stop'
    };
    let shapesAt = event => {
      const point = eventToLocalPoint$1(event, chart);
      return chart.shapesAt(point, shapesAtConfig);
    };
    if (isContinuous) {
      const {
        getCalculatedValue
      } = trendLineModel.query;
      shapesAtConfig = {
        components: [{
          key: 'trend-lines'
        }],
        propagation: 'stop'
      };

      // Continuous shapesAt tries to find the actual trend lines and mutate the data in order to show correct tooltip
      shapesAt = (event, tooltip) => {
        const point = eventToLocalPoint$1(event, chart);
        const shapes = chart.shapesAt(pointToCircle(point), shapesAtConfig);
        if (shapes.length) {
          const dimValue = localPointToDatum(point, tooltip, viewState, rtl);
          const scale = chart.scale(keys.majorInnerScale);
          const formatter = scale !== null && scale !== void 0 && scale.formatter ? scale.formatter() : chart.formatter({
            data: {
              fields: ['qDimensionInfo/0']
            }
          });
          const dimLabel = formatter(dimValue);
          shapes.forEach(shape => {
            shape.data.dimValue.value = dimValue; // eslint-disable-line no-param-reassign
            shape.data.dimValue.label = dimLabel; // eslint-disable-line no-param-reassign
            shape.data.minor.value = getCalculatedValue(shape.data.layer.value, dimValue).y; // eslint-disable-line no-param-reassign
          });
        }

        return shapes;
      };
    }
    return event => {
      const tooltip = chart.component(keys.tooltip);
      if (tooltip && isOverTooltip(event)) {
        const shapes = shapesAt(event, tooltip);
        if (shapes.length) {
          tooltip.emit('show', event, {
            nodes: shapes
          });
          return true;
        }
        tooltip.emit('hide');
        return false;
      }
      return false;
    };
  }

  /* eslint-disable no-param-reassign */
  const CONTINUOUS_AXIS_POSSIBLE = 'Possible';
  const CONTINUOUS_AXIS_NEVER = 'Never';
  const isContinuous$2 = properties => !bt(properties, 'dimensionAxis.continuousAuto', false) && properties.preferContinuousAxis;
  const onChangeDashed = properties => {
    if (properties.style.dashed) {
      properties.style.lineDash = '8, 4';
    } else {
      properties.style.lineDash = '';
    }
  };
  const onAdd = qTrendLineDef => {
    onChangeDashed(qTrendLineDef);
    qTrendLineDef.qMultiDimMode = 'Sum'; // Multi || Sum
    qTrendLineDef.qXColIx = 0;
  };
  function create$y(opts = {}) {
    const {
      translator,
      events = {
        onGlobalChange: () => {}
      },
      allowStackedByDimension = false
    } = opts;
    const onGlobalChange = properties => {
      // Handle cases when continuous mode is toggled via PP
      const qTrendLines = bt(properties, 'qHyperCubeDef.qMeasures', []).reduce((ary, qMeasure) => {
        if (Array.isArray(qMeasure.qTrendLines)) {
          ary.push(...qMeasure.qTrendLines);
        }
        return ary;
      }, []);
      const qContinuousXAxis = isContinuous$2(properties) ? CONTINUOUS_AXIS_POSSIBLE : CONTINUOUS_AXIS_NEVER;
      qTrendLines.forEach(qTrendLine => {
        qTrendLine.qContinuousXAxis = qContinuousXAxis;
      });
      events.onGlobalChange(properties, qTrendLines);
    };
    const onItemTitleRef = properties => {
      const type = typeof properties.label;
      if (type === 'string' && properties.label) {
        return properties.label;
      }
      if (type === 'object') {
        if (properties.label.qStringExpression) {
          return properties.label.qStringExpression.qExpr;
        }
        return properties.label.qValueExpression.qExpr;
      }
      return translator.get(TRANSLATIONS.TYPES[properties.qType]);
    };
    return {
      show: (data, handler, {
        layout
      }) => !isType.dimensionless(layout) && !isType.groupedByDimension(layout) && (allowStackedByDimension || !isType.stackedByDimension(layout)),
      type: 'array',
      ref: 'qTrendLines',
      titleTranslation: TRANSLATIONS.HEADER,
      itemTitleRef: onItemTitleRef,
      max: 8,
      allowAdd: true,
      allowRemove: true,
      allowMove: false,
      addTranslation: TRANSLATIONS.ADD_BUTTON,
      add: onAdd,
      globalChange: onGlobalChange,
      items: {
        label: {
          ref: 'label',
          type: 'string',
          expression: 'optional',
          translation: 'Common.Label',
          defaultValue: ''
        },
        type: {
          ref: 'qType',
          type: 'string',
          component: 'dropdown',
          translation: TRANSLATIONS.TYPE,
          options: [{
            value: TYPES$1.AVERAGE,
            translation: TRANSLATIONS.TYPES.AVERAGE
          }, {
            value: TYPES$1.LINEAR,
            translation: TRANSLATIONS.TYPES.LINEAR
          }, {
            value: TYPES$1.POLYNOMIAL2,
            translation: TRANSLATIONS.TYPES.POLYNOMIAL2
          }, {
            value: TYPES$1.POLYNOMIAL3,
            translation: TRANSLATIONS.TYPES.POLYNOMIAL3
          }, {
            value: TYPES$1.POLYNOMIAL4,
            translation: TRANSLATIONS.TYPES.POLYNOMIAL4
          }, {
            value: TYPES$1.EXPONENTIAL,
            translation: TRANSLATIONS.TYPES.EXPONENTIAL
          }, {
            value: TYPES$1.LOG,
            translation: TRANSLATIONS.TYPES.LOG
          }, {
            value: TYPES$1.POWER,
            translation: TRANSLATIONS.TYPES.POWER
          }],
          defaultValue: TYPES$1.AVERAGE
        },
        autoColor: {
          ref: 'style.autoColor',
          type: 'boolean',
          translation: 'properties.colors',
          component: 'switch',
          defaultValue: true,
          options: [{
            value: true,
            translation: 'Common.Auto'
          }, {
            value: false,
            translation: 'Common.Custom'
          }]
        },
        paletteColor: {
          ref: 'style.paletteColor',
          translation: 'properties.color',
          type: 'object',
          component: 'color-picker',
          dualOutput: true,
          defaultValue: DEFAULT_PALETTE_COLOR,
          show: data => !data.style.autoColor
        },
        dashed: {
          ref: 'style.dashed',
          translation: TRANSLATIONS.STYLE.DASHED,
          type: 'boolean',
          defaultValue: true,
          change: onChangeDashed
        }
      }
    };
  }

  const dataPointSize = {
    component: 'slider',
    type: 'number',
    expression: 'optional',
    ref: 'style.dataPointSize',
    translation: 'LayerStyleEditor.style.dataPointSize',
    show: true,
    defaultValue: 6,
    min: 3,
    max: 20,
    step: 1
  };
  const lineThickness = {
    component: 'slider',
    type: 'number',
    expression: 'optional',
    ref: 'style.lineThickness',
    translation: 'LayerStyleEditor.style.lineThickness',
    show: true,
    defaultValue: 1,
    min: 1,
    max: 5,
    step: 1
  };
  const lineType = {
    component: 'dropdown',
    type: 'string',
    expression: 'optional',
    ref: 'style.lineType',
    translation: 'LayerStyleEditor.style.lineType',
    show: true,
    defaultValue: 'solid',
    options: [{
      value: 'solid',
      translation: 'LayerStyleEditor.style.solid'
    }, {
      value: 'dashed',
      translation: 'LayerStyleEditor.style.dashed'
    }]
  };
  const lineCurve = {
    component: 'dropdown',
    type: 'string',
    expression: 'optional',
    ref: 'style.lineCurve',
    translation: 'LayerStyleEditor.style.lineCurve',
    show: true,
    defaultValue: 'linear',
    options: [{
      value: 'linear',
      translation: 'LayerStyleEditor.style.linear'
    }, {
      value: 'monotone',
      translation: 'LayerStyleEditor.style.monotone'
    }]
  };
  function createLineStylingProperties() {
    const lineStyling = {
      component: 'style-editor',
      translation: 'LayerStyleEditor.component.styling',
      subtitle: 'LayerStyleEditor.component.styling',
      resetBtnTranslation: 'LayerStyleEditor.component.resetAll',
      key: 'line',
      ref: 'components',
      defaultValue: [],
      defaultValues() {
        return {
          key: 'line',
          style: {
            dataPointSize: dataPointSize.defaultValue,
            lineThickness: lineThickness.defaultValue,
            lineType: lineType.defaultValue,
            lineCurve: lineCurve.defaultValue
          }
        };
      },
      items: {
        line: {
          component: 'items',
          type: 'items',
          items: {
            dataPointSize: {
              ...dataPointSize,
              styleMeasure: true
            },
            lineThickness: {
              ...lineThickness,
              styleMeasure: true
            },
            lineType: {
              ...lineType,
              styleMeasure: true
            },
            lineCurve: {
              ...lineCurve,
              styleMeasure: true
            }
          }
        }
      }
    };
    return lineStyling;
  }
  function createLineStylingDefinition(translator) {
    const onItemTitleRef = () => {
      return translator.get('properties.lineStyle');
    };
    const lineStyling = {
      type: 'array',
      max: 1,
      allowAdd: true,
      allowRemove: true,
      allowMove: false,
      ref: 'qDef.styling',
      itemTitleRef: onItemTitleRef,
      titleTranslation: 'LayerStyleEditor.component.styling',
      addTranslation: 'Object.Container.Props.Add',
      items: {
        dataPointSize,
        lineThickness,
        lineType,
        lineCurve
      }
    };
    return lineStyling;
  }

  /**
   * Get a property definiton containing settings for Font Family, Font Size and Color
   * @param {string} path
   * @param {object} fontResolver
   * @param {object} theme
   * @returns {object} property definition object
   */
  const labelStylingDefinition = (path, fontResolver, theme) => {
    const pathFontFamily = `${path}.fontFamily`;
    const pathFontSize = `${path}.fontSize`;
    return {
      fontFamilyItem: {
        component: 'dropdown',
        ref: pathFontFamily,
        options: () => {
          return fontResolver.getOptions(pathFontFamily);
        },
        defaultValue: () => {
          return fontResolver.getDefaultValue(pathFontFamily);
        }
      },
      fontWrapperItem: {
        component: 'inline-wrapper',
        items: {
          fontSizeItem: {
            component: 'dropdown',
            ref: pathFontSize,
            options: () => {
              return fontResolver.getOptions(pathFontSize);
            },
            defaultValue: () => {
              return fontResolver.getDefaultValue(pathFontSize);
            }
          },
          fontColorItem: {
            component: 'color-picker',
            width: false,
            ref: `${path}.color`,
            defaultValue: () => ({
              color: theme.getStyle('object.lineChart', path, 'color')
            })
          }
        }
      }
    };
  };

  const createStylingPanelDefinition = (flags, theme, translator) => {
    const fontResolver = Gi({
      theme,
      translator,
      flags,
      config: {
        id: 'lineChart',
        paths: ['axis.title', 'axis.label.name', 'label.value', 'legend.title', 'legend.label']
      }
    });
    return {
      component: 'styling-panel',
      translation: 'LayerStyleEditor.component.styling',
      chartTitle: 'Object.LineChart',
      subtitle: 'LayerStyleEditor.component.styling',
      useGeneral: true,
      useBackground: true,
      useMeasureStyling: true,
      items: {
        dataPointSizeSection: {
          translation: 'LayerStyleEditor.style.dataPointSize',
          component: 'panel-section',
          items: {
            dataPointSizeItem: {
              component: 'items',
              ref: 'components',
              key: 'line',
              items: {
                dataPointSizeSlider: {
                  component: 'slider',
                  ref: 'style.dataPointSize',
                  min: 3,
                  max: 20,
                  step: 1,
                  width: 12,
                  defaultValue: 6,
                  styleMeasure: true
                }
              }
            }
          }
        },
        lineOptionSection: {
          translation: 'LayerStyleEditor.style.lineOptions',
          component: 'panel-section',
          items: {
            lineOptionItem: {
              component: 'items',
              ref: 'components',
              key: 'line',
              items: {
                lineThicknessText: {
                  component: 'text',
                  translation: 'LayerStyleEditor.style.lineThickness'
                },
                lineThickness: {
                  component: 'slider',
                  ref: 'style.lineThickness',
                  min: 1,
                  max: 5,
                  step: 1,
                  width: 12,
                  defaultValue: 1,
                  styleMeasure: true
                },
                lineTypeWrapper: {
                  component: 'inline-wrapper',
                  alignItems: 'center',
                  items: {
                    lineTypeText: {
                      component: 'text',
                      translation: 'LayerStyleEditor.style.lineType'
                    },
                    lineTypeDropdown: {
                      component: 'dropdown',
                      ref: 'style.lineType',
                      options: [{
                        value: 'solid',
                        translation: 'LayerStyleEditor.style.solid'
                      }, {
                        value: 'dashed',
                        translation: 'LayerStyleEditor.style.dashed'
                      }],
                      defaultValue: 'solid',
                      styleMeasure: true
                    }
                  }
                },
                lineCurveWrapper: {
                  component: 'inline-wrapper',
                  alignItems: 'center',
                  items: {
                    lineCurveText: {
                      component: 'text',
                      translation: 'LayerStyleEditor.style.lineCurve'
                    },
                    lineCurveDropdown: {
                      component: 'dropdown',
                      ref: 'style.lineCurve',
                      options: [{
                        value: 'linear',
                        translation: 'LayerStyleEditor.style.linear'
                      }, {
                        value: 'monotone',
                        translation: 'LayerStyleEditor.style.monotone'
                      }],
                      defaultValue: 'linear',
                      styleMeasure: true
                    }
                  }
                }
              }
            }
          }
        },
        axisTitleSection: flags !== null && flags !== void 0 && flags.isEnabled('CLIENT_IM_3050') ? {
          translation: 'properties.axis.title',
          component: 'panel-section',
          items: {
            labelItems: {
              component: 'items',
              ref: 'components',
              key: 'axis',
              items: labelStylingDefinition('axis.title', fontResolver, theme)
            }
          }
        } : undefined,
        axisLabelSection: flags !== null && flags !== void 0 && flags.isEnabled('CLIENT_IM_3050') ? {
          translation: 'properties.axis.label',
          component: 'panel-section',
          items: {
            labelItems: {
              component: 'items',
              ref: 'components',
              key: 'axis',
              items: labelStylingDefinition('axis.label.name', fontResolver, theme)
            }
          }
        } : undefined,
        labelValueSection: flags !== null && flags !== void 0 && flags.isEnabled('CLIENT_IM_3050') ? {
          translation: 'properties.value.label',
          component: 'panel-section',
          items: {
            labelItems: {
              component: 'items',
              ref: 'components',
              key: 'label',
              items: labelStylingDefinition('label.value', fontResolver, theme)
            }
          }
        } : undefined,
        legendTitleSection: flags !== null && flags !== void 0 && flags.isEnabled('CLIENT_IM_3051') ? {
          translation: 'properties.legend.title',
          component: 'panel-section',
          items: {
            labelItems: {
              component: 'items',
              ref: 'components',
              key: 'legend',
              items: labelStylingDefinition('legend.title', fontResolver, theme)
            }
          }
        } : undefined,
        legendLabelSection: flags !== null && flags !== void 0 && flags.isEnabled('CLIENT_IM_3051') ? {
          translation: 'properties.legend.label',
          component: 'panel-section',
          items: {
            labelItems: {
              component: 'items',
              ref: 'components',
              key: 'legend',
              items: labelStylingDefinition('legend.label', fontResolver, theme)
            }
          }
        } : undefined
      }
    };
  };

  var NUMBERS$1 = {
    MAX_NUM_POINTS: 50000,
    MAX_NUM_LINES: 1000,
    DEFAULT_NUM_POINTS: 2000,
    DEFAULT_NUM_LINES: 12,
    LARGE_NUM_POINTS: 10000,
    LARGE_NUM_POINTS_ANIMATIONS: 1000,
    CHUNK_SIZE: 3000
  };

  var ERROR_CODE = 7005;

  /* eslint-disable no-param-reassign */
  const {
    MAX_NUM_POINTS: MAX_NUM_POINTS$2,
    MAX_NUM_LINES: MAX_NUM_LINES$1,
    DEFAULT_NUM_POINTS: DEFAULT_NUM_POINTS$6,
    DEFAULT_NUM_LINES: DEFAULT_NUM_LINES$4
  } = NUMBERS$1;
  const DEFAULT_MAX_VISIBLE_ITEMS = 10;
  const isValidPredicate$2 = i => {
    var _i$qError;
    return ((_i$qError = i.qError) === null || _i$qError === void 0 ? void 0 : _i$qError.qErrorCode) !== ERROR_CODE;
  };
  const getValidDimensions$2 = layout => layout.qHyperCube.qDimensionInfo.filter(d => isValidPredicate$2(d));
  const getValidMeasures$1 = layout => layout.qHyperCube.qMeasureInfo.filter(d => isValidPredicate$2(d));
  const hasValidData = layout => getValidDimensions$2(layout).length && getValidMeasures$1(layout).length;
  const showStackedOptions = (data, handler) => data.lineType === 'area' && getValidDimensions$2(handler.layout).length + getValidMeasures$1(handler.layout).length > 2;
  const isContinuous$1 = layout => isType.continuous(layout, () => timeUtils.isTime(true, layout));
  const overrideIfContinuous = overrideValue => ({
    get(getter, definition, args) {
      if (isContinuous$1(args.layout)) {
        return overrideValue;
      }
      return getter(definition.type);
    },
    set(value, setter, definition, args) {
      const defaultValue = propertyResolver.getDefaultValue(definition.type, definition);
      setter(definition.type, isContinuous$1(args.layout) ? overrideValue : value, defaultValue);
    }
  });
  const addons = {
    type: 'items',
    component: 'expandable-items',
    translation: 'properties.addons',
    items: {
      dataHandling: {
        uses: 'dataHandling',
        items: {
          calcCond: {
            uses: 'calcCond'
          }
        }
      },
      refLines: {
        uses: 'reflines'
      },
      dimRefLines: {
        uses: 'dimReflines'
      }
    }
  };
  const getAxisTitle = (handler, translator, axis) => {
    let direction;
    let titles;
    if (axis === 'measure') {
      direction = handler.layout.orientation === 'vertical' && !isContinuous$1(handler.layout) ? 'x' : 'y';
      titles = getValidMeasures$1(handler.layout).map(m => m.qFallbackTitle || '').join(', ');
    } else {
      direction = handler.layout.orientation === 'vertical' && !isContinuous$1(handler.layout) ? 'y' : 'x';
      titles = getValidDimensions$2(handler.layout).map(m => m.qFallbackTitle || '').join(', ');
    }
    return titles ? translator.get(`properties.${direction}AxisWithInfo`, [titles]) : translator.get(`properties.${direction}Axis`);
  };
  function createDefinition({
    flags,
    isUnsupportedFeature,
    translator,
    theme
  }) {
    const trendLines = isUnsupportedFeature !== null && isUnsupportedFeature !== void 0 && isUnsupportedFeature('trendlines') ? undefined : create$y({
      translator,
      events: {
        onGlobalChange: (properties, qTrendLinesDefs) => {
          let qMultiDimMode = 'Multi';
          let qContinuousXAxis = 'Never';
          if (properties.lineType === 'area' && properties.stackedArea) {
            qMultiDimMode = 'Sum';
          }
          if (bt(properties, 'dimensionAxis.continuousAuto', false)) {
            qContinuousXAxis = 'Time';
          } else if (properties.preferContinuousAxis) {
            qContinuousXAxis = 'Possible';
          }
          qTrendLinesDefs.forEach(qTrendLine => {
            qTrendLine.qMultiDimMode = qMultiDimMode; // eslint-disable-line no-param-reassign
            qTrendLine.qContinuousXAxis = qContinuousXAxis; // eslint-disable-line no-param-reassign
          });
        }
      }
    });

    const tooltip = {
      uses: 'tooltip'
    };
    const lineStyling = createLineStylingDefinition(translator);
    const colorModeOptions = (data, handler) => {
      var _data$color;
      const {
        length: dimensions
      } = getValidDimensions$2(handler.layout);
      const {
        length: measures
      } = getValidMeasures$1(handler.layout);
      const options = [{
        value: 'primary',
        translation: 'properties.colorMode.primary'
      }];
      if (measures > 1) {
        options.push({
          value: 'byMultiple',
          translation: 'properties.colorMode.multicolored'
        });
      }
      if (dimensions > 1) {
        options.push({
          value: 'byDimension',
          translation: 'properties.colorMode.byDimension'
        });
      }
      switch ((_data$color = data.color) === null || _data$color === void 0 ? void 0 : _data$color.mode) {
        case 'byMeasure':
          options.push({
            value: 'byMeasure',
            translation: 'properties.colorMode.byMeasure'
          });
          break;
        case 'byExpression':
          options.push({
            value: 'byExpression',
            translation: 'properties.colorMode.byExpression'
          });
          break;
      }
      return options;
    };
    const simpleColors = {
      items: {
        simpleItems: {
          items: {
            colorMode: {
              options: colorModeOptions
            }
          }
        }
      }
    };
    const simpleLabels = {
      items: {
        labels: {
          items: {
            header: {
              show(props, handler, args) {
                return hasValidData(args.layout);
              }
            },
            pointLabels: {
              component: 'checkbox',
              ref: 'dataPoint.showLabels',
              type: 'string',
              translation: 'Simple.Label.Value',
              show(props, handler, args) {
                return hasValidData(args.layout);
              },
              convertFunctions: {
                get(getter, def, args, data) {
                  var _data$dataPoint, _data$dataPoint2, _data$dataPoint3;
                  return ((_data$dataPoint = data.dataPoint) === null || _data$dataPoint === void 0 ? void 0 : _data$dataPoint.show) && ((_data$dataPoint2 = data.dataPoint) === null || _data$dataPoint2 === void 0 ? void 0 : _data$dataPoint2.showLabels) !== false && ((_data$dataPoint3 = data.dataPoint) === null || _data$dataPoint3 === void 0 ? void 0 : _data$dataPoint3.showLabels) !== 'none';
                },
                set(value, setter, def, args, data) {
                  qt(data, 'dataPoint.showLabels', value ? 'auto' : 'none');
                  qt(data, 'dataPoint.show', value);
                }
              },
              reset(data) {
                qt(data, 'dataPoint.show', false);
                qt(data, 'dataPoint.showLabels', 'auto');
              }
            },
            dimensionTitle: {
              component: 'checkbox',
              ref: 'dimensionAxis.show',
              type: 'string',
              translation: 'Simple.Label.Dimension.Hide',
              defaultValue: 'all',
              show(props, handler, args) {
                return hasValidData(args.layout);
              },
              convertFunctions: {
                get(getter, def, args, data) {
                  return data.dimensionAxis.show === 'labels' || data.dimensionAxis.show === 'none';
                },
                set(value, setter, def, args, data) {
                  data.dimensionAxis.show = value ? 'labels' : 'all';
                }
              }
            },
            measureTitle: {
              component: 'checkbox',
              ref: 'measureAxis.show',
              type: 'string',
              translation: 'Simple.Label.Measure.Hide',
              defaultValue: 'all',
              show(props, handler, args) {
                return hasValidData(args.layout);
              },
              convertFunctions: {
                get(getter, def, args, data) {
                  return data.measureAxis.show === 'labels' || data.measureAxis.show === 'none';
                },
                set(value, setter, def, args, data) {
                  data.measureAxis.show = value ? 'labels' : 'all';
                }
              }
            }
          }
        }
      }
    };
    const settings = {
      uses: 'settings',
      items: {
        simpleLabels,
        general: {
          items: {
            showDisclaimer: flags !== null && flags !== void 0 && flags.isEnabled('SHOW_DISCLAIMER') ? {
              translation: 'properties.showDisclaimer',
              type: 'boolean',
              ref: 'showDisclaimer',
              component: 'switch',
              defaultValue: true,
              options: [{
                value: true,
                translation: 'Common.Show'
              }, {
                value: false,
                translation: 'properties.hide'
              }]
            } : undefined
          }
        },
        presentation: {
          type: 'items',
          translation: 'properties.presentation',
          grouped: true,
          items: {
            stylingPanel: flags.isEnabled('SENSECLIENT_IM_312_STYLINGPANEL_LINECHART') ? createStylingPanelDefinition(flags, theme, translator) : createLineStylingProperties(),
            lineType: {
              ref: 'lineType',
              type: 'string',
              component: 'item-selection-list',
              defaultValue: 'line',
              horizontal: true,
              items: [{
                icon: 'line_chart_line',
                component: 'icon-item',
                labelPlacement: 'bottom',
                translation: 'properties.style.line',
                value: 'line'
              }, {
                icon: 'line_chart_area',
                component: 'icon-item',
                labelPlacement: 'bottom',
                translation: 'properties.style.area',
                value: 'area'
              }]
            },
            stackedProps: {
              type: 'items',
              grouped: false,
              items: {
                stackedArea: {
                  ref: 'stackedArea',
                  translation: 'properties.style.stackedArea',
                  type: 'boolean',
                  defaultValue: false,
                  show(data, handler) {
                    return showStackedOptions(data, handler);
                  }
                },
                separateStacking: {
                  ref: 'separateStacking',
                  translation: 'properties.separateStacking',
                  type: 'boolean',
                  defaultValue: true,
                  readOnly(data) {
                    return !data.stackedArea;
                  },
                  show(data, handler) {
                    return showStackedOptions(data, handler);
                  }
                }
              }
            },
            orientation: {
              ref: 'orientation',
              type: 'string',
              component: 'item-selection-list',
              defaultValue: 'horizontal',
              horizontal: true,
              items: [{
                component: 'icon-item',
                icon: 'direction_up_down',
                labelPlacement: 'bottom',
                translation: 'properties.orientation.vertical',
                value: 'vertical'
              }, {
                component: 'icon-item',
                icon: 'direction_left_right',
                labelPlacement: 'bottom',
                translation: 'Common.Horizontal',
                value: 'horizontal'
              }],
              readOnly(data, handler, args) {
                return isContinuous$1(args.layout);
              },
              convertFunctions: overrideIfContinuous('horizontal')
            },
            scroll: {
              type: 'items',
              items: {
                scrollbar: {
                  type: 'string',
                  component: 'dropdown',
                  ref: 'scrollbar',
                  translation: 'properties.scrollbar',
                  options: Object.keys(SCROLLBARS.OPTIONS).map(k => SCROLLBARS.OPTIONS[k]),
                  defaultValue: SCROLLBARS.DEFAULT.value
                },
                scrollStartPos: {
                  ref: 'scrollStartPos',
                  type: 'number',
                  translation: 'properties.ScrollAlignment',
                  component: 'dropdown',
                  defaultValue: 0,
                  options: [{
                    value: 0,
                    translation: 'properties.ScrollAlignStart'
                  }, {
                    value: 1,
                    translation: 'properties.ScrollAlignEnd'
                  }],
                  show(data, handler, args) {
                    return !isContinuous$1(args.layout);
                  }
                }
              }
            },
            nullMode: {
              type: 'string',
              component: 'dropdown',
              ref: 'nullMode',
              translation: 'properties.nullMode',
              options: [{
                value: 'gap',
                translation: 'properties.nullMode.gap'
              }, {
                value: 'connect',
                translation: 'properties.nullMode.connect'
              }, {
                value: 'zero',
                translation: 'properties.nullMode.zero'
              }],
              defaultValue: 'gap'
            },
            dataPointSettings: {
              type: 'items',
              grouped: false,
              snapshot: {
                tid: 'property-dataPoint'
              },
              items: {
                dataPoints: {
                  ref: 'dataPoint.show',
                  translation: 'properties.dataPoints.showDataPoints',
                  type: 'boolean',
                  defaultValue: false
                },
                showDataPointLabels: {
                  ref: 'dataPoint.showLabels',
                  translation: 'properties.dataPoints.labelmode',
                  type: 'string',
                  component: 'dropdown',
                  defaultValue: 'none',
                  show(data) {
                    return !!(data.dataPoint && data.dataPoint.show);
                  },
                  options: [{
                    value: 'none',
                    translation: 'Common.None'
                  }, {
                    value: 'auto',
                    translation: 'Common.Auto'
                  }, {
                    value: 'all',
                    translation: 'Common.All'
                  }],
                  convertFunctions: {
                    get(getter, definition, args) {
                      var _args$properties;
                      const {
                        showLabels
                      } = ((_args$properties = args.properties) === null || _args$properties === void 0 ? void 0 : _args$properties.dataPoint) || {};
                      if (showLabels === false) {
                        return 'none';
                      }
                      if (showLabels === true) {
                        return 'auto';
                      }
                      return getter(definition.type);
                    }
                  }
                }
              }
            },
            maxNumPoints: flags !== null && flags !== void 0 && flags.isEnabled('IM_1620_LINECHART_MORE_POINTS') ? {
              type: 'integer',
              expression: 'optional',
              ref: 'maxNumPoints',
              translation: 'properties.dataPoints.maxVisiblePoints',
              defaultValue: DEFAULT_NUM_POINTS$6,
              show(properties, handler, args) {
                const continuous = isContinuous$1(args.layout);
                return continuous;
              },
              min: DEFAULT_NUM_POINTS$6,
              max: MAX_NUM_POINTS$2
            } : undefined,
            maxNumLines: flags !== null && flags !== void 0 && flags.isEnabled('IM_1620_LINECHART_MORE_POINTS') ? {
              type: 'integer',
              expression: 'optional',
              ref: 'maxNumLines',
              translation: 'properties.dataPoints.maxVisibleLines',
              defaultValue: DEFAULT_NUM_LINES$4,
              show(properties, handler, args) {
                const continuous = isContinuous$1(args.layout);
                const isTwoDims = getValidDimensions$2(args.layout).length === 2;
                return continuous && isTwoDims;
              },
              min: 1,
              max: MAX_NUM_LINES$1
            } : undefined,
            gridLines: {
              type: 'items',
              snapshot: {
                tid: 'property-gridLines'
              },
              items: {
                showGridLines: {
                  ref: 'gridLine.auto',
                  type: 'boolean',
                  translation: 'properties.gridLine.spacing',
                  component: 'switch',
                  defaultValue: true,
                  options: [{
                    value: true,
                    translation: 'Common.Auto'
                  }, {
                    value: false,
                    translation: 'Common.Custom'
                  }]
                },
                gridSpacing: {
                  ref: 'gridLine.spacing',
                  type: 'number',
                  component: 'dropdown',
                  defaultValue: 2,
                  options: [{
                    value: 0,
                    translation: 'properties.gridLine.noLines'
                  }, {
                    value: 1,
                    translation: 'properties.gridLine.wide'
                  }, {
                    value: 2,
                    translation: 'properties.gridLine.medium'
                  }, {
                    value: 3,
                    translation: 'properties.gridLine.narrow'
                  }],
                  show(data) {
                    return data.gridLine && !data.gridLine.auto;
                  }
                }
              }
            }
          }
        },
        colorsAndLegend: {
          uses: 'colorsAndLegend',
          items: {
            colors: {
              items: {
                /**
                 * To support conditionally hidden measures.
                 */
                attributeExpression,
                colorMode: {
                  options(data, handler, args) {
                    const {
                      length: dimensions
                    } = getValidDimensions$2(args.layout);
                    const {
                      length: measures
                    } = getValidMeasures$1(args.layout);
                    const options = [{
                      value: 'primary',
                      translation: 'properties.colorMode.primary'
                    }];
                    if (measures > 1) {
                      options.push({
                        value: 'byMultiple',
                        translation: 'properties.colorMode.multicolored'
                      });
                    }
                    if (dimensions > 1) {
                      options.push({
                        value: 'byDimension',
                        translation: 'properties.colorMode.byDimension'
                      });
                    }
                    if (dimensions <= 1) {
                      options.push({
                        value: 'byMeasure',
                        translation: 'properties.colorMode.byMeasure'
                      });
                    }
                    if (measures >= 1) {
                      options.push({
                        value: 'byExpression',
                        translation: 'properties.colorMode.byExpression'
                      });
                    }
                    return options;
                  }
                }
              }
            },
            simpleColors,
            legend: {
              items: {
                show: {
                  snapshot: {
                    tid: 'property-legend'
                  }
                }
              }
            }
          }
        },
        dimensionAxis: {
          uses: 'axis.dimensionAxis',
          label(properties, handler) {
            return getAxisTitle(handler, translator, 'dimension');
          },
          items: {
            dimensionAxisTitle: {
              component: 'header',
              type: 'string',
              label(properties, handler) {
                return getAxisTitle(handler, translator, 'dimension');
              },
              classification: {
                section: 'axis',
                tags: ['simple'],
                exclusive: true
              }
            },
            othersGroup: {
              items: {
                label: {
                  show(properties, handler, args) {
                    const horizontal = args.layout.orientation !== 'vertical';
                    const labels = !!(properties.dimensionAxis && (properties.dimensionAxis.show === 'all' || properties.dimensionAxis.show === 'labels'));
                    const continuous = isContinuous$1(args.layout);
                    return horizontal && labels && !continuous;
                  }
                },
                dock: {
                  options(properties, handler, args) {
                    const near = {
                      value: 'near',
                      translation: 'Common.Bottom'
                    };
                    const far = {
                      value: 'far',
                      translation: 'Common.Top'
                    };
                    if (args.layout.orientation === 'vertical' && !isContinuous$1(args.layout)) {
                      near.translation = args.yMirrorMode ? 'properties.dock.right' : 'properties.dock.left';
                      far.translation = args.yMirrorMode ? 'properties.dock.left' : 'properties.dock.right';
                    }
                    return [near, far];
                  }
                }
              }
            },
            axisDisplaySettings: {
              type: 'items',
              components: 'items',
              show(data, handler, args) {
                return !isContinuous$1(args.layout);
              },
              items: {
                axisDisplayMode: {
                  type: 'string',
                  translation: 'properties.axis.displaymode',
                  ref: 'dimensionAxis.axisDisplayMode',
                  component: 'dropdown',
                  defaultValue: 'auto',
                  options: [{
                    value: 'auto',
                    translation: 'properties.axis.displaymode.auto'
                  }, {
                    value: 'max',
                    translation: 'properties.axis.displaymode.max'
                  }, {
                    value: 'custom',
                    translation: 'properties.axis.displaymode.custom'
                  }]
                },
                maxVisibleItems: {
                  type: 'integer',
                  translation: 'properties.axis.maxvisiblevalues',
                  ref: 'dimensionAxis.maxVisibleItems',
                  expression: 'optional',
                  defaultValue: DEFAULT_MAX_VISIBLE_ITEMS,
                  show(data) {
                    return data.dimensionAxis.axisDisplayMode === 'custom';
                  },
                  invalid(data, handler, args) {
                    const {
                      maxVisibleItems
                    } = data.dimensionAxis;
                    const dimensions = getValidDimensions$2(args.layout);
                    const measures = getValidMeasures$1(args.layout);
                    return maxVisibleItems < 0 || maxVisibleItems > 10000 / (dimensions.length + measures.length);
                  },
                  globalChange(data, handler, args) {
                    /* eslint-disable no-param-reassign */
                    if (data.dimensionAxis.axisDisplayMode === 'custom') {
                      const {
                        maxVisibleItems
                      } = data.dimensionAxis;
                      const dimensions = getValidDimensions$2(args.layout);
                      const measures = getValidMeasures$1(args.layout);
                      if (maxVisibleItems < 1) {
                        data.dimensionAxis.maxVisibleItems = DEFAULT_MAX_VISIBLE_ITEMS;
                      } else if (maxVisibleItems > 10000 / (dimensions.length + measures.length)) {
                        data.dimensionAxis.maxVisibleItems = Math.min(maxVisibleItems, Math.floor(10000 / (dimensions.length + measures.length)));
                      }
                    }
                    /* eslint-enable no-param-reassign */
                  }
                },

                hint: {
                  component: 'text',
                  translation: 'properties.axis.maxvisiblevalues.hint',
                  style: 'hint',
                  show(data) {
                    return ['custom', 'max'].indexOf(data.dimensionAxis.axisDisplayMode) > -1;
                  }
                }
              }
            },
            continuousGroup: {
              items: {
                miniChart: null
              },
              show: !(isUnsupportedFeature !== null && isUnsupportedFeature !== void 0 && isUnsupportedFeature('continuousData'))
            }
          }
        },
        measureAxis: {
          uses: 'axis.flippableMeasureAxis',
          label(properties, handler) {
            return getAxisTitle(handler, translator, 'measure');
          },
          items: {
            axis: {
              items: {
                measureAxisTitle: {
                  component: 'header',
                  type: 'string',
                  label(properties, handler) {
                    return getAxisTitle(handler, translator, 'measure');
                  },
                  classification: {
                    section: 'axis',
                    tags: ['simple'],
                    exclusive: true
                  }
                },
                dock: {
                  options(properties, handler, args) {
                    const near = {
                      value: 'near',
                      translation: 'Common.Bottom'
                    };
                    const far = {
                      value: 'far',
                      translation: 'Common.Top'
                    };
                    if (args.layout.orientation !== 'vertical' || isContinuous$1(args.layout)) {
                      near.translation = args.yMirrorMode ? 'properties.dock.right' : 'properties.dock.left';
                      far.translation = args.yMirrorMode ? 'properties.dock.left' : 'properties.dock.right';
                    }
                    return [near, far];
                  }
                }
              }
            },
            scale: {
              type: 'items',
              items: {
                logScale: {
                  ref: 'measureAxis.logarithmic',
                  component: 'buttongroup',
                  type: 'string',
                  options: [{
                    value: false,
                    label: translator.get('properties.axis.linear'),
                    tooltipTranslation: 'properties.axis.linear'
                  }, {
                    value: true,
                    label: translator.get('properties.axis.logarithmic'),
                    tooltipTranslation: 'properties.axis.logarithmic'
                  }],
                  defaultValue: false,
                  classification: {
                    section: 'axis',
                    tags: ['simple']
                  }
                },
                label: {
                  component: 'text',
                  translation: 'properties.axis.logarithmicScaleNote',
                  show(data) {
                    return !!(data.measureAxis && data.measureAxis.logarithmic);
                  }
                }
              }
            },
            startAt: {
              type: 'string',
              component: 'dropdown',
              translation: 'properties.axis.startAt',
              readOnly: data => {
                return !data.measureAxis.autoMinMax && !(data.measureAxis.minMax === 'min' && data.measureAxis.min === 0);
              },
              options: [{
                value: 'zero',
                translation: 'properties.axis.startAt.zero'
              }, {
                value: 'lowest',
                translation: 'properties.axis.startAt.lowest'
              }],
              defaultValue: 'lowest',
              convertFunctions: {
                get(getter, definition, args, data) {
                  const {
                    autoMinMax,
                    minMax,
                    min
                  } = (data === null || data === void 0 ? void 0 : data.measureAxis) || {};
                  if (autoMinMax === true) {
                    return 'lowest';
                  }
                  if (!autoMinMax && minMax === 'min' && min === 0) {
                    return 'zero';
                  }
                  return getter(definition.type);
                },
                set(value, setter, definition, args, data) {
                  if (value === 'zero') {
                    qt(data, 'measureAxis.autoMinMax', false);
                    qt(data, 'measureAxis.minMax', 'min');
                    qt(data, 'measureAxis.min', 0);
                  } else {
                    qt(data, 'measureAxis.autoMinMax', true);
                  }
                }
              },
              classification: {
                section: 'axis',
                tags: ['simple'],
                exclusive: true
              }
            }
          }
        },
        tooltip
      }
    };
    if (flags !== null && flags !== void 0 && flags.isEnabled('SENSECLIENT_LAYERED_LABELS')) {
      settings.items.dimensionAxis.items.othersGroup.items.label.options = [{
        value: 'auto',
        translation: 'Common.Auto'
      }, {
        value: 'horizontal',
        translation: 'Common.Horizontal'
      }, {
        value: 'tilted',
        translation: 'properties.labels.tilted'
      }, {
        value: 'layered',
        translation: 'properties.labels.layered'
      }];
    }
    const res = {
      type: 'items',
      component: 'accordion',
      items: {
        data: {
          uses: 'data',
          items: {
            dimensions: {
              items: {
                nullSuppression: {
                  show(itemData, handler, args) {
                    var _handler$layout, _handler$properties;
                    if (isUnsupportedFeature !== null && isUnsupportedFeature !== void 0 && isUnsupportedFeature('includeZeroValues')) {
                      return false;
                    }
                    const firstValidIndex = (_handler$layout = handler.layout) === null || _handler$layout === void 0 || (_handler$layout = _handler$layout.qHyperCube) === null || _handler$layout === void 0 || (_handler$layout = _handler$layout.qDimensionInfo) === null || _handler$layout === void 0 ? void 0 : _handler$layout.findIndex(i => isValidPredicate$2(i));
                    const isFirst = ((_handler$properties = handler.properties) === null || _handler$properties === void 0 || (_handler$properties = _handler$properties.qHyperCubeDef) === null || _handler$properties === void 0 || (_handler$properties = _handler$properties.qDimensions) === null || _handler$properties === void 0 ? void 0 : _handler$properties[firstValidIndex]) === itemData;
                    return !isFirst || !isContinuous$1(args.layout);
                  }
                },
                visibilityCondition: {
                  type: 'string',
                  component: 'expression',
                  ref: 'qCalcCondition.qCond',
                  expression: 'optional',
                  expressionType: 'ValueExpr',
                  translation: 'Object.Chart.Dimensions.VisibilityCondition',
                  defaultValue: {
                    qv: ''
                  },
                  tid: 'visibilityCondition',
                  isExpression(val) {
                    return typeof val === 'string' && val.trim().length > 0;
                  },
                  show() {
                    return flags.isEnabled('IM_1869_HIDE_DIM_MEA_LINE');
                  }
                }
              }
            },
            measures: {
              items: {
                visibilityCondition: {
                  type: 'string',
                  component: 'expression',
                  ref: 'qCalcCondition.qCond',
                  expression: 'optional',
                  expressionType: 'ValueExpr',
                  translation: 'Object.Chart.Measures.VisibilityCondition',
                  defaultValue: {
                    qv: ''
                  },
                  tid: 'visibilityCondition',
                  isExpression(val) {
                    return typeof val === 'string' && val.trim().length > 0;
                  },
                  show() {
                    return flags.isEnabled('IM_1869_HIDE_DIM_MEA_LINE');
                  }
                },
                trendLines,
                styling: flags !== null && flags !== void 0 && flags.isEnabled('SENSECLIENT_IM_312_STYLINGPANEL_LINECHART') ? lineStyling : undefined
              }
            }
          }
        },
        sorting: {
          type: 'items',
          translation: 'properties.sorting',
          items: {
            noContinuousSortingMessage: {
              component: 'text',
              translation: 'properties.sorting.noContinuousSortingMessage',
              show(data, handler, args) {
                return isContinuous$1(args.layout);
              },
              classification: {
                section: 'sorting',
                tags: ['simple']
              }
            },
            defaultSorting: {
              uses: 'sorting',
              show(data, handler, args) {
                return !isContinuous$1(args.layout);
              },
              items: {
                dimensions: {
                  locked(index, data, handler) {
                    return handler.getMeasures().length === 1 && handler.getDimensions().length === 2;
                  },
                  items: {
                    autoSort: {
                      change(dimension) {
                        autoSortDimension(dimension);
                      }
                    }
                  }
                },
                measures: {
                  locked(index, data, handler) {
                    return handler.getMeasures().length === 1 && handler.getDimensions().length === 2;
                  }
                }
              }
            }
          }
        },
        addons,
        settings
      }
    };
    if (flags.isEnabled('LINECHART_FORECAST')) {
      res.items.data.items.dimensions.items.forecast = createForecastDimensionProperties();
      res.items.data.items.measures.items.forecast = createForecastMeasureProperties();
    } else {
      res.items.data.items.dimensions.items.forecast = {
        show: false,
        globalChange: (properties, handler) => {
          const {
            layout
          } = handler;
          checkToUpdateProperties({
            enabledForecast: false,
            properties,
            layout
          });
        }
      };
    }
    return res;
  }

  const constants$1 = {
    CUSTOM: {
      EXPRESSION: 'customTooltipExpression',
      TITLE: 'customTooltipTitle',
      DESCRIPTION: 'customTooltipDescription',
      QUARANTINE: 'customTooltip',
      IMAGES: 'customTooltipImages'
    },
    CHART: {
      CONTAINER_ID: 'tooltipContainerId',
      STATE: 'customTooltipSessionState',
      CHART_OBJECT_ID: 'customTooltipSessionObjectId',
      CHART_PARENT_TYPE: 'TooltipChartParent',
      CHART_CHILD_TYPE: 'TooltipChart',
      STYLE: {
        small: '140px',
        medium: '200px',
        large: '340px'
      }
    }
  };

  function validateQmem(qmemUrl) {
    const substrings = qmemUrl.split('/');
    return substrings[0] === 'qmem:' && substrings[1] === '';
  }
  function getSenseServerUrl(app) {
    var _app$session, _app$enigmaModel, _app$session2;
    let config;
    let protocol;
    let host;
    let port;
    let prefix;
    let isSecure;
    if (app && ((_app$session = app.session) !== null && _app$session !== void 0 && _app$session.options || (_app$enigmaModel = app.enigmaModel) !== null && _app$enigmaModel !== void 0 && (_app$enigmaModel = _app$enigmaModel.session) !== null && _app$enigmaModel !== void 0 && _app$enigmaModel.sessionConfig || (_app$session2 = app.session) !== null && _app$session2 !== void 0 && (_app$session2 = _app$session2.config) !== null && _app$session2 !== void 0 && _app$session2.url)) {
      var _app$enigmaModel2;
      config = app.session.options || ((_app$enigmaModel2 = app.enigmaModel) === null || _app$enigmaModel2 === void 0 ? void 0 : _app$enigmaModel2.session.sessionConfig);

      // fix for usage in mashups
      if (!config) {
        var _app$session3;
        config = (_app$session3 = app.session) === null || _app$session3 === void 0 ? void 0 : _app$session3.config;
        const url = new URL(config.url);
        config.host = url.hostname;
        config.port = url.port;
        config.isSecure = url.protocol === 'wss:';
      }
      if (config.secure !== undefined) {
        isSecure = config.secure;
      } else {
        isSecure = config.isSecure;
      }
      protocol = isSecure ? 'https://' : 'http://';
      host = config.host || 'localhost';
      port = config.port ? `:${config.port}` : '';
      prefix = config.prefix ? config.prefix : '/';
      if (prefix[prefix.length - 1] !== '/') {
        prefix = `${prefix}/`;
      }
      return protocol + host + port + prefix;
    }
    return '';
  }
  function stripBasePath(path, rootPath) {
    const result = path.replace(rootPath, '').replace(/^\.\.\//i, '/'); // Remove url:s like http://localhost:4848/
    if (result[0] !== '/') {
      return `/${result}`;
    }
    return result;
  }
  function addBasePath(path, rootPath) {
    return rootPath + (path[0] === '/' ? path.substr(1) : path);
  }
  const imageSize = {
    getImageSize(src, size) {
      let timer;
      function clearTimer() {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
      }
      function handleFail(img) {
        const image = img;
        // kill previous error handlers
        image.onload = null;
        image.onerror = null;
        // stop existing timer
        clearTimer();
      }
      const maxSize = {
        small: 50,
        medium: 200,
        large: 340,
        original: 340
      };
      return new Promise(resolve => {
        const img = new Image();
        img.referrerPolicy = 'no-referrer';
        img.onload = () => {
          let result;
          const {
            height,
            width
          } = img;
          const heightRatio = height > width ? 1 : height / width;
          const widthRation = width > height ? 1 : width / height;
          const maxHeight = maxSize[size] * heightRatio;
          const maxWidth = maxSize[size] * widthRation;
          if (!height || !width || height === 0 && width === 0) {
            result = {
              height: 20,
              width: 20,
              imageError: true
            };
            handleFail(img);
          } else if (size === 'original') {
            result = {
              height: Math.min(maxHeight, height),
              width: Math.min(maxWidth, width)
            };
            clearTimer();
          } else {
            result = {
              height: maxHeight,
              width: maxWidth
            };
            clearTimer();
          }
          resolve(result);
        };
        img.onerror = () => {
          handleFail(img);
          resolve({
            height: 20,
            width: 20,
            imageError: true
          });
        };
        img.src = src;
        timer = setTimeout(() => {
          handleFail(img);
          resolve({
            height: 20,
            width: 20,
            imageError: true
          });
        }, 3000);
      });
    }
  };
  async function handleMediaImage(image, size, app) {
    let src = image.ref.qStaticContentUrl.qUrl;

    // for QB-2492 bug
    const rootPath = getSenseServerUrl(app);
    if (rootPath) {
      stripBasePath(src, rootPath);
      src = src.replace(/"/g, '\\"');
      src = src.replace(/'/g, "\\'");
      src = addBasePath(src, rootPath);
    }
    const {
      height,
      width,
      imageError
    } = await imageSize.getImageSize(src, size);
    return {
      src,
      size,
      height,
      width,
      imageError
    };
  }
  async function handleUrlImage(app, flags, imageComponent, size, nodeValue) {
    let result;
    let value = imageComponent.ref;
    if (nodeValue && nodeValue.label) {
      value = nodeValue.label;
    }
    if (flags.isEnabled('IMAGE_BUNDLE_LOAD') && app !== null && app !== void 0 && app.getImage && validateQmem(value)) {
      try {
        const image = await app.getImage(value);
        const imageSrc = `data:image/png;base64, ${image}`;
        const {
          height,
          width,
          imageError
        } = await imageSize.getImageSize(imageSrc, size);
        result = {
          src: imageSrc,
          size,
          height,
          width,
          imageError
        };
      } catch (e) {
        // Ignore if error occur
      }
    } else {
      const {
        height,
        width,
        imageError
      } = await imageSize.getImageSize(value, size);
      result = {
        src: value,
        size,
        height,
        width,
        imageError
      };
    }
    return result;
  }
  async function handleFieldImage(app, attrExpr, size, nodeValue) {
    let result;
    const value = nodeValue.label;
    const fieldName = attrExpr.qFallbackTitle;
    const qmemUrl = `qmem://${fieldName}/${value}`;
    // }
    if (validateQmem(qmemUrl)) {
      try {
        const image = await app.getImage(qmemUrl);
        if (image) {
          const imageSrc = `data:image/png;base64, ${image}`;
          const {
            height,
            width,
            imageError
          } = await imageSize.getImageSize(imageSrc, size);
          result = {
            src: imageSrc,
            size,
            height,
            width,
            imageError
          };
        }
      } catch (e) {
        // Ignore if error occur
      }
    }
    return result;
  }
  async function retrieveImagesFromNode(customTooltipModel, opts, attrExps, node) {
    var _customTooltipModel$l, _node$data, _imageComponent$ref;
    const {
      app,
      flags
    } = opts;

    // get imageComponents from layout
    const imageComponents = (_customTooltipModel$l = customTooltipModel.layout) === null || _customTooltipModel$l === void 0 || (_customTooltipModel$l = _customTooltipModel$l.tooltip) === null || _customTooltipModel$l === void 0 ? void 0 : _customTooltipModel$l.imageComponents;
    if (!imageComponents) {
      return [];
    }
    const [imageComponent] = imageComponents;
    const size = imageComponent.size || 'small';
    const imageType = imageComponent.type || 'media';
    let attrIndex = -1;
    for (let i = 0; i < attrExps.length; i++) {
      if (attrExps[i].cId === imageComponent.cId) {
        attrIndex = i;
        break;
      }
    }
    const nodeValues = ((_node$data = node.data) === null || _node$data === void 0 || (_node$data = _node$data.customTooltipAttrExps) === null || _node$data === void 0 ? void 0 : _node$data.value) || [];
    let nodeValue;
    if (attrIndex !== -1 && nodeValues[attrIndex]) {
      nodeValue = nodeValues[attrIndex];
    }
    if (imageType === 'media' && (_imageComponent$ref = imageComponent.ref) !== null && _imageComponent$ref !== void 0 && (_imageComponent$ref = _imageComponent$ref.qStaticContentUrl) !== null && _imageComponent$ref !== void 0 && _imageComponent$ref.qUrl) {
      return handleMediaImage(imageComponent, size, app);
    }
    if (imageType === 'url') {
      return handleUrlImage(app, flags, imageComponent, size, nodeValue);
    }
    if (flags.isEnabled('IMAGE_BUNDLE_LOAD') && imageType === 'field' && nodeValue && nodeValue.label) {
      const attrExpr = attrExps[attrIndex];
      return handleFieldImage(app, attrExpr, size, nodeValue);
    }
    return [];
  }
  const images = {
    async addImagesToTheNodes({
      customTooltipModel,
      nodes,
      attrExps,
      opts
    }) {
      const modifiedNodes = nodes;
      const promises = [];
      for (let i = 0; i < modifiedNodes.length; i++) {
        promises.push(retrieveImagesFromNode(customTooltipModel, opts, attrExps, modifiedNodes[i]));
      }
      const nodeImagesArray = await Promise.all(promises);
      for (let i = 0; i < modifiedNodes.length; i++) {
        modifiedNodes[i].data.customTooltipImages = [nodeImagesArray[i]];
      }
      return modifiedNodes;
    },
    checkIfPromisesExist({
      customTooltipModel
    }) {
      var _customTooltipModel$l2;
      // get imageComponents from layout
      const imageComponents = (_customTooltipModel$l2 = customTooltipModel.layout) === null || _customTooltipModel$l2 === void 0 || (_customTooltipModel$l2 = _customTooltipModel$l2.tooltip) === null || _customTooltipModel$l2 === void 0 ? void 0 : _customTooltipModel$l2.imageComponents;
      if (!imageComponents) return false;
      return imageComponents.length > 0;
    }
  };

  const CustomTooltipPromises = {
    async handlePromises({
      customTooltipModel,
      nodes,
      attrExps,
      opts
    }) {
      let modifiedNodes = nodes;
      modifiedNodes = await images.addImagesToTheNodes({
        customTooltipModel,
        nodes,
        attrExps,
        opts
      });
      return modifiedNodes;
    },
    checkIfPromisesExist({
      customTooltipModel
    }) {
      return images.checkIfPromisesExist({
        customTooltipModel
      });
    }
  };

  function container$1(ctx, layout) {
    var _layout$tooltip$chart, _layout$tooltip;
    const sizeType = (_layout$tooltip$chart = (_layout$tooltip = layout.tooltip) === null || _layout$tooltip === void 0 || (_layout$tooltip = _layout$tooltip.chart) === null || _layout$tooltip === void 0 || (_layout$tooltip = _layout$tooltip.style) === null || _layout$tooltip === void 0 ? void 0 : _layout$tooltip.size) !== null && _layout$tooltip$chart !== void 0 ? _layout$tooltip$chart : 'medium';
    const sizeValue = constants$1.CHART.STYLE[sizeType];
    const content = [ctx.h('div', {
      style: {
        display: 'flex',
        width: sizeValue,
        height: sizeValue,
        backgroundColor: '#FFFFFF',
        borderRadius: '5px',
        padding: '2px',
        color: '#595959'
      },
      colspan: 2,
      id: constants$1.CHART.CONTAINER_ID
    })];
    return [{
      content,
      colspan: 2,
      style: {
        'text-align': ctx.rtl ? 'right' : 'left',
        'max-width': sizeValue,
        width: '100%'
      }
    }, {}];
  }

  const objectProp = {
    createParentProp: (properties, state) => {
      var _properties$qHyperCub, _properties$qHyperCub2, _properties$qHyperCub3;
      const qDimensions = properties === null || properties === void 0 || (_properties$qHyperCub = properties.qHyperCubeDef) === null || _properties$qHyperCub === void 0 ? void 0 : _properties$qHyperCub.qDimensions;
      const qMeasures = properties === null || properties === void 0 || (_properties$qHyperCub2 = properties.qHyperCubeDef) === null || _properties$qHyperCub2 === void 0 ? void 0 : _properties$qHyperCub2.qMeasures;
      const qInterColumnSortOrder = properties === null || properties === void 0 || (_properties$qHyperCub3 = properties.qHyperCubeDef) === null || _properties$qHyperCub3 === void 0 ? void 0 : _properties$qHyperCub3.qInterColumnSortOrder;
      const qStateName = state;
      return {
        qInfo: {
          qType: constants$1.CHART.CHART_PARENT_TYPE,
          qId: constants$1.CHART.CHART_OBJECT_ID
        },
        qHyperCubeDef: {
          qDimensions,
          qMeasures,
          qInterColumnSortOrder,
          qInitialDataFetch: [{
            qWidth: 0,
            qHeight: 0
          }]
        },
        qStateName
      };
    },
    createChildProp: properties => {
      var _properties$tooltip;
      const visualizationId = (_properties$tooltip = properties.tooltip) === null || _properties$tooltip === void 0 || (_properties$tooltip = _properties$tooltip.chart) === null || _properties$tooltip === void 0 || (_properties$tooltip = _properties$tooltip.object) === null || _properties$tooltip === void 0 ? void 0 : _properties$tooltip.refId;
      return {
        qInfo: {
          qType: constants$1.CHART.CHART_CHILD_TYPE
        },
        qExtendsId: visualizationId
      };
    }
  };

  async function object$2({
    app,
    properties,
    customTooltipModel
  }) {
    var _cttModel$miniChartTo;
    const cttModel = customTooltipModel;
    if ((_cttModel$miniChartTo = cttModel.miniChartToken.sessionObj) !== null && _cttModel$miniChartTo !== void 0 && _cttModel$miniChartTo.id) {
      await app.destroySessionObject(cttModel.miniChartToken.sessionObj.id);
    }
    const stateName = constants$1.CHART.STATE;
    const parentProp = objectProp.createParentProp(properties, stateName);
    const obj = await app.createSessionObject(parentProp);
    const tooltipChartProp = objectProp.createChildProp(properties);
    if (obj.id !== constants$1.CHART.CHART_OBJECT_ID) {
      app.destroySessionObject(obj.id);
      return undefined;
    }
    cttModel.miniChartToken.sessionObj = obj;
    const model = await obj.createChild(tooltipChartProp);
    if (!cttModel.miniChartToken.sessionObj || cttModel.miniChartToken.sessionObj.id !== obj.id) {
      app.destroySessionObject(obj.id);
      return undefined;
    }
    cttModel.miniChartToken.model = model;
    return model;
  }

  async function destroySessionAlternateState({
    app,
    customTooltipModel
  }) {
    const cttModel = customTooltipModel;
    const stateName = constants$1.CHART.STATE;
    cttModel.miniChartToken.alternateState = undefined;
    await app.removeSessionAlternateState(stateName);
  }
  async function createSessionAlternateState({
    app,
    properties,
    customTooltipModel
  }) {
    const cttModel = customTooltipModel;
    const stateName = constants$1.CHART.STATE;
    const state = properties.qStateName;
    if (!cttModel.miniChartToken.alternateState) {
      cttModel.miniChartToken.alternateState = stateName;
      await app.addSessionAlternateState(stateName, state);
      cttModel.miniChartToken.alternateState = stateName;
    }
  }

  const chart = {
    createContainer: ({
      ctx,
      layout
    }) => {
      var _layout$qHyperCube;
      if (((_layout$qHyperCube = layout.qHyperCube) === null || _layout$qHyperCube === void 0 || (_layout$qHyperCube = _layout$qHyperCube.qDimensionInfo) === null || _layout$qHyperCube === void 0 ? void 0 : _layout$qHyperCube.length) <= 0) {
        return undefined;
      }
      return container$1(ctx, layout);
    },
    show: async ({
      app,
      properties,
      selectedNodes,
      dimIndex,
      customTooltipModel,
      rtl
    }) => {
      var _properties$tooltip;
      // initialize and display the mini chart on the already created container
      const cttModel = customTooltipModel;
      const chartRefId = properties === null || properties === void 0 || (_properties$tooltip = properties.tooltip) === null || _properties$tooltip === void 0 || (_properties$tooltip = _properties$tooltip.chart) === null || _properties$tooltip === void 0 || (_properties$tooltip = _properties$tooltip.object) === null || _properties$tooltip === void 0 ? void 0 : _properties$tooltip.refId;
      if (!(cttModel !== null && cttModel !== void 0 && cttModel.embed) || !app.removeSessionAlternateState || !app.addSessionAlternateState || !chartRefId || properties.qHyperCubeDef.qDimensions.length <= 0) {
        return;
      }
      // destroy previous altStates and SessionObjects
      await chart.hide({
        app,
        customTooltipModel
      });
      try {
        await createSessionAlternateState({
          app,
          properties,
          customTooltipModel
        });
        const sessionObjectModel = await object$2({
          app,
          properties,
          customTooltipModel
        });
        // cttModel.miniChartToken may be destroyed at any time by another tooltip that tries to be displayed
        if (cttModel.miniChartToken.alternateState && cttModel.miniChartToken.sessionObj && sessionObjectModel) {
          var _selectedNodes$0$data, _selectedNodes$0$data2, _cttModel$miniChartTo, _cttModel$miniChartTo2;
          const elementNumbers = selectedNodes.length > 0 && ((_selectedNodes$0$data = selectedNodes[0].data) === null || _selectedNodes$0$data === void 0 ? void 0 : _selectedNodes$0$data.value) !== undefined ? [(_selectedNodes$0$data2 = selectedNodes[0].data) === null || _selectedNodes$0$data2 === void 0 ? void 0 : _selectedNodes$0$data2.value] : [];
          const targetIndex = dimIndex !== undefined ? dimIndex : properties.qHyperCubeDef.qDimensions.length - 1;
          if (properties.qHyperCubeDef.qDimensions.length === 2 && dimIndex === undefined && selectedNodes.length > 0) {
            var _selectedNodes$0$data3, _outerNode$source;
            // handle multiple dimensions
            const outerNode = (_selectedNodes$0$data3 = selectedNodes[0].data.selectionOuterDimension) !== null && _selectedNodes$0$data3 !== void 0 ? _selectedNodes$0$data3 : selectedNodes[0].data.selectionDimension;
            if (outerNode !== null && outerNode !== void 0 && (_outerNode$source = outerNode.source) !== null && _outerNode$source !== void 0 && _outerNode$source.field) {
              var _outerNode$source2;
              const outerSourceParts = outerNode === null || outerNode === void 0 || (_outerNode$source2 = outerNode.source) === null || _outerNode$source2 === void 0 ? void 0 : _outerNode$source2.field.split('/');
              const outerTargetIndex = outerSourceParts[outerSourceParts.length - 1];
              const outerDimensionElementNumbers = outerNode.value !== undefined ? [outerNode.value] : [];
              if (outerDimensionElementNumbers.length > 0 && outerTargetIndex !== undefined) {
                cttModel.miniChartToken.sessionObj.selectHyperCubeValues('/qHyperCubeDef', Number(outerTargetIndex), outerDimensionElementNumbers, false);
              }
            }
          }
          if (elementNumbers.length > 0) {
            cttModel.miniChartToken.sessionObj.selectHyperCubeValues('/qHyperCubeDef', targetIndex, elementNumbers, false);
          }
          // add the visualization to the container
          const element = document.getElementById(constants$1.CHART.CONTAINER_ID);
          const direction = rtl ? 'rtl' : 'ltr';
          const options = {
            direction,
            isReadonly: true,
            isPopover: true,
            navigation: false,
            selections: false
          };
          cttModel.miniChartToken.vis = await customTooltipModel.embed.render({
            element,
            model: cttModel.miniChartToken.model,
            // used for sense-client rendering (qv-object)
            options,
            // used for sense-client rendering (qv-object)
            id: (_cttModel$miniChartTo = cttModel.miniChartToken.model) === null || _cttModel$miniChartTo === void 0 ? void 0 : _cttModel$miniChartTo.id,
            // used for nebula rendering
            type: (_cttModel$miniChartTo2 = cttModel.miniChartToken.model) === null || _cttModel$miniChartTo2 === void 0 ? void 0 : _cttModel$miniChartTo2.genericType // used for nebula rendering
          });
        }
      } catch (err) {
        // catching error when the ID of mini-chart container in the DOM does not exist
        await chart.hide({
          app,
          customTooltipModel
        });
      }
    },
    hide: async ({
      app,
      customTooltipModel
    }) => {
      const cttModel = customTooltipModel;
      if (!(cttModel !== null && cttModel !== void 0 && cttModel.embed)) {
        return;
      }
      chart.destroyVisualization({
        customTooltipModel
      });
      await app.destroySessionObject(constants$1.CHART.CHART_OBJECT_ID);
      cttModel.miniChartToken.sessionObj = undefined;
      await destroySessionAlternateState({
        app,
        customTooltipModel
      });
    },
    destroyVisualization: ({
      customTooltipModel
    }) => {
      var _cttModel$miniChartTo3;
      const cttModel = customTooltipModel;
      if (typeof ((_cttModel$miniChartTo3 = cttModel.miniChartToken) === null || _cttModel$miniChartTo3 === void 0 || (_cttModel$miniChartTo3 = _cttModel$miniChartTo3.vis) === null || _cttModel$miniChartTo3 === void 0 ? void 0 : _cttModel$miniChartTo3.destroy) === 'function') {
        // closing previously displayed visualization
        cttModel.miniChartToken.vis.destroy();
        cttModel.miniChartToken.vis = undefined;
      }
    }
  };

  // used by the deprecated custom tooltip
  function toPoint$1(event, chart) {
    let x = 0;
    let y = 0;
    if (event.center) {
      x += event.center.x;
      y += event.center.y;
    } else {
      x += event.clientX;
      y += event.clientY;
    }
    const chartBounds = chart.element.getBoundingClientRect();
    const cx = x - chartBounds.left;
    const cy = y - chartBounds.top;
    return {
      cx,
      cy
    };
  }
  function quarantineAttributeExpressions(expressions, data) {
    const properties = data;
    let propExcluded = properties.qLayoutExclude;
    if (!propExcluded) {
      properties.qLayoutExclude = {
        quarantine: {}
      };
      propExcluded = properties.qLayoutExclude;
    }
    if (!propExcluded.quarantine) {
      propExcluded.quarantine = {};
    }
    propExcluded.quarantine[constants$1.CUSTOM.QUARANTINE] = [];
    expressions.forEach(expr => {
      propExcluded.quarantine[constants$1.CUSTOM.QUARANTINE].push(expr);
    });
    properties.qLayoutExclude = propExcluded;
  }
  function getDimensions(data) {
    const dimensions = data.qHyperCubeDef ? data.qHyperCubeDef.qDimensions : data.qHyperCube.qDimensionInfo;
    if (dimensions && dimensions.length > 0) {
      return dimensions;
    }
    return undefined;
  }
  function getTooltipAttrList() {
    const {
      EXPRESSION,
      TITLE,
      DESCRIPTION,
      IMAGES
    } = constants$1.CUSTOM;
    const idList = {};
    idList[EXPRESSION] = true;
    idList[TITLE] = true;
    idList[DESCRIPTION] = true;
    idList[IMAGES] = true;
    return idList;
  }
  function extractTooltipAttrs(attrs) {
    const idList = getTooltipAttrList();
    return attrs.filter(obj => idList[obj.id]);
  }
  const customTooltipUtils = {
    getNodes(event, chart) {
      const pointer = toPoint$1(event, chart);
      const nodes = chart.shapesAt({
        x: pointer.cx,
        y: pointer.cy
      });
      return nodes;
    },
    // getDataNodes retrieves the nodes that will be displayed and need to load an image
    // get the first data node when hovering over to label e.t.c
    // filter nodes that still needs to load the image when hovering over to data nodes
    // exclude nodes that are not linked to data nodes
    getDataNodes(chart, nodes) {
      let result = [];
      let allDataNodes;
      // data node key per each chart type.
      const keysPerType = {
        container: {
          bar: true,
          'bullet-axis': true
        },
        circle: {
          'point-component': true
        }
      };
      nodes.forEach(node => {
        var _node$data$selectionD, _node$data, _node$data2, _node$data3;
        // initialDataSrc is where the selection information about the hovering nodes is stored
        const initialDataSrc = (_node$data$selectionD = (_node$data = node.data) === null || _node$data === void 0 ? void 0 : _node$data.selectionDimension) !== null && _node$data$selectionD !== void 0 ? _node$data$selectionD : node.data;

        // search for data nodes only when needed (e.g: hovering over to axis nodes)
        if (initialDataSrc && !((_node$data2 = node.data) !== null && _node$data2 !== void 0 && _node$data2.customTooltipAttrExps) && !keysPerType[node.type]) {
          // populate allDataNodes variable here, chart.findShapes can affect the performance
          if (!allDataNodes) {
            allDataNodes = [];
            Object.keys(keysPerType).forEach(type => {
              allDataNodes = allDataNodes.concat(chart.findShapes(type).filter(n => n.data && n.data.customTooltipAttrExps && !n.data.customTooltipImages && keysPerType[type][n.key]));
            });
          }
          const dataNodes = allDataNodes.filter(n => {
            var _ref, _n$data$stack;
            const currentDataSrc = (_ref = (_n$data$stack = n.data.stack) !== null && _n$data$stack !== void 0 ? _n$data$stack : n.data.selectionOuterDimension) !== null && _ref !== void 0 ? _ref : n.data.selectionDimension;
            return currentDataSrc && currentDataSrc.value === initialDataSrc.value && currentDataSrc.label === initialDataSrc.label;
          });
          if (dataNodes.length > 0) {
            // if we are hovering over to a label, pick only the first node
            result = result.concat(dataNodes[0]);
          }
        } else if ((_node$data3 = node.data) !== null && _node$data3 !== void 0 && _node$data3.customTooltipAttrExps && !node.data.customTooltipImages) {
          const modifiedNodes = node;
          modifiedNodes.data.customTooltipImages = [];
          result.push(modifiedNodes);
        }
      });
      return result;
    },
    displayTooltip(e, tooltip, {
      nodes,
      opts = {},
      customTooltipModel,
      extractedNodes = [],
      hide
    }) {
      if (customTooltipModel && !hide) {
        const {
          layout,
          chart
        } = customTooltipModel;
        const {
          attrExps
        } = customTooltipUtils.getAttrExprData(layout);
        if (!extractedNodes.length && !nodes.length) {
          // if there are no nodes given, do not try to add images or other data from promises
          tooltip.emit('show', e, nodes.length ? {
            nodes
          } : undefined);
        } else {
          CustomTooltipPromises.handlePromises({
            customTooltipModel,
            nodes: customTooltipUtils.getDataNodes(chart, extractedNodes.length > 0 ? extractedNodes : nodes),
            attrExps,
            opts
          }).then(() => {
            tooltip.emit('show', e, nodes.length ? {
              nodes
            } : undefined);
          });
        }
      } else {
        var _customTooltipModel$m;
        // destroy mini chart's sessionAlternateState, necessary for the onHide functionality
        if (customTooltipModel !== null && customTooltipModel !== void 0 && (_customTooltipModel$m = customTooltipModel.miniChartToken) !== null && _customTooltipModel$m !== void 0 && _customTooltipModel$m.alternateState) {
          chart.hide({
            app: opts.app,
            customTooltipModel
          });
        }
        tooltip.emit('hide');
      }
    },
    checkIfPromisesExist({
      customTooltipModel
    }) {
      return CustomTooltipPromises.checkIfPromisesExist({
        customTooltipModel
      });
    },
    getAttrExps(data, dimension) {
      var _data$qHyperCubeDef;
      const result = dimension;
      const pathToAttrExpr = (_data$qHyperCubeDef = data.qHyperCubeDef) !== null && _data$qHyperCubeDef !== void 0 && _data$qHyperCubeDef.qDimensions ? 'qAttributeExpressions' : 'qAttrExprInfo';
      if (!result[pathToAttrExpr]) result[pathToAttrExpr] = [];
      return result[pathToAttrExpr];
    },
    getAttrExprData(layout) {
      var _layout$qHyperCube;
      let attrExps = [];
      let fieldPath = '';
      const dimensions = ((_layout$qHyperCube = layout.qHyperCube) === null || _layout$qHyperCube === void 0 ? void 0 : _layout$qHyperCube.qDimensionInfo) || [];
      if (dimensions.length > 0) {
        var _layout$qHyperCube2;
        const lastIndex = dimensions.length - 1;
        attrExps = ((_layout$qHyperCube2 = layout.qHyperCube) === null || _layout$qHyperCube2 === void 0 || (_layout$qHyperCube2 = _layout$qHyperCube2.qDimensionInfo) === null || _layout$qHyperCube2 === void 0 || (_layout$qHyperCube2 = _layout$qHyperCube2[lastIndex]) === null || _layout$qHyperCube2 === void 0 ? void 0 : _layout$qHyperCube2.qAttrExprInfo) || [];
        fieldPath = `qDimensionInfo/${lastIndex}/qAttrExprInfo`;
      }
      return {
        attrExps,
        fieldPath
      };
    },
    quarantineCustomTooltipAttrs(data, dimension = {}) {
      var _data$qLayoutExclude;
      const alreadyStored = (_data$qLayoutExclude = data.qLayoutExclude) === null || _data$qLayoutExclude === void 0 || (_data$qLayoutExclude = _data$qLayoutExclude.quarantine) === null || _data$qLayoutExclude === void 0 ? void 0 : _data$qLayoutExclude[constants$1.CUSTOM.QUARANTINE];
      if (!alreadyStored) {
        const attrs = dimension.qAttributeExpressions || [];
        const tooltipAttrs = extractTooltipAttrs(attrs);
        quarantineAttributeExpressions(tooltipAttrs, data);
      }
    },
    unquarantineCustomTooltipAttrs(data) {
      var _data$qLayoutExclude2;
      const properties = data;
      const storedAttrs = (_data$qLayoutExclude2 = data.qLayoutExclude) === null || _data$qLayoutExclude2 === void 0 || (_data$qLayoutExclude2 = _data$qLayoutExclude2.quarantine) === null || _data$qLayoutExclude2 === void 0 ? void 0 : _data$qLayoutExclude2[constants$1.CUSTOM.QUARANTINE];
      if (storedAttrs) {
        delete properties.qLayoutExclude.quarantine[constants$1.CUSTOM.QUARANTINE];
      }
    },
    setAttrsFromQuarantine(data, index) {
      const dimensions = getDimensions(data);
      if (!dimensions) return;
      const targetIndex = index !== undefined ? index : dimensions.length - 1;
      if (!dimensions[targetIndex]) return;
      const attrs = this.getAttrExps(data, dimensions[targetIndex]);
      const tooltipAttrs = extractTooltipAttrs(attrs);
      const noTooltipExpressions = tooltipAttrs.length === 0;
      if (noTooltipExpressions) {
        var _data$qLayoutExclude3;
        const quarantineAttrs = ((_data$qLayoutExclude3 = data.qLayoutExclude) === null || _data$qLayoutExclude3 === void 0 || (_data$qLayoutExclude3 = _data$qLayoutExclude3.quarantine) === null || _data$qLayoutExclude3 === void 0 ? void 0 : _data$qLayoutExclude3.customTooltip) || [];
        const result = [...attrs, ...quarantineAttrs];
        const newData = data;
        if (newData.qHyperCubeDef) {
          newData.qHyperCubeDef.qDimensions[targetIndex].qAttributeExpressions = result;
        } else {
          newData.qHyperCube.qDimensionInfo[targetIndex].qAttrExprInfo = result;
        }
      }
    },
    moveCustomTooltipAttrs(data, oldDimension = {}, index) {
      let attributesToMove = [];
      const newDimensionList = getDimensions(data) || [];
      const oldDimensionList = [...newDimensionList, ...[oldDimension]];
      oldDimensionList.forEach(dim => {
        const attrs = dim.qAttributeExpressions || [];
        const tooltipAttrs = extractTooltipAttrs(attrs);
        if (tooltipAttrs.length > 0) {
          attributesToMove = tooltipAttrs;
        }
      });
      // Remove tooltip attributes from dimensions
      const idList = getTooltipAttrList();
      const cleanedAttributes = newDimensionList.map(dim => {
        const result = dim;
        const attrs = dim.qAttributeExpressions || [];
        result.qAttributeExpressions = attrs.filter(obj => !idList[obj.id]);
        return result;
      });
      const targetIndex = index !== undefined ? index : cleanedAttributes.length - 1;
      // move tooltip attributes to target dim
      if (cleanedAttributes.length > 0) {
        cleanedAttributes[targetIndex].qAttributeExpressions = cleanedAttributes[targetIndex].qAttributeExpressions.concat(attributesToMove);
      }
      const newData = data;
      if (data.qHyperCubeDef) {
        newData.qHyperCubeDef.qDimensions = cleanedAttributes;
      } else {
        newData.qHyperCube.qDimensionInfo = cleanedAttributes;
      }
    },
    addCallbackCustomTooltip(data) {
      if (data.qHyperCubeDef.qDimensions.length > 1) {
        this.moveCustomTooltipAttrs(data);
      } else {
        this.setAttrsFromQuarantine(data);
        this.unquarantineCustomTooltipAttrs(data);
      }
    },
    moveCallbackCustomTooltip(data, dimension) {
      if (data.qHyperCubeDef.qDimensions.length === 1) {
        this.setAttrsFromQuarantine(data);
        this.unquarantineCustomTooltipAttrs(data);
      }
      if (data.qHyperCubeDef.qDimensions.length > 1) {
        this.moveCustomTooltipAttrs(data, dimension);
      }
    },
    removeCallbackCustomTooltip(data, dimension) {
      if (data.qHyperCubeDef.qDimensions.length > 0) {
        this.moveCustomTooltipAttrs(data, dimension);
      } else {
        this.quarantineCustomTooltipAttrs(data, dimension);
      }
    },
    replaceCallbackCustomTooltip(data, oldDimension) {
      if (data.qHyperCubeDef.qDimensions.length > 1) {
        this.moveCustomTooltipAttrs(data, oldDimension);
      } else {
        this.quarantineCustomTooltipAttrs(data, oldDimension);
        this.setAttrsFromQuarantine(data);
        this.unquarantineCustomTooltipAttrs(data);
      }
    },
    shouldIgnoreDefaultRows(layout) {
      var _layout$tooltip;
      return ((_layout$tooltip = layout.tooltip) === null || _layout$tooltip === void 0 ? void 0 : _layout$tooltip.hideBasic) || 0;
    },
    DEBOUNCE_THRESHOLD: 50,
    getFooterRow(value, rtl) {
      const contentDir = rtlUtils.detectTextDirection(value);
      return [{
        content: value,
        style: {
          'font-style': 'italic',
          'font-size': '12px',
          'line-height': '16px',
          color: 'rgba(255, 255, 255, 0.6)',
          'text-align': rtl ? 'right' : 'left',
          direction: contentDir
        },
        colspan: 2
      }, {}];
    },
    getImageRow(data, ctx) {
      const contentDir = rtlUtils.detectTextDirection(data.src);
      const imageElement = [];
      const containerProps = {
        style: {
          display: 'block',
          'margin-left': 'auto',
          'margin-right': 'auto',
          overflow: 'hidden',
          width: data.width,
          height: data.height
        }
      };

      // The original image is set as an image inside a container instead of a background image
      // This is because we want it to scale down when neccessary but without the ability to scale up.
      // For the small, medium and large images we want them to scale up and down as much as needed for them to fit the container
      if (data.size === 'original' || data.imageError) {
        imageElement.push(ctx.h('span', {
          style: {
            display: 'inline-block',
            height: '100%',
            'vertical-align': 'middle'
          }
        }));
        const src = data.imageError ? `${data.src}?${Math.random()}` : data.src;
        imageElement.push(ctx.h('img', {
          style: {
            'max-width': data.width,
            'max-height': data.height,
            'vertical-align': 'middle'
          },
          src,
          referrerpolicy: 'no-referrer'
        }));
        containerProps.style['text-align'] = 'center';
        containerProps.style['white-space'] = 'nowrap';
      } else {
        containerProps.style['background-size'] = 'contain';
        containerProps.style['background-repeat'] = 'no-repeat';
        containerProps.style['background-position'] = 'center';
        containerProps.style['background-image'] = `url('${data.src}')`;
      }
      const imageContainer = [ctx.h('div', containerProps, imageElement), ''];
      return [{
        content: imageContainer,
        style: {
          'text-align': ctx.rtl ? 'right' : 'left',
          direction: contentDir,
          'max-width': data.width
        },
        colspan: 2
      }, {}];
    }
  };

  function customTooltipModel({
    layout,
    app,
    picasso,
    model,
    chart,
    translator,
    localeInfo,
    embed
  }) {
    const useCustomTooltip = layout.tooltip && !layout.tooltip.auto;
    return {
      layout,
      app,
      picasso,
      model,
      chart,
      translator,
      localeInfo,
      useCustomTooltip,
      utils: customTooltipUtils,
      miniChartToken: {},
      embed
    };
  }

  function getLabel$2(attribute, attrValue) {
    let label;
    switch (attribute.id) {
      case constants$1.CUSTOM.EXPRESSION:
        if (attrValue.qNum === 'NaN' || attribute.isCustomFormatted) {
          label = attrValue.qText === undefined ? 'NaN' : attrValue.qText;
        } else {
          label = attrValue.qNum;
        }
        break;
      case constants$1.CUSTOM.TITLE:
      case constants$1.CUSTOM.DESCRIPTION:
      case constants$1.CUSTOM.IMAGES:
        label = attrValue.qText === undefined ? attribute.qFallbackTitle : attrValue.qText;
        break;
      default:
        label = 'NaN';
    }
    return label;
  }
  function retrieveAttributeExpressions(d, layout, target, lastIndex) {
    var _layout$qHyperCube;
    const attrExprInfo = ((_layout$qHyperCube = layout.qHyperCube) === null || _layout$qHyperCube === void 0 || (_layout$qHyperCube = _layout$qHyperCube[target]) === null || _layout$qHyperCube === void 0 || (_layout$qHyperCube = _layout$qHyperCube[lastIndex]) === null || _layout$qHyperCube === void 0 ? void 0 : _layout$qHyperCube.qAttrExprInfo) || [];
    // when the bar-chart is stacked on dimnesions, we retrieve qSubNodes of the last measure from the last dimension's reference
    const nodes = [];
    const attrExpsValues = d.qSubNodes && d.qSubNodes[lastIndex] ? d.qSubNodes[lastIndex].qAttrExps : d.qAttrExps;
    if (!attrExpsValues) {
      return nodes;
    }
    attrExprInfo.forEach((attribute, attributeIndex) => {
      const attrValue = attrExpsValues.qValues && attrExpsValues.qValues[attributeIndex] ? attrExpsValues.qValues[attributeIndex] : undefined;
      const label = attrValue === undefined ? 'NaN' : getLabel$2(attribute, attrValue);
      nodes.push({
        source: {
          key: 'qHyperCube',
          field: `${target}/${lastIndex}/qAttrExprInfo/${attributeIndex}`
        },
        label,
        value: 'value'
      });
    });
    return nodes;
  }
  const customTooltipNodes = {
    getNode(layout, {
      dimensionCount
    }) {
      if (!dimensionCount || dimensionCount < 1) {
        return undefined;
      }
      const lastIndex = dimensionCount - 1;
      const target = 'qDimensionInfo';
      const field = `${target}/${lastIndex}`;
      return {
        field,
        value: d => {
          return retrieveAttributeExpressions(d, layout, target, lastIndex);
        }
      };
    }
  };

  function extractAttrExpr(layout, measures, dataset, attrExpsValuesObj) {
    const infoList = {
      [constants$1.CUSTOM.TITLE]: true,
      [constants$1.CUSTOM.DESCRIPTION]: true
    };
    const {
      attrExps,
      fieldPath
    } = customTooltipUtils.getAttrExprData(layout);
    if (measures.length === 0 || attrExps.length === 0 || fieldPath === '') {
      return attrExpsValuesObj;
    }
    attrExps.forEach((attr, index) => {
      const attrExpsValue = measures[index];
      if (attr.id === constants$1.CUSTOM.EXPRESSION && attrExpsValue) {
        const label = attr.qFallbackTitle;
        const formatedValue = attrExpsValue.value !== 'NaN' && !attr.isCustomFormatted ? dataset('qHyperCube').field(`${fieldPath}/${index}`).formatter()(attrExpsValue.value) : attrExpsValue.value;
        attrExpsValuesObj.customTooltipAttrExpsArr.push({
          label,
          value: formatedValue
        });
      } else if (infoList[attr.id] && attrExpsValue) {
        const attributeValue = attrExpsValue.value !== '-' && attrExpsValue.value !== 'NaN' ? attrExpsValue.value : attrExpsValue.label;
        if (attributeValue && attributeValue !== 'undefined') {
          attrExpsValuesObj.customTooltipInfoAttrExpsArr.push({
            ...(attr.id === constants$1.CUSTOM.TITLE && {
              title: attributeValue
            }),
            value: attributeValue,
            id: attr.id
          });
        }
      }
    });
    return attrExpsValuesObj;
  }
  const customTooltipAttr = {
    getCustomAttrExps(ds, node, layout) {
      var _node$data;
      const attrExpsValuesObj = {
        customTooltipAttrExpsArr: [],
        customTooltipInfoAttrExpsArr: []
      };
      const props = ((_node$data = node.data) === null || _node$data === void 0 || (_node$data = _node$data.customTooltipAttrExps) === null || _node$data === void 0 ? void 0 : _node$data.value) || [];
      if (Number.isNaN(props)) {
        return attrExpsValuesObj;
      }
      const measures = props.map(prop => {
        const measure = tooltipHelper.getMeasure(ds, prop);
        return measure;
      });
      return extractAttrExpr(layout, measures, ds, attrExpsValuesObj);
    }
  };

  function retriveAttrExpsFromNodes(nodes, layout, dataset) {
    const customAttrExps = [];
    nodes.forEach(node => {
      customAttrExps.push(customTooltipAttr.getCustomAttrExps(dataset, node, layout));
    });
    return customAttrExps;
  }
  function getAttributeExpression({
    nodes,
    layout,
    dataset
  }) {
    const customAttrExps = retriveAttrExpsFromNodes(nodes, layout, dataset);
    const result = customAttrExps.reduce((attrExprResult, attribute) => {
      return {
        customTooltipAttrExpsArr: attrExprResult.customTooltipAttrExpsArr.concat(attribute.customTooltipAttrExpsArr),
        customTooltipInfoAttrExpsArr: attrExprResult.customTooltipInfoAttrExpsArr.concat(attribute.customTooltipInfoAttrExpsArr)
      };
    }, {
      customTooltipAttrExpsArr: [],
      customTooltipInfoAttrExpsArr: []
    });
    return result;
  }

  const {
    CUSTOM
  } = constants$1;
  function createCustomTooltipService({
    flags,
    layout,
    app,
    model,
    picasso,
    chart: chart$1,
    translator,
    localeInfo,
    embed,
    options
  }) {
    const state = {
      properties: undefined
    };
    const customTooltipModel$1 = customTooltipModel({
      layout,
      app,
      model,
      picasso,
      chart: chart$1,
      translator,
      localeInfo,
      embed
    });
    const rtl = options.direction === 'rtl';
    const isEnabled = () => {
      var _state$properties;
      const hasDimensionCondition = !!((_state$properties = state.properties) !== null && _state$properties !== void 0 && (_state$properties = _state$properties.qHyperCubeDef) !== null && _state$properties !== void 0 && _state$properties.qDimensions.some(d => {
        var _d$qCalcCondition;
        return (_d$qCalcCondition = d.qCalcCondition) === null || _d$qCalcCondition === void 0 || (_d$qCalcCondition = _d$qCalcCondition.qCond) === null || _d$qCalcCondition === void 0 ? void 0 : _d$qCalcCondition.qv;
      }));
      return !!(layout.tooltip && !layout.tooltip.auto) && !hasDimensionCondition;
    };
    const hideBasic = () => isEnabled() && bt(layout, 'tooltip.hideBasic', false);
    const isChartEnabled = () => {
      var _layout$tooltip;
      return !!(isEnabled() && (_layout$tooltip = layout.tooltip) !== null && _layout$tooltip !== void 0 && (_layout$tooltip = _layout$tooltip.chart) !== null && _layout$tooltip !== void 0 && (_layout$tooltip = _layout$tooltip.object) !== null && _layout$tooltip !== void 0 && _layout$tooltip.refId && embed && typeof (model === null || model === void 0 ? void 0 : model.getEffectiveProperties) === 'function');
    };
    return {
      setProperties: properties => {
        state.properties = properties;
      },
      isEnabled: () => isEnabled(),
      hideBasic: () => hideBasic(),
      getAttributes: ({
        dataset,
        nodes
      }) => {
        var _attributes$customToo, _attributes$customToo2;
        const attributes = getAttributeExpression({
          dataset,
          nodes,
          layout
        });
        return {
          title: (_attributes$customToo = attributes.customTooltipInfoAttrExpsArr.find(a => a.id === CUSTOM.TITLE)) === null || _attributes$customToo === void 0 ? void 0 : _attributes$customToo.title,
          description: (_attributes$customToo2 = attributes.customTooltipInfoAttrExpsArr.find(a => a.id === CUSTOM.DESCRIPTION)) === null || _attributes$customToo2 === void 0 ? void 0 : _attributes$customToo2.value,
          measures: attributes.customTooltipAttrExpsArr
        };
      },
      hasImages: () => customTooltipUtils.checkIfPromisesExist({
        customTooltipModel: customTooltipModel$1
      }),
      createImageRow: ({
        value,
        h
      }) => customTooltipUtils.getImageRow(value, {
        h,
        rtl
      }),
      addImages: ({
        nodes
      }) => {
        const modified = customTooltipUtils.getDataNodes(chart$1, nodes);
        const {
          attrExps
        } = customTooltipUtils.getAttrExprData(layout);
        return CustomTooltipPromises.handlePromises({
          customTooltipModel: customTooltipModel$1,
          nodes: modified,
          attrExps,
          opts: {
            flags,
            app
          }
        });
      },
      chart: {
        isEnabled: () => isChartEnabled(),
        hasLimitation: () => {
          var _app$isInModalSelecti;
          return !!(app !== null && app !== void 0 && (_app$isInModalSelecti = app.isInModalSelection) !== null && _app$isInModalSelecti !== void 0 && _app$isInModalSelecti.call(app));
        },
        createContainer: ({
          h
        }) => chart.createContainer({
          layout,
          ctx: {
            h,
            rtl
          }
        }),
        createLimitationRow: () => customTooltipUtils.getFooterRow(translator.get('properties.tooltip.notselectedmessage'), rtl),
        show: ({
          nodes,
          properties
        }) => chart.show({
          app,
          properties,
          selectedNodes: nodes,
          customTooltipModel: customTooltipModel$1,
          rtl
        }),
        hasAlternateState: () => {
          var _customTooltipModel$m;
          return !!((_customTooltipModel$m = customTooltipModel$1.miniChartToken) !== null && _customTooltipModel$m !== void 0 && _customTooltipModel$m.alternateState);
        },
        hide: () => chart.hide({
          app,
          customTooltipModel: customTooltipModel$1
        }),
        destroy: () => chart.destroyVisualization({
          customTooltipModel: customTooltipModel$1
        })
      }
    };
  }

  /* eslint-disable no-param-reassign */
  const isValidPredicate$1 = i => {
    var _i$qError;
    return ((_i$qError = i.qError) === null || _i$qError === void 0 ? void 0 : _i$qError.qErrorCode) !== ERROR_CODE;
  };
  const getValidDimensions$1 = layout => layout.qHyperCube.qDimensionInfo.filter(d => isValidPredicate$1(d));
  const setInitialSort = data => {
    const {
      qDimensions,
      qMeasures
    } = data.qHyperCubeDef;
    const {
      qInterColumnSortOrder
    } = data.qHyperCubeDef;
    if (qDimensions.length === 1 && qMeasures.length === 1) {
      if (qInterColumnSortOrder[0] !== 0) {
        util$2.moveArrayElement(qInterColumnSortOrder, 1, 0);
      }
    } else if (qDimensions.length > 1 && qMeasures.length === 1) {
      const index = qInterColumnSortOrder.indexOf(0);
      if (index !== 0) {
        util$2.moveArrayElement(qInterColumnSortOrder, index, 0);
      }
    }
  };
  const setColorVars$1 = data => {
    const dims = data.qHyperCubeDef.qDimensions;
    const measures = data.qHyperCubeDef.qMeasures;
    const {
      color: {
        mode
      }
    } = data;
    if (dims.length > 1) {
      qt(data, 'color.persistent', true);
    }
    if (mode === 'byMeasure' && dims.length > 1) {
      qt(data, 'color.mode', 'byDimension');
    } else if (mode === 'byDimension' && dims.length <= 1 && measures.length <= 1) {
      qt(data, 'color.mode', 'primary');
    } else if (mode === 'byExpression' && measures.length === 0) {
      qt(data, 'color.mode', 'primary');
    }
  };
  function disableForecastOnDuplicate(measure, data) {
    var _data$qHyperCubeDef$q, _measure$qDef$forecas;
    const forecastMeasures = (data.qHyperCubeDef.qMeasures || []).concat(((_data$qHyperCubeDef$q = data.qHyperCubeDef.qLayoutExclude) === null || _data$qHyperCubeDef$q === void 0 || (_data$qHyperCubeDef$q = _data$qHyperCubeDef$q.qHyperCubeDef) === null || _data$qHyperCubeDef$q === void 0 ? void 0 : _data$qHyperCubeDef$q.qMeasures) || []).filter(m => {
      var _m$qDef$forecast;
      return (_m$qDef$forecast = m.qDef.forecast) === null || _m$qDef$forecast === void 0 ? void 0 : _m$qDef$forecast.enabled;
    });
    if ((_measure$qDef$forecas = measure.qDef.forecast) !== null && _measure$qDef$forecas !== void 0 && _measure$qDef$forecas.enabled && forecastMeasures.length > 1) {
      measure.qDef.forecast.enabled = false;
    }
  }
  function createDataDefinition({
    translator
  }) {
    return {
      dimensions: {
        min: 1,
        max(measureCount) {
          return measureCount >= 2 ? 1 : 2;
        },
        description(properties, index, config, handler) {
          let translationProperty;
          const dimensionCount = handler ? getValidDimensions$1(handler.layout).length : properties.qHyperCubeDef.qDimensions.length;
          if (dimensionCount > 1) {
            if (index === 0) {
              translationProperty = properties.lineType === 'area' && properties.stackedArea === true ? 'Visualizations.Descriptions.Stack' : 'Visualizations.Descriptions.Group';
            } else {
              translationProperty = properties.lineType === 'area' ? 'Visualizations.Descriptions.Area' : 'Visualizations.Descriptions.Line';
            }
          } else {
            translationProperty = properties.lineType === 'area' ? 'Visualizations.Descriptions.Area' : 'Visualizations.Descriptions.Line';
          }
          return translator.get(translationProperty);
        },
        added(dimension, data) {
          if (data.qHyperCubeDef.qDimensions.length > 1) {
            data.qHyperCubeDef.qMode = 'K';
            data.qHyperCubeDef.qAlwaysFullyExpanded = true;
          }
          setInitialSort(data);
          setColorVars$1(data);
          customTooltipUtils.addCallbackCustomTooltip(data);
        },
        moved(dimension, data, handler) {
          if (getValidDimensions$1(handler.layout).length > 1) {
            data.qHyperCubeDef.qMode = 'K';
            data.qHyperCubeDef.qAlwaysFullyExpanded = true;
          }
          setInitialSort(data);
          setColorVars$1(data);
          customTooltipUtils.moveCallbackCustomTooltip(data, dimension);
        },
        removed(dimension, data) {
          const dimensions = data.qHyperCubeDef.qDimensions;
          setColorVars$1(data);
          if (dimensions.length === 1) {
            data.qHyperCubeDef.qMode = 'S';
          }
          customTooltipUtils.removeCallbackCustomTooltip(data, dimension);
        },
        replaced(dimension, oldDimension, index, data) {
          customTooltipUtils.replaceCallbackCustomTooltip(data, oldDimension);
        }
      },
      measures: {
        min: 1,
        max(dimensionCount) {
          return dimensionCount >= 2 ? 1 : 15;
        },
        description() {
          return translator.get('Visualizations.Descriptions.HeightLine');
        },
        added(measure, data) {
          setInitialSort(data);
          setColorVars$1(data);
          disableForecastOnDuplicate(measure, data);
        },
        moved(measure, data) {
          setInitialSort(data);
          setColorVars$1(data);
        },
        removed(measure, data) {
          const dimensions = data.qHyperCubeDef.qDimensions;
          setColorVars$1(data);
          if (dimensions.length > 1) {
            data.qHyperCubeDef.qMode = 'K';
            data.qHyperCubeDef.qAlwaysFullyExpanded = true;
          } else if (dimensions.length === 1) {
            data.qHyperCubeDef.qMode = 'S';
          }
        }
      }
    };
  }

  /* eslint-disable no-param-reassign */
  const isValidPredicate = i => {
    var _i$qError;
    return ((_i$qError = i.qError) === null || _i$qError === void 0 ? void 0 : _i$qError.qErrorCode) !== ERROR_CODE;
  };
  const getValidDimensions = layout => layout.qHyperCube.qDimensionInfo.filter(d => isValidPredicate(d));
  const getValidMeasures = layout => layout.qHyperCube.qMeasureInfo.filter(d => isValidPredicate(d));
  const isContinuous = layout => isType.continuous(layout, () => timeUtils.isTime(true, layout));
  function createSoftDefinition({
    flags
  }) {
    const res = {
      type: 'items',
      component: 'accordion',
      items: {
        data: {
          uses: 'data',
          items: {
            dimensions: {
              items: {}
            },
            measures: {
              items: {}
            }
          }
        },
        sort: {
          uses: 'sort',
          show(data, layout) {
            return !isType.continuous(layout, () => timeUtils.isTime(true, layout));
          },
          items: {
            dimensions: {
              locked: (index, data, layout) => getValidDimensions(layout).length === 2 && getValidMeasures(layout).length === 1
            },
            measures: {
              locked: (index, data, layout) => getValidDimensions(layout).length === 2 && getValidMeasures(layout).length === 1
            }
          }
        },
        presentation: {
          uses: 'presentation',
          items: {
            valueLabels: {
              type: 'string',
              component: 'radio-list',
              translation: 'properties.dataPoints.labelmode',
              diffs: ['dataPoint.show', 'dataPoint.showLabels'],
              options: [{
                value: 'none',
                translation: 'Common.None'
              }, {
                value: 'auto',
                translation: 'Common.Auto'
              }, {
                value: 'all',
                translation: 'Common.All'
              }],
              setPropertyValue(props, v) {
                props.dataPoint.show = v === true || v === 'auto' || v === 'all';
                props.dataPoint.showLabels = v;
              },
              getValue(props) {
                const {
                  showLabels
                } = (props === null || props === void 0 ? void 0 : props.dataPoint) || {};
                if (showLabels === false) {
                  return 'none';
                }
                if (showLabels === true) {
                  return 'auto';
                }
                return showLabels;
              }
            },
            orientation: {
              ref: 'orientation',
              type: 'string',
              component: 'item-selection-list',
              defaultValue: 'horizontal',
              horizontal: true,
              items: [{
                component: 'icon-item',
                icon: 'direction_up_down',
                labelPlacement: 'bottom',
                translation: 'properties.orientation.vertical',
                value: 'vertical'
              }, {
                component: 'icon-item',
                icon: 'direction_left_right',
                labelPlacement: 'bottom',
                translation: 'Common.Horizontal',
                value: 'horizontal'
              }],
              show(data, layout) {
                return !isContinuous(layout);
              }
            },
            lineType: {
              ref: 'lineType',
              type: 'string',
              component: 'item-selection-list',
              horizontal: true,
              items: [{
                icon: 'line_chart_line',
                component: 'icon-item',
                labelPlacement: 'bottom',
                translation: 'properties.style.line',
                value: 'line'
              }, {
                icon: 'line_chart_area',
                component: 'icon-item',
                labelPlacement: 'bottom',
                translation: 'properties.style.area',
                value: 'area'
              }]
            },
            logarithmic: {
              type: 'boolean',
              component: 'switch',
              translation: 'properties.axis.logarithmicScale',
              ref: 'measureAxis.logarithmic',
              options: [{
                value: true,
                translation: 'Common.Auto'
              }, {
                value: false,
                translation: 'properties.off'
              }]
            }
          }
        },
        color: {
          uses: 'color',
          items: {
            mode: {
              options(data, args) {
                const {
                  length: dimensions
                } = getValidDimensions(args.layout);
                const {
                  length: measures
                } = getValidMeasures(args.layout);
                const options = [{
                  value: 'auto',
                  translation: 'Common.Auto'
                }, {
                  value: 'primary',
                  translation: 'properties.colorMode.primary'
                }];
                if (measures > 1) {
                  options.push({
                    value: 'byMultiple',
                    translation: 'properties.colorMode.multicolored'
                  });
                }
                if (dimensions > 1) {
                  options.push({
                    value: 'byDimension',
                    translation: 'properties.colorMode.byDimension'
                  });
                }
                if (dimensions <= 1) {
                  options.push({
                    value: 'byMeasure',
                    translation: 'properties.colorMode.byMeasure'
                  });
                }
                return options;
              }
            }
          }
        }
      }
    };
    if (flags.isEnabled('LINECHART_FORECAST')) {
      res.items.data.items.dimensions.items.forecast = createForecastDimensionSoftProperties();
      res.items.data.items.measures.items.forecast = createForecastMeasureSoftProperties();
    }
    return res;
  }

  function createMetrics(layout) {
    const metrics = {};
    const tooltip = bt(layout, 'tooltip');
    if (tooltip) {
      metrics.chart_tooltip_custom = !tooltip.auto;
      const tooltipChart = bt(tooltip, 'chart.object.refId');
      if (!tooltip.auto && tooltipChart) {
        metrics.chart_tooltip_custom_mini_chart = tooltipChart;
      }
    }
    return metrics;
  }

  const SUPPORTED_MODIFIERS = {
    ACCUMULATIONS: 'accumulation',
    MOVING_AVERAGE: 'movingAverage',
    DIFFERENCE: 'difference',
    NORMALIZATION: 'normalization',
    TIME_SERIES_DECOMPOSITION: 'timeSeriesDecomposition'
  };
  const isValidLayout = layout => !!(layout && layout.qHyperCube.qSize.qcy > 0);
  const getSupportedModifiers = () => {
    const modifiers = [];
    Object.keys(SUPPORTED_MODIFIERS).forEach(key => {
      modifiers.push(SUPPORTED_MODIFIERS[key]);
    });
    return modifiers;
  };
  function createExt(env) {
    const {
      flags = {
        isEnabled: () => false
      },
      isUnsupportedFeature = () => false,
      translator,
      sense
    } = env;
    const theme = sense === null || sense === void 0 ? void 0 : sense.theme;
    return {
      definition: createDefinition({
        flags,
        isUnsupportedFeature,
        translator,
        theme
      }),
      softDefinition: createSoftDefinition({
        flags
      }),
      support: {
        snapshot: isValidLayout,
        export: isValidLayout,
        exportData: true,
        sharing: isValidLayout,
        viewData: true,
        effects: true,
        modifiers: getSupportedModifiers()
      },
      importProperties: (exportFormat, initialProperties, extension, hypercubePath) => {
        extension.mapProperties({
          layout: {
            templateId: initialProperties.templateId
          }
        });
        const defaultPropertyValues = {
          defaultDimension: extension.getDefaultDimensionProperties(),
          defaultMeasure: extension.getDefaultMeasureProperties()
        };
        const propertyTree = conversion.axisChart.importProperties({
          exportFormat,
          initialProperties,
          dataDefinition: createDataDefinition(env),
          defaultPropertyValues,
          hypercubePath,
          extension
        });
        const {
          qProperty: p
        } = propertyTree;
        if (p.qHyperCubeDef.qDimensions.length > 1) {
          p.qHyperCubeDef.qMode = 'K';
        }
        const {
          qDimensions,
          qMeasures
        } = p.qHyperCubeDef;
        if (p.color && p.color.mode === 'byDimension' && qDimensions.length <= 1 && qMeasures.length <= 1) {
          p.color.mode = 'primary';
        }
        if (flags.isEnabled('IM_1869_HIDE_DIM_MEA_LINE')) {
          conversion.conditionalShow.unquarantine(p);
          conversion.conditionalShow.unquarantineAlternative(p);
        }
        return propertyTree;
      },
      exportProperties: (propertyTree, hyperCubePath, viewDataMode) => {
        if (flags.isEnabled('IM_1869_HIDE_DIM_MEA_LINE')) {
          conversion.conditionalShow.quarantine(propertyTree.qProperty);
          conversion.conditionalShow.quarantineAlternative(propertyTree.qProperty);
        }
        disableForecast(propertyTree === null || propertyTree === void 0 ? void 0 : propertyTree.qProperty);
        const exportFormat = conversion.axisChart.exportProperties({
          propertyTree,
          hypercubePath: hyperCubePath,
          viewDataMode
        });
        const {
          showLabels: value
        } = exportFormat.properties.dataPoint;
        exportFormat.properties.dataPoint.showLabels = value === true || value === 'auto' || value === 'all';
        return exportFormat;
      },
      onSoftPropertyChange(prevProperties, nextProperties, layout) {
        updateForecastProperties(nextProperties, {
          layout
        });
      },
      migrate: {
        properties(properties) {
          if (!properties.qExtendsId) {
            autoSortAdapter(properties);
            scrollbarAdapter({
              properties
            });
          }
          return properties;
        }
      },
      extendMetrics: createMetrics
    };
  }

  /**
   * @namespace properties
   * @entry
   */
  function objectDefinition() {
    /**
     * @lends properties
     */
    const definition = {
      /**
       * Current version of this generic object definition
       * @type {string}
       * @default
       */
      version: "1.30.8",
      /**
       * Color settings.
       * Most color options for visualizations are set in the color object in the options. You activate custom coloring by setting `"auto": false` which turns off auto-coloring.
       * If `"auto": true`, no other properties need to be defined in the color object.
       * Note: Some of the color properties are depending on which theme is currently being used.
       * @type {object}
       */
      color: {
        /**
         * Set to use automatic coloring.
         * When `"auto": true`, color settings are based on the visualization used and the number of dimensions
         * and measures, that is, the settings are not fixed, but are dependent on the data input.
         * @type {boolean}
         * @default
         */
        auto: true,
        /**
         * Set to false to define custom color range. Custom color range is only applicable when coloring is by measure (`"mode": "byMeasure"`) or by expression (`"mode": "byExpression"`).
         * When coloring is by expression, `"expressionIsColor": "false"` must be set for custom color range to work.
         * @type {boolean}
         * @default
         */
        autoMinMax: true,
        /**
         * @type {byDimDef=}
         * @default undefined
         */
        byDimDef: undefined,
        /**
         * @type {byMeasureDef=}
         * @default undefined
         */
        byMeasureDef: undefined,
        /**
         * Sets the color expression to be used when `"mode": "byExpression"` is defined.
         * Expression can evaluate either to a numerical value or a color code if `"expressionIsColor": true`.
         * Supported formats are: `RGB`, `ARGB` and `HSL`
         * @type {string=}
         * @example
         * "colorExpression": "=if(sum(Sales)<avg(Total aggr(sum(Sales),Product)),rgb(255,0,0),RGB(0,255,0))"
         * @default undefined
         */
        colorExpression: undefined,
        /**
         * Color scheme when `"mode": "byDimension"` or `"mode": "byMultiple"` (`"12"` or `"100"` for most themes).
         * @type {'12'|'100'}
         * @default
         */
        dimensionScheme: '12',
        /**
         * Set to define whether the result of the expression is a valid CSS3 color.
         * Only applicable when `"mode": "byExpression"`.
         * @type {boolean}
         * @default
         */
        expressionIsColor: true,
        /**
         * Label to be defined on tool tips when using a coloring expression.
         * Only used if `'expressionIsColor': false`.
         * @type {string}
         * @default
         */
        expressionLabel: '',
        /**
         * Color by measure number formatting options
         */
        formatting: {
          /**
           * When enabled, the number format to use can be selected from multiple predefined formats based on the desired type (number, date).
           * @type {boolean=}
           * @default
           */
          numFormatFromTemplate: true,
          /**
           * If true, the client formatting will be toggled off
           * @type {boolean=}
           * @default undefined
           */
          isCustomFormatted: undefined
        },
        /**
         * Set the min value for the color range.
         * Only applicable if `"autoMinMax": false`.
         * @type {ValueExpression=}
         * @default undefined
         */
        measureMin: undefined,
        /**
         * Set the max value for the color range.
         * Only applicable if `"autoMinMax": false`.
         * @type {ValueExpression=}
         * @default undefined
         */
        measureMax: undefined,
        /**
         * Color scheme when `"mode": "byMeasure"`. Can be one of:
         * * `sg`: (sequential gradient) the transition between the different color groups is made using different shades of colors. High measure values have darker hues
         * * `sc`: (sequential classes) the transition between the different color groups is made using distinctly different colors.
         * * `dg`: (diverging gradient) used when working with data that is ordered from low to high, for instance, to show the relationship between different areas on a map. Low and high values have dark colors, mid-range colors are light.
         * * `dc`: (diverging classes) can be seen as two sequential classes combined, with the mid-range shared. The two extremes, high and low, are emphasized with dark colors with contrasting hues, and the mid-range critical values are emphasized with light colors.
         * @type {'sg'|'sc'|'dg'|'dc'}
         * @default "sg"
         */
        measureScheme: 'sg',
        /**
         * Sets the coloring mode for the visualization when auto-coloring has been switched off (`"auto": false`). Can be one of:
         * * `primary`: a single color (by default blue) is used for all items in the chart. In visualizations that do not benefit from multiple colors (bar charts with one dimension and scatter plots), single color is the default setting.
         * * `byDimension`: coloring is based upon the amount of dimension values. Details are set in the `"byDimDef"` property.
         * !Note: `byDimension` can only be used in conjunction with an attribute dimension on the dimension to color by, as shown in the example below.
         * ```json
         * {
         *     "qDef": {
         *       "qFieldDefs": [
         *         "NetScoreName"
         *       ]
         *     },
         *     "qAttributeDimensions": [
         *       {
         *         "qDef": "NetScoreName",
         *         "id": "colorByAlternative",
         *         "label": "Year"
         *       }
         *     ]
         * }
         * ```
         * * `byExpression`: coloring is based on an expression, which in most cases is a color code. Details are set in the `"expressionIsColor"`, `"expressionLabel`" and `"colorExpression"` properties.
         * * `byMeasure`: coloring is based on the measure value. Details are set in the `"byMeasureDef"` property.
         * * `byMultiple`: can be used when more than one measure is used. By default, 12 colors are used for the dimensions. The colors are reused when there are more than 12 dimension values.
         * @type {'primary'|'byDimension'|'byExpression'|'byMeasure'|'byMultiple'}
         * @default "primary"
         */
        mode: 'primary',
        /**
         * The paletteColor object is used to define the color when you color by single color `("mode": "primary")`.
         * @type {paletteColor}
         * @default { index: 6 }
         */
        paletteColor: {
          index: 6
        },
        /**
         * Set to use persistent colors on data points between selections. Only applicable when using one dimension and when `"mode": "byDimension"` or when `"mode": "byMultiple"`.
         * @type {boolean}
         * @default
         */
        persistent: false,
        /**
         * Set to reverse the color scheme.
         * @type {boolean}
         * @default
         */
        reverseScheme: false,
        /**
         * @type {number}
         * @deprecated Use `paletteColor` instead.
         */
        singleColor: undefined,
        /**
         * Use colors encoded in master items.
         * Only applicable when `"mode": "primary"` or `"mode": "byMultiple"` has been defined.
         * @type {'off'|'dimension'|'measure'}
         * @default "off"
         */
        useBaseColors: 'off',
        /**
         * Set to true if you want to apply the colors defined for library dimensions when used.
         * Only applicable if `'colorMode': 'byDimension'`.
         * @type {boolean}
         * @default
         */
        useDimColVal: true,
        /**
         * Set to true if you want to apply the colors defined for library measures when used. Only applicable if `"mode": "byMeasure"`.
         * @type {boolean}
         * @default
         */
        useMeasureGradient: true
      },
      /**
       * Styling of chart components.
       * @type {Component[]}
       */
      components: [],
      /**
       * Data point settings.
       * @type {object}
       */
      dataPoint: {
        /**
         * Show data points.
         * @type {boolean}
         * @default
         */
        show: false,
        /**
         * Show labels on data points.
         * @type {boolean}
         * @default
         */
        showLabels: false
      },
      /**
       * Dimension axis settings.
       * @type {object}
       */
      dimensionAxis: {
        /**
         * Set to specify axis display mode (number of axis values).
         * @type {'auto'|'custom'|'max'}
         * @default "auto"
         */
        axisDisplayMode: 'auto',
        /**
         * Continuous setting used for toggling between auto and custom setting
         * @type {boolean}
         * @default
         */
        continuousAuto: true,
        /**
         * Axis docking position
         * @type {'near'|'far'}
         * @default "near"
         */
        dock: 'near',
        /**
         * Label orientation
         * @type {'auto'|'horizontal'|'tilted'}
         */
        label: 'auto',
        /**
         * Only visible when axisDisplayMode is custom.
         * Max = 10000 / (numDims+numMeasures)
         * @type {number|ValueExpression}
         * @default
         */
        maxVisibleItems: 10,
        /**
         * Labels and title
         * @type {'all'|'labels'|'title'|'none'}
         */
        show: 'all'
      },
      /**
       * Visualization footnote.
       * @type {(string|StringExpression)=}
       * @default
       */
      footnote: '',
      /**
       * Grid lines settings.
       * @type {object}
       */
      gridLine: {
        /**
         * Automatic grid line spacing.
         * @type {boolean}
         * @default
         */
        auto: true,
        /**
         * Grid line spacing. Used only when auto is set to false.
         * @type {0|1|2|3}
         * @default
         */
        spacing: 2
      },
      /**
       * Legend settings.
       * @type {object}
       */
      legend: {
        /**
         * Sets the legend position.
         * @type {'auto'|'right'|'left'|'bottom'|'top'}
         * @default "auto"
         */
        dock: 'auto',
        /**
         * Set to show the legend.
         * @type {boolean}
         * @default
         */
        show: true,
        /**
         * Show the legend title.
         * @type {boolean}
         * @default
         */
        showTitle: true
      },
      /**
       * Type of line chart.
       * @type {'line'|'area'}
       */
      lineType: 'line',
      /**
       * Measure axis settings.
       * @type {object}
       */
      measureAxis: {
        /**
         * Automatic max/min
         * @type {boolean}
         * @default
         */
        autoMinMax: true,
        /**
         * Axis docking position
         * @type {'near'|'far'}
         * @default "near"
         */
        dock: 'near',
        /**
         * Logarithmic scale
         * @type {boolean}
         * @default
         */
        logarithmic: false,
        /**
         * Axis max value. `"autoMinMax"` must be set to false and `"minMax"`
         * must be set to `"max"` or `"minMax"` to use this property
         * @type {number|ValueExpression}
         * @default
         */
        max: 10,
        /**
         * Axis min value. `"autoMinMax"` must be set to false and `"minMax"`
         * must be set to `"min"` or `"minMax"` to use this property
         * @type {number|ValueExpression}
         * @default
         */
        min: 0,
        /**
         * Set custom max/min
         * @type {'min'|'max'|'minMax'}
         * @default "min"
         */
        minMax: 'min',
        /**
         * Labels and title
         * @type {'all'|'labels'|'title'|'none'}
         * @default "all"
         */
        show: 'all',
        /**
         * Axis scale
         * @type {number}
         * @default
         */
        spacing: 1
      },
      /**
       * Orientation setting.
       * If horizontal, the dimension axis can only be docked on bottom or top and measure axis on left or right.
       * @type {'vertical'|'horizontal'}
       * @default "horizontal"
       */
      orientation: 'horizontal',
      /**
       * Chart axis setting to control preference of scale on a dimensional axis.
       * If true, the scale along the dimensional axis will be continuous if
       * the data supports it, discrete otherwise.
       * @type {boolean}
       * @default
       */
      preferContinuousAxis: true,
      /**
       * Extends `HyperCubeDef`, see Engine API: `HyperCubeDef`.
       * @extends {HyperCubeDef}
       */
      qHyperCubeDef: {
        /**
         * @type {boolean}
         * @default
         * */
        qAlwaysFullyExpanded: true,
        /** @type {DimensionProperties[]} */
        qDimensions: [],
        /** @type {MeasureProperties[]} */
        qMeasures: [],
        qInitialDataFetch: [{
          qWidth: 17,
          qHeight: 500
        }],
        /**
         * @type {boolean}
         * @default
         * */
        qSuppressMissing: true,
        /**
         * @type {boolean}
         * @default
         */
        qSuppressZero: false,
        qDynamicScript: []
      },
      /**
       * Reference lines settings
       * @type {object}
       */
      refLine: {
        /**
         * Array of measure based reference line definitions
         * @type {refLine[]}
         */
        refLines: [],
        /**
         * Array of dimension based reference line definitions
         * @type {dimRefLine[]}
         */
        dimRefLines: []
      },
      /**
       * Sets the style of the scroll bar
       * @type {'bar'|'miniChart'|'none'}
       * @default "miniChart"
       */
      scrollbar: 'miniChart',
      /**
       * Scroll Alignment. If 0, then the scrollbar will start at the left/top of the chart,
       * if 1 it starts at the right/bottom of the chart. Generally decides if the scroll
       * starts at the beginning or end of the data
       * @type {number}
       * @default
       */
      scrollStartPos: 0,
      /**
       * Stack positive and negative values separately. Dependent of lineType property.
       * @type {boolean}
       * @default
       */
      separateStacking: true,
      /**
       * Show visualization details toggle
       * @type {boolean=}
       * @default
       */
      showDetails: true,
      /**
       * Show visualization disclaimer toggle
       * @type {boolean}
       * @default
       */
      showDisclaimer: true,
      /**
       * Chart axis setting to turn on/off the mini chart for continuous axis.
       * @type {boolean}
       * @default
       */
      showMiniChartForContinuousAxis: true,
      /**
       * Stack areas. Dependent of lineType property.
       * @type {boolean}
       * @default
       */
      stackedArea: false,
      /**
       * Null value presentation
       * @type {('gap'|'connect'|'zero')=}
       * @default "gap"
       */
      nullMode: 'gap',
      /**
       * Show title for the visualization.
       * @type {boolean=}
       * @default
       */
      showTitles: true,
      /**
       * Visualization subtitle.
       * @type {(string|StringExpression)=}
       * @default
       */
      subtitle: '',
      /**
       * Visualization title.
       * @type {(string|StringExpression)=}
       * @default
       */
      title: '',
      /**
       * Custom tooltip properties
       * @type {object}
       */
      tooltip: {
        /**
         * Toggle for using custom tooltip or regular tooltip
         * @type {boolean}
         * @default
         */
        auto: true,
        /**
         * Toggle for hiding basic information from custom tooltip
         * @type {boolean}
         * @default
         */
        hideBasic: false,
        /**
         * Custom tooltip title.
         * @type {(string|StringExpression)=}
         * @default
         */
        title: '',
        /**
         * Custom tooltip description.
         * @type {(string|StringExpression)=}
         * @default
         */
        description: '',
        /**
         * The chart object is used to define the chart displayed by the custom tooltip.
         * @type {MasterVisualizationChart}
         * @default undefined
         */
        chart: undefined,
        /**
         * The imageComponents objects are used to define the images displayed by the custom tooltip.
         * @type {ImageComponent[]}
         * @default undefined
         */
        imageComponents: undefined
      }
    };

    /**
     * Color information structure. Holds the actual color and index in palette.
     * @name paletteColor
     * @type object
     * @property {string} color - Color as hex string (mandatory if index: -1)
     * @property {number} index - Index in palette
     */

    /**
     * Styling settings for reference line
     * @name refLineStyle
     * @type object
     * @property {number} [lineThickness=2] Set the thickness for this reference line.
     * @property {string} [lineType=''] Set the dash type for this reference line.
     */

    /**
     * @name refLine
     * @type object
     * @property {boolean|ValueExpression} show=true Set to true to display this reference line.
     * @property {string} label Reference line label.
     * @property {boolean} [showLabel=true] Set to true to show the label of this reference line.
     * @property {boolean} [showValue=true] Set to true to show the value of this reference line.
     * @property {paletteColor} paletteColor
     * @property {refLineStyle} [style] - Styling settings for reference line
     * @property {boolean} [coloredBackground=false] Set to true to fill the label and/or value of this reference line with this color
     * @property {number|ValueExpression} refLineExpr.value
     * @property {string|StringExpression} [refLineExpr.label]
     */

    /**
     * @name dimRefLine
     * @type object
     * @property {boolean|ValueExpression} show=true Set to true to display this reference line.
     * @property {string} label Reference line label.
     * @property {boolean} [showLabel=true] Set to true to show the label of this reference line.
     * @property {boolean} [showValue=true] Set to true to show the value of this reference line.
     * @property {paletteColor} paletteColor
     * @property {refLineStyle} [style] - Styling settings for reference line
     * @property {boolean} [coloredBackground=false] Set to true to fill the label and/or value of this reference line with this color
     * @property {'start' | 'center' | 'end'} [align='center'] Set alignment for this reference line
     * @property {number|ValueExpression} refLineExpr.value
     * @property {string|StringExpression} [refLineExpr.label]
     * @property {string|StringExpression} refLineExpr.stringValue
     */

    /**
     * @typedef {Line|Label|Axis|Legend} Component
     */

    /**
     * @name Line
     * @type object
     * @property {string} key This should be set to `"line"` (Determines which component the settings apply to).
     * @property {LineStyling} style
     */

    /**
     * @name LineStyling
     * @type object
     * @property {number} dataPointSize=6 Set to specify the size of the data point.
     * @property {'linear'|'monotone'} lineCurve="linear"
     * @property {number} lineThickness=1 Set to specify line thickness. Can be set from 1 to 5.
     * @property {'solid'|'dashed'} lineType="solid"
     */

    /**
     * @name Label
     * @type object
     * @property {string} key This should be set to `"label"` (Determines which component the settings apply to).
     * @property {LabelValueStyling} label
     */

    /**
     * @name Axis
     * @type object
     * @property {string} key This should be set to `"axis"` (Determines which component the settings apply to).
     * @property {AxisStyling} axis
     */

    /**
     * @name Legend
     * @type object
     * @property {string} key This should be set to `"legend"` (Determines which component the settings apply to).
     * @property {LegendStyling} legend
     */

    /**
     * @name AxisStyling
     * @type object
     * @property {LabelNameStyling} label
     * @property {FontStyling} title
     */

    /**
     * @name LegendStyling
     * @type object
     * @property {LabelNameStyling} label
     * @property {FontStyling} title
     */

    /**
     * @name LabelValueStyling
     * @type object
     * @property {FontStyling} value Data points labels
     */

    /**
     * @name LabelNameStyling
     * @type object
     * @property {FontStyling} name
     */

    /**
     * @name FontStyling
     * @type object
     * @property {paletteColor} color
     * @property {string} fontFamily
     * @property {string} fontSize
     */

    /**
     * Settings when coloring by dimension (`"mode": "byDimension"`)
     * @name byDimDef
     * @type object
     * @property {string} key libraryId if `"type": "libraryItem"`, dimension expression if `"type": "expression"`
     * @property {string} label Label displayed for coloring (in legend and tooltip for instance). String or expression. Not used when coloring by library items.
     * @property {'expression'|'libraryItem'} type
     */

    /**
     * Settings when coloring by measure (`"mode": "byMeasure"`)
     * @name byMeasureDef
     * @type object
     * @property {string} key libraryId if `"type": "libraryItem"`, measure expression if `"type": "expression"`
     * @property {string} label Label displayed for coloring (in legend and tooltip for instance). String or expression. Not used when coloring by library items.
     * @property {'expression'|'libraryItem'} type
     */

    /**
     * Extends `NxDimension`, see Engine API: `NxDimension`.
     * @name DimensionProperties
     * @type object
     * @extends NxDimension
     * @property {AttributeDimensionProperties[]} qAttributeDimensions
     * @property {InlineDimensionDef} qDef
     */

    /**
     * Extends `NxInlineDimensionDef`, see Engine API: `NxInlineDimensionDef`.
     * @name InlineDimensionDef
     * @type object
     * @extends NxInlineDimensionDef
     * @property {boolean=} autoSort Set to automatically sort the dimension.
     * @property {string=} cId ID used by the Qlik Sense. Must be unique within the current chart.
     * @property {string|StringExpression} othersLabel
     * @property {DimensionForecast} forecast
     */

    /**
     * @name DimensionForecast
     * @type object
     * @property {number} steps=3 Number of forecast steps
     * @property {number} stepSizeMultiplier=1
     * @property {'seconds'|'minutes'|'hours'|'days'|'weeks'|'months'|'years'|'number'} stepSize='days'
     */

    /**
     * Extends `NxMeasure`, see Engine API: `NxMeasure`.
     * @name MeasureProperties
     * @type object
     * @extends NxMeasure
     * @property {AttributeExpressionProperties[]} qAttributeExpressions
     * @property {InlineMeasureDef} qDef
     */

    /**
     * Extends `NxInlineMeasureDef`, see Engine API: `NxInlineMeasureDef`.
     * @name InlineMeasureDef
     * @type object
     * @extends NxInlineMeasureDef
     * @property {boolean=} autoSort Set to automatically sort the measure.
     * @property {string=} cId ID used by the Qlik Sense. Must be unique within the current chart.
     * @property {boolean} isCustomFormatted Set to true to toggle off the default client formatting.
     * @property {(Modifier[])=} modifiers Set to apply a modifier to a measure.
     * @property {boolean} numFormatFromTemplate=true When enabled, the number format to use can be selected from multiple predefined formats based on the desired type (number, date).
     * @property {string|StringExpression} othersLabel
     * @property {LineStyling=} style Can be used to change the line thickness, line type, and line curve for one of the lines.
     * These style settings will override the components styling settings.
     * @property {MeasureForecast} forecast
     */

    /**
     * Extends `NxAttrDimDef`, see Engine API: `NxAttrDimDef`.
     * @name AttributeDimensionProperties
     * @type object
     * @extends NxAttrDimDef
     * @property {string} id - One of: `colorByAlternative`: colors the chart using different dimensions (can be used together with color.mode="byDimension") or `colorByExpression` together with color.mode="byExpression".
     */

    /**
     * @name MeasureForecast
     * @type object
     * @property {boolean} enabled=false
     * @property {'ssa_forecast'|'ols_forecast'} method='ssa_forecast' Forecast method
     * @property {paletteColor} paletteColor
     * @property {number} lineThickness=1 Set to specify line thickness. Can be set from 1 to 5.
     * @property {'solid'|'dashed'} lineType="dashed"
     * @property {'linear'|'monotone'} lineCurve="linear"
     * @property {boolean} showConfidence=true Only used when method is 'SSA'
     * @property {number} confidence=0.95 Only relevant when method is 'SSA' and showConfidence is true. should be between 0 and 1 (exclusive)
     */

    /**
     * @typedef {ColorAttributes|CustomTooltipAttributes|ForecastAttributes} AttributeExpressionProperties
     */

    /**
     * Extends `NxAttrExprDef`, see Engine API: `NxAttrExprDef`.
     * @name ColorAttributes
     * @type object
     * @extends NxAttrExprDef
     * @property {string} id - One of: `colorByAlternative`: colors the chart using different dimensions (can be used together with color.mode="byDimension") or `colorByExpression` together with color.mode="byExpression".
     */

    /**
     * Extends `NxAttrExprDef`, see Engine API: `NxAttrExprDef`.
     * @name CustomTooltipAttributes
     * @type object
     * @extends NxAttrExprDef
     * @property {'customTooltipTitle' | 'customTooltipDescription' | 'customTooltipExpression'} id - Indicates how the attribute expression will be interpreted by the chart.
     * `customTooltipTitle`: additional title displayed on the custom tooltip
     * `customTooltipDescription`: description displayed on the custom tooltip
     * `customTooltipExpression`: measures displayed on the custom tooltip
     * @example
     * ```json
     * "qAttributeExpressions": [{
     *   "qExpression": "",
     *   "qLibraryId": "",
     *   "qAttribute": true,
     *   "qNumFormat": {
     *      "qType": "U",
     *      "qnDec": 10,
     *      "qUseThou": 0,
     *      "qFmt": "",
     *      "qDec": "",
     *      "qThou": "",
     *    }
     *   "qLabel": "custom title",
     *   "qLabelExpression": "",
     *   "id": "customTooltipTitle"
     * },
     * {
     *   "qExpression": "avg(population)",
     *   "qLibraryId": "",
     *   "qAttribute": true,
     *   "qNumFormat": {
     *      "qType": "U",
     *      "qnDec": 10,
     *      "qUseThou": 0,
     *      "qFmt": "",
     *      "qDec": "",
     *      "qThou": "",
     *    }
     *   "qLabel": "",
     *   "qLabelExpression": "",
     *   "id": "customTooltipDescription"
     * },
     * {
     *   "qExpression": "",
     *   "qLibraryId": "zpDNMcg",
     *   "qAttribute": true,
     *   "qNumFormat": {
     *      "qType": "U",
     *      "qnDec": 10,
     *      "qUseThou": 0,
     *      "qFmt": "",
     *      "qDec": "",
     *      "qThou": "",
     *    }
     *   "qLabel": "",
     *   "qLabelExpression": "",
     *   "id": "customTooltipExpression"
     * },
     * {
     *   "qExpression": "sum(population)",
     *   "qLibraryId": "",
     *   "qAttribute": true,
     *   "qNumFormat": {
     *      "qType": "M",
     *      "qnDec": 2,
     *      "qUseThou": 0,
     *      "qFmt": "$#,##0.00;-$#,##0.00",
     *      "qDec": ".",
     *      "qThou": ",",
     *    }
     *   "qLabel": "",
     *   "qLabelExpression": "=avg(population)",
     *   "id": "customTooltipExpression"
     * },
     * {
     *   "qExpression": "'https://my_url/'+sum(population)",
     *   "qLibraryId": "",
     *   "qAttribute": true,
     *   "qNumFormat": null,
     *   "qLabel": "",
     *   "qLabelExpression": "",
     *   "cId": "generatedUniqueId",
     *   "id": "customTooltipImages"
     * }]
     * ```
     */

    /**
     * Extends `NxAttrExprDef`, see Engine API: `NxAttrExprDef`.
     * @name ForecastAttributes
     * @type object
     * @extends NxAttrExprDef
     * @property {'forecast'|'forecast_lower'|'forecast_lower'} id - Indicates how the attribute expression will be interpreted by the chart.
     * `forecast`: forecast line
     * `forecast_lower`: lower edge of forecast confidence interval
     * `forecast_upper`: upper edge of forecast confidence interval
     */

    /**
     * @typedef {Accumulation|Difference|MovingAverage} Modifier
     */

    /**
     * It allows you to accumulate values of your measure over one or two dimensions.
     * @name Accumulation
     * @type object
     * @property {string} type This should be set to `"accumulation"`.
     * @property {number=} accumulationDimension: Only applicable when there are two dimensions. Selects the dimension on which the accumulation will take place. If the accumulation is made across multiple dimensions, this will be the first dimension.
     * @property {boolean=} crossAllDimensions Only applicable when there are two dimensions. Continues accumulation across both dimensions.
     * @property {boolean} fullAccumulation Select whether the accumulation will happen on the Full range or Custom range.
     * @property {number=} steps Only applicable when `fullAccumulation` is set to `false`. The number of steps in the dimensions which form an accumulation range. Only zero and positive integers are accepted.
     * Note: Sorting order of dimension values (or step order) is important and affects results.
     * @property {boolean} showExcludedValues Shows the excluded values (values not in the current selection) in the accumulation.
     * @property {boolean=} disabled
     */

    /**
     * @name Difference
     * @type object
     * @property {string} type This should be set to `"difference"`.
     * @property {number=} accumulationDimension: Only applicable when there are two dimensions. Selects the dimension on which the difference will take place. If the difference is made across multiple dimensions, this will be the first dimension.
     * @property {boolean=} crossAllDimensions Only applicable when there are two dimensions. Continues the difference across both dimensions.
     * @property {boolean} showExcludedValues Shows the excluded values (values not in the current selection) in the difference.
     * @property {boolean=} disabled
     */

    /**
     * @name MovingAverage
     * @type object
     * @property {string} type This should be set to `"movingAverage"`.
     * @property {number=} accumulationDimension: Only applicable when there are two dimensions. Selects the dimension on which the moving average will take place. If the moving average is made across multiple dimensions, this will be the first dimension.
     * @property {boolean=} crossAllDimensions Only applicable when there are two dimensions. Continues the moving average across both dimensions.
     * @property {boolean} fullRange Select whether the moving average will happen on the Full range or Custom range.
     * @property {number=} steps Only applicable when `fullRange` is set to `false`. The number of steps in the dimension which form a moving average. Only zero and positive integers are accepted.
     * Note: Sorting order of dimension values (or step order) is important and affects results.
     * @property {boolean} nullSuppression Choose to have null values calculated by the moving average modifier.
     * @property {boolean} showExcludedValues Shows the excluded values (values not in the current selection) in the moving average.
     * @property {boolean=} disabled
     */

    /**
     * Chart component information structure.
     * @name MasterVisualizationChart
     * @type object
     * @property {MasterVisualizationChartStyle} style - Object containing the styles of the chart such as 'size'
     * @property {MasterVisualizationChartObject} object - Object containing the information fo the visualization, such as refId in case of master visualization
     */

    /**
     * Chart component information structure.
     * @name MasterVisualizationChartStyle
     * @type object
     * @property {string} size - Input type as 'small' or 'medium' or 'large'
     */

    /**
     * Chart component information structure.
     * @name MasterVisualizationChartObject
     * @type object
     * @property {string} refId - Input field containing the qExtendsId of the visualization, where qExtendsId is the unique id of the master visualization
     */

    /**
     * Image component information structure.
     * @name ImageComponent
     * @type object
     * @property {string} type - Input type as 'url' or 'media library'
     * @property {string} size - Size as 'small','medium','large' or 'original'
     * @property {string} cId - Identifier of the image component - used as a link with an attribute expression
     * @property {string|StringExpression|MediaLibraryRef} ref - The reference value of the image
     */

    /**
     * Media Library Reference structure.
     * @name MediaLibraryRef
     * @type object
     * @property {object} qStaticContentUrlDef - Media library structure
     */

    /**
     * Media Library structure that will be evaluated by the engine.
     * @name qStaticContentUrlDef
     * @type object
     * @property {string} qUrl - Value of media library image
     */

    return definition;
  }

  function qae(env) {
    return {
      properties: objectDefinition(),
      data: {
        targets: [{
          path: '/qHyperCubeDef',
          ...createDataDefinition(env)
        }]
      }
    };
  }

  function hasForecastInLayout(layout) {
    if (layout.qHyperCube.qError) {
      return false;
    }
    return layout.qHyperCube.qMeasureInfo.some(measureInfo => {
      return measureInfo.qAttrExprInfo.some(info => info.id === 'forecast');
    });
  }

  /* eslint-disable no-unused-expressions */
  /* eslint-disable no-param-reassign */
  const setColorVars = (properties, layout) => {
    const {
      qDimensionInfo: dimensions,
      qMeasureInfo: measures
    } = layout.qHyperCube;
    const {
      color: {
        mode
      }
    } = properties;
    if (dimensions.length > 1) {
      qt(properties, 'color.persistent', true);
    }
    if (mode === 'byMeasure' && dimensions.length > 1) {
      qt(properties, 'color.mode', 'byDimension');
    } else if (mode === 'byDimension' && dimensions.length <= 1 && measures.length <= 1) {
      qt(properties, 'color.mode', 'primary');
    } else if (mode === 'byExpression' && measures.length === 0) {
      qt(properties, 'color.mode', 'primary');
    }
  };
  function shouldUpdateForConditional({
    model,
    properties,
    layoutService,
    flags
  }) {
    var _model$colorSupport, _model$colorSupport$c;
    if (!flags.isEnabled('IM_1869_HIDE_DIM_MEA_LINE')) {
      return false;
    }
    const original = extend$7(true, {}, properties);
    setColorVars(properties, layoutService.getLayout());
    const {
      dimensionCount,
      isContinuous
    } = layoutService.meta;
    if (isContinuous || dimensionCount === 1) {
      properties.qHyperCubeDef.qMode = 'S';
    } else if (dimensionCount === 2) {
      properties.qHyperCubeDef.qMode = 'K';
    }
    const layout = layoutService.getLayout();
    (_model$colorSupport = model.colorSupport) === null || _model$colorSupport === void 0 || (_model$colorSupport$c = _model$colorSupport.colorByUpdater) === null || _model$colorSupport$c === void 0 || _model$colorSupport$c.call(_model$colorSupport, properties, 'qHyperCubeDef.', layout);
    patchColoring({
      properties,
      layoutService
    });
    if (JSON.stringify(original) === JSON.stringify(properties)) {
      return false;
    }

    /**
     * When checking if properties has changed using JSON.stringify
     * It is not smart enough to ignore preoperties order changes
     * But engine doesn't think properties has changed when some properties order changed
     * Add an extra properties here to get properties back from engine
     */
    properties.hash = Math.random();
    return true;
  }

  function shouldUpdate({
    model,
    properties,
    layoutService,
    flags
  }) {
    const layout = layoutService.getLayout();
    const updateForecast = checkToUpdateProperties({
      enabledForecast: flags.isEnabled('LINECHART_FORECAST') || hasForecastInLayout(layout),
      properties,
      layout
    });
    if (updateForecast) {
      return true;
    }
    return shouldUpdateForConditional({
      model,
      properties,
      layoutService,
      flags
    });
  }

  function createPropertiesUpdater({
    app,
    model,
    properties,
    layoutService,
    flags
  }) {
    const previousProperties = extend$7(true, {}, properties);
    const layout = layoutService.getLayout();
    return {
      shouldUpdate: () => shouldUpdate({
        model,
        properties,
        layoutService,
        flags
      }),
      update: async () => {
        if (canSetProperties(layout)) {
          return model.setProperties(properties).then(() => {
            app.clearUndoBuffer();
          });
        }
        return saveSoftProperties(model, previousProperties, properties);
      }
    };
  }

  var NUMBERS = {
    MAX_NUM_POINTS: 50000,
    DEFAULT_NUM_POINTS: 2000,
    DEFAULT_NUM_LINES: 12
  };

  const {
    DEFAULT_NUM_POINTS: DEFAULT_NUM_POINTS$5
  } = NUMBERS;
  function shouldFetchReduced({
    layoutService,
    largeDataService
  }) {
    const {
      maxNumPoints = DEFAULT_NUM_POINTS$5
    } = (largeDataService === null || largeDataService === void 0 ? void 0 : largeDataService.meta) || {};
    const {
      qHyperCube
    } = layoutService.getLayout();
    return qHyperCube.qSize.qcy * qHyperCube.qMeasureInfo.length > maxNumPoints;
  }

  const {
    DEFAULT_NUM_LINES: DEFAULT_NUM_LINES$3
  } = NUMBERS;
  const computeMaxNumLines = ({
    layoutService,
    largeDataService
  }) => {
    const {
      maxNumLines = DEFAULT_NUM_LINES$3
    } = (largeDataService === null || largeDataService === void 0 ? void 0 : largeDataService.meta) || {};
    const {
      qHyperCube
    } = layoutService.getLayout();
    return qHyperCube.qDimensionInfo.length > 1 && !shouldFetchReduced({
      layoutService,
      largeDataService
    }) ? layoutService.meta.size.dimensions[1] + 1 // possible null value
    : maxNumLines;
  };

  const {
    DEFAULT_NUM_POINTS: DEFAULT_NUM_POINTS$4
  } = NUMBERS;
  const computeNumBins1D = ({
    layoutService,
    largeDataService
  }) => {
    const {
      maxNumPoints = DEFAULT_NUM_POINTS$4
    } = (largeDataService === null || largeDataService === void 0 ? void 0 : largeDataService.meta) || {};
    const {
      measureCount = 1
    } = (layoutService === null || layoutService === void 0 ? void 0 : layoutService.meta) || {};
    const maxPointsPerBinPerLine = 4;
    const maxPointsPerBin = maxPointsPerBinPerLine + 2 * (measureCount - 1);
    return Math.floor(maxNumPoints / (measureCount * maxPointsPerBin));
  };

  const {
    MAX_NUM_POINTS: MAX_NUM_POINTS$1,
    DEFAULT_NUM_POINTS: DEFAULT_NUM_POINTS$3,
    DEFAULT_NUM_LINES: DEFAULT_NUM_LINES$2
  } = NUMBERS;
  const computeNumBins2D = ({
    layoutService,
    largeDataService
  }) => {
    var _layoutService$meta;
    const {
      dimensions = []
    } = (layoutService === null || layoutService === void 0 || (_layoutService$meta = layoutService.meta) === null || _layoutService$meta === void 0 ? void 0 : _layoutService$meta.size) || {};
    const {
      maxNumLines = DEFAULT_NUM_LINES$2,
      maxNumPoints = DEFAULT_NUM_POINTS$3,
      hasInjectedData = false
    } = (largeDataService === null || largeDataService === void 0 ? void 0 : largeDataService.meta) || {};
    const qMaxNumberLines = computeMaxNumLines({
      layoutService,
      largeDataService
    });
    if (qMaxNumberLines * dimensions[0] <= maxNumPoints) {
      return dimensions[0];
    }

    // Get compressed data
    const numLines = Math.max(1, Math.min(maxNumLines, dimensions[1]));
    const maxNumPointsPerLine = maxNumPoints / numLines;
    const maxPointsPerBin = 4; // start, end, min, max per bin (all lines are independent)
    const numBins = Math.floor(dimensions[0] <= maxNumPointsPerLine ? maxNumPointsPerLine : maxNumPointsPerLine / maxPointsPerBin);
    const numPointsPerBin = 2 * numLines * (numLines + 1);
    if (hasInjectedData && (numLines > DEFAULT_NUM_LINES$2 || maxNumPoints > DEFAULT_NUM_POINTS$3)) {
      return Math.min(numBins, Math.ceil(MAX_NUM_POINTS$1 / numPointsPerBin));
    }
    return numBins;
  };

  const {
    DEFAULT_NUM_POINTS: DEFAULT_NUM_POINTS$2
  } = NUMBERS;

  /**
   * The start/min/max/end binning algorithm can at most generate 4 points per bin per line (for multiple measures)
   * assuming we never want more than 2000 points in total:
   * 1 measure -> 2000 / 4
   * 2 measure -> 2000 / 12    // start + end for each line = 2(points) * 2(lines), min/max for each line = 2(points) * 2(lines) * 2(non-coincident) -> 4 + 8 = 12
   * n measures -> 2000 / n * ( 4 + 2*(n-1) )
   */

  const computeNumBins = ({
    layoutService,
    largeDataService
  }) => {
    // Don't compress if there is less data than in maxNumPoints
    if (!shouldFetchReduced({
      layoutService,
      largeDataService
    })) {
      const {
        maxNumPoints = DEFAULT_NUM_POINTS$2
      } = (largeDataService === null || largeDataService === void 0 ? void 0 : largeDataService.meta) || {};
      return maxNumPoints;
    }
    const {
      dimensionCount
    } = layoutService.meta;
    // Get compressed data
    return dimensionCount > 1 ? computeNumBins2D({
      layoutService,
      largeDataService
    }) : computeNumBins1D({
      layoutService,
      largeDataService
    });
  };

  const fetch = ({
    start,
    end,
    model,
    layoutService,
    largeDataService,
    definitionPath
  }) => {
    const qNbrPoints = computeNumBins({
      layoutService,
      largeDataService
    });
    const qMaxNumberLines = computeMaxNumLines({
      layoutService,
      largeDataService
    });
    const opts = {
      qStart: start,
      qEnd: end,
      qNbrPoints,
      qMaxNbrTicks: 300,
      qMaxNumberLines
    };
    /**
     * @returns {object} A continuous dataset with qDataPages and qAxisData
     */
    return model.getHyperCubeContinuousData(definitionPath, opts, false);
  };

  function fetcher$3({
    model,
    layoutService,
    largeDataService,
    definitionPath = '/qHyperCubeDef'
  }) {
    const shouldFetchReduced$1 = () => shouldFetchReduced({
      layoutService,
      largeDataService
    });
    const computeNbrOfBins = () => computeNumBins({
      layoutService,
      largeDataService
    });
    const computeMaxNumberLines = () => computeMaxNumLines({
      layoutService,
      largeDataService
    });
    const fetch$1 = (start, end) => fetch({
      start,
      end,
      model,
      layoutService,
      largeDataService,
      definitionPath
    });
    return {
      shouldFetchReduced: shouldFetchReduced$1,
      computeNbrOfBins,
      computeMaxNumberLines,
      fetch: fetch$1
    };
  }

  function fetcher$2(deps = {}) {
    const {
      cache = {}
    } = deps;
    return {
      fetch: () => Promise.resolve(cache.merged)
    };
  }

  function legacySnapshotDataResolver({
    scrollOffset = 0,
    viewRange = 0
  }, startValue) {
    let min = startValue + scrollOffset;
    let max = min + viewRange;

    // Handle a case when there is only 1 data point, in such case expand the range
    if (viewRange === 1 && scrollOffset === 0) {
      min = startValue - 0.5;
      max = startValue + 0.5;
    }
    return {
      zoom: {
        min,
        max
      }
    };
  }
  function defaultSnapshotDataResolver({
    zoom
  }) {
    return {
      zoom
    };
  }
  function fetcher$1({
    layoutService,
    viewCache
  }) {
    return {
      fetch: () => {
        const {
          qAxisData,
          qDataPages
        } = layoutService.getHyperCube();
        return Promise.resolve({
          qAxisData,
          qDataPages
        });
      },
      getSnapshotData() {
        const chartData = layoutService.getLayoutValue('snapshotData.content.chartData', {});
        if ('zoom' in chartData && 'min' in chartData.zoom && 'max' in chartData.zoom) {
          return defaultSnapshotDataResolver(chartData);
        }
        return legacySnapshotDataResolver(chartData, viewCache.get('continuousMin'));
      }
    };
  }

  function singleDimensionReducer({
    start,
    end,
    matrix
  }) {
    const reducedMatrix = [];
    let rowBeforeStart;
    let rowAfterEnd;
    for (let i = 0; i < matrix.length; i++) {
      const row = matrix[i];
      if (row[0].qNum < start) {
        rowBeforeStart = row;
      } else if (row[0].qNum > end) {
        if (!rowAfterEnd) {
          rowAfterEnd = row;
        }
      }
      if (row[0].qNum >= start && row[0].qNum <= end) {
        reducedMatrix.push(row);
      }
    }
    if (rowBeforeStart) {
      reducedMatrix.unshift(rowBeforeStart);
    }
    if (rowAfterEnd) {
      reducedMatrix.push(rowAfterEnd);
    }
    return reducedMatrix;
  }

  // Use a custom hash map in order to maintain sort order of the matrix
  function HashMap() {
    const fn = () => {};
    const valuesIndex = [];
    const values = {};
    fn.set = (key, value) => {
      const trackedIndex = valuesIndex.indexOf(key);
      if (trackedIndex > -1) {
        // If a key is update with a new value, refresh the index
        valuesIndex.splice(trackedIndex, 1);
      }
      valuesIndex.push(key);
      values[key] = value;
    };
    fn.forEach = callback => {
      valuesIndex.forEach((key, index) => callback(values[key], index));
    };
    fn.has = key => key in values;
    return fn;
  }
  function dualDimensionReducer({
    start,
    end,
    matrix
  }) {
    const reducedMatrix = [];
    const rowsBeforeStart = HashMap();
    const rowsAfterEnd = HashMap();
    for (let i = 0; i < matrix.length; i++) {
      const row = matrix[i];
      const trackByElemNumber = row[1].qElemNumber.toString();
      if (row[0].qNum < start) {
        rowsBeforeStart.set(trackByElemNumber, row);
      } else if (row[0].qNum > end) {
        if (!rowsAfterEnd.has(trackByElemNumber)) {
          rowsAfterEnd.set(trackByElemNumber, row);
        }
      }
      if (row[0].qNum >= start && row[0].qNum <= end) {
        reducedMatrix.push(row);
      }
    }
    rowsBeforeStart.forEach((row, i) => reducedMatrix.splice(i, 0, row));
    rowsAfterEnd.forEach(row => reducedMatrix.push(row));
    return reducedMatrix;
  }

  function reducer$2(start, end, matrix) {
    if (matrix[0] && matrix[0][1] && matrix[0][1].qElemNumber > -1) {
      // Is not a measure, assume it's an inner dimension value
      return dualDimensionReducer({
        start,
        end,
        matrix
      });
    }
    return singleDimensionReducer({
      start,
      end,
      matrix
    });
  }

  function reducer$1(start, end, qAxisData) {
    return {
      qAxis: qAxisData.qAxis.map(a => ({
        qName: a.qName,
        qTags: a.qTags,
        qTicks: a.qTicks.reduce((ticks, tick) => {
          if (tick.qStart >= start && tick.qStart <= end) {
            ticks.push(tick);
          } else if (tick.qEnd >= start && tick.qEnd <= end) {
            ticks.push(tick);
          } else if (tick.qStart < start && tick.qEnd > end) {
            ticks.push(tick);
          }
          return ticks;
        }, [])
      }))
    };
  }

  function patchArea(qArea, qMatrix) {
    // Need patch qArea because "getHyperCubeContinuousData" always returns an object with all properties set to 0
    return {
      ...qArea,
      qWidth: qMatrix[0] ? qMatrix[0].length : 0,
      qHeight: qMatrix.length
    };
  }

  function reducer(start, end, data) {
    const reducedData = {
      qDataPages: (data.qDataPages || []).map(page => {
        const qMatrix = reducer$2(start, end, page.qMatrix);
        const qArea = patchArea(page.qArea, qMatrix);
        return {
          ...page,
          qArea,
          qMatrix
        };
      })
    };
    if (data.qAxisData && data.qAxisData.qAxis) {
      reducedData.qAxisData = reducer$1(start, end, data.qAxisData);
    }
    return reducedData;
  }

  function merger$2(initial, latest) {
    if (!latest || !latest.length || !latest[0].length) {
      return initial;
    }
    const currStart = latest[0][0].qNum;
    const currEnd = latest[latest.length - 1][0].qNum;
    const before = [];
    const after = [];
    for (let i = 0, len = initial.length; i < len; i++) {
      const dim = initial[i][0];
      if (dim.qNum < currStart) {
        before.push(initial[i]);
      } else if (dim.qNum > currEnd) {
        after.push(initial[i]);
      }
    }
    return [...before, ...latest, ...after];
  }

  function merger$1(initial, latest) {
    if (!latest || !latest.qAxis.length || latest.qAxis.every(t => !t.qTicks.length)) {
      return initial;
    }
    const currNames = latest.qAxis.map(a => a.qName);
    const currRanges = latest.qAxis.map(t => ({
      start: t.qTicks[0].qStart,
      end: t.qTicks[t.qTicks.length - 1].qStart
    }));
    const mergedData = latest.qAxis.map(t => ({
      qName: t.qName,
      qTags: [...t.qTags],
      qTicks: [...t.qTicks]
    }));
    for (let i = 0, len = initial.qAxis.length; i < len; i++) {
      const init = initial.qAxis[i];
      const idx = currNames.indexOf(init.qName);
      const before = [];
      const after = [];
      if (idx > -1) {
        const {
          start,
          end
        } = currRanges[idx];
        for (let k = 0, l = init.qTicks.length; k < l; k++) {
          const tick = init.qTicks[k];
          if (tick.qStart < start) {
            before.push(tick);
          } else if (tick.qStart > end) {
            after.push(tick);
          }
        }
        mergedData[idx].qTicks = [...before, ...mergedData[idx].qTicks, ...after];
      }
    }
    return {
      qAxis: mergedData
    };
  }

  function merger(set, subset) {
    const data = {};
    data.qDataPages = (set.qDataPages || []).map((page, i) => {
      const qMatrix = merger$2(page.qMatrix, subset.qDataPages[i].qMatrix);
      const qArea = patchArea(page.qArea, qMatrix);
      return {
        ...page,
        qArea,
        qMatrix
      };
    });
    if (set.qAxisData && set.qAxisData.qAxis) {
      data.qAxisData = merger$1(set.qAxisData, subset.qAxisData);
    }
    return data;
  }

  function patchData(data) {
    return {
      qDataPages: data.qDataPages.map(page => {
        const qArea = patchArea(page.qArea, page.qMatrix);
        return {
          ...page,
          qArea
        };
      }),
      qAxisData: data.qAxisData
    };
  }

  /**
   * Crude approximation of max zoom level from Sense Client
   */
  const MAX_ZOOM_LEVEL = 44;

  /**
   * ~1.41
   */
  const ZOOM_OUT = 2 ** (1 / 2);

  /**
   * ~0.71
   */
  const ZOOM_IN = 1 / ZOOM_OUT;

  const EPSILON$4 = 1e-6;
  const POW = ZOOM_IN ** MAX_ZOOM_LEVEL;
  function resolver$4(min, max) {
    return Math.max(EPSILON$4, (max - min) * POW);
  }

  function isOtherCell(cell) {
    return cell.qIsOtherCell;
  }
  function getStackedByDimensionCardinality(matrix) {
    const dimGroup = {};
    matrix.forEach(row => {
      if (!row.some(isOtherCell)) {
        const cId = row[0].qElemNumber;
        dimGroup[cId] = undefined;
      }
    });
    return Object.keys(dimGroup).length;
  }
  function getDefaultCardinality(matrix) {
    let count = 0;
    matrix.forEach(row => {
      if (!row.some(isOtherCell)) {
        count++;
      }
    });
    return count;
  }
  function getDimensionCardinality({
    qDataPages = []
  } = {}, meta = {}) {
    const matrix = qDataPages.length ? qDataPages[0].qMatrix : [];
    if (meta.isStackedByDimension) {
      return getStackedByDimensionCardinality(matrix);
    }
    return getDefaultCardinality(matrix);
  }

  function getInitialRange(qDimensionInfo = {}) {
    let {
      qMin,
      qMax
    } = qDimensionInfo;
    qMin = Number.isNaN(+qMin) ? 0 : qMin;
    qMax = Number.isNaN(+qMax) ? 0 : qMax;
    return {
      initialMin: qMin,
      initialMax: qMax
    };
  }

  const NOOP_DATA_PROCESSOR_MODEL = {
    query: {
      getShouldProcess: () => false
    },
    command: {
      processDataPage: () => {}
    }
  };
  function create$x({
    model,
    layoutService,
    largeDataService,
    dataProcessorModel = NOOP_DATA_PROCESSOR_MODEL,
    viewCache,
    viewState,
    definitionPath
  }, deps = {}) {
    const {
      engineFetcherFactory = fetcher$3,
      snapshotFetcherFactory = fetcher$1,
      cacheFetcherFactory = fetcher$2,
      cache = {
        initial: {},
        merged: {}
      }
    } = deps;
    const concreteEngineFetcher = engineFetcherFactory({
      model,
      layoutService,
      largeDataService,
      definitionPath
    });
    const concreteSnapshotFetcher = snapshotFetcherFactory({
      layoutService,
      viewCache
    });
    const concreteCacheFetcher = cacheFetcherFactory({
      cache
    });
    const handleError = error => {
      // error caused by an update of the object after getLayout should not show any error dialog
      error.isHandled = true; // eslint-disable-line no-param-reassign
      throw error;
    };
    let fetcher;
    let initialMin;
    let initialMax;
    return {
      update(layout) {
        ({
          initialMin,
          initialMax
        } = getInitialRange(layout.qHyperCube.qDimensionInfo[0]));
        viewCache.set('continuousMin', initialMin);
        viewCache.set('continuousMax', initialMax);
        viewCache.set('minimiumZoomSpan', resolver$4(initialMin, initialMax));
        fetcher = layoutService.meta.isSnapshot ? concreteSnapshotFetcher : concreteEngineFetcher;
        if (layoutService.meta.isSnapshot) {
          ({
            zoom: {
              min: initialMin,
              max: initialMax
            }
          } = concreteSnapshotFetcher.getSnapshotData());
        }
        viewState.preventSet('zoom', {
          min: initialMin,
          max: initialMax
        });
      },
      updateLayout(data) {
        // Update the layout with continuous data
        const {
          qDataPages,
          qAxisData
        } = data;
        layoutService.setHyperCubeValue('qDataPages', qDataPages);
        layoutService.setHyperCubeValue('qAxisData', qAxisData);

        // Explicitly set qMode = 'S' to handle cases when the data is continuous but qMode is not 'S'.
        // Such as when a user explicitly sets a chart to stacked and than changes to continuous mode. See issue #941
        layoutService.setHyperCubeValue('qMode', 'S');

        // The positions of fields in data pages of continuous data is not influenced by column order, unlike the discrete data.
        layoutService.setHyperCubeValue('qColumnOrder', []);
        return data;
      },
      initialFetch() {
        return fetcher.fetch(initialMin, initialMax).then(data => {
          const patchedData = patchData(data);
          dataProcessorModel.command.processDataPage({
            dataPage: patchedData.qDataPages.length ? patchedData.qDataPages[0] : []
          });
          cache.initial = patchedData;
          cache.merged = patchedData;
          return data;
        }).then(data => reducer(initialMin, initialMax, data)).then(data => this.updateLayout(data)).catch(handleError);
      },
      fetch(start, end) {
        return fetcher.fetch(start, end).then(data => merger(cache.initial, data)).then(data => {
          dataProcessorModel.command.processDataPage({
            dataPage: data.qDataPages.length ? data.qDataPages[0] : []
          });
          cache.merged = data;
          return data;
        }).then(data => reducer(start, end, data)).catch(handleError);
      },
      fetchFromCache(start, end) {
        return concreteCacheFetcher.fetch(start, end).then(data => reducer(start, end, data));
      },
      fetchMinMaxData() {
        return Promise.resolve(cache.initial.qDataPages || []);
      },
      getInitialCube() {
        const currentCube = layoutService.getHyperCube();
        return extend$7({}, currentCube, {
          ...cache.initial
        });
      },
      getInitialLayout() {
        const initialCube = this.getInitialCube();
        return extend$7({}, layoutService.getLayout(), {
          qHyperCube: initialCube
        });
      },
      getDimensionCardinality() {
        return getDimensionCardinality(cache.initial, layoutService.meta);
      },
      setSnapshotData(layout) {
        const {
          qHyperCube
        } = layout;
        const dataPages = dataProcessorModel.query.getShouldProcess() ? [dataProcessorModel.query.getFilteredDataPage({
          dataPage: cache.merged.qDataPages[0]
        })] : cache.merged.qDataPages;
        qHyperCube.qDataPages = dataPages;
        qHyperCube.qAxisData = cache.merged.qAxisData;
      }
    };
  }

  function onZoomChange(view, update) {
    const {
      layoutService,
      continuousDataModel: continuousModel
    } = view;
    function fetcher(method, min, max) {
      return continuousModel[method](min, max).then(data => {
        continuousModel.updateLayout(data);
        update();
        return data;
      });
    }
    const debouncedFetcher = St((min, max) => fetcher('fetch', min, max), 50);
    return ({
      min,
      max
    }, {
      min: prevMin,
      max: prevMax
    }) => {
      if (!layoutService.meta.isContinuous || min === prevMin && max === prevMax) {
        return Promise.resolve(null);
      }
      return fetcher('fetchFromCache', min, max).then(data => {
        debouncedFetcher(min, max);
        return data;
      });
    };
  }

  function onZoomIntercept({
    viewCache
  }) {
    let initialMin = NaN;
    let initialMax = NaN;
    let minimiumZoomSpan = NaN;
    return (next, curr) => {
      // Update to ensure that the continuous min/max are up-to-date
      initialMin = viewCache.get('continuousMin');
      initialMax = viewCache.get('continuousMax');
      minimiumZoomSpan = viewCache.get('minimiumZoomSpan');
      if (Math.abs(next.max - next.min) < minimiumZoomSpan) {
        return curr;
      }
      return {
        min: Math.min(next.max, Math.max(initialMin, next.min)),
        max: Math.max(next.min, Math.min(initialMax, next.max))
      };
    };
  }

  function getRelativeX(p, chart, component) {
    let {
      x
    } = p;
    x -= chart.element.getBoundingClientRect().left;
    x -= component.rect.x;
    return Math.max(0, Math.min(1, x / component.rect.width));
  }
  function create$w({
    viewCache,
    viewState,
    chart
  }, {
    threshold = 50,
    rtl = false,
    targetKey
  }) {
    const initialMin = viewCache.get('continuousMin');
    const initialMax = viewCache.get('continuousMax');
    const getTargetComponent = point => chart.componentsFromPoint(point).filter(c => c.key === targetKey)[0];
    return Ct((point, sign) => {
      const target = getTargetComponent(point);
      if (target) {
        const x = getRelativeX(point, chart, target);
        const virtual = rtl ? 1 - x : x;
        const {
          min: currMin,
          max: currMax
        } = viewState.get('zoom');
        const currSpan = Math.abs(currMax - currMin);
        const newSpan = (sign > 0 ? ZOOM_IN : ZOOM_OUT) * currSpan;
        const diff = currSpan - newSpan;
        const newMin = currMin + diff * virtual;
        const newMax = currMax - diff * (1 - virtual);
        const minLeftOver = newMin < initialMin ? initialMin - newMin : 0; // Always positive
        const maxLeftOver = newMax > initialMax ? newMax - initialMax : 0; // Always positive

        viewState.set('zoom', {
          min: Math.max(newMin - maxLeftOver, initialMin),
          max: Math.min(newMax + minLeftOver, initialMax)
        });
      }
    }, threshold);
  }

  function appendTickSpan(scale, ticks) {
    const [, max] = scale.domain();
    for (let index = 0; index < ticks.length; index++) {
      const t = ticks[index];
      const tNext = ticks[index + 1];
      t.data = {};
      if (!tNext && t.end !== 1) {
        t.data.start = t.value;
        t.data.end = max;
        t.end = 1;
      } else if (tNext) {
        t.data.start = t.value;
        t.data.end = tNext.value;
        t.end = tNext.position;
      } else {
        t.data.start = t.value;
        t.data.end = t.value;
      }
    }
  }

  /**
   * The purpose of this component is to enable single tap selection to trigger a range brush
   */
  var axisOverlay = {
    created() {
      this.state = {};
    },
    beforeUpdate() {
      this.state = {};
    },
    beforeRender({
      size
    }) {
      this.state.ticks = this.scale.ticks({
        distance: size.width
      }).filter(t => !t.isMinor);
      if (this.scale.type === 'linear') {
        appendTickSpan(this.scale, this.state.ticks);
      }
    },
    render() {
      const field = this.scale.data().fields.length ? this.scale.data().fields[0].id() : '';
      const {
        ticks
      } = this.state;
      const nodes = ticks.map(t => {
        const rect = {
          type: 'rect',
          fill: 'none',
          data: {
            source: {
              field
            },
            value: [t.data.start, t.data.end]
          },
          x: t.start * this.rect.width,
          y: 0,
          width: (t.end - t.start) * this.rect.width,
          height: this.rect.height
        };
        return rect;
      });
      if (ticks.length && ticks[0].start > 0) {
        const t = ticks[0];
        nodes.unshift({
          type: 'rect',
          fill: 'none',
          data: {
            source: {
              field
            },
            value: [this.scale.domain()[0], t.data.start]
          },
          x: 0,
          y: 0,
          width: t.start * this.rect.width,
          height: this.rect.height
        });
      }
      return nodes;
    }
  };

  const ELLIPSIS_CHAR$1 = '…';
  function labelResolver({
    props,
    localProps: {
      size
    },
    style,
    renderer
  }) {
    const PADDING = props.label.padding;
    const justify = Math.max(0, Math.min(props.label.justify, 1));
    const align = Math.max(0, Math.min(props.label.align, 1));
    const measureText = text => renderer.measureText({
      text,
      fontSize: style.label.fontSize,
      fontFamily: style.label.fontFamily
    });
    return {
      resolve: (tick, rect) => {
        const text = typeof tick.label === 'string' ? tick.label : '';
        const textMeasure = measureText(text);
        let {
          x,
          width
        } = rect;
        if (tick.start === tick.end) {
          width = textMeasure.width + 2 * PADDING;
          if (tick.end === 1) {
            // adjust x if it is to the right
            x -= width;
          }
        }
        const labelRect = {
          // rect including padding
          x: x + PADDING,
          y: PADDING,
          width: width - PADDING * 2,
          height: size.height - PADDING * 2
        };
        const minimumRequiredWidth = measureText(`${text[0]}${ELLIPSIS_CHAR$1}`).width; // Use first char + ellips char to avoid cases where only a elipsis char would be visible
        const xDiff = Math.max(0, labelRect.width - textMeasure.width);
        const yDiff = Math.max(0, labelRect.height - textMeasure.height);
        const dx = justify * xDiff;
        const dy = align * yDiff;
        return {
          show: labelRect.width >= Math.min(minimumRequiredWidth, textMeasure.width),
          text,
          dx,
          dy,
          rect: labelRect,
          style: style.label,
          segment: {
            x: x + dx,
            width: textMeasure.width + 2 * PADDING
          },
          tickValue: tick.value
        };
      }
    };
  }

  function crispEdges(coord, strokeWidth = 1) {
    if (strokeWidth % 2 === 0) {
      return coord;
    }
    let rounded = Math.round(coord);
    const diff = coord - rounded;
    if (diff > 0) {
      rounded += 0.5;
    } else {
      rounded -= 0.5;
    }
    return rounded;
  }

  function resolver$3({
    localProps: {
      size
    },
    style,
    scale,
    props
  }) {
    const [min, max] = scale.domain();
    const justify = Math.max(0, Math.min(1, props.guideLine.major.justify));
    return {
      resolve: (tick, rect) => {
        const dx = justify * rect.width;
        const x = crispEdges(rect.x + dx, style.majorGuideLine.strokeWidth);
        return {
          show: tick.value >= min && tick.value <= max,
          x1: x,
          y1: 0,
          x2: x,
          y2: crispEdges(size.height, style.majorGuideLine.strokeWidth),
          style: style.majorGuideLine,
          tickValue: tick.value
        };
      }
    };
  }

  function resolveFullRect(tick, size, anchor) {
    const width = Math.abs(Math.max(tick.start, 0) - Math.min(tick.end, 1)) * size.width;
    const start = Math.max(tick[anchor], 0) * size.width;
    return {
      // Full size rect
      x: start,
      y: 0,
      width,
      height: size.height
    };
  }

  function isOverlapping(segment1, segment2) {
    return segment1.x < segment2.x ? segment1.x + segment1.width >= segment2.x : segment2.x + segment2.width >= segment1.x;
  }
  function labelsOverlapping(ticks, tickLabels) {
    const numTicks = ticks.length;
    if (numTicks < 2) {
      return;
    }
    const lastTick = ticks[numTicks - 1];
    const lastTickLabel = tickLabels[numTicks - 1].label;
    if (lastTick && lastTick.start === lastTick.end) {
      for (let i = numTicks - 2; i > -1; i--) {
        const tickLabel = tickLabels[i].label;
        tickLabel.show = tickLabel.show && !isOverlapping(tickLabel.segment, lastTickLabel.segment);
      }
    }
  }

  function majorResolver(ticks, context) {
    const {
      localProps: {
        size
      },
      props: {
        anchor
      }
    } = context;
    const lr = labelResolver(context);
    const mglr = resolver$3(context);
    const tickLabels = ticks.map(tick => {
      const rect = resolveFullRect(tick, size, anchor);
      const label = lr.resolve(tick, rect);
      const guideLine = mglr.resolve(tick, rect);
      return {
        rect,
        label,
        guideLine
      };
    });
    labelsOverlapping(ticks, tickLabels);
    return tickLabels;
  }

  function resolver$2({
    localProps: {
      size
    },
    props,
    style
  }) {
    return {
      resolve: tick => {
        const yDiff = Math.max(size.height - props.guideLine.minor.size, 0);
        const dy = yDiff * Math.max(0, Math.min(props.guideLine.minor.align, 1));
        const x = crispEdges(tick.position * size.width, style.minorGuideLine.strokeWidth);
        return {
          guideLine: {
            show: true,
            x1: x,
            y1: crispEdges(dy, style.minorGuideLine.strokeWidth),
            x2: x,
            y2: crispEdges(props.guideLine.minor.size + dy, style.minorGuideLine.strokeWidth),
            style: style.minorGuideLine
          }
        };
      }
    };
  }

  function resolver$1(ticks, context) {
    const mglr = resolver$2(context);
    return context.props.guideLine.minor.show ? ticks.map(mglr.resolve) : [];
  }

  function resolve$3({
    localProps: {
      size
    },
    style,
    props
  }) {
    const y = crispEdges(1, style.line.strokeWidth);
    return {
      show: props.line.show,
      x1: crispEdges(0, style.line.strokeWidth),
      y1: y,
      x2: crispEdges(size.width, style.line.strokeWidth),
      y2: y,
      style: style.line
    };
  }

  function create$v(resolved) {
    return resolved.filter(label => label.show).map(label => extend$7({}, label.style, {
      type: 'text',
      x: label.rect.x,
      y: label.rect.y,
      dx: label.dx,
      dy: label.dy,
      maxWidth: label.rect.width,
      text: label.text,
      title: label.text,
      baseline: 'text-before-edge',
      tickValue: label.tickValue
    }));
  }

  function create$u(resolved) {
    return resolved.filter(guideLine => guideLine.show).map(guideLine => extend$7({
      strokeWidth: 1
    }, guideLine.style, {
      type: 'line',
      x1: guideLine.x1,
      y1: guideLine.y1,
      x2: guideLine.x2,
      y2: guideLine.y2,
      tickValue: guideLine.tickValue
    }));
  }

  var timeAxis = {
    require: ['renderer'],
    defaultSettings: {
      layout: {
        displayOrder: 0,
        prioOrder: 0
      },
      settings: {
        anchor: 'start',
        // or end
        label: {
          show: true,
          padding: 4,
          align: 0,
          justify: 0
        },
        line: {
          show: true
        },
        guideLine: {
          major: {
            justify: 0
          },
          minor: {
            show: true,
            size: 4,
            align: 0
          }
        }
      },
      style: {
        label: '$label',
        line: '$guide-line',
        majorGuideLine: '$guide-line',
        minorGuideLine: '$guide-line'
      }
    },
    preferredSize: () => ({
      size: 30,
      edgeBleed: {
        left: 1,
        right: 1
      }
    }),
    init() {
      this.props = this.settings.settings;
      this.localProps = {};
      this.state = {
        major: [],
        minor: []
      };
    },
    created() {
      this.init();
    },
    beforeUpdate() {
      this.init();
    },
    beforeRender({
      size
    }) {
      this.localProps.size = size;
      const ticks = this.scale.ticks({
        distance: size.width
      });
      const major = ticks.filter(tick => !tick.isMinor);
      const minor = ticks.filter(tick => tick.isMinor);
      this.state.line = resolve$3(this);
      this.state.major = majorResolver(major, this);
      this.state.minor = resolver$1(minor, this);
    },
    render() {
      return [...create$u([this.state.line]), ...create$v(this.state.major.map(m => m.label)), ...create$u(this.state.major.map(m => m.guideLine)), ...create$u(this.state.minor.map(m => m.guideLine))
      // ...this.state.major.map(m => ({
      //   type: 'rect',
      //   fill: 'rgba(0, 123, 0, 0.1)',
      //   stroke: 'lime',
      //   strokeWidth: 0,
      //   ...m.label.rect,
      // })),
      ];
    }
  };

  /**
   * Checks if two sets of ticks are equal
   * @param {array} q1
   * @param {array} q2
   */
  function areEqual(q1, q2) {
    return q1 && q2 && q1.qTicks.length === q2.qTicks.length && q1.qTicks.every((t, i) => t.qStart === q2.qTicks[i].qStart && t.qEnd === q2.qTicks[i].qEnd);
  }
  function isQualified(q) {
    return q.qTags.indexOf('$qualified') > -1;
  }

  /**
   * Converts the qAxisData into two arrays, one containing qualified data and the other non-qualified data.
   * The two arrays are exepected to be of equal length and a corresponding index in one array
   * should represent either a qualified or non-qualified value in the other array.
   *
   * Both arrays may contain qualified and/or non-qualified data, depending on the structure of qAxisData.
   * However the arrays should if available prefer one over the other.
   * @param {array} qAxis
   */
  function mapper({
    qAxis
  }) {
    const qualified = [];
    const nonQualified = [];
    for (let i = 0; i < qAxis.length; i++) {
      const k = i + 1;
      const q1 = qAxis[i];
      const q2 = qAxis[k];
      if (areEqual(q1, q2)) {
        if (isQualified(q2)) {
          qualified.push(k);
          nonQualified.push(i);
        } else {
          qualified.push(i);
          nonQualified.push(k);
        }
        i++;
      } else {
        qualified.push(i);
        nonQualified.push(i);
      }
    }
    return {
      qualified,
      nonQualified
    };
  }

  /**
   * The concrete resolver is responsible for the actual resolve logic. It will take
   * qAxis meta data and based on that decide an appropriate level for the outer, inner
   * and minor level.
   *
   * In essence it will output a result that says use this qAxisData set as outer axis and
   * another set as inner axis.
   *
   * There are 5 major cases to consider:
   * Case 1: Outer, inner and minor is found.
   * Case 2: Outer and inner is found.
   * Case 3: Outer is found -> Swap outer with inner and check if a minor can be found.
   * Case 4: Outer is found and the tick interval is equal too or shorter than a day -> Auto-generate inner
   * and ensure that auto-generated ticks have an interval that is shortern than 1 day.
   * Case 5: No match is found -> Auto-generate Outer and Inner.
   * @returns {object} Where the outer, inner and minor properties respresent an index in the qAxisData array
   * @example
   * // Case 1:
   * { outer: 0, inner: 1, minor: 2, isDayOrShorter: false }
   * // Case 2:
   * { outer: 0, inner: 1, minor: NaN, isDayOrShorter: false }
   * // Case 3:
   * { outer: NaN, inner: 0, minor: 1 || NaN, isDayOrShorter: false }
   * // Case 4:
   * { outer: 0, inner: 'auto', minor: NaN, isDayOrShorter: true }
   * // Case 5:
   * { outer: 'auto', inner: 'auto', minor: NaN, isDayOrShorter: false }
   */
  function resolver({
    qualifiedMeta,
    nonQualifiedMeta
  }) {
    return {
      resolve(distance) {
        let qMetaIndex;
        let outer = NaN;
        let inner = NaN;
        let minor = NaN;
        let isDayOrShorter = false;
        for (let i = qualifiedMeta.length - 1; i >= 0; i--) {
          const qMeta = qualifiedMeta[i];
          if (qMeta.queries.outer(distance)) {
            const nqMeta = nonQualifiedMeta[i + 1];
            outer = qMeta.index;
            qMetaIndex = i;
            if (qMeta.attrs.isDayOrShorter() && qMeta.queries.canFitHalfDayTicks(distance)) {
              inner = 'auto';
              isDayOrShorter = true;
              break; // Outer & auto-generated
            } else if (nqMeta && nqMeta.queries.inner(distance)) {
              inner = nqMeta.index;
              const minorMeta = nonQualifiedMeta[i + 2];
              if (minorMeta && minorMeta.queries.minor(distance)) {
                minor = minorMeta.index; // Outer & Inner & Minor
              }

              break; // Outer & Inner
            }
          }
        }

        if (!Number.isNaN(outer) && Number.isNaN(inner) && inner !== 'auto') {
          inner = outer;
          outer = NaN;
          const minorMeta = nonQualifiedMeta[qMetaIndex + 1];
          if (minorMeta && minorMeta.queries.minor(distance)) {
            minor = minorMeta.index; // Outer & Minor
          }
        } else if (Number.isNaN(outer)) {
          outer = 'auto';
          inner = 'auto';
        }
        return {
          outer,
          inner,
          minor,
          isDayOrShorter
        };
      }
    };
  }

  const PADDING$3 = 16;

  /**
   * Represent attributes of a set of qTicks. To reduce computation some
   * attributes are cached,
   */
  function attributes({
    qTicks,
    measureText = () => ({
      width: 0
    }),
    cache = {},
    scale
  }) {
    // TODO re-introduce the cache again. Temp removed because it could return invalid data.
    const attrsCache = cache;
    // const sumTextWidth = (prev, curr) => prev + measureText(`${curr.qText}`).width + PADDING;

    return {
      isDayOrShorter() {
        attrsCache.isDayOrShorter = qTicks.length > 0 && Math.abs(qTicks[0].qStart - qTicks[0].qEnd) <= 1;
        return attrsCache.isDayOrShorter;
      },
      count() {
        return qTicks.length;
      },
      maxRange() {
        attrsCache.maxRange = qTicks.length ? Math.max(...qTicks.map(tick => Math.abs(scale(tick.qStart) - scale(tick.qEnd)))) : 0;
        return attrsCache.maxRange;
      },
      rangeAndWidth() {
        // Cannot measure range if first or last tick might be clamp to 0 or 1. Such that the range is shortend.
        const clamp = scale.clamp();
        scale.clamp(false);
        attrsCache.rangeAndWidth = qTicks.map(tick => {
          const range = Math.abs(scale(tick.qStart) - scale(tick.qEnd));
          const width = measureText(`${tick.qText}`).width + PADDING$3;
          return {
            range,
            width
          };
        });
        scale.clamp(clamp);
        return attrsCache.rangeAndWidth;
      }
    };
  }

  // const MIN_REQ_OUTER_WIDTH = 90;
  const MIN_REQ_MINOR_WIDTH = 6;
  function queries({
    attrs,
    reqAutoFitWidth
  }) {
    return {
      outer(distance) {
        return !attrs.rangeAndWidth().some(({
          width,
          range
        }) => width > range * distance);
      },
      inner(distance) {
        return !attrs.rangeAndWidth().some(({
          width,
          range
        }) => width > range * distance);
      },
      minor(distance) {
        return attrs.maxRange() * distance >= MIN_REQ_MINOR_WIDTH;
      },
      canFitHalfDayTicks(distance) {
        const reqSize = reqAutoFitWidth * attrs.count();
        return distance >= reqSize;
      }
    };
  }

  /**
   * Creates meta objects for each qAxisData value, these objects contains data needed to
   * evaluate a specific qAxisData value.
   */
  function factory$1({
    qualified,
    nonQualified,
    qAxis,
    measureText,
    reqAutoFitWidth,
    scale
  }, {
    attributesFactory = attributes,
    queryFactory = queries
  } = {
    attributesFactory: attributes,
    queryFactory: queries
  }) {
    function createMeta(data, index) {
      const {
        qTicks
      } = data;
      const attrs = attributesFactory({
        qTicks,
        measureText,
        scale
      });
      return {
        data,
        index,
        attrs,
        queries: queryFactory({
          attrs,
          reqAutoFitWidth
        })
      };
    }
    const qAxisMeta = qAxis.map((data, i) => createMeta(data, i));
    const qualifiedMeta = qualified.map(i => qAxisMeta[i]);
    const nonQualifiedMeta = nonQualified.map(i => qAxisMeta[i]);
    return {
      qAxisMeta,
      qualifiedMeta,
      nonQualifiedMeta
    };
  }

  function isInvalidqAxisData(qAxis) {
    return !Array.isArray(qAxis) || qAxis.length === 0 || qAxis.every(lvl => lvl.qTicks.length === 0);
  }

  /**
   * The purpose of this module is given a qAxisData set, find an appropriate level for the outer and inner axis.
   *
   * @example
   * // With an qAxisData set of 5 levels [year, year-quarter, quarter, month, date]
   * // Find appropriate level for distance X. Which can result in an output like this:
   * { outer: 1, inner: 3, minor: 4 } // Year, Month, Date
   */
  function create$t({
    qAxis = [],
    measureText = () => ({
      width: 0
    }),
    cache = {},
    reqAutoFitWidth = 0,
    scale
  }, {
    metaFactory = factory$1,
    mapper: mapper$1 = mapper,
    resolver: resolver$1 = resolver
  } = {
    metaFactory: factory$1,
    mapper: mapper,
    resolver: resolver
  }) {
    const {
      qualified,
      nonQualified
    } = mapper$1({
      qAxis
    });
    const {
      qualifiedMeta,
      nonQualifiedMeta
    } = metaFactory({
      qAxis,
      qualified,
      nonQualified,
      measureText,
      reqAutoFitWidth,
      scale
    });
    const concreteResolver = resolver$1({
      qualifiedMeta,
      nonQualifiedMeta
    });
    return {
      resolve: distance => {
        const cacheKey = cache.key({
          distance
        });
        if (cache.get(cacheKey)) {
          return cache.get(cacheKey);
        }
        if (isInvalidqAxisData(qAxis)) {
          return {
            outer: 'auto',
            inner: 'auto',
            minor: NaN,
            isDayOrShorter: false
          };
        }
        const resolved = concreteResolver.resolve(distance);
        cache.set(cacheKey, resolved);
        return resolved;
      }
    };
  }

  const SECONDS_PER_DAY$2 = 86400; // (60 * 60 * 24)
  const MS_PER_DAY$1 = 86400000; // 1000 * 24 * 60 * 60;

  function QlikTimeToDate$1(value) {
    return new Date(Date.UTC(1899, 11, 30 + Math.floor(value), 0, 0, 0, Math.round(MS_PER_DAY$1 * (value - Math.floor(value)))));
  }
  const QT = QlikTimeToDate$1(0).getTime();
  function DateToQlikTimestamp(date) {
    return (date.getTime() - QT) / SECONDS_PER_DAY$2 / 1000;
  }

  const t0$1 = new Date(),
    t1$1 = new Date();
  function timeInterval$1(floori, offseti, count, field) {
    function interval(date) {
      return floori(date = arguments.length === 0 ? new Date() : new Date(+date)), date;
    }
    interval.floor = date => {
      return floori(date = new Date(+date)), date;
    };
    interval.ceil = date => {
      return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
    };
    interval.round = date => {
      const d0 = interval(date),
        d1 = interval.ceil(date);
      return date - d0 < d1 - date ? d0 : d1;
    };
    interval.offset = (date, step) => {
      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
    };
    interval.range = (start, stop, step) => {
      const range = [];
      start = interval.ceil(start);
      step = step == null ? 1 : Math.floor(step);
      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
      let previous;
      do range.push(previous = new Date(+start)), offseti(start, step), floori(start); while (previous < start && start < stop);
      return range;
    };
    interval.filter = test => {
      return timeInterval$1(date => {
        if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
      }, (date, step) => {
        if (date >= date) {
          if (step < 0) while (++step <= 0) {
            while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
          } else while (--step >= 0) {
            while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
          }
        }
      });
    };

    if (count) {
      interval.count = (start, end) => {
        t0$1.setTime(+start), t1$1.setTime(+end);
        floori(t0$1), floori(t1$1);
        return Math.floor(count(t0$1, t1$1));
      };
      interval.every = step => {
        step = Math.floor(step);
        return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? d => field(d) % step === 0 : d => interval.count(0, d) % step === 0);
      };
    }
    return interval;
  }

  const durationSecond$1 = 1000;
  const durationMinute$1 = durationSecond$1 * 60;
  const durationHour$1 = durationMinute$1 * 60;
  const durationDay$1 = durationHour$1 * 24;
  const durationWeek$1 = durationDay$1 * 7;

  const second = timeInterval$1(date => {
    date.setTime(date - date.getMilliseconds());
  }, (date, step) => {
    date.setTime(+date + step * durationSecond$1);
  }, (start, end) => {
    return (end - start) / durationSecond$1;
  }, date => {
    return date.getUTCSeconds();
  });
  second.range;

  const timeMinute = timeInterval$1(date => {
    date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond$1);
  }, (date, step) => {
    date.setTime(+date + step * durationMinute$1);
  }, (start, end) => {
    return (end - start) / durationMinute$1;
  }, date => {
    return date.getMinutes();
  });
  timeMinute.range;
  const utcMinute = timeInterval$1(date => {
    date.setUTCSeconds(0, 0);
  }, (date, step) => {
    date.setTime(+date + step * durationMinute$1);
  }, (start, end) => {
    return (end - start) / durationMinute$1;
  }, date => {
    return date.getUTCMinutes();
  });
  utcMinute.range;

  const timeHour = timeInterval$1(date => {
    date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond$1 - date.getMinutes() * durationMinute$1);
  }, (date, step) => {
    date.setTime(+date + step * durationHour$1);
  }, (start, end) => {
    return (end - start) / durationHour$1;
  }, date => {
    return date.getHours();
  });
  timeHour.range;
  const utcHour = timeInterval$1(date => {
    date.setUTCMinutes(0, 0, 0);
  }, (date, step) => {
    date.setTime(+date + step * durationHour$1);
  }, (start, end) => {
    return (end - start) / durationHour$1;
  }, date => {
    return date.getUTCHours();
  });
  utcHour.range;

  const timeDay$1 = timeInterval$1(date => date.setHours(0, 0, 0, 0), (date, step) => date.setDate(date.getDate() + step), (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationDay$1, date => date.getDate() - 1);
  timeDay$1.range;
  const utcDay$1 = timeInterval$1(date => {
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCDate(date.getUTCDate() + step);
  }, (start, end) => {
    return (end - start) / durationDay$1;
  }, date => {
    return date.getUTCDate() - 1;
  });
  utcDay$1.range;
  const unixDay$1 = timeInterval$1(date => {
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCDate(date.getUTCDate() + step);
  }, (start, end) => {
    return (end - start) / durationDay$1;
  }, date => {
    return Math.floor(date / durationDay$1);
  });
  unixDay$1.range;

  function timeWeekday$1(i) {
    return timeInterval$1(date => {
      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
      date.setHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setDate(date.getDate() + step * 7);
    }, (start, end) => {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;
    });
  }
  const timeSunday$1 = timeWeekday$1(0);
  const timeMonday$1 = timeWeekday$1(1);
  const timeTuesday$1 = timeWeekday$1(2);
  const timeWednesday$1 = timeWeekday$1(3);
  const timeThursday$1 = timeWeekday$1(4);
  const timeFriday$1 = timeWeekday$1(5);
  const timeSaturday$1 = timeWeekday$1(6);
  timeSunday$1.range;
  timeMonday$1.range;
  timeTuesday$1.range;
  timeWednesday$1.range;
  timeThursday$1.range;
  timeFriday$1.range;
  timeSaturday$1.range;
  function utcWeekday$1(i) {
    return timeInterval$1(date => {
      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCDate(date.getUTCDate() + step * 7);
    }, (start, end) => {
      return (end - start) / durationWeek$1;
    });
  }
  const utcSunday$1 = utcWeekday$1(0);
  const utcMonday$1 = utcWeekday$1(1);
  const utcTuesday$1 = utcWeekday$1(2);
  const utcWednesday$1 = utcWeekday$1(3);
  const utcThursday$1 = utcWeekday$1(4);
  const utcFriday$1 = utcWeekday$1(5);
  const utcSaturday$1 = utcWeekday$1(6);
  utcSunday$1.range;
  utcMonday$1.range;
  utcTuesday$1.range;
  utcWednesday$1.range;
  utcThursday$1.range;
  utcFriday$1.range;
  utcSaturday$1.range;

  const timeMonth = timeInterval$1(date => {
    date.setDate(1);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setMonth(date.getMonth() + step);
  }, (start, end) => {
    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
  }, date => {
    return date.getMonth();
  });
  timeMonth.range;
  const utcMonth = timeInterval$1(date => {
    date.setUTCDate(1);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCMonth(date.getUTCMonth() + step);
  }, (start, end) => {
    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
  }, date => {
    return date.getUTCMonth();
  });
  utcMonth.range;

  const timeYear$1 = timeInterval$1(date => {
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setFullYear(date.getFullYear() + step);
  }, (start, end) => {
    return end.getFullYear() - start.getFullYear();
  }, date => {
    return date.getFullYear();
  });

  // An optimized implementation for this simple case.
  timeYear$1.every = k => {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval$1(date => {
      date.setFullYear(Math.floor(date.getFullYear() / k) * k);
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setFullYear(date.getFullYear() + step * k);
    });
  };
  timeYear$1.range;
  const utcYear$1 = timeInterval$1(date => {
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCFullYear(date.getUTCFullYear() + step);
  }, (start, end) => {
    return end.getUTCFullYear() - start.getUTCFullYear();
  }, date => {
    return date.getUTCFullYear();
  });

  // An optimized implementation for this simple case.
  utcYear$1.every = k => {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval$1(date => {
      date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCFullYear(date.getUTCFullYear() + step * k);
    });
  };
  utcYear$1.range;

  const TIME_MAP = {
    second: 1,
    minute: 2,
    hour: 3,
    day: 4,
    month: 5,
    year: 6
  };
  function getInterval(start, end, distance, formats, isDayOrShorter, initialMin) {
    function createYearIntervalFilter(interval) {
      return utcYear$1.filter(d => (d.getUTCFullYear() - initialMin.getUTCFullYear()) % interval === 0);
    }
    const seconds = second.count(start, end);
    const minutes = utcMinute.count(start, end);
    const hours = utcHour.count(start, end);
    const days = utcDay$1.count(start, end);
    const weeks = utcSunday$1.count(start, end);
    const months = utcMonth.count(start, end);
    const years = utcYear$1.count(start, end);

    // Reserve space for 1 more tick as the first tick, may not be at the start of the scale
    const secondTicks = distance / formats.second.width - 1;
    const minuteTicks = distance / formats.minute.width - 1;
    const dayTicks = distance / formats.date.width - 1;
    const yearTicks = distance / formats.year.width - 1;
    const result = {
      type: 'year',
      desc: 'year',
      count: years,
      interval: utcYear$1.every(1),
      formatter: formats.year.formatter,
      offset: from => utcYear$1.offset(from, -1),
      floor: utcYear$1.floor
    };
    if (seconds <= secondTicks) {
      // Seconds
      result.type = TIME_MAP.second;
      result.desc = 'second';
      result.count = seconds;
      result.interval = second.every(1);
      result.formatter = formats.second.formatter;
      result.offset = from => second.offset(from, -1);
      result.floor = second.floor;
    } else if (seconds / 2 <= secondTicks) {
      result.type = TIME_MAP.second;
      result.desc = 'every other second';
      result.count = seconds / 2;
      result.interval = second.every(2);
      result.formatter = formats.second.formatter;
      result.offset = from => second.offset(from, -2);
      result.floor = second.floor;
    } else if (seconds / 5 <= secondTicks) {
      result.type = TIME_MAP.second;
      result.desc = 'every 5 second';
      result.count = seconds / 5;
      result.interval = second.every(5);
      result.formatter = formats.second.formatter;
      result.offset = from => second.offset(from, -5);
      result.floor = second.floor;
    } else if (seconds / 15 <= secondTicks) {
      result.type = TIME_MAP.second;
      result.desc = 'every 15 second';
      result.count = seconds / 15;
      result.interval = second.every(15);
      result.formatter = formats.second.formatter;
      result.offset = from => second.offset(from, -15);
      result.floor = second.floor;
    } else if (seconds / 30 <= secondTicks) {
      result.type = TIME_MAP.second;
      result.desc = 'every 30 second';
      result.count = seconds / 30;
      result.interval = second.every(30);
      result.formatter = formats.second.formatter;
      result.offset = from => second.offset(from, -30);
      result.floor = second.floor;
    } else if (minutes <= minuteTicks) {
      // Minutes
      result.type = TIME_MAP.minute;
      result.desc = 'minute';
      result.count = minutes;
      result.interval = utcMinute.every(1);
      result.formatter = formats.minute.formatter;
      result.offset = from => utcMinute.offset(from, -1);
      result.floor = utcMinute.floor;
    } else if (minutes / 2 <= minuteTicks) {
      result.type = TIME_MAP.minute;
      result.desc = 'every 2 minute';
      result.count = minutes / 2;
      result.interval = utcMinute.every(2);
      result.formatter = formats.minute.formatter;
      result.offset = from => utcMinute.offset(from, -2);
      result.floor = utcMinute.floor;
    } else if (minutes / 5 <= minuteTicks) {
      result.type = TIME_MAP.minute;
      result.desc = 'every 5 minute';
      result.count = minutes / 5;
      result.interval = utcMinute.every(5);
      result.formatter = formats.minute.formatter;
      result.offset = from => utcMinute.offset(from, -5);
      result.floor = utcMinute.floor;
    } else if (minutes / 10 <= minuteTicks) {
      result.type = TIME_MAP.minute;
      result.desc = 'every 10 minute';
      result.count = minutes / 10;
      result.interval = utcMinute.every(10);
      result.formatter = formats.minute.formatter;
      result.offset = from => utcMinute.offset(from, -10);
      result.floor = utcMinute.floor;
    } else if (minutes / 15 <= minuteTicks) {
      result.type = TIME_MAP.minute;
      result.desc = 'every 15 minute';
      result.count = minutes / 15;
      result.interval = utcMinute.every(15);
      result.formatter = formats.minute.formatter;
      result.offset = from => utcMinute.offset(from, -15);
      result.floor = utcMinute.floor;
    } else if (minutes / 30 <= minuteTicks) {
      result.type = TIME_MAP.minute;
      result.desc = 'every 30 minute';
      result.count = minutes / 30;
      result.interval = utcMinute.every(30);
      result.formatter = formats.minute.formatter;
      result.offset = from => utcMinute.offset(from, -30);
      result.floor = utcMinute.floor;
    } else if (hours <= minuteTicks) {
      // Hours
      result.type = TIME_MAP.hour;
      result.desc = 'hour';
      result.count = hours;
      result.interval = utcHour.every(1);
      result.formatter = formats.minute.formatter;
      result.offset = from => utcHour.offset(from, -1);
      result.floor = utcHour.floor;
    } else if (hours / 2 <= minuteTicks) {
      result.type = TIME_MAP.hour;
      result.desc = 'every 2 hour';
      result.count = hours / 2;
      result.interval = utcHour.every(2);
      result.formatter = formats.minute.formatter;
      result.offset = from => utcHour.offset(from, -2);
      result.floor = utcHour.floor;
    } else if (hours / 3 <= minuteTicks) {
      result.type = TIME_MAP.hour;
      result.desc = 'every 3 hour';
      result.count = hours / 3;
      result.interval = utcHour.every(3);
      result.formatter = formats.minute.formatter;
      result.offset = from => utcHour.offset(from, -3);
      result.floor = utcHour.floor;
    } else if (hours / 6 <= minuteTicks) {
      result.type = TIME_MAP.hour;
      result.desc = 'every 6 hour';
      result.count = hours / 6;
      result.interval = utcHour.every(6);
      result.formatter = formats.minute.formatter;
      result.offset = from => utcHour.offset(from, -6);
      result.floor = utcHour.floor;
    } else if (hours / 12 <= minuteTicks || isDayOrShorter) {
      result.type = TIME_MAP.hour;
      result.desc = 'every 12 hour';
      result.count = hours / 12;
      result.interval = utcHour.every(12);
      result.formatter = formats.minute.formatter;
      result.offset = from => utcHour.offset(from, -12);
      result.floor = utcHour.floor;
    } else if (days <= dayTicks) {
      // Days
      result.type = TIME_MAP.day;
      result.desc = 'day';
      result.count = days;
      result.interval = utcDay$1.every(1);
      result.formatter = formats.date.formatter;
      result.offset = from => utcDay$1.offset(from, -1);
      result.floor = utcDay$1.floor;
    } else if (days / 2 <= dayTicks) {
      result.type = TIME_MAP.day;
      result.desc = 'every 2 day';
      result.count = days / 2;
      result.interval = utcDay$1.every(2);
      result.formatter = formats.date.formatter;
      result.offset = from => utcDay$1.offset(from, -2);
      result.floor = utcDay$1.floor;
    } else if (days / 3 <= dayTicks) {
      result.type = TIME_MAP.day;
      result.desc = 'every 3 day';
      result.count = days / 3;
      result.interval = utcDay$1.every(3);
      result.formatter = formats.date.formatter;
      result.offset = from => utcDay$1.offset(from, -3);
      result.floor = utcDay$1.floor;
    } else if (weeks <= dayTicks) {
      // Weeks
      result.type = TIME_MAP.day;
      result.desc = 'week';
      result.count = weeks;
      result.interval = utcSunday$1.every(1);
      result.formatter = formats.date.formatter;
      result.offset = from => utcSunday$1.offset(from, -1);
      result.floor = utcDay$1.floor;
    } else if (weeks / 2 <= dayTicks) {
      result.type = TIME_MAP.day;
      result.desc = 'every 2 week';
      result.count = weeks / 2;
      result.interval = utcSunday$1.every(2);
      result.formatter = formats.date.formatter;
      result.offset = from => utcSunday$1.offset(from, -2);
      result.floor = utcDay$1.floor;
    } else if (months <= dayTicks) {
      // Month
      result.type = TIME_MAP.month;
      result.desc = 'month';
      result.count = months;
      result.interval = utcMonth.every(1);
      result.formatter = formats.date.formatter;
      result.offset = from => utcMonth.offset(from, -1);
      result.floor = utcDay$1.floor;
    } else if (months / 3 <= dayTicks) {
      result.type = TIME_MAP.month;
      result.desc = 'quarter';
      result.count = months / 3;
      result.interval = utcMonth.every(3);
      result.formatter = formats.date.formatter;
      result.offset = from => utcMonth.offset(from, -3);
      result.floor = utcDay$1.floor;
    } else if (months / 6 <= dayTicks) {
      result.type = TIME_MAP.month;
      result.desc = 'half year';
      result.count = months / 6;
      result.interval = utcMonth.every(6);
      result.formatter = formats.date.formatter;
      result.offset = from => utcMonth.offset(from, -6);
      result.floor = utcDay$1.floor;
    } else if (years <= yearTicks) {
      // Years
      result.type = TIME_MAP.year;
      result.desc = 'year';
      result.count = years;
      result.interval = utcYear$1.every(1);
      result.formatter = formats.year.formatter;
      result.offset = from => utcYear$1.offset(from, -1);
      result.floor = utcYear$1.floor;
    } else if (years / 2 <= yearTicks) {
      result.type = TIME_MAP.year;
      result.desc = 'every 2 year';
      result.count = years / 2;
      result.interval = createYearIntervalFilter(2);
      result.formatter = formats.year.formatter;
      result.offset = from => utcYear$1.offset(from, -2);
      result.floor = utcYear$1.floor;
    } else if (years / 5 <= yearTicks) {
      result.type = TIME_MAP.year;
      result.desc = 'every 5 year';
      result.count = years / 5;
      result.interval = createYearIntervalFilter(5);
      result.formatter = formats.year.formatter;
      result.offset = from => utcYear$1.offset(from, -5);
      result.floor = utcYear$1.floor;
    } else if (years / 10 <= yearTicks) {
      result.type = TIME_MAP.year;
      result.desc = 'every 10 year';
      result.count = years / 10;
      result.interval = createYearIntervalFilter(10);
      result.formatter = formats.year.formatter;
      result.offset = from => utcYear$1.offset(from, -10);
      result.floor = utcYear$1.floor;
    } else {
      const count = Math.floor(years / yearTicks);
      result.type = TIME_MAP.year;
      result.desc = 'every nth year';
      result.count = count;
      result.interval = createYearIntervalFilter(count);
      result.formatter = formats.year.formatter;
      result.offset = from => utcYear$1.offset(from, -count);
      result.floor = utcYear$1.floor;
    }
    return result;
  }

  function generateD3Ticks({
    timeScale,
    labels,
    distance,
    isDayOrShorter,
    cache,
    timeOnly,
    initialMin
  }) {
    const [startTime, endTime] = timeScale.domain();

    // Hackely hack hack to solve an issue with flickering due to the interval changes while user scroll/pan.
    const cacheKey = cache.key({
      distance
    });
    let result;
    if (cache.get(cacheKey, 1)) {
      result = cache.get(cacheKey, 1);
    } else {
      result = getInterval(startTime, endTime, distance, labels.all(), isDayOrShorter, initialMin);
      cache.set(cacheKey, result, 1);
    }
    const ticks = timeScale.ticks(result.interval);
    if (!ticks.length) {
      ticks.push(result.floor(startTime));
    } else if (startTime.getTime() !== ticks[0].getTime()) {
      ticks.unshift(result.offset(ticks[0]));
    }
    const inner = ticks.map((t, i, ary) => {
      const tickRange = ary[i + 1] ? ary[i + 1] - t : endTime - t;
      return {
        start: t,
        end: new Date(t.getTime() + tickRange),
        formatter: result.formatter
      };
    });
    let outer = [];
    if (!timeOnly && result.type <= TIME_MAP.hour) {
      const dateLabel = labels.getFormat('date');
      const dayTicks = timeScale.ticks(utcDay$1.every(1));
      if (dayTicks.length && startTime.getUTCDate() !== dayTicks[0].getUTCDate()) {
        dayTicks.unshift(utcDay$1.offset(dayTicks[0], -1));
      }
      outer = (dayTicks.length ? dayTicks : [utcDay$1.floor(startTime)]).map((t, i, ary) => {
        const tickRange = ary[i + 1] ? ary[i + 1] - t : endTime - t;
        return {
          start: t,
          end: new Date(t.getTime() + tickRange),
          formatter: dateLabel.formatter
        };
      });
    }
    return {
      inner,
      outer
    };
  }

  const SECONDS_PER_DAY$1 = 24 * 60 * 60;
  const MINUTES_PER_DAY = 24 * 60;
  const CACHE = {};
  function createDateTick(type, start, end, formatter) {
    return {
      type,
      start: new Date(Date.UTC(...start)),
      end: new Date(Date.UTC(...end)),
      formatter
    };
  }
  function generateTicks(labels, distance, dataMin, explicitPlotMin, explicitPlotMax, timeOnly = false) {
    if (CACHE[[distance, dataMin, explicitPlotMin, explicitPlotMin, timeOnly]]) {
      return CACHE[[distance, dataMin, explicitPlotMin, explicitPlotMin, timeOnly]];
    }
    const formats = {
      year: labels.getFormat('year'),
      date: labels.getFormat('date'),
      minute: labels.getFormat('minute'),
      second: labels.getFormat('second')
    };
    const minDataDate = QlikTimeToDate$1(dataMin);
    const minDataYear = minDataDate.getFullYear();
    const minDataMonth = minDataDate.getMonth();
    const minDataDay = minDataDate.getDate();
    const daysOffset = explicitPlotMin - dataMin;
    const dayDist = distance / (explicitPlotMax - explicitPlotMin);
    const minuteDist = dayDist / (24 * 60);
    const secondDist = dayDist / SECONDS_PER_DAY$1;
    const yearDist = dayDist * 366;
    const quarterDist = dayDist * 3 * 30;
    const secondsToSecondsRatio = formats.second.width / secondDist;
    const minutesToMinutesRatio = formats.minute.width / minuteDist;
    const quarterToDateRatio = formats.date.width / quarterDist;
    const yearToYearRatio = formats.year.width / yearDist;
    let newDate;
    let tick = 0;
    let m;
    let mNext;
    let approxTickSpacing = 0;
    let seconds = null;
    let minutes = null;
    let hours = null;
    let days = null;
    let months = null;
    let years = null;
    const result = {
      outer: [],
      inner: []
    };
    if (secondsToSecondsRatio < 1) {
      seconds = 1;
      approxTickSpacing = 1 / SECONDS_PER_DAY$1;
    } else if (secondsToSecondsRatio < 2) {
      seconds = 2;
      approxTickSpacing = 1 / SECONDS_PER_DAY$1 * 2;
    } else if (secondsToSecondsRatio < 5) {
      seconds = 5;
      approxTickSpacing = 1 / SECONDS_PER_DAY$1 * 5;
    } else if (secondsToSecondsRatio < 10) {
      seconds = 10;
      approxTickSpacing = 1 / SECONDS_PER_DAY$1 * 10;
    } else if (secondsToSecondsRatio < 30) {
      seconds = 30;
      approxTickSpacing = 1 / SECONDS_PER_DAY$1 * 30;
    } else if (minutesToMinutesRatio < 1) {
      minutes = 1;
      approxTickSpacing = 1 / MINUTES_PER_DAY;
    } else if (minutesToMinutesRatio < 2) {
      minutes = 2;
      approxTickSpacing = 1 / MINUTES_PER_DAY * 2;
    } else if (minutesToMinutesRatio < 5) {
      minutes = 5;
      approxTickSpacing = 1 / MINUTES_PER_DAY * 5;
    } else if (minutesToMinutesRatio < 10) {
      minutes = 10;
      approxTickSpacing = 1 / MINUTES_PER_DAY * 10;
    } else if (minutesToMinutesRatio < 30) {
      minutes = 30;
      approxTickSpacing = 1 / MINUTES_PER_DAY * 30;
    } else if (minutesToMinutesRatio < 60) {
      hours = 1;
      approxTickSpacing = 1 / 24;
    } else if (minutesToMinutesRatio < 60 * 2) {
      hours = 2;
      approxTickSpacing = 2 / 24;
    } else if (minutesToMinutesRatio < 60 * 6) {
      hours = 6;
      approxTickSpacing = 6 / 24;
    } else if (minutesToMinutesRatio < 60 * 12) {
      hours = 12;
      approxTickSpacing = 12 / 24;
    } else if (quarterToDateRatio < 1 / 90) {
      approxTickSpacing = 1;
      days = 1;
    } else if (quarterToDateRatio < 2 / 90) {
      approxTickSpacing = 2;
      days = 2;
    } else if (quarterToDateRatio < 7 / 90) {
      approxTickSpacing = 7;
      days = 7;
    } else if (quarterToDateRatio < 31 / 90) {
      months = 1;
      approxTickSpacing = 31;
    } else if (quarterToDateRatio < 1) {
      months = 3;
      approxTickSpacing = 3 * 30;
    } else if (yearToYearRatio < 1) {
      years = 1;
      approxTickSpacing = 366;
    } else if (yearToYearRatio < 2) {
      years = 2;
      approxTickSpacing = 366 * 2;
    } else if (yearToYearRatio < 5) {
      years = 5;
      approxTickSpacing = 5 * 365.25;
    } else {
      years = 10;
      approxTickSpacing = 10 * 365.25;
    }
    m = Math.floor((daysOffset + dataMin % 1) / approxTickSpacing);
    while (tick < explicitPlotMax) {
      mNext = m + 1;
      if (years) {
        newDate = createDateTick('year', [minDataYear + m * years, 0, 1], [minDataYear + mNext * years, 0, 1], formats.year.formatter);
      } else if (months) {
        newDate = createDateTick('month', [minDataYear, minDataMonth + m * months, 1], [minDataYear, minDataMonth + mNext * months, 1], formats.date.formatter);
      } else if (days) {
        newDate = createDateTick('day', [minDataYear, minDataMonth, minDataDay + m * days], [minDataYear, minDataMonth, minDataDay + mNext * days], formats.date.formatter);
      } else if (hours) {
        newDate = createDateTick('hour', [minDataYear, minDataMonth, minDataDay, 0 + m * hours], [minDataYear, minDataMonth, minDataDay, 0 + mNext * hours], formats.minute.formatter);
      } else if (minutes) {
        newDate = createDateTick('minute', [minDataYear, minDataMonth, minDataDay, 0, 0 + m * minutes], [minDataYear, minDataMonth, minDataDay, 0, 0 + mNext * minutes], formats.minute.formatter);
      } else {
        newDate = createDateTick('second', [minDataYear, minDataMonth, minDataDay, 0, 0, 0 + m * seconds], [minDataYear, minDataMonth, minDataDay, 0, 0, 0 + mNext * seconds], formats.second.formatter);
      }
      tick = DateToQlikTimestamp(newDate.start);
      result.inner.push(newDate);
      const dayLevelTick = Math.floor(tick);
      if (!timeOnly && !years && !months && !days) {
        const mainDate = {
          type: 'day',
          start: QlikTimeToDate$1(dayLevelTick),
          end: QlikTimeToDate$1(dayLevelTick + 1),
          formatter: formats.date.formatter,
          qStart: dayLevelTick
        };
        if (!result.outer[result.outer.length - 1] || result.outer[result.outer.length - 1].qStart !== mainDate.qStart) {
          result.outer.push(mainDate);
        }
      }
      m++;
    }
    result.min = explicitPlotMin;
    result.max = explicitPlotMax;
    CACHE[[distance, dataMin, explicitPlotMin, explicitPlotMin, timeOnly]] = result;
    return result;
  }

  function factory(scale, settings, labels) {
    const {
      generator,
      anchor,
      clamp,
      level
    } = settings.ticks;
    const {
      qNumFormat
    } = settings.formatter;
    scale.clamp(clamp);
    const [min, max] = scale.domain();
    const timeScale = d3ScaleTime().domain([QlikTimeToDate$1(min), QlikTimeToDate$1(max)]);
    timeScale.clamp(clamp);
    timeScale.range(settings.invert ? [1, 0] : [0, 1]);
    const gen = typeof generator === 'object' ? generator : {
      type: generator
    };
    let tickGenerator;
    if (gen.type === 'd3') {
      tickGenerator = (distance, isDayOrShorter) => generateD3Ticks({
        timeScale,
        labels,
        distance,
        isDayOrShorter,
        cache: settings.cache,
        timeOnly: qNumFormat.qType === 'T',
        initialMin: typeof gen.initialMin === 'undefined' ? timeScale.domain()[0] : QlikTimeToDate$1(generator.initialMin)
      });
    } else {
      tickGenerator = distance => generateTicks(labels, distance, gen.min, min, max, qNumFormat.qType === 'T');
    }
    const obj = {};
    obj.transform = (qTicks = [], {
      isMinor = false
    } = {}) => qTicks.map(tick => {
      let value;
      if (anchor === 'start') {
        value = tick.qStart;
      } else if (anchor === 'end') {
        value = tick.qEnd;
      } else {
        value = (tick.qStart + tick.qEnd) / 2;
      }
      const c = scale.clamp();
      if (isMinor) {
        scale.clamp(false);
      }
      const position = scale(value);
      const start = scale(tick.qStart);
      const end = scale(tick.qEnd);
      scale.clamp(c);
      return {
        value,
        position,
        start,
        end,
        label: tick.qText,
        isMinor,
        data: !isMinor ? {
          start: tick.qStart,
          end: tick.qEnd,
          scaleStart: scale.domain()[0]
        } : undefined
      };
    }).filter(t => t.position >= 0 && t.position <= 1);
    obj.generate = (distance = 100, isDayOrShorter) => {
      const result = tickGenerator(distance, isDayOrShorter);
      const ticks = result[level];
      return ticks.map(tick => {
        let value;
        if (anchor === 'start') {
          value = DateToQlikTimestamp(tick.start);
        } else if (anchor === 'end') {
          value = DateToQlikTimestamp(tick.end);
        } else {
          value = (DateToQlikTimestamp(tick.start) + DateToQlikTimestamp(tick.end)) / 2;
        }
        return {
          position: timeScale(tick.start),
          start: timeScale(tick.start),
          end: timeScale(tick.end),
          value,
          label: tick.formatter(value),
          isMinor: false,
          data: {
            start: DateToQlikTimestamp(tick.start),
            end: DateToQlikTimestamp(tick.end),
            scaleStart: scale.domain()[0]
          }
        };
      }).filter(t => t.position >= 0 && t.position <= 1);
    };
    return obj;
  }

  const SAMPLE_TIMESTAMP = 41000.2343433;
  const TIME_STAMP_REGEX = /t+/i;
  const TICK_PADDING = 16;
  const MIN_WIDTH = 60;
  function create$s(settings) {
    const obj = {};
    const {
      measureText,
      fn: createFormatter,
      localeInfo
    } = settings.formatter;
    const format = {
      second: {
        type: 'second',
        pattern: 'hh:mm:ss',
        width: MIN_WIDTH,
        formatter: undefined
      },
      minute: {
        type: 'minute',
        pattern: 'hh:mm',
        width: MIN_WIDTH,
        formatter: undefined
      },
      date: {
        type: 'date',
        pattern: 'YYYY-MM-DD',
        width: MIN_WIDTH,
        formatter: undefined
      },
      // fallback, use localeInfo.qDateFmt when available
      year: {
        type: 'year',
        pattern: 'YYYY',
        width: MIN_WIDTH,
        formatter: undefined
      }
    };
    if (localeInfo && TIME_STAMP_REGEX.test(localeInfo.qTimestampFmt)) {
      format.minute.pattern += ' tt';
      format.second.pattern += ' tt';
    }
    format.date.pattern = localeInfo && localeInfo.qDateFmt ? localeInfo.qDateFmt : format.date.pattern;
    Object.keys(format).forEach(key => {
      format[key].formatter = createFormatter(format[key].pattern);
      format[key].width = Math.max(format[key].width, measureText(format[key].formatter(SAMPLE_TIMESTAMP)).width + TICK_PADDING);
    });
    obj.getFormat = key => format[key];
    obj.all = () => format;
    obj.getFormatFromTicks = ticks => {
      const majorTicks = ticks.filter(t => !t.isMinor);
      const {
        length
      } = majorTicks;
      if (!length) {
        return format.date;
      }
      const start = QlikTimeToDate$1(majorTicks[0].data.start);
      const end = QlikTimeToDate$1(majorTicks[length - 1].data.start);
      if (utcDay$1.count(start, end) / length >= 1) {
        return format.date;
      }
      if (utcHour.count(start, end) / length > 0) {
        return format.minute;
      }
      if (utcMinute.count(start, end) / length > 0) {
        return format.second;
      }
      return format.date;
    };
    return obj;
  }

  function settingsResolver$1(settings, _default, context) {
    const resolved = {};
    Object.keys(_default).forEach(key => {
      const stgn = settings[key];
      const type = typeof stgn;
      if (type === 'function') {
        resolved[key] = stgn(context);
      } else if (type === 'object' && !Array.isArray(stgn)) {
        resolved[key] = extend$7(true, {}, _default[key], stgn);
      } else if (type === 'undefined') {
        resolved[key] = _default[key];
      } else {
        resolved[key] = stgn;
      }
    });
    return resolved;
  }

  const DEFAULT_SETTINGS$a = {
    min: NaN,
    max: NaN,
    invert: false,
    qAxis: [],
    field: undefined,
    formatter: {
      fn: () => val => val,
      measureText: () => ({
        width: 0,
        height: 0
      }),
      localeInfo: {},
      qNumFormat: {}
    },
    ticks: {
      generator: 'd3',
      // keying or object with generator specific props
      level: 'outer',
      anchor: undefined,
      // start or end, default to middle.
      clamp: false
    },
    cache: {
      get: () => false,
      set: () => {},
      key: () => ''
    }
  };
  function getMinMax$3(settings, qAxis) {
    let min = +settings.min;
    let max = +settings.max;
    if (Number.isNaN(min) && Number.isNaN(max) && Array.isArray(qAxis) && qAxis.length) {
      min = Math.min(...qAxis[qAxis.length - 1].qTicks.map(t => t.qStart));
      max = Math.max(...qAxis[qAxis.length - 1].qTicks.map(t => t.qEnd));
    }
    if (min === max) {
      // Assume single point, expand by half a day in each direction
      min -= 0.5;
      max += 0.5;
    }
    return {
      min: Number.isNaN(+min) ? 0 : min,
      max: Number.isNaN(+max) ? 1 : max
    };
  }
  function initNormScale$2(normScale, scale) {
    if (normScale.instance) {
      return;
    }
    normScale.instance = scale.copy(); // eslint-disable-line
    normScale.instance.domain(scale.domain());
    normScale.instance.clamp(true);
    normScale.instance.range(normScale.invert ? [1, 0] : [0, 1]);
  }
  function create$r(settings, data = {}) {
    const stgns = settingsResolver$1(settings, DEFAULT_SETTINGS$a, data);
    const {
      qAxis
    } = stgns;
    const d3Scale = linear$3();
    const normScale = {
      instance: null,
      invert: false
    };
    const {
      min,
      max
    } = getMinMax$3(stgns, qAxis);
    let lvl;
    let tickResolver;
    let ticks = [];
    const fn = function fn(v) {
      if (Number.isNaN(+v)) {
        return NaN;
      }
      return d3Scale(v);
    };
    fn.ticks = ({
      distance,
      resolve = lvl.resolve
    } = {}) => {
      const result = resolve(distance);
      const target = result[stgns.ticks.level]; // 'auto' or an index

      if (!Number.isNaN(+target)) {
        ticks = tickResolver.transform(qAxis[target].qTicks, {
          isMinor: false
        });
      }
      if (!Number.isNaN(+result.minor)) {
        const mt = tickResolver.transform(qAxis[result.minor].qTicks, {
          isMinor: true
        });
        ticks = ticks.concat(mt);
      }
      if (target === 'auto') {
        ticks = tickResolver.generate(distance, result.isDayOrShorter);
      }
      return ticks;
    };
    fn.invert = v => d3Scale.invert(v);
    fn.domain = d => Array.isArray(d) ? d3Scale.domain(d) : d3Scale.domain();
    fn.range = r => Array.isArray(r) ? d3Scale.range(r) : d3Scale.range();
    fn.norm = v => {
      initNormScale$2(normScale, fn);
      return normScale.instance(v);
    };
    fn.normInvert = v => {
      initNormScale$2(normScale, fn);
      return normScale.instance.invert(v);
    };
    fn.copy = () => create$r(settings, data);
    fn.clamp = (value = true) => {
      d3Scale.clamp(value);
      return d3Scale.clamp();
    };

    /**
     * Get the minimum value of the domain
     * @return { number }
     */
    fn.min = () => Math.min(min, max);

    /**
     * Get the maximum value of the domain
     * @return { number }
     */
    fn.max = () => Math.max(min, max);
    d3Scale.range(stgns.invert ? [1, 0] : [0, 1]);
    d3Scale.domain([min, max]);
    normScale.invert = stgns.invert;
    const labels = create$s(stgns);
    // Copy as tick generator might set clamp specifically for ticks
    // Slightly risky as the scale in tickGenerator might be out of sync of any of the fn methods changes the d3scale
    tickResolver = factory(d3Scale.copy(), stgns, labels);
    lvl = create$t({
      qAxis,
      measureText: stgns.formatter.measureText,
      reqAutoFitWidth: labels.getFormat('minute').width * 2,
      // Double to ensure half day ticks fits
      cache: stgns.cache,
      scale: fn
    });
    fn.data = () => ({
      fields: [{
        formatter: fn.formatter,
        id: () => `qHyperCube/${stgns.field}`,
        key: () => stgns.field,
        raw: bt(data, 'fields.0.raw', () => ({}))
      }]
    });
    fn.formatter = () => labels.getFormatFromTicks(ticks).formatter;
    return fn;
  }

  const eventName$4 = 'continuousPan';
  const threshold$3 = 10;
  function createAreaPan({
    targetKey,
    chart,
    actions,
    viewState,
    viewCache
  }) {
    return {
      type: 'Pan',
      key: 'continuous:pan',
      options: {
        event: eventName$4,
        pointers: 1,
        threshold: threshold$3,
        enable(r, e) {
          if (this.started === eventName$4 || !e) {
            return true;
          }
          if (!actions.scroll.enabled()) {
            return false;
          }
          return chart.componentsFromPoint({
            x: e.center.x,
            y: e.center.y
          }).some(c => c.key === targetKey);
        }
      },
      events: {
        [`${eventName$4}start`](e) {
          e.preventDefault();
          this.started = eventName$4;
          const {
            min,
            max
          } = viewState.get('zoom');
          this[eventName$4] = {
            min,
            max,
            size: chart.component(targetKey).rect.computedInner.width,
            span: max - min
          };
        },
        [`${eventName$4}move`](e) {
          e.preventDefault();
          const {
            span,
            min,
            max,
            size
          } = this[eventName$4];
          const relativeDelta = -(e.deltaX / size);
          viewState.set('zoom', {
            min: Math.min(min + relativeDelta * span, viewCache.get('continuousMax') - span),
            max: Math.max(max + relativeDelta * span, viewCache.get('continuousMin') + span)
          });
        },
        [`${eventName$4}end`](e) {
          e.preventDefault();
          this.started = false;
        },
        [`${eventName$4}cancel`](e) {
          e.preventDefault();
          this.started = false;
        }
      }
    };
  }

  var continuous$1 = {
    model: create$x,
    event: {
      onZoomChange,
      onZoomIntercept,
      onZoom: create$w
    },
    interactions: {
      areaPan: createAreaPan
    },
    picassoComponents: {
      axisOverlay,
      timeAxis
    },
    picassoScales: {
      time: create$r
    }
  };

  function configureViewState({
    core,
    options,
    services
  }) {
    const {
      viewCache,
      viewState
    } = core;
    const {
      chartModel,
      continuousModel,
      discreteModel,
      layoutService,
      legendModel,
      refLineModel
    } = services;
    const {
      isContinuous,
      isDiscrete,
      isSnapshot
    } = layoutService.meta;
    const viewStateOptions = options.viewState || {};
    const source = isSnapshot ? layoutService.getLayoutValue('snapshotData.content.chartData', {}) : viewStateOptions;
    viewState.preventSet('scrollOffset', source.scrollOffset);
    viewState.preventSet('legendScrollOffset', source.legendScrollOffset || 0);
    if (source.zoom) {
      viewState.preventSet('zoom', source.zoom);
    }
    const {
      onZoomChange,
      onZoomIntercept
    } = continuous$1.event;
    if (isDiscrete) {
      viewState.onChanged('scrollOffset', () => {
        legendModel.command.setDataPages([discreteModel.query.getCurrentDataPage()]);
        refLineModel.update();
        chartModel.command.updatePartial();
      });
    }
    if (isContinuous) {
      viewState.intercept('zoom', onZoomIntercept({
        viewCache
      }));
      viewState.onChanged('zoom', onZoomChange({
        continuousDataModel: continuousModel,
        layoutService
      }, chartModel.command.updatePartial));
    }
  }

  var KEYS = {
    DATA: {
      MAIN: 'qHyperCube',
      LEGEND: 'legend-data',
      REDUCED: 'reduced-data'
    },
    SCALE: {
      MAIN: {
        MINOR: 'main-minor',
        MAJOR: 'main-major',
        MAJOR_INNER: 'main-major-inner',
        COLOR: 'color'
      },
      REDUCED: {
        MINOR: 'reduced-minor',
        MAJOR: 'reduced-major',
        COLOR: 'reduced-color'
      }
    },
    COMPONENT: {
      LINE: 'line-component',
      POINT: 'point-component',
      GHOST_POINT: 'ghost-point-component',
      MAJOR_AXIS: 'major-axis-component',
      MAJOR_AXIS_CONTINUOUS: 'major-axis-continuous-component',
      MAJOR_AXIS_TIME_INNER: 'major-axis-time-inner-component',
      MAJOR_AXIS_TIME_OUTER: 'major-axis-time-outer-component',
      MINOR_AXIS: 'minor-axis-component',
      MAJOR_AXIS_OVERLAY_CONTINUOUS: 'major-axis-overlay-continuous-component',
      MAJOR_AXIS_OVERLAY_TIME_INNER: 'major-axis-overlay-time-inner-component',
      MAJOR_AXIS_OVERLAY_TIME_OUTER: 'major-axis-overlay-time-outer-component',
      REDUCED_LINE: 'reduced-line-component',
      POINT_TOOLTIP: 'tooltip-qcm',
      LABEL_SPACE: 'label-space-component',
      LEGEND_TOOLTIP: 'legend-tooltip',
      MAJOR_AXIS_TITLE: 'major-axis-title',
      MINOR_AXIS_TITLE: 'minor-axis-title',
      GRID_LINE: 'grid-line',
      ZERO_LINE: 'zero-line',
      MEASURE_REF_LINE: 'mes-ref-line',
      DIMENSION_REF_LINE: 'dim-ref-line',
      MEASURE_REF_LINE_LABEL: 'mes-ref-line-label',
      DIMENSION_REF_LINE_LABEL: 'dim-ref-line-label',
      LEGEND: 'legend-color',
      LEGEND_CATEGORICAL: 'legend-color-cat',
      OUT_OF_MAX_BOUNDS: 'out-of-max-bounds-marker',
      OUT_OF_MIN_BOUNDS: 'out-of-min-bounds-marker',
      TREND_LINES_TOOLTIP: 'trend-lines-tooltip',
      TREND_LINES_TOOLTIP_OVERLAY: 'trend-lines-tooltip-overlay',
      FORECAST_POINT: 'forcast-points',
      FORECAST_LINE: 'forcast-lines',
      FORECAST_CONFIDENCE: 'forcast-confidence',
      FORECAST_OUT_OF_MAX_BOUNDS: 'forecast-out-of-max-bounds-marker',
      FORECAST_OUT_OF_MIN_BOUNDS: 'forecast-out-of-min-bounds-marker',
      FORECAST_REDUCED_LINE: 'forcast-reduced-lines',
      FORECAST_REDUCED_CONFIDENCE: 'forcast-reduced-confidence',
      BRUSH_HIGHLIGHTER: 'brush-highlighter',
      RANGE_BRUSH_HIGHLIGHTER: 'range-brush-highlighter',
      POINT_LABEL: 'point-label'
    },
    COLLECTION: {
      MAIN: 'main-collection',
      REDUCED: 'reduced-collection',
      FORECAST: 'forecast-collection',
      REDUCED_FORECAST: 'reduced-forecast-collection'
    },
    FORMATTER: {
      MINOR: 'minor',
      COLOR: 'color'
    },
    RANGE: {
      CONTINUOUS: 'continuous-range-brush'
    }
  };

  function useGetViewState({
    core
  }) {
    stardust.useImperativeHandle(() => ({
      getViewState() {
        var _legend$_DO_NOT_USE_g;
        if (!core) {
          return undefined;
        }
        const {
          chart,
          viewState
        } = core;
        const legend = chart.component(KEYS.COMPONENT.LEGEND_CATEGORICAL);
        return {
          scrollOffset: viewState.get('scrollOffset'),
          zoom: viewState.get('zoom'),
          // eslint-disable-next-line camelcase
          legendScrollOffset: legend === null || legend === void 0 || (_legend$_DO_NOT_USE_g = legend._DO_NOT_USE_getInfo) === null || _legend$_DO_NOT_USE_g === void 0 ? void 0 : _legend$_DO_NOT_USE_g.call(legend).offset
        };
      }
    }), [core]);
  }

  /* eslint-disable no-param-reassign */
  function useOnTakeSnapshot({
    core,
    services
  }) {
    stardust.onTakeSnapshot(layout => {
      if (!core || !services) {
        return undefined;
      }
      const {
        chart,
        viewState
      } = core;
      const {
        colorService,
        continuousModel,
        discreteModel,
        dockService,
        layoutService,
        reducedModel
      } = services;
      const {
        isDiscrete,
        isSnapshot
      } = layoutService.meta;
      const {
        width: w,
        height: h
      } = dockService.meta.chart.size;
      layout.snapshotData = layout.snapshotData || {};
      layout.snapshotData.content = {
        size: {
          w,
          h
        }
      };

      /**
       * If the layout we are working with already is a snapshot, there is no need to recreate the chartData.
       * This will for example occur when doing a free-resize in story telling.
       */
      if (isSnapshot) {
        return Promise.resolve();
      }
      layout.snapshotData.content.chartData = {
        scrollOffset: viewState.get('scrollOffset'),
        zoom: viewState.get('zoom'),
        legendScrollOffset: getLegendScrollOffset(chart, KEYS.COMPONENT.LEGEND_CATEGORICAL)
      };
      if (isDiscrete) {
        discreteModel.command.setSnapshotData(layout);
        reducedModel.command.setSnapshotData(layout);
      } else {
        continuousModel.setSnapshotData(layout);
      }
      return colorService.getMain().getSnapshotData().then(data => {
        layout.snapshotData.content.chartData = {
          ...layout.snapshotData.content.chartData,
          ...data
        };
      }).catch(() => {});
    });
  }

  /* eslint-disable consistent-return */
  function useBootstrap({
    core,
    services
  }) {
    const app = stardust.useApp();
    const model = stardust.useModel();
    const options = stardust.useOptions();
    const renderState = stardust.useRenderState();
    useGetViewState({
      core
    });
    useOnTakeSnapshot({
      core,
      services
    });
    const [resolved, rejected] = stardust.usePromise(() => {
      if (!core || !services) {
        return Promise.resolve();
      }
      const {
        flags
      } = core;
      const {
        chartModel,
        colorService,
        continuousModel,
        customTooltipService,
        disclaimerModel,
        extremumModel,
        layoutService,
        pluginService,
        reducedModel,
        selectionService,
        tooltipService,
        largeDataService
      } = services;
      const {
        isContinuous,
        isSnapshot
      } = layoutService.meta;
      configureViewState({
        core,
        options,
        services
      });
      const queries = [];
      if (!isSnapshot) {
        queries.push(model.getEffectiveProperties());
      }
      if (isContinuous) {
        largeDataService.clear();
        queries.push(continuousModel.initialFetch());
      }
      queries.push(reducedModel.command.initialize());
      return Promise.all(queries).then(async result => {
        const properties = result[0] || undefined;
        if (properties !== null && properties !== void 0 && properties.qHyperCubeDef) {
          const propertiesUpdater = createPropertiesUpdater({
            app,
            model,
            properties,
            layoutService,
            flags
          });
          if (propertiesUpdater.shouldUpdate()) {
            await propertiesUpdater.update();
            renderState.pending();
            return;
          }
          renderState.restore();
        }
        customTooltipService.setProperties(properties);
        tooltipService.expando.set('properties', properties);
        await pluginService.initialize();
        await extremumModel.command.initialize();
        await colorService.initialize();

        /**
         * Requires extremum-model to have been initialized.
         */
        disclaimerModel.command.initialize();

        /**
         * Requires reduced-model to have been initialized.
         */
        chartModel.command.initialize();
        const {
          field: colorField
        } = colorService.getMain().getSettings();
        selectionService.setBrushAliases({
          colorField,
          useLegendCube: chartModel.query.getIsUsingLegendCube(),
          legendAlias: `${KEYS.DATA.LEGEND}/${colorField}`
        });
        return {
          properties
        };
      });
    }, [core, services]);
    if (rejected && !rejected.isHandled) {
      throw rejected;
    }
    return resolved;
  }

  var CLASSIFICATIONS = {
    UNCLASSIFIED: 'unclassified',
    EQUAL_EQUAL: 'equal-equal',
    EQUAL_HIGHER: 'equal-higher',
    EQUAL_LOWER: 'equal-lower',
    EQUAL_VOID: 'equal-void',
    HIGHER_EQUAL: 'higher-equal',
    HIGHER_HIGHER_ACUTE: 'higher-higher-acute',
    HIGHER_HIGHER_OBTUSE: 'higher-higher-obtuse',
    HIGHER_LOWER_NEGATIVE: 'higher-lower-negative',
    HIGHER_LOWER_POSITIVE: 'higher-lower-positive',
    HIGHER_VOID: 'higher-void',
    LOWER_EQUAL: 'lower-equal',
    LOWER_HIGHER_NEGATIVE: 'lower-higher-negative',
    LOWER_HIGHER_POSITIVE: 'lower-higher-positive',
    LOWER_LOWER_ACUTE: 'lower-lower-acute',
    LOWER_LOWER_OBTUSE: 'lower-lower-obtuse',
    LOWER_VOID: 'lower-void',
    VOID_EQUAL: 'void-equal',
    VOID_HIGHER: 'void-higher',
    VOID_LOWER: 'void-lower',
    VOID_VOID: 'void-void'
  };

  function fromTwo(origin, a) {
    return Math.atan2(a.y - origin.y, a.x - origin.x) * (180 / Math.PI);
  }
  function fromThree(a, b, c) {
    const ab = Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);
    const bc = Math.sqrt((b.x - c.x) ** 2 + (b.y - c.y) ** 2);
    const ac = Math.sqrt((c.x - a.x) ** 2 + (c.y - a.y) ** 2);
    return Math.acos((bc * bc + ab * ab - ac * ac) / (2 * bc * ab)) * (180 / Math.PI);
  }

  function classify$1({
    previous,
    current,
    next
  }) {
    const previousValue = previous && previous.value;
    const currentValue = current && current.value;
    const nextValue = next && next.value;
    if (!previous && !next) {
      return CLASSIFICATIONS.VOID_VOID;
    }
    if (!previous) {
      if (currentValue === nextValue) {
        return CLASSIFICATIONS.VOID_EQUAL;
      }
      return currentValue < nextValue ? CLASSIFICATIONS.VOID_HIGHER : CLASSIFICATIONS.VOID_LOWER;
    }
    if (!next) {
      if (previousValue === currentValue) {
        return CLASSIFICATIONS.EQUAL_VOID;
      }
      return previousValue > currentValue ? CLASSIFICATIONS.HIGHER_VOID : CLASSIFICATIONS.LOWER_VOID;
    }
    if (previousValue === currentValue) {
      if (currentValue === nextValue) {
        return CLASSIFICATIONS.EQUAL_EQUAL;
      }
      return currentValue < nextValue ? CLASSIFICATIONS.EQUAL_HIGHER : CLASSIFICATIONS.EQUAL_LOWER;
    }
    if (currentValue === nextValue) {
      return previousValue > currentValue ? CLASSIFICATIONS.HIGHER_EQUAL : CLASSIFICATIONS.LOWER_EQUAL;
    }
    if (previousValue > currentValue) {
      if (currentValue < nextValue) {
        return fromThree(previous, current, next) > 90 ? CLASSIFICATIONS.HIGHER_HIGHER_OBTUSE : CLASSIFICATIONS.HIGHER_HIGHER_ACUTE;
      }
      return fromTwo(previous, current) > fromTwo(previous, next) ? CLASSIFICATIONS.HIGHER_LOWER_POSITIVE : CLASSIFICATIONS.HIGHER_LOWER_NEGATIVE;
    }
    if (currentValue > nextValue) {
      return fromThree(previous, current, next) > 90 ? CLASSIFICATIONS.LOWER_LOWER_OBTUSE : CLASSIFICATIONS.LOWER_LOWER_ACUTE;
    }
    return fromTwo(previous, current) > fromTwo(previous, next) ? CLASSIFICATIONS.LOWER_HIGHER_POSITIVE : CLASSIFICATIONS.LOWER_HIGHER_NEGATIVE;
  }

  function classify({
    groups
  }) {
    for (let i = 0; i < groups.length; i++) {
      const items = Object.keys(groups[i]).map(key => groups[i][key]);
      for (let j = 0; j < items.length; j++) {
        const item = items[j];
        const classification = classify$1({
          previous: groups[i - 1] && groups[i - 1][item.line],
          current: item,
          next: groups[i + 1] && groups[i + 1][item.line]
        });
        item.setClassification(classification);
      }
    }
  }

  function getMeta({
    nodes
  }) {
    const extrema = {
      top: [],
      right: [],
      bottom: [],
      left: []
    };
    const items = nodes.map(node => {
      const {
        localBounds
      } = node;
      const center = {
        x: localBounds.x + localBounds.width / 2,
        y: localBounds.y + localBounds.height / 2
      };
      const key = `${center.x}-${center.y}`;
      return {
        key,
        center
      };
    });
    const accumulated = items.reduce((accumulator, item) => {
      if (!accumulator.top || item.center.y < accumulator.top.center.y) {
        accumulator.top = item;
      }
      if (!accumulator.right || item.center.x > accumulator.right.center.x) {
        accumulator.right = item;
      }
      if (!accumulator.bottom || item.center.y > accumulator.bottom.center.y) {
        accumulator.bottom = item;
      }
      if (!accumulator.left || item.center.x < accumulator.left.center.x) {
        accumulator.left = item;
      }
      return accumulator;
    }, {});
    extrema.top = items.filter(i => i.center.y === accumulated.top.center.y).map(i => i.key);
    extrema.right = items.filter(i => i.center.x === accumulated.right.center.x).map(i => i.key);
    extrema.bottom = items.filter(i => i.center.y === accumulated.bottom.center.y).map(i => i.key);
    extrema.left = items.filter(i => i.center.x === accumulated.left.center.x).map(i => i.key);
    return {
      getExtrema: key => ({
        top: extrema.top.indexOf(key) !== -1,
        right: extrema.right.indexOf(key) !== -1,
        bottom: extrema.bottom.indexOf(key) !== -1,
        left: extrema.left.indexOf(key) !== -1
      }),
      getExtreme: key => {
        const {
          top,
          right,
          bottom,
          left
        } = extrema;
        return [top, right, bottom, left].some(i => i.indexOf(key) !== -1);
      }
    };
  }

  /* eslint-disable no-param-reassign */
  function group({
    nodes,
    by,
    lineIndex
  }) {
    const hash = nodes.reduce((grouped, node, index) => {
      const key = by(node.data);
      if (!grouped[key]) {
        grouped[key] = {
          items: [],
          index
        };
      }
      grouped[key].items.push({
        node,
        line: node.data[lineIndex].value
      });
      return grouped;
    }, {});
    return Object.keys(hash).map(key => hash[key]).sort((a, b) => a.index - b.index).map(item => item.items);
  }

  function inside$1({
    bounds,
    size
  }) {
    const {
      x,
      y,
      width,
      height
    } = bounds;
    const {
      insideStrategy
    } = size;
    if (insideStrategy === 'center') {
      return Math.floor(x + width / 2) >= 0 && Math.ceil(x + width / 2) <= size.width && Math.floor(y + height / 2) >= 0 && Math.ceil(y + height / 2) <= size.height;
    }
    return Math.floor(x + width) > 0 && Math.ceil(x) < size.width && Math.floor(y + height / 2) >= 0 && Math.ceil(y + height / 2) <= size.height;
  }

  const PADDING$2 = {
    X: 1,
    Y: 0
  };
  function createItem({
    node,
    line,
    groupIndex,
    extract,
    style,
    measureText,
    size,
    horizontal,
    rtl,
    meta,
    showLabel
  }) {
    const text = extract.label(node.data);
    if (typeof text !== 'string' && typeof text !== 'number' || text === '') {
      return false;
    }
    const labelMeasurements = measureText({
      fontFamily: style.fontFamily,
      fontSize: style.fontSize,
      text
    });
    const {
      localBounds
    } = node;
    const {
      'stroke-width': strokeWidth
    } = node.attrs;
    const value = extract.pointValue(node.data);
    const bounds = {
      x: localBounds.x + localBounds.width / 2,
      y: localBounds.y + localBounds.height / 2,
      width: labelMeasurements.width + PADDING$2.X * 2,
      height: labelMeasurements.height + PADDING$2.Y * 2
    };
    const key = `${bounds.x}-${bounds.y}`;
    const invert = !horizontal && !rtl;
    const measurement = horizontal ? size.height : size.width;
    const threshold = measurement <= 200 ? 0.25 : 0.1;
    const coordinate = horizontal ? bounds.y : bounds.x;
    const ratio = coordinate / measurement;
    const elite = (invert ? 1 - ratio : ratio) <= threshold;
    const item = {
      key,
      node,
      line,
      group: groupIndex,
      value,
      labelMeasurements,
      bounds,
      inside: inside$1({
        bounds: localBounds,
        size
      }),
      border: strokeWidth ? strokeWidth / 2 : 0,
      classification: CLASSIFICATIONS.UNCLASSIFIED,
      setClassification(c) {
        item.classification = c;
      },
      preferences: [],
      setPreferences(p) {
        item.preferences.push(...p);
      },
      placement: undefined,
      setPlacement(p) {
        item.placement = p;
      },
      duplicate: false,
      setDuplicate() {
        item.duplicate = true;
      },
      extreme: meta.getExtreme(key),
      elite,
      show: showLabel(node)
    };
    return item;
  }

  function createGroups$2({
    nodes,
    extract,
    style,
    measureText,
    size,
    horizontal,
    rtl,
    showLabel
  }) {
    const meta = getMeta({
      nodes
    });
    const groups = group({
      nodes,
      by: extract.majorValue,
      lineIndex: extract.lineIndex
    }).map((nodeGroup, index) => {
      const items = nodeGroup.map(ng => ({
        line: ng.line,
        item: createItem({
          node: ng.node,
          line: ng.line,
          groupIndex: index,
          extract,
          style,
          measureText,
          size,
          horizontal,
          rtl,
          meta,
          showLabel
        })
      })).filter(item => item.item);
      return items.reduce((accumulator, item) => {
        accumulator[item.line] = item.item;
        return accumulator;
      }, {});
    });
    return groups.filter(group => Object.keys(group).length);
  }

  function createLines({
    groups,
    threshold
  }) {
    const mappedGroups = groups.map(g => Object.keys(g).map(key => g[key]));
    const hash = {};
    for (let i = 0; i <= mappedGroups.length; i++) {
      const group = mappedGroups[i];
      if (group) {
        for (let j = 0; j < group.length; j++) {
          const item = group[j];
          const {
            line
          } = item;
          if (!hash[line]) {
            hash[line] = [];
          }
          hash[line].push(item.bounds);
        }
      }
    }
    const matrix = Object.keys(hash).map(key => hash[key]);
    const lines = [];
    for (let j = 0; j < matrix.length; j++) {
      for (let y = 0; y < matrix[j].length - 1; y++) {
        const point1 = matrix[j][y];
        const point2 = matrix[j][y + 1];
        const line = {
          x1: point1.x,
          y1: point1.y,
          x2: point2.x,
          y2: point2.y
        };
        const a = line.x1 - line.x2;
        const b = line.y1 - line.y2;
        const length = Math.sqrt(a * a + b * b);
        if (length > threshold) {
          lines.push(line);
        }
      }
    }
    return lines;
  }

  var POSITIONS = {
    TOP: 'top',
    TOP_RIGHT: 'top-right',
    RIGHT: 'right',
    BOTTOM_RIGHT: 'bottom-right',
    BOTTOM: 'bottom',
    BOTTOM_LEFT: 'bottom-left',
    LEFT: 'left',
    TOP_LEFT: 'top-left'
  };

  var PREFERENCES = {
    [CLASSIFICATIONS.EQUAL_EQUAL]: [POSITIONS.TOP, POSITIONS.BOTTOM],
    [CLASSIFICATIONS.EQUAL_HIGHER]: [POSITIONS.BOTTOM, POSITIONS.BOTTOM_RIGHT],
    [CLASSIFICATIONS.EQUAL_LOWER]: [POSITIONS.TOP, POSITIONS.TOP_RIGHT],
    [CLASSIFICATIONS.EQUAL_VOID]: [POSITIONS.TOP, POSITIONS.BOTTOM],
    [CLASSIFICATIONS.HIGHER_EQUAL]: [POSITIONS.LEFT, POSITIONS.BOTTOM_LEFT, POSITIONS.TOP, POSITIONS.TOP_RIGHT],
    [CLASSIFICATIONS.HIGHER_HIGHER_ACUTE]: [POSITIONS.BOTTOM, POSITIONS.BOTTOM_LEFT, POSITIONS.LEFT, POSITIONS.TOP_RIGHT],
    [CLASSIFICATIONS.HIGHER_HIGHER_OBTUSE]: [POSITIONS.BOTTOM, POSITIONS.TOP],
    [CLASSIFICATIONS.HIGHER_LOWER_NEGATIVE]: [POSITIONS.TOP, POSITIONS.TOP_RIGHT, POSITIONS.RIGHT],
    [CLASSIFICATIONS.HIGHER_LOWER_POSITIVE]: [POSITIONS.BOTTOM, POSITIONS.BOTTOM_LEFT, POSITIONS.LEFT],
    [CLASSIFICATIONS.HIGHER_VOID]: [POSITIONS.TOP],
    [CLASSIFICATIONS.LOWER_EQUAL]: [POSITIONS.TOP],
    [CLASSIFICATIONS.LOWER_HIGHER_NEGATIVE]: [POSITIONS.TOP, POSITIONS.TOP_LEFT],
    [CLASSIFICATIONS.LOWER_HIGHER_POSITIVE]: [POSITIONS.BOTTOM_RIGHT],
    [CLASSIFICATIONS.LOWER_LOWER_ACUTE]: [POSITIONS.TOP, POSITIONS.TOP_LEFT, POSITIONS.LEFT, POSITIONS.TOP_RIGHT, POSITIONS.RIGHT],
    [CLASSIFICATIONS.LOWER_LOWER_OBTUSE]: [POSITIONS.TOP, POSITIONS.BOTTOM],
    [CLASSIFICATIONS.LOWER_VOID]: [POSITIONS.TOP],
    [CLASSIFICATIONS.VOID_EQUAL]: [POSITIONS.TOP],
    [CLASSIFICATIONS.VOID_HIGHER]: [POSITIONS.TOP, POSITIONS.BOTTOM],
    [CLASSIFICATIONS.VOID_LOWER]: [POSITIONS.TOP, POSITIONS.BOTTOM, POSITIONS.LEFT],
    [CLASSIFICATIONS.VOID_VOID]: [POSITIONS.TOP]
  };

  function createModel({
    nodes,
    extract,
    style,
    measureText,
    size,
    horizontal,
    rtl,
    showLabel
  }) {
    const groups = createGroups$2({
      nodes,
      extract,
      style,
      measureText,
      size,
      horizontal,
      rtl,
      showLabel
    });
    const flattened = [...groups.reduce((items, group) => {
      items.push(...Object.keys(group).map(key => group[key]));
      return items;
    }, [])];
    const [first] = flattened;
    const lines = createLines({
      groups,
      threshold: first.node.localBounds.height
    });
    const model = {
      getItems() {
        return flattened;
      },
      getLines() {
        return lines;
      }
    };
    classify({
      groups
    });
    model.getItems().forEach(item => item.setPreferences(PREFERENCES[item.classification]));
    return model;
  }

  function prioritize({
    model
  }) {
    const items = model.getItems();
    items.sort((a, b) => {
      if (a.extreme === b.extreme) {
        return 0;
      }
      return a.extreme && !b.extreme ? -1 : 1;
    });
  }

  function inside({
    item,
    placement,
    size
  }) {
    return placement.x >= 0 - size.edgeBleed.left && placement.x <= size.width - item.bounds.width + size.edgeBleed.right && placement.y >= 0 - size.edgeBleed.top && placement.y <= size.height - item.bounds.height;
  }

  function lineIntersectsLine({
    line1,
    line2
  }) {
    const determinant = (line2.y2 - line2.y1) * (line1.x2 - line1.x1) - (line2.x2 - line2.x1) * (line1.y2 - line1.y1);
    if (determinant === 0) {
      return false;
    }
    const uA = ((line2.x2 - line2.x1) * (line1.y1 - line2.y1) - (line2.y2 - line2.y1) * (line1.x1 - line2.x1)) / determinant;
    const uB = ((line1.x2 - line1.x1) * (line1.y1 - line2.y1) - (line1.y2 - line1.y1) * (line1.x1 - line2.x1)) / determinant;
    return uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1;
  }

  function lineIntersectsRect({
    line,
    rect
  }) {
    const topLeft = {
      x: rect.x,
      y: rect.y
    };
    const topRight = {
      x: rect.x + rect.width,
      y: rect.y
    };
    const bottomRight = {
      x: rect.x + rect.width,
      y: rect.y + rect.height
    };
    const bottomLeft = {
      x: rect.x,
      y: rect.y + rect.height
    };
    const rectLineTop = {
      x1: topLeft.x,
      y1: topLeft.y,
      x2: topRight.x,
      y2: topRight.y
    };
    const rectLineRight = {
      x1: topRight.x,
      y1: topRight.y,
      x2: bottomRight.x,
      y2: bottomRight.y
    };
    const rectLineBottom = {
      x1: bottomRight.x,
      y1: bottomRight.y,
      x2: bottomLeft.x,
      y2: bottomLeft.y
    };
    const rectLineLeft = {
      x1: bottomLeft.x,
      y1: bottomLeft.y,
      x2: topLeft.x,
      y2: topLeft.y
    };
    return lineIntersectsLine({
      line1: line,
      line2: rectLineTop
    }) || lineIntersectsLine({
      line1: line,
      line2: rectLineRight
    }) || lineIntersectsLine({
      line1: line,
      line2: rectLineBottom
    }) || lineIntersectsLine({
      line1: line,
      line2: rectLineLeft
    });
  }

  function rectIntersectsRect({
    rect1,
    rect2
  }) {
    return !(rect2.x > rect1.x + rect1.width || rect2.x + rect2.width < rect1.x || rect2.y > rect1.y + rect1.height || rect2.y + rect2.height < rect1.y);
  }

  function collides({
    candidate,
    lines,
    rects
  }) {
    const collision = rects.some(rect => rectIntersectsRect({
      rect1: rect,
      rect2: candidate
    }));
    if (collision) {
      return true;
    }
    return lines.some(line => lineIntersectsRect({
      line,
      rect: candidate
    }));
  }

  const DEFAULT_ADJUSTMENT = {
    x: 0,
    width: 0,
    y: 0,
    height: 0
  };
  function createValidator({
    size,
    lines,
    placements
  }) {
    return function validate({
      item,
      placement,
      adjustment = DEFAULT_ADJUSTMENT,
      ignoreLines = false
    }) {
      const result = {
        inside: inside({
          item,
          placement,
          size
        }),
        collides: true,
        valid: false
      };
      if (!result.inside) {
        return result;
      }
      result.collides = collides({
        candidate: {
          x: placement.x + adjustment.x,
          y: placement.y + adjustment.y,
          width: item.bounds.width + adjustment.width,
          height: item.bounds.height + adjustment.height
        },
        lines: ignoreLines ? [] : lines,
        rects: placements
      });
      result.valid = !result.collides;
      return result;
    };
  }

  const top = ({
    item
  }) => ({
    x: item.bounds.x - item.bounds.width / 2,
    y: item.bounds.y - item.bounds.height - item.node.localBounds.height / 2 - item.border
  });
  const topRight = ({
    item
  }) => ({
    x: item.bounds.x,
    y: item.bounds.y - item.bounds.height - item.node.localBounds.height / 2 - item.border
  });
  const right = ({
    item
  }) => ({
    x: item.bounds.x + item.node.localBounds.width / 2 + item.border,
    y: item.bounds.y - item.bounds.height / 2
  });
  const bottomRight = ({
    item
  }) => ({
    x: item.bounds.x,
    y: item.bounds.y + item.node.localBounds.height / 2 + item.border
  });
  const bottom = ({
    item
  }) => ({
    x: item.bounds.x - item.bounds.width / 2,
    y: item.bounds.y + item.node.localBounds.height / 2 + item.border
  });
  const bottomLeft = ({
    item
  }) => ({
    x: item.bounds.x - item.bounds.width,
    y: item.bounds.y + item.node.localBounds.height / 2 + item.border
  });
  const left = ({
    item
  }) => ({
    x: item.bounds.x - item.bounds.width - item.node.localBounds.width / 2 - item.border,
    y: item.bounds.y - item.bounds.height / 2
  });
  const topLeft = ({
    item
  }) => ({
    x: item.bounds.x - item.bounds.width,
    y: item.bounds.y - item.bounds.height - item.node.localBounds.height / 2 - item.border
  });
  function createPlacers() {
    return {
      [POSITIONS.TOP]: top,
      [POSITIONS.TOP_RIGHT]: topRight,
      [POSITIONS.RIGHT]: right,
      [POSITIONS.BOTTOM_RIGHT]: bottomRight,
      [POSITIONS.BOTTOM]: bottom,
      [POSITIONS.BOTTOM_LEFT]: bottomLeft,
      [POSITIONS.LEFT]: left,
      [POSITIONS.TOP_LEFT]: topLeft
    };
  }

  var REDUCEMENT = {
    X: 2.5,
    Y: 4
  };

  const TOP = [POSITIONS.TOP, POSITIONS.TOP_LEFT, POSITIONS.TOP_RIGHT];
  const BOTTOM = [POSITIONS.BOTTOM, POSITIONS.BOTTOM_LEFT, POSITIONS.BOTTOM_RIGHT];
  function getAdjustment({
    position
  }) {
    const adjustment = {
      x: REDUCEMENT.X,
      width: -(REDUCEMENT.X * 2),
      y: 0,
      height: 0
    };
    const isTop = TOP.indexOf(position) > -1;
    const isBottom = BOTTOM.indexOf(position) > -1;
    if (isTop) {
      adjustment.y = REDUCEMENT.Y;
      adjustment.height = -REDUCEMENT.Y;
    }
    if (isBottom) {
      adjustment.height = -REDUCEMENT.Y;
    }
    return adjustment;
  }

  function getDistances({
    item
  }) {
    return [item.node.localBounds.height / 2 * Math.sqrt(2)];
  }

  function getCoordinates({
    cx,
    cy,
    r,
    degrees
  }) {
    const radians = degrees * (Math.PI / 180);
    const x = Math.round(cx + r * Math.sin(radians));
    const y = Math.round(cy + r * -Math.cos(radians));
    return {
      x,
      y
    };
  }

  function getOffsetted({
    coordinates,
    degrees,
    item
  }) {
    const offsetted = {
      x: coordinates.x,
      y: coordinates.y
    };
    if (degrees <= 90) {
      offsetted.y -= item.bounds.height;
    } else if (degrees > 180 && degrees <= 270) {
      offsetted.x -= item.bounds.width;
    } else if (degrees > 270) {
      offsetted.y -= item.bounds.height;
      offsetted.x -= item.bounds.width;
    }
    return offsetted;
  }

  const STEP = 15;
  function getDynamicPlacement({
    item,
    validator,
    force = false
  }) {
    const distances = getDistances({
      item
    });
    const cx = item.bounds.x;
    const cy = item.bounds.y;
    for (let i = 0; i < distances.length; i++) {
      const distance = distances[i];
      for (let degrees = 40; degrees <= 180; degrees += STEP) {
        const offsetted = getOffsetted({
          coordinates: getCoordinates({
            cx,
            cy,
            r: distance,
            degrees
          }),
          degrees,
          item
        });
        const result = validator({
          item,
          placement: offsetted,
          ignoreLines: force
        });
        if (result.valid) {
          return offsetted;
        }
      }
      for (let degrees = 320; degrees > 180; degrees -= STEP) {
        const offsetted = getOffsetted({
          coordinates: getCoordinates({
            cx,
            cy,
            r: distance,
            degrees
          }),
          degrees,
          item
        });
        const result = validator({
          item,
          placement: offsetted,
          ignoreLines: force
        });
        if (result.valid) {
          return offsetted;
        }
      }
    }
    return false;
  }

  const PLACELESS = undefined;
  function findPlacement({
    item,
    validator,
    force = false
  }) {
    const positions = [...item.preferences, ...Object.keys(POSITIONS).map(p => POSITIONS[p]).filter(p => item.preferences.indexOf(p) === -1)];
    const placers = createPlacers();
    const fallbacks = [];
    for (let i = 0; i < positions.length; i++) {
      const position = positions[i];
      const placement = placers[position]({
        item
      });
      const adjustment = getAdjustment({
        position
      });
      const result = validator({
        item,
        placement,
        adjustment,
        ignoreLines: force
      });
      if (force && result.inside) {
        fallbacks.push(placement);
      }
      if (result.valid) {
        return placement;
      }
    }
    const getDynamic = () => getDynamicPlacement({
      item,
      validator,
      force
    });
    if (force) {
      const dynamic = getDynamic();
      if (dynamic) {
        return dynamic;
      }
      return fallbacks[0] || PLACELESS;
    }
    return (item.extreme || item.elite) && getDynamic() || PLACELESS;
  }

  function place({
    model,
    size,
    all
  }) {
    const keys = {};
    const items = model.getItems();
    const placements = [...items.map(i => ({
      x: i.node.localBounds.x - i.border + 1,
      y: i.node.localBounds.y - i.border + 1,
      height: i.node.localBounds.height + i.border * 2 - 2,
      width: i.node.localBounds.width + i.border * 2 - 2
    }))];
    const placelesses = [];
    const lines = model.getLines();
    items.forEach(item => {
      const {
        data
      } = item.node;
      if (!item.show || !item.inside || data.null && data.null.value || data.interpolated && data.interpolated.value) {
        return;
      }
      const {
        key
      } = item;
      if (keys[key]) {
        item.setDuplicate();
        return;
      }
      keys[key] = true;
      const validator = createValidator({
        size,
        lines,
        placements
      });
      const placement = findPlacement({
        item,
        validator
      });
      if (placement) {
        placement.height = item.bounds.height;
        placement.width = item.bounds.width;
        placements.push(placement);
        item.setPlacement(placement);
      } else if (all) {
        placelesses.push({
          item,
          validator
        });
      }
    });
    placelesses.forEach(placeless => {
      const {
        item,
        validator
      } = placeless;
      const placement = findPlacement({
        item,
        validator,
        force: true
      });
      if (!placement) {
        return;
      }
      placement.height = item.bounds.height;
      placement.width = item.bounds.width;
      placements.push(placement);
      item.setPlacement(placement);
    });
  }

  var pointLabel = {
    require: ['chart', 'renderer'],
    defaultSettings: {
      settings: {
        orientation: 'horizontal',
        rtl: false,
        connect: false,
        all: false,
        label: () => {},
        showLabel: () => true,
        pointValue: () => {},
        majorValue: () => {},
        target: {
          point: 'point-component',
          allPoints: []
        },
        lineIndex: 'line',
        insideStrategy: 'edge',
        labelSpace: {
          use: () => false,
          size: 10
        }
      },
      style: {
        fontFamily: '"Source Sans Pro", "Arial", "sans-serif"',
        fontSize: '12px',
        fill: '#333'
      }
    },
    preferredSize() {
      const size = {
        edgeBleed: {
          top: 0,
          right: 0,
          left: 0
        }
      };
      const {
        orientation,
        rtl,
        labelSpace
      } = this.settings.settings;
      const {
        use,
        size: bleed
      } = labelSpace;
      if (use()) {
        const horizontal = orientation === 'horizontal';
        size.edgeBleed.top = horizontal ? bleed : 0;
        size.edgeBleed[rtl ? 'left' : 'right'] = horizontal ? 0 : bleed;
      }
      return size;
    },
    render() {
      const {
        settings
      } = this.settings;
      const {
        target,
        enabled
      } = settings;
      const component = this.chart.component(target.point);
      if (!component) {
        return [];
      }
      if (typeof enabled === 'function' && !enabled()) {
        return [];
      }
      const {
        allPoints
      } = target;
      const nodeFilter = allPoints.length ? node => allPoints.includes(node.key) : node => node.key === target.point;
      const nodes = this.chart.findShapes('circle').filter(nodeFilter);
      if (!nodes.length) {
        return [];
      }
      const horizontal = settings.orientation === 'horizontal';
      const axis = horizontal ? 'x' : 'y';
      nodes.sort((a, b) => a.localBounds[axis] - b.localBounds[axis]);
      const extract = {
        label: settings.label,
        pointValue: settings.pointValue,
        majorValue: settings.majorValue,
        lineIndex: settings.lineIndex
      };
      const {
        height,
        width,
        edgeBleed
      } = this.rect;
      const size = {
        height,
        width,
        edgeBleed,
        insideStrategy: settings.insideStrategy
      };
      const {
        style
      } = this;
      const model = createModel({
        nodes,
        extract,
        style,
        measureText: this.renderer.measureText,
        size,
        horizontal,
        rtl: settings.rtl,
        showLabel: settings.showLabel
      });
      prioritize({
        model
      });
      place({
        model,
        size,
        all: settings.all
      });
      return model.getItems().filter(i => i.placement && i.node.key === this.settings.settings.target.point).map(i => ({
        type: 'text',
        x: i.placement.x + i.placement.width / 2,
        y: i.placement.y + i.labelMeasurements.height / 2,
        fontSize: style.fontSize,
        fontFamily: style.fontFamily,
        fill: style.fill,
        text: extract.label(i.node.data),
        data: i.node.data.value,
        baseline: 'central',
        anchor: 'middle'
      }));
    }
  };

  var labelSpace = {
    defaultSettings: {
      settings: {
        size: 10
      }
    },
    preferredSize() {
      return this.settings.settings.size;
    },
    render() {
      return [];
    }
  };

  const getUniques = ({
    type,
    extremum,
    separateStacking,
    items
  }) => {
    const comparison = type === 'max' ? value => value > extremum : value => value < extremum;
    const predicate = separateStacking ? item => comparison(item.point.value < 0 ? item.start.value : item.end.value) : item => comparison(item.end.value);
    const filtered = items.filter(predicate);
    const values = [];
    const uniques = [];
    filtered.forEach(i => {
      const {
        value
      } = i.major;
      if (!values[value]) {
        values[value] = true;
        uniques.push(i);
      }
    });
    return uniques;
  };
  function getItems({
    type,
    extremum,
    primaryextremum,
    secondaryextremum,
    separateStacking,
    items,
    lineSeries
  }) {
    const uniques = [];
    if (lineSeries.length) {
      lineSeries.forEach(series => {
        const seriesExtremum = series.isPrimary ? primaryextremum : secondaryextremum;
        const filteredItems = items.filter(item => item.typeIndex.value === series.typeIndex);
        uniques.push(getUniques({
          type,
          extremum: seriesExtremum,
          items: filteredItems
        }));
      });
    } else {
      uniques.push(getUniques({
        type,
        extremum,
        separateStacking,
        items
      }));
    }
    return uniques.reduce((arr, currentValue) => arr.concat(currentValue), []);
  }

  function createSymbol({
    symbol,
    size,
    fill,
    startAngle,
    x,
    y,
    data
  }) {
    return symbol({
      type: 'n-polygon',
      show: true,
      size,
      fill,
      stroke: '#205891',
      strokeWidth: 0,
      sides: 3,
      startAngle,
      width: 0.7,
      x,
      y,
      data
    });
  }

  var outOfBoundsMarker = {
    require: ['resolver', 'symbol'],
    defaultSettings: {
      settings: {
        type: 'max',
        extremum: () => undefined,
        primaryextremum: () => undefined,
        secondaryextremum: () => undefined,
        separateStacking: false,
        orientation: 'horizontal',
        rtl: false,
        lineSeries: [],
        major: {
          scale: 'major-scale'
        },
        markerOffset: 1,
        size: 10
      },
      style: {
        fill: '#999'
      }
    },
    preferredSize() {
      return this.settings.settings.size;
    },
    render() {
      const {
        items
      } = this.data;
      if (!items.length) {
        return [];
      }
      const {
        type,
        separateStacking,
        orientation,
        rtl,
        markerOffset,
        size,
        major,
        lineSeries
      } = this.settings.settings;
      const extremum = this.settings.settings.extremum();
      const primaryextremum = this.settings.settings.primaryextremum();
      const secondaryextremum = this.settings.settings.secondaryextremum();
      if (!lineSeries.length && extremum === undefined) {
        return [];
      }
      if (lineSeries.length && (primaryextremum === undefined || secondaryextremum === undefined)) {
        return [];
      }
      const uniques = getItems({
        type,
        extremum,
        primaryextremum,
        secondaryextremum,
        separateStacking,
        items,
        lineSeries
      });
      if (!uniques.length) {
        return [];
      }
      const horizontal = orientation === 'horizontal';
      const dimension = this.rect[horizontal ? 'width' : 'height'];
      const resolved = this.resolver.resolve({
        data: {
          items: uniques
        },
        settings: {
          major
        },
        scaled: {
          major: dimension
        }
      });
      const startAngle = (type === 'max' ? 90 : -90) - (horizontal ? 0 : 90) - (!horizontal && rtl ? 180 : 0);
      const offset = size / 2 * markerOffset;
      const {
        fill
      } = this.settings.style;
      const symbols = resolved.items.map(item => createSymbol({
        symbol: this.symbol,
        size,
        fill,
        startAngle,
        x: horizontal ? dimension * item.major : offset,
        y: horizontal ? offset : dimension * item.major,
        data: item.data
      }));
      return symbols;
    }
  };

  var hammer = {exports: {}};

  /*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license */
  (function (module) {
    (function (window, document, exportName, undefined$1) {

      var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
      var TEST_ELEMENT = document.createElement('div');
      var TYPE_FUNCTION = 'function';
      var round = Math.round;
      var abs = Math.abs;
      var now = Date.now;

      /**
       * set a timeout with a given scope
       * @param {Function} fn
       * @param {Number} timeout
       * @param {Object} context
       * @returns {number}
       */
      function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
      }

      /**
       * if the argument is an array, we want to execute the fn on each entry
       * if it aint an array we don't want to do a thing.
       * this is used by all the methods that accept a single and array argument.
       * @param {*|Array} arg
       * @param {String} fn
       * @param {Object} [context]
       * @returns {Boolean}
       */
      function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
        }
        return false;
      }

      /**
       * walk objects and arrays
       * @param {Object} obj
       * @param {Function} iterator
       * @param {Object} context
       */
      function each(obj, iterator, context) {
        var i;
        if (!obj) {
          return;
        }
        if (obj.forEach) {
          obj.forEach(iterator, context);
        } else if (obj.length !== undefined$1) {
          i = 0;
          while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
          }
        } else {
          for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
        }
      }

      /**
       * wrap a method with a deprecation warning and stack trace
       * @param {Function} method
       * @param {String} name
       * @param {String} message
       * @returns {Function} A new function wrapping the supplied method.
       */
      function deprecate(method, name, message) {
        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
        return function () {
          var e = new Error('get-stack-trace');
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
          var log = window.console && (window.console.warn || window.console.log);
          if (log) {
            log.call(window.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
        };
      }

      /**
       * extend object.
       * means that properties in dest will be overwritten by the ones in src.
       * @param {Object} target
       * @param {...Object} objects_to_assign
       * @returns {Object} target
       */
      var assign;
      if (typeof Object.assign !== 'function') {
        assign = function assign(target) {
          if (target === undefined$1 || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
          }
          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined$1 && source !== null) {
              for (var nextKey in source) {
                if (source.hasOwnProperty(nextKey)) {
                  output[nextKey] = source[nextKey];
                }
              }
            }
          }
          return output;
        };
      } else {
        assign = Object.assign;
      }

      /**
       * extend object.
       * means that properties in dest will be overwritten by the ones in src.
       * @param {Object} dest
       * @param {Object} src
       * @param {Boolean} [merge=false]
       * @returns {Object} dest
       */
      var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
          if (!merge || merge && dest[keys[i]] === undefined$1) {
            dest[keys[i]] = src[keys[i]];
          }
          i++;
        }
        return dest;
      }, 'extend', 'Use `assign`.');

      /**
       * merge the values from src in the dest.
       * means that properties that exist in dest will not be overwritten by src
       * @param {Object} dest
       * @param {Object} src
       * @returns {Object} dest
       */
      var merge = deprecate(function merge(dest, src) {
        return extend(dest, src, true);
      }, 'merge', 'Use `assign`.');

      /**
       * simple class inheritance
       * @param {Function} child
       * @param {Function} base
       * @param {Object} [properties]
       */
      function inherit(child, base, properties) {
        var baseP = base.prototype,
          childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
          assign(childP, properties);
        }
      }

      /**
       * simple function bind
       * @param {Function} fn
       * @param {Object} context
       * @returns {Function}
       */
      function bindFn(fn, context) {
        return function boundFn() {
          return fn.apply(context, arguments);
        };
      }

      /**
       * let a boolean value also be a function that must return a boolean
       * this first item in args will be used as the context
       * @param {Boolean|Function} val
       * @param {Array} [args]
       * @returns {Boolean}
       */
      function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined$1 : undefined$1, args);
        }
        return val;
      }

      /**
       * use the val2 when val1 is undefined
       * @param {*} val1
       * @param {*} val2
       * @returns {*}
       */
      function ifUndefined(val1, val2) {
        return val1 === undefined$1 ? val2 : val1;
      }

      /**
       * addEventListener with multiple events at once
       * @param {EventTarget} target
       * @param {String} types
       * @param {Function} handler
       */
      function addEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
          target.addEventListener(type, handler, false);
        });
      }

      /**
       * removeEventListener with multiple events at once
       * @param {EventTarget} target
       * @param {String} types
       * @param {Function} handler
       */
      function removeEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
          target.removeEventListener(type, handler, false);
        });
      }

      /**
       * find if a node is in the given parent
       * @method hasParent
       * @param {HTMLElement} node
       * @param {HTMLElement} parent
       * @return {Boolean} found
       */
      function hasParent(node, parent) {
        while (node) {
          if (node == parent) {
            return true;
          }
          node = node.parentNode;
        }
        return false;
      }

      /**
       * small indexOf wrapper
       * @param {String} str
       * @param {String} find
       * @returns {Boolean} found
       */
      function inStr(str, find) {
        return str.indexOf(find) > -1;
      }

      /**
       * split string on whitespace
       * @param {String} str
       * @returns {Array} words
       */
      function splitStr(str) {
        return str.trim().split(/\s+/g);
      }

      /**
       * find if a array contains the object using indexOf or a simple polyFill
       * @param {Array} src
       * @param {String} find
       * @param {String} [findByKey]
       * @return {Boolean|Number} false when not found, or the index
       */
      function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
          return src.indexOf(find);
        } else {
          var i = 0;
          while (i < src.length) {
            if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
              return i;
            }
            i++;
          }
          return -1;
        }
      }

      /**
       * convert array-like objects to real arrays
       * @param {Object} obj
       * @returns {Array}
       */
      function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
      }

      /**
       * unique array with objects based on a key (like 'id') or just by the array's value
       * @param {Array} src [{id:1},{id:2},{id:1}]
       * @param {String} [key]
       * @param {Boolean} [sort=False]
       * @returns {Array} [{id:1},{id:2}]
       */
      function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
          var val = key ? src[i][key] : src[i];
          if (inArray(values, val) < 0) {
            results.push(src[i]);
          }
          values[i] = val;
          i++;
        }
        if (sort) {
          if (!key) {
            results = results.sort();
          } else {
            results = results.sort(function sortUniqueArray(a, b) {
              return a[key] > b[key];
            });
          }
        }
        return results;
      }

      /**
       * get the prefixed property
       * @param {Object} obj
       * @param {String} property
       * @returns {String|Undefined} prefixed
       */
      function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = prefix ? prefix + camelProp : property;
          if (prop in obj) {
            return prop;
          }
          i++;
        }
        return undefined$1;
      }

      /**
       * get a unique id
       * @returns {number} uniqueId
       */
      var _uniqueId = 1;
      function uniqueId() {
        return _uniqueId++;
      }

      /**
       * get the window object of an element
       * @param {HTMLElement} element
       * @returns {DocumentView|Window}
       */
      function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window;
      }
      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
      var SUPPORT_TOUCH = ('ontouchstart' in window);
      var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined$1;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
      var INPUT_TYPE_TOUCH = 'touch';
      var INPUT_TYPE_PEN = 'pen';
      var INPUT_TYPE_MOUSE = 'mouse';
      var INPUT_TYPE_KINECT = 'kinect';
      var COMPUTE_INTERVAL = 25;
      var INPUT_START = 1;
      var INPUT_MOVE = 2;
      var INPUT_END = 4;
      var INPUT_CANCEL = 8;
      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;
      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
      var PROPS_XY = ['x', 'y'];
      var PROPS_CLIENT_XY = ['clientX', 'clientY'];

      /**
       * create new input type manager
       * @param {Manager} manager
       * @param {Function} callback
       * @returns {Input}
       * @constructor
       */
      function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;

        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function (ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
          }
        };
        this.init();
      }
      Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function () {},
        /**
         * bind the events
         */
        init: function () {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
         * unbind the events
         */
        destroy: function () {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
      };

      /**
       * create new input type manager
       * called by the Manager constructor
       * @param {Hammer} manager
       * @returns {Input}
       */
      function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
          Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
          Type = MouseInput;
        } else {
          Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
      }

      /**
       * handle input events
       * @param {Manager} manager
       * @param {String} eventType
       * @param {Object} input
       */
      function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
          manager.session = {};
        }

        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;

        // compute scale, rotation etc
        computeInputData(manager, input);

        // emit secret event
        manager.emit('hammer.input', input);
        manager.recognize(input);
        manager.session.prevInput = input;
      }

      /**
       * extend the data with some usable properties like scale, rotate, velocity etc
       * @param {Object} manager
       * @param {Object} input
       */
      function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;

        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
        }

        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
          session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);

        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
        }
        input.target = target;
      }
      function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
          };
          offset = session.offsetDelta = {
            x: center.x,
            y: center.y
          };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
      }

      /**
       * velocity is calculated every x ms
       * @param {Object} session
       * @param {Object} input
       */
      function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
          deltaTime = input.timeStamp - last.timeStamp,
          velocity,
          velocityX,
          velocityY,
          direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined$1)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;
          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);
          session.lastInterval = input;
        } else {
          // use latest velocity info if it doesn't overtake a minimum period
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
      }

      /**
       * create a simple clone from the input used for storage of firstInput and firstMultiple
       * @param {Object} input
       * @returns {Object} clonedInputData
       */
      function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
          pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
          };
          i++;
        }
        return {
          timeStamp: now(),
          pointers: pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
        };
      }

      /**
       * get the center of all the pointers
       * @param {Array} pointers
       * @return {Object} center contains `x` and `y` properties
       */
      function getCenter(pointers) {
        var pointersLength = pointers.length;

        // no need to loop when only one touch
        if (pointersLength === 1) {
          return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
          };
        }
        var x = 0,
          y = 0,
          i = 0;
        while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
        }
        return {
          x: round(x / pointersLength),
          y: round(y / pointersLength)
        };
      }

      /**
       * calculate the velocity between two points. unit is in px per ms.
       * @param {Number} deltaTime
       * @param {Number} x
       * @param {Number} y
       * @return {Object} velocity `x` and `y`
       */
      function getVelocity(deltaTime, x, y) {
        return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
        };
      }

      /**
       * get the direction between two points
       * @param {Number} x
       * @param {Number} y
       * @return {Number} direction
       */
      function getDirection(x, y) {
        if (x === y) {
          return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }

      /**
       * calculate the absolute distance between two points
       * @param {Object} p1 {x, y}
       * @param {Object} p2 {x, y}
       * @param {Array} [props] containing x and y keys
       * @return {Number} distance
       */
      function getDistance(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
      }

      /**
       * calculate the angle between two coordinates
       * @param {Object} p1
       * @param {Object} p2
       * @param {Array} [props] containing x and y keys
       * @return {Number} angle
       */
      function getAngle(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
      }

      /**
       * calculate the rotation degrees between two pointersets
       * @param {Array} start array of pointers
       * @param {Array} end array of pointers
       * @return {Number} rotation
       */
      function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
      }

      /**
       * calculate the scale factor between two pointersets
       * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
       * @param {Array} start array of pointers
       * @param {Array} end array of pointers
       * @return {Number} scale
       */
      function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
      }
      var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
      };
      var MOUSE_ELEMENT_EVENTS = 'mousedown';
      var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

      /**
       * Mouse events input
       * @constructor
       * @extends Input
       */
      function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false; // mousedown state

        Input.apply(this, arguments);
      }
      inherit(MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type];

          // on start we want to have the left mouse button down
          if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
          }
          if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
          }

          // mouse must be down
          if (!this.pressed) {
            return;
          }
          if (eventType & INPUT_END) {
            this.pressed = false;
          }
          this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
          });
        }
      });
      var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
      };

      // in IE10 the pointer types is defined as an enum
      var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
      };

      var POINTER_ELEMENT_EVENTS = 'pointerdown';
      var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

      // IE10 has prefixed support, and case-sensitive
      if (window.MSPointerEvent && !window.PointerEvent) {
        POINTER_ELEMENT_EVENTS = 'MSPointerDown';
        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
      }

      /**
       * Pointer events input
       * @constructor
       * @extends Input
       */
      function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
      }
      inherit(PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;
          var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
          var isTouch = pointerType == INPUT_TYPE_TOUCH;

          // get index of the event in the store
          var storeIndex = inArray(store, ev.pointerId, 'pointerId');

          // start and mouse must be down
          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
              store.push(ev);
              storeIndex = store.length - 1;
            }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
          }

          // it not found, so the pointer hasn't been down (so it's probably a hover)
          if (storeIndex < 0) {
            return;
          }

          // update the event in the store
          store[storeIndex] = ev;
          this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
          });
          if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
          }
        }
      });
      var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
      var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

      /**
       * Touch events input
       * @constructor
       * @extends Input
       */
      function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
      }
      inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

          // should we handle the touch events?
          if (type === INPUT_START) {
            this.started = true;
          }
          if (!this.started) {
            return;
          }
          var touches = normalizeSingleTouches.call(this, ev, type);

          // when done, reset the started state
          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });

      /**
       * @this {TouchInput}
       * @param {Object} ev
       * @param {Number} type flag
       * @returns {undefined|Array} [all, changed]
       */
      function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), 'identifier', true);
        }
        return [all, changed];
      }
      var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

      /**
       * Multi-user touch events input
       * @constructor
       * @extends Input
       */
      function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
      }
      inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
            return;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });

      /**
       * @this {TouchInput}
       * @param {Object} ev
       * @param {Number} type flag
       * @returns {undefined|Array} [all, changed]
       */
      function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;

        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
        }
        var i,
          targetTouches,
          changedTouches = toArray(ev.changedTouches),
          changedTargetTouches = [],
          target = this.target;

        // get target touches from touches
        targetTouches = allTouches.filter(function (touch) {
          return hasParent(touch.target, target);
        });

        // collect touches
        if (type === INPUT_START) {
          i = 0;
          while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
          }
        }

        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
          }

          // cleanup removed touches
          if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
          }
          i++;
        }
        if (!changedTargetTouches.length) {
          return;
        }
        return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
      }

      /**
       * Combined touch and mouse input
       *
       * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
       * This because touch devices also emit mouse events while doing a touch.
       *
       * @constructor
       * @extends Input
       */

      var DEDUP_TIMEOUT = 2500;
      var DEDUP_DISTANCE = 25;
      function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
      }
      inherit(TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
            isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          }

          // when we're in a touch event, record touches to  de-dupe synthetic mouse event
          if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
          }
          this.callback(manager, inputEvent, inputData);
        },
        /**
         * remove the event listeners
         */
        destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
        }
      });
      function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
        }
      }
      function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
          var lastTouch = {
            x: touch.clientX,
            y: touch.clientY
          };
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function () {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
              lts.splice(i, 1);
            }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
      }
      function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX,
          y = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
          var t = this.lastTouches[i];
          var dx = Math.abs(x - t.x),
            dy = Math.abs(y - t.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
          }
        }
        return false;
      }
      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined$1;

      // magical touchAction value
      var TOUCH_ACTION_COMPUTE = 'compute';
      var TOUCH_ACTION_AUTO = 'auto';
      var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
      var TOUCH_ACTION_NONE = 'none';
      var TOUCH_ACTION_PAN_X = 'pan-x';
      var TOUCH_ACTION_PAN_Y = 'pan-y';
      var TOUCH_ACTION_MAP = getTouchActionProps();

      /**
       * Touch Action
       * sets the touchAction property or uses the js alternative
       * @param {Manager} manager
       * @param {String} value
       * @constructor
       */
      function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
      }
      TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function (value) {
          // find out the touch-action by the event handlers
          if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
          }
          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function () {
          this.set(this.manager.options.touchAction);
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function () {
          var actions = [];
          each(this.manager.recognizers, function (recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
              actions = actions.concat(recognizer.getTouchAction());
            }
          });
          return cleanTouchActions(actions.join(' '));
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function (input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;

          // if the touch action did prevented once this session
          if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
          }
          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
          if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;
            if (isTapPointer && isTapMovement && isTapTouchTime) {
              return;
            }
          }
          if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
          }
          if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
            return this.preventSrc(srcEvent);
          }
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function (srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
        }
      };

      /**
       * when the touchActions are collected they are not a valid value, so we need to clean things up. *
       * @param {String} actions
       * @returns {*}
       */
      function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

        // if both pan-x and pan-y are set (different recognizers
        // for different directions, e.g. horizontal pan but vertical swipe?)
        // we need none (as otherwise with pan-x pan-y combined none of these
        // recognizers will work, since the browser would handle all panning
        if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
        }

        // pan-x OR pan-y
        if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }

        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
      }
      function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
          return false;
        }
        var touchMap = {};
        var cssSupports = window.CSS && window.CSS.supports;
        ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
          // If css.supports is not supported but there is native touch-action assume it supports
          // all values. This is the case for IE 10 and 11.
          touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
        });
        return touchMap;
      }

      /**
       * Recognizer flow explained; *
       * All recognizers have the initial state of POSSIBLE when a input session starts.
       * The definition of a input session is from the first input until the last input, with all it's movement in it. *
       * Example session for mouse-input: mousedown -> mousemove -> mouseup
       *
       * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
       * which determines with state it should be.
       *
       * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
       * POSSIBLE to give it another change on the next cycle.
       *
       *               Possible
       *                  |
       *            +-----+---------------+
       *            |                     |
       *      +-----+-----+               |
       *      |           |               |
       *   Failed      Cancelled          |
       *                          +-------+------+
       *                          |              |
       *                      Recognized       Began
       *                                         |
       *                                      Changed
       *                                         |
       *                                  Ended/Recognized
       */
      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;

      /**
       * Recognizer
       * Every recognizer needs to extend from this class.
       * @constructor
       * @param {Object} options
       */
      function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null;

        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }
      Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function (options) {
          assign(this.options, options);

          // also update the touchAction, in case something changed about the directions/enabled state
          this.manager && this.manager.touchAction.update();
          return this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function (otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
          }
          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
          }
          return this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function (otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function (otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
          }
          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
          }
          return this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function (otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray(this.requireFail, otherRecognizer);
          if (index > -1) {
            this.requireFail.splice(index, 1);
          }
          return this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function () {
          return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function (otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function (input) {
          var self = this;
          var state = this.state;
          function emit(event) {
            self.manager.emit(event, input);
          }

          // 'panstart' and 'panmove'
          if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
          }
          emit(self.options.event); // simple 'eventName' events

          if (input.additionalEvent) {
            // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
          }

          // panend and pancancel
          if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
          }
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function (input) {
          if (this.canEmit()) {
            return this.emit(input);
          }
          // it's failing anyway
          this.state = STATE_FAILED;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function () {
          var i = 0;
          while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
              return false;
            }
            i++;
          }
          return true;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function (inputData) {
          // make a new copy of the inputData
          // so we can change the inputData without messing up the other recognizers
          var inputDataClone = assign({}, inputData);

          // is is enabled and allow recognizing?
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
          }

          // reset when we've reached the end
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
          }
          this.state = this.process(inputDataClone);

          // the recognizer has recognized a gesture
          // so trigger an event
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
          }
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function (inputData) {},
        // jshint ignore:line

        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function () {},
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function () {}
      };

      /**
       * get a usable string, used as event postfix
       * @param {Const} state
       * @returns {String} state
       */
      function stateStr(state) {
        if (state & STATE_CANCELLED) {
          return 'cancel';
        } else if (state & STATE_ENDED) {
          return 'end';
        } else if (state & STATE_CHANGED) {
          return 'move';
        } else if (state & STATE_BEGAN) {
          return 'start';
        }
        return '';
      }

      /**
       * direction cons to string
       * @param {Const} direction
       * @returns {String}
       */
      function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
          return 'down';
        } else if (direction == DIRECTION_UP) {
          return 'up';
        } else if (direction == DIRECTION_LEFT) {
          return 'left';
        } else if (direction == DIRECTION_RIGHT) {
          return 'right';
        }
        return '';
      }

      /**
       * get a recognizer by name if it is bound to a manager
       * @param {Recognizer|String} otherRecognizer
       * @param {Recognizer} recognizer
       * @returns {Recognizer}
       */
      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
          return manager.get(otherRecognizer);
        }
        return otherRecognizer;
      }

      /**
       * This recognizer is just used as a base for the simple attribute recognizers.
       * @constructor
       * @extends Recognizer
       */
      function AttrRecognizer() {
        Recognizer.apply(this, arguments);
      }
      inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function (input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function (input) {
          var state = this.state;
          var eventType = input.eventType;
          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);

          // on cancel input and we've recognized before, return STATE_CANCELLED
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
              return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
              return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
          }
          return STATE_FAILED;
        }
      });

      /**
       * Pan
       * Recognized when the pointer is down and moved in the allowed direction.
       * @constructor
       * @extends AttrRecognizer
       */
      function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
      }
      inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: 'pan',
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        },
        getTouchAction: function () {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
        },
        directionTest: function (input) {
          var options = this.options;
          var hasMoved = true;
          var distance = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY;

          // lock to axis?
          if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
              direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
              hasMoved = x != this.pX;
              distance = Math.abs(input.deltaX);
            } else {
              direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              hasMoved = y != this.pY;
              distance = Math.abs(input.deltaY);
            }
          }
          input.direction = direction;
          return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function (input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function (input) {
          this.pX = input.deltaX;
          this.pY = input.deltaY;
          var direction = directionStr(input.direction);
          if (direction) {
            input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
        }
      });

      /**
       * Pinch
       * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
       * @constructor
       * @extends AttrRecognizer
       */
      function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: 'pinch',
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function () {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function (input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function (input) {
          if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
        }
      });

      /**
       * Press
       * Recognized when the pointer is down for x ms without any movement.
       * @constructor
       * @extends Recognizer
       */
      function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
      }
      inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: 'press',
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9 // a minimal movement is ok, but keep it low
        },

        getTouchAction: function () {
          return [TOUCH_ACTION_AUTO];
        },
        process: function (input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;
          this._input = input;

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
            this.reset();
          } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function () {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.time, this);
          } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
        },
        reset: function () {
          clearTimeout(this._timer);
        },
        emit: function (input) {
          if (this.state !== STATE_RECOGNIZED) {
            return;
          }
          if (input && input.eventType & INPUT_END) {
            this.manager.emit(this.options.event + 'up', input);
          } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
          }
        }
      });

      /**
       * Rotate
       * Recognized when two or more pointer are moving in a circular motion.
       * @constructor
       * @extends AttrRecognizer
       */
      function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: 'rotate',
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function () {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function (input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
      });

      /**
       * Swipe
       * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
       * @constructor
       * @extends AttrRecognizer
       */
      function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: 'swipe',
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        },
        getTouchAction: function () {
          return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function (input) {
          var direction = this.options.direction;
          var velocity;
          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
          }
          return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function (input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
            this.manager.emit(this.options.event + direction, input);
          }
          this.manager.emit(this.options.event, input);
        }
      });

      /**
       * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
       * between the given interval and position. The delay option can be used to recognize multi-taps without firing
       * a single tap.
       *
       * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
       * multi-taps being recognized.
       * @constructor
       * @extends Recognizer
       */
      function TapRecognizer() {
        Recognizer.apply(this, arguments);

        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
      }
      inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: 'tap',
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10 // a multi-tap can be a bit off the initial position
        },

        getTouchAction: function () {
          return [TOUCH_ACTION_MANIPULATION];
        },
        process: function (input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;
          this.reset();
          if (input.eventType & INPUT_START && this.count === 0) {
            return this.failTimeout();
          }

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
              return this.failTimeout();
            }
            var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
            this.pTime = input.timeStamp;
            this.pCenter = input.center;
            if (!validMultiTap || !validInterval) {
              this.count = 1;
            } else {
              this.count += 1;
            }
            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
              // no failing requirements, immediately trigger the tap event
              // or wait as long as the multitap interval to trigger
              if (!this.hasRequireFailures()) {
                return STATE_RECOGNIZED;
              } else {
                this._timer = setTimeoutContext(function () {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
                }, options.interval, this);
                return STATE_BEGAN;
              }
            }
          }
          return STATE_FAILED;
        },
        failTimeout: function () {
          this._timer = setTimeoutContext(function () {
            this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
        },
        reset: function () {
          clearTimeout(this._timer);
        },
        emit: function () {
          if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
          }
        }
      });

      /**
       * Simple way to create a manager with a default set of recognizers.
       * @param {HTMLElement} element
       * @param {Object} [options]
       * @constructor
       */
      function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
      }

      /**
       * @const {string}
       */
      Hammer.VERSION = '2.0.7';

      /**
       * default settings
       * @namespace
       */
      Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {
          enable: false
        }], [PinchRecognizer, {
          enable: false
        }, ['rotate']], [SwipeRecognizer, {
          direction: DIRECTION_HORIZONTAL
        }], [PanRecognizer, {
          direction: DIRECTION_HORIZONTAL
        }, ['swipe']], [TapRecognizer], [TapRecognizer, {
          event: 'doubletap',
          taps: 2
        }, ['tap']], [PressRecognizer]],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: 'none',
          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: 'none',
          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: 'none',
          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: 'none',
          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: 'none',
          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: 'rgba(0,0,0,0)'
        }
      };
      var STOP = 1;
      var FORCED_STOP = 2;

      /**
       * Manager
       * @param {HTMLElement} element
       * @param {Object} [options]
       * @constructor
       */
      function Manager(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function (item) {
          var recognizer = this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }
      Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function (options) {
          assign(this.options, options);

          // Options that need a little more setup
          if (options.touchAction) {
            this.touchAction.update();
          }
          if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
          }
          return this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function (force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function (inputData) {
          var session = this.session;
          if (session.stopped) {
            return;
          }

          // run the touch-action polyfill
          this.touchAction.preventDefaults(inputData);
          var recognizer;
          var recognizers = this.recognizers;

          // this holds the recognizer that is being recognized.
          // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
          // if no recognizer is detecting a thing, it is set to `null`
          var curRecognizer = session.curRecognizer;

          // reset when the last recognizer is recognized
          // or when we're in a new session
          if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
            curRecognizer = session.curRecognizer = null;
          }
          var i = 0;
          while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && (
            // 1
            !curRecognizer || recognizer == curRecognizer ||
            // 2
            recognizer.canRecognizeWith(curRecognizer))) {
              // 3
              recognizer.recognize(inputData);
            } else {
              recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
              curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
          }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function (recognizer) {
          if (recognizer instanceof Recognizer) {
            return recognizer;
          }
          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
              return recognizers[i];
            }
          }
          return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function (recognizer) {
          if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
          }

          // remove existing
          var existing = this.get(recognizer.options.event);
          if (existing) {
            this.remove(existing);
          }
          this.recognizers.push(recognizer);
          recognizer.manager = this;
          this.touchAction.update();
          return recognizer;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function (recognizer) {
          if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
          }
          recognizer = this.get(recognizer);

          // let's make sure this recognizer exists
          if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);
            if (index !== -1) {
              recognizers.splice(index, 1);
              this.touchAction.update();
            }
          }
          return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function (events, handler) {
          if (events === undefined$1) {
            return;
          }
          if (handler === undefined$1) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function (event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
          });
          return this;
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function (events, handler) {
          if (events === undefined$1) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function (event) {
            if (!handler) {
              delete handlers[event];
            } else {
              handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
          });
          return this;
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function (event, data) {
          // we also want to trigger dom events
          if (this.options.domEvents) {
            triggerDomEvent(event, data);
          }

          // no handlers, so skip it all
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
            return;
          }
          data.type = event;
          data.preventDefault = function () {
            data.srcEvent.preventDefault();
          };
          var i = 0;
          while (i < handlers.length) {
            handlers[i](data);
            i++;
          }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function () {
          this.element && toggleCssProps(this, false);
          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
        }
      };

      /**
       * add/remove the css properties as defined in manager.options.cssProps
       * @param {Manager} manager
       * @param {Boolean} add
       */
      function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) {
          return;
        }
        var prop;
        each(manager.options.cssProps, function (value, name) {
          prop = prefixed(element.style, name);
          if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
          } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
          }
        });
        if (!add) {
          manager.oldCssProps = {};
        }
      }

      /**
       * trigger dom event
       * @param {String} event
       * @param {Object} data
       */
      function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
      }
      assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,
        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,
        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
      });

      // this prevents errors when Hammer is loaded in the presence of an AMD
      //  style loader but by script tag, not by the loader.
      var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line
      freeGlobal.Hammer = Hammer;
      if (typeof undefined$1 === 'function' && undefined$1.amd) {
        undefined$1(function () {
          return Hammer;
        });
      } else if (module.exports) {
        module.exports = Hammer;
      } else {
        window[exportName] = Hammer;
      }
    })(window, document, 'Hammer');
  })(hammer);
  var hammerExports = hammer.exports;
  var Hammer$1 = /*@__PURE__*/getDefaultExportFromCjs(hammerExports);

  /*
  * picasso-plugin-hammer v2.2.5
  * Copyright (c) 2023 QlikTech International AB
  * Released under the MIT license.
  */

  const translateKnownTypes = {
    click: 'Tap',
    Click: 'Tap',
    tap: 'Tap',
    pan: 'Pan',
    swipe: 'Swipe',
    rotate: 'Rotate',
    press: 'Press',
    pinch: 'Pinch'
  };

  /**
   * Helper function for translating typical non-hammer gesture to a hammer gesture. Currently only supporting 'click'
   * @param {String} type Gesture type
   * @private
   */
  function getGestureType(type) {
    return translateKnownTypes[type] || type;
  }

  /**
   * Manages event handlers for HammerJS.
   * @param {Hammer} Hammered - The Hammer instance
   */
  function hammered(Hammered) {
    return function hammer(chart, mediator, element) {
      let settings;
      let instance;
      let mc;
      let key;
      let hammerGestures = [];
      let isOn = true;
      /**
       * Set default settings
       * @private
       */
      function setDefaultSettings(newSettings) {
        key = newSettings.key; //eslint-disable-line
        settings = newSettings;
        instance = {
          chart,
          mediator,
          settings
        };
        settings.gestures = settings.gestures || [];
        if (settings.enable === undefined) {
          settings.enable = true;
        }
      }

      /**
       * @private
       * add hammer recognizers based on settings
       */
      function addRecognizers() {
        if (typeof settings.enable === 'function') {
          settings.enable = settings.enable.bind(instance)();
        }
        if (!settings.enable) {
          return; // interaction is disabled
        }

        settings.gestures.forEach(gesture => {
          gesture.options = gesture.options || {};
          // handle action enable
          if (gesture.options.enable === undefined) {
            gesture.options.enable = true;
          }
          if (typeof gesture.options.enable === 'function') {
            gesture.options.enable = gesture.options.enable.bind(instance);
          }
          // setup hammer gestures
          const type = getGestureType(gesture.type);
          if (Hammered && Hammered[type]) {
            gesture.options.event = gesture.options.event || gesture.type.toLowerCase();
            mc = mc || new Hammered.Manager(element);
            mc.add(new Hammered[type](gesture.options));
            Object.keys(gesture.events).forEach(eventName => {
              gesture.events[eventName] = gesture.events[eventName].bind(instance);
              mc.on(eventName, gesture.events[eventName]);
            });
            hammerGestures.push(gesture);
          }
        });

        // setup mixing hammer gestures
        settings.gestures.forEach(gesture => {
          const type = getGestureType(gesture.type);
          if (Hammered && Hammered[type]) {
            if (gesture.recognizeWith) {
              mc.get(gesture.options.event).recognizeWith(gesture.recognizeWith.split(' ').filter(e => e !== ''));
            }
            if (gesture.requireFailure) {
              mc.get(gesture.options.event).requireFailure(gesture.requireFailure.split(' ').filter(e => e !== ''));
            }
          }
        });
      }
      /**
       * @private
       * removes all added hammer recognizers and native events
       */
      function removeAddedEvents() {
        // remove hammer recognizers and registered events
        hammerGestures.forEach(gesture => {
          Object.keys(gesture.events).forEach(eventName => {
            mc.off(eventName, gesture.events[eventName]);
          });
          mc.remove(gesture.options.event);
        });
        hammerGestures = [];
      }
      return {
        /**
         * Getter for the key.
         */
        get key() {
          return key;
        },
        /**
         * Updates this with new settings
         * @typedef settings
         * @type {object}
         * @property {string} [type] - The interaction type. Is 'hammer' for this component
         * @property {boolean|function} [enable] - Should the interaction be enabled or not.
         * This is only run when adding event handlers. In effect at startup, update or during on/off.
         * It does not run during every event loop.
         * @property {object} [events] - The keys in this object is the names of native events
         * that should be added to the chart element and they should all point to function which
         * will be the corresponding event handler.
         */
        set(newSettings) {
          setDefaultSettings(newSettings);
          removeAddedEvents();
          if (isOn) {
            addRecognizers();
          }
        },
        /**
         * Turns off interactions
         */
        off() {
          isOn = false;
          removeAddedEvents();
        },
        /**
         * Turns off interactions
         */
        on() {
          isOn = true;
          if (hammerGestures.length === 0) {
            addRecognizers();
          }
        },
        /**
         * Destroys and unbinds all event handlers
         */
        destroy() {
          removeAddedEvents();
          if (mc) {
            mc.destroy();
          }
          mc = null;
          instance = null;
          settings = null;
        }
      };
    };
  }

  /* global Hammer */
  function initialize$1(picassoOrHammer) {
    const isPicasso = typeof picassoOrHammer.interaction === 'function';
    if (!isPicasso) {
      return picasso => {
        picasso.interaction('hammer', hammered(picassoOrHammer));
      };
    }
    picassoOrHammer.interaction('hammer', hammered(Hammer));
    return undefined;
  }

  /*
  * picasso.js v2.2.5
  * Copyright (c) 2023 QlikTech International AB
  * Released under the MIT license.
  */var ARG_LENGTH={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0};var SEGMENT_PATTERN=/([astvzqmhlc])([^astvzqmhlc]*)/gi;var NUMBER=/-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;function parseValues(args){var numbers=args.match(NUMBER);return numbers?numbers.map(Number):[];}/**
   * parse an svg path data string. Generates an Array
   * of commands where each command is an Array of the
   * form `[command, arg1, arg2, ...]`
   *
   * https://www.w3.org/TR/SVG/paths.html#PathDataGeneralInformation
   * @ignore
   *
   * @param {string} path
   * @returns {array}
   */function parse(path){var data=[];var p=String(path).trim();// A path data segment (if there is one) must begin with a "moveto" command
  if(p[0]!=="M"&&p[0]!=="m"){return data;}p.replace(SEGMENT_PATTERN,function(_,command,args){var type=command.toLowerCase();var theArgs=parseValues(args);var theCommand=command;// overloaded moveTo
  if(type==="m"&&theArgs.length>2){data.push([theCommand].concat(theArgs.splice(0,2)));type="l";theCommand=theCommand==="m"?"l":"L";}// Ignore invalid commands
  if(theArgs.length<ARG_LENGTH[type]){return "";}data.push([theCommand].concat(theArgs.splice(0,ARG_LENGTH[type])));// The command letter can be eliminated on subsequent commands if the
  // same command is used multiple times in a row (e.g., you can drop the
  // second "L" in "M 100 200 L 200 100 L -100 -200" and use
  // "M 100 200 L 200 100 -100 -200" instead).
  while(theArgs.length>=ARG_LENGTH[type]&&theArgs.length&&ARG_LENGTH[type]){data.push([theCommand].concat(theArgs.splice(0,ARG_LENGTH[type])));}return "";});return data;}var parsePath$2=parse;function _classCallCheck$1(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _defineProperties$1(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass$1(Constructor,protoProps,staticProps){if(protoProps)_defineProperties$1(Constructor.prototype,protoProps);if(staticProps)_defineProperties$1(Constructor,staticProps);Object.defineProperty(Constructor,"prototype",{writable:false});return Constructor;}function _toConsumableArray$1(arr){return _arrayWithoutHoles$1(arr)||_iterableToArray$1(arr)||_unsupportedIterableToArray$1(arr)||_nonIterableSpread$1();}function _arrayWithoutHoles$1(arr){if(Array.isArray(arr))return _arrayLikeToArray$1(arr);}function _iterableToArray$1(iter){if(typeof Symbol!=="undefined"&&iter[Symbol.iterator]!=null||iter["@@iterator"]!=null)return Array.from(iter);}function _unsupportedIterableToArray$1(o,minLen){if(!o)return;if(typeof o==="string")return _arrayLikeToArray$1(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray$1(o,minLen);}function _arrayLikeToArray$1(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2;}function _nonIterableSpread$1(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var parsePath$1=parsePath$2;/**
   * Work around for https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8438884/
   * @ignore
   */function supportsSvgPathArgument(window){var canvas=window.document.createElement("canvas");var g=canvas.getContext("2d");var p=new window.Path2D("M0 0 L1 1");g.strokeStyle="red";g.lineWidth=1;g.stroke(p);var imgData=g.getImageData(0,0,1,1);return imgData.data[0]===255;// Check if pixel is red
  }function rotatePoint$1(point,angle){var nx=point.x*Math.cos(angle)-point.y*Math.sin(angle);var ny=point.y*Math.cos(angle)+point.x*Math.sin(angle);point.x=nx;point.y=ny;}function translatePoint(point,dx,dy){point.x+=dx;point.y+=dy;}function scalePoint(point,s){point.x*=s;point.y*=s;}function polyFillPath2D(window){if(typeof window==="undefined"||!window.CanvasRenderingContext2D){return;}if(window.Path2D&&supportsSvgPathArgument(window)){return;}/**
     * Crates a Path2D polyfill object
     * @constructor
     * @ignore
     * @param {String} path
     */var Path2D=/*#__PURE__*/function(){function Path2D(path){_classCallCheck$1(this,Path2D);this.segments=[];if(path&&path instanceof Path2D){var _this$segments;(_this$segments=this.segments).push.apply(_this$segments,_toConsumableArray$1(path.segments));}else if(path){this.segments=parsePath$1(path);}}_createClass$1(Path2D,[{key:"addPath",value:function addPath(path){if(path&&path instanceof Path2D){var _this$segments2;(_this$segments2=this.segments).push.apply(_this$segments2,_toConsumableArray$1(path.segments));}}},{key:"moveTo",value:function moveTo(x,y){this.segments.push(["M",x,y]);}},{key:"lineTo",value:function lineTo(x,y){this.segments.push(["L",x,y]);}},{key:"arc",value:function arc(x,y,r,start,end,ccw){this.segments.push(["AC",x,y,r,start,end,!!ccw]);}},{key:"arcTo",value:function arcTo(x1,y1,x2,y2,r){this.segments.push(["AT",x1,y1,x2,y2,r]);}},{key:"ellipse",value:function ellipse(x,y,rx,ry,angle,start,end,ccw){this.segments.push(["E",x,y,rx,ry,angle,start,end,!!ccw]);}},{key:"closePath",value:function closePath(){this.segments.push(["Z"]);}},{key:"bezierCurveTo",value:function bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y){this.segments.push(["C",cp1x,cp1y,cp2x,cp2y,x,y]);}},{key:"quadraticCurveTo",value:function quadraticCurveTo(cpx,cpy,x,y){this.segments.push(["Q",cpx,cpy,x,y]);}},{key:"rect",value:function rect(x,y,width,height){this.segments.push(["R",x,y,width,height]);}}]);return Path2D;}();function buildPath(canvas,segments){var endAngle;var startAngle;var largeArcFlag;var sweepFlag;var endPoint;var midPoint;var angle;var lambda;var t1;var t2;var x;var x1;var y;var y1;var r;var rx;var ry;var w;var h;var pathType;var centerPoint;var cpx;var cpy;var qcpx;var qcpy;var ccw;var startPoint={x:0,y:0};var currentPoint={x:0,y:0};canvas.beginPath();for(var i=0;i<segments.length;++i){var s=segments[i];pathType=s[0];// Reset control point if command is not cubic
  if(pathType!=="S"&&pathType!=="s"&&pathType!=="C"&&pathType!=="c"){cpx=null;cpy=null;}if(pathType!=="T"&&pathType!=="t"&&pathType!=="Q"&&pathType!=="q"){qcpx=null;qcpy=null;}switch(pathType){case"m":case"M":if(pathType==="m"){x+=s[1];y+=s[2];}else {x=s[1];y=s[2];}if(pathType==="M"||!startPoint){startPoint={x:x,y:y};}canvas.moveTo(x,y);break;case"l":x+=s[1];y+=s[2];canvas.lineTo(x,y);break;case"L":x=s[1];y=s[2];canvas.lineTo(x,y);break;case"H":x=s[1];canvas.lineTo(x,y);break;case"h":x+=s[1];canvas.lineTo(x,y);break;case"V":y=s[1];canvas.lineTo(x,y);break;case"v":y+=s[1];canvas.lineTo(x,y);break;case"a":case"A":if(pathType==="a"){x+=s[6];y+=s[7];}else {x=s[6];y=s[7];}rx=s[1];// rx
  ry=s[2];// ry
  angle=s[3]*Math.PI/180;largeArcFlag=!!s[4];sweepFlag=!!s[5];endPoint={x:x,y:y};// https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
  midPoint={x:(currentPoint.x-endPoint.x)/2,y:(currentPoint.y-endPoint.y)/2};rotatePoint$1(midPoint,-angle);// radius correction
  lambda=midPoint.x*midPoint.x/(rx*rx)+midPoint.y*midPoint.y/(ry*ry);if(lambda>1){lambda=Math.sqrt(lambda);rx*=lambda;ry*=lambda;}centerPoint={x:rx*midPoint.y/ry,y:-(ry*midPoint.x)/rx};t1=rx*rx*ry*ry;t2=rx*rx*midPoint.y*midPoint.y+ry*ry*midPoint.x*midPoint.x;if(sweepFlag!==largeArcFlag){scalePoint(centerPoint,Math.sqrt((t1-t2)/t2)||0);}else {scalePoint(centerPoint,-Math.sqrt((t1-t2)/t2)||0);}startAngle=Math.atan2((midPoint.y-centerPoint.y)/ry,(midPoint.x-centerPoint.x)/rx);endAngle=Math.atan2(-(midPoint.y+centerPoint.y)/ry,-(midPoint.x+centerPoint.x)/rx);rotatePoint$1(centerPoint,angle);translatePoint(centerPoint,(endPoint.x+currentPoint.x)/2,(endPoint.y+currentPoint.y)/2);canvas.save();canvas.translate(centerPoint.x,centerPoint.y);canvas.rotate(angle);canvas.scale(rx,ry);canvas.arc(0,0,1,startAngle,endAngle,!sweepFlag);canvas.restore();break;case"C":cpx=s[3];// Last control point
  cpy=s[4];x=s[5];y=s[6];canvas.bezierCurveTo(s[1],s[2],cpx,cpy,x,y);break;case"c":canvas.bezierCurveTo(s[1]+x,s[2]+y,s[3]+x,s[4]+y,s[5]+x,s[6]+y);cpx=s[3]+x;// Last control point
  cpy=s[4]+y;x+=s[5];y+=s[6];break;case"S":if(cpx===null||cpy===null){cpx=x;cpy=y;}canvas.bezierCurveTo(2*x-cpx,2*y-cpy,s[1],s[2],s[3],s[4]);cpx=s[1];// last control point
  cpy=s[2];x=s[3];y=s[4];break;case"s":if(cpx===null||cpy===null){cpx=x;cpy=y;}canvas.bezierCurveTo(2*x-cpx,2*y-cpy,s[1]+x,s[2]+y,s[3]+x,s[4]+y);cpx=s[1]+x;// last control point
  cpy=s[2]+y;x+=s[3];y+=s[4];break;case"Q":qcpx=s[1];// last control point
  qcpy=s[2];x=s[3];y=s[4];canvas.quadraticCurveTo(qcpx,qcpy,x,y);break;case"q":qcpx=s[1]+x;// last control point
  qcpy=s[2]+y;x+=s[3];y+=s[4];canvas.quadraticCurveTo(qcpx,qcpy,x,y);break;case"T":if(qcpx===null||qcpy===null){qcpx=x;qcpy=y;}qcpx=2*x-qcpx;// last control point
  qcpy=2*y-qcpy;x=s[1];y=s[2];canvas.quadraticCurveTo(qcpx,qcpy,x,y);break;case"t":if(qcpx===null||qcpy===null){qcpx=x;qcpy=y;}qcpx=2*x-qcpx;// last control point
  qcpy=2*y-qcpy;x+=s[1];y+=s[2];canvas.quadraticCurveTo(qcpx,qcpy,x,y);break;case"z":case"Z":x=startPoint.x;y=startPoint.y;startPoint=undefined;canvas.closePath();break;case"AC":// arc
  x=s[1];y=s[2];r=s[3];startAngle=s[4];endAngle=s[5];ccw=s[6];canvas.arc(x,y,r,startAngle,endAngle,ccw);break;case"AT":// arcTo
  x1=s[1];y1=s[2];x=s[3];y=s[4];r=s[5];canvas.arcTo(x1,y1,x,y,r);break;case"E":// ellipse
  x=s[1];y=s[2];rx=s[3];ry=s[4];angle=s[5];startAngle=s[6];endAngle=s[7];ccw=s[8];canvas.save();canvas.translate(x,y);canvas.rotate(angle);canvas.scale(rx,ry);canvas.arc(0,0,1,startAngle,endAngle,ccw);canvas.restore();break;case"R":// rect
  x=s[1];y=s[2];w=s[3];h=s[4];startPoint={x:x,y:y};canvas.rect(x,y,w,h);break;// throw new Error(`${pathType} is not implemented`); ?
  }currentPoint.x=x;currentPoint.y=y;}}var cFill=window.CanvasRenderingContext2D.prototype.fill;var cStroke=window.CanvasRenderingContext2D.prototype.stroke;window.CanvasRenderingContext2D.prototype.fill=function fill(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}var fillRule="nonzero";if(args.length===0||args.length===1&&typeof args[0]==="string"){cFill.apply(this,args);return;}if(arguments.length===2){fillRule=args[1];}var path=args[0];buildPath(this,path.segments);cFill.call(this,fillRule);};window.CanvasRenderingContext2D.prototype.stroke=function stroke(path){if(!path){cStroke.call(this);return;}buildPath(this,path.segments);cStroke.call(this);};var cIsPointInPath=window.CanvasRenderingContext2D.prototype.isPointInPath;window.CanvasRenderingContext2D.prototype.isPointInPath=function isPointInPath(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}// let fillRule = 'nonzero';
  if(args[0].constructor.name==="Path2D"){// first argument is a Path2D object
  var x=args[1];var y=args[2];var fillRule=args[3]||"nonzero";var path=args[0];buildPath(this,path.segments);return cIsPointInPath.apply(this,[x,y,fillRule]);}else {return cIsPointInPath.apply(this,args);}};window.Path2D=Path2D;}var path2dPolyfill$1=polyFillPath2D;var parsePath=parsePath$2;var path2dPolyfill=path2dPolyfill$1;if(typeof window!=="undefined"){path2dPolyfill(window);}var src={path2dPolyfill:path2dPolyfill,parsePath:parsePath};var hasOwn$1=Object.prototype.hasOwnProperty;var toStr$1=Object.prototype.toString;var defineProperty$2=Object.defineProperty;var gOPD$1=Object.getOwnPropertyDescriptor;var isArray$1=function isArray(arr){if(typeof Array.isArray==='function'){return Array.isArray(arr);}return toStr$1.call(arr)==='[object Array]';};var isPlainObject$2=function isPlainObject(obj){if(!obj||toStr$1.call(obj)!=='[object Object]'){return false;}var hasOwnConstructor=hasOwn$1.call(obj,'constructor');var hasIsPrototypeOf=obj.constructor&&obj.constructor.prototype&&hasOwn$1.call(obj.constructor.prototype,'isPrototypeOf');// Not own constructor property must be Object
  if(obj.constructor&&!hasOwnConstructor&&!hasIsPrototypeOf){return false;}// Own properties are enumerated firstly, so to speed up,
  // if last one is own, then all properties are own.
  var key;for(key in obj){/**/}return typeof key==='undefined'||hasOwn$1.call(obj,key);};// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
  var setProperty$2=function setProperty(target,options){if(defineProperty$2&&options.name==='__proto__'){defineProperty$2(target,options.name,{enumerable:true,configurable:true,value:options.newValue,writable:true});}else {target[options.name]=options.newValue;}};// Return undefined instead of __proto__ if '__proto__' is not an own property
  var getProperty$1=function getProperty(obj,name){if(name==='__proto__'){if(!hasOwn$1.call(obj,name)){return void 0;}else if(gOPD$1){// In early versions of node, obj['__proto__'] is buggy when obj has
  // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
  return gOPD$1(obj,name).value;}}return obj[name];};var extend$1=function extend(){var options,name,src,copy,copyIsArray,clone;var target=arguments[0];var i=1;var length=arguments.length;var deep=false;// Handle a deep copy situation
  if(typeof target==='boolean'){deep=target;target=arguments[1]||{};// skip the boolean and the target
  i=2;}if(target==null||typeof target!=='object'&&typeof target!=='function'){target={};}for(;i<length;++i){options=arguments[i];// Only deal with non-null/undefined values
  if(options!=null){// Extend the base object
  for(name in options){src=getProperty$1(target,name);copy=getProperty$1(options,name);// Prevent never-ending loop
  if(target!==copy){// Recurse if we're merging plain objects or arrays
  if(deep&&copy&&(isPlainObject$2(copy)||(copyIsArray=isArray$1(copy)))){if(copyIsArray){copyIsArray=false;clone=src&&isArray$1(src)?src:[];}else {clone=src&&isPlainObject$2(src)?src:{};}// Never move original objects, clone them
  setProperty$2(target,{name:name,newValue:extend(deep,clone,copy)});// Don't bring in undefined values
  }else if(typeof copy!=='undefined'){setProperty$2(target,{name:name,newValue:copy});}}}}}// Return the modified object
  return target;};var about={version:'2.2.5'};function ownKeys$1(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread2$1(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys$1(Object(source),!0).forEach(function(key){_defineProperty$2(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys$1(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}function _defineProperty$2(obj,key,value){key=_toPropertyKey$2(key);if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else {obj[key]=value;}return obj;}function _toPrimitive$2(input,hint){if(typeof input!=="object"||input===null)return input;var prim=input[Symbol.toPrimitive];if(prim!==undefined){var res=prim.call(input,hint||"default");if(typeof res!=="object")return res;throw new TypeError("@@toPrimitive must return a primitive value.");}return (hint==="string"?String:Number)(input);}function _toPropertyKey$2(arg){var key=_toPrimitive$2(arg,"string");return typeof key==="symbol"?key:String(key);}/* global navigator */function detectTouchSupport(e){if('ontouchstart'in e&&'ontouchend'in e||navigator.maxTouchPoints>1){return true;}return false;}function isTouchEvent(e){return !!e.changedTouches;}function isValidTapEvent(e,eventInfo){const isTouch=isTouchEvent(e);const ee=isTouch?e.changedTouches[0]:e;const dt=Date.now()-eventInfo.time;const dx=isNaN(eventInfo.x)?0:Math.abs(ee.clientX-eventInfo.x);const dy=isNaN(eventInfo.y)?0:Math.abs(ee.clientY-eventInfo.y);return (e.button===0||isTouch)&&!eventInfo.multiTouch&&dx<=12&&dy<=12&&dt<=300;}function isNumber$1(v){return typeof v==='number'&&!isNaN(v);}function notNumber(value){return typeof value!=='number'||isNaN(value);}function getMinMax$1$1(points){const num=points.length;let xMin=NaN;let xMax=NaN;let yMin=NaN;let yMax=NaN;for(let i=0;i<num;i++){xMin=isNaN(xMin)?points[i].x:Math.min(xMin,points[i].x);xMax=isNaN(xMax)?points[i].x:Math.max(xMax,points[i].x);yMin=isNaN(yMin)?points[i].y:Math.min(yMin,points[i].y);yMax=isNaN(yMax)?points[i].y:Math.max(yMax,points[i].y);}return [xMin,yMin,xMax,yMax];}/**
   * @ignore
   * @param {oject} line
   * @returns {Point[]} Array of points
   */function lineToPoints(line){const x1=line.x1||0;const y1=line.y1||0;const x2=line.x2||0;const y2=line.y2||0;return [{x:x1,y:y1},{x:x2,y:y2}];}/**
   * @ignore
   * @param {oject} rect
   * @returns {Point[]} Array of points
   */function rectToPoints(rect){return [{x:rect.x,y:rect.y},{x:rect.x+rect.width,y:rect.y},{x:rect.x+rect.width,y:rect.y+rect.height},{x:rect.x,y:rect.y+rect.height}];}function pointsToRect(points){const[xMin,yMin,xMax,yMax]=getMinMax$1$1(points);return {x:xMin,y:yMin,width:xMax-xMin,height:yMax-yMin};}function pointsToCircle(points,r){return {cx:points[0].x,cy:points[0].y,r};}function pointsToLine(points){return {x1:points[0].x,y1:points[0].y,x2:points[1].x,y2:points[1].y};}/**
   * @ignore
   * @param {oject}
   * @returns {string} Type of geometry
   */function getShapeType(shape){const{x,y,// Point
  width,height,// Rect
  x1,x2,y1,y2,// Line
  cx,cy,r,// Circle
  vertices// Polygon or GeoPolygon
  }=shape||{};if(isNumber$1(cx)&&isNumber$1(cy)&&isNumber$1(r)){return 'circle';}if(isNumber$1(x1)&&isNumber$1(x2)&&isNumber$1(y1)&&isNumber$1(y2)){return 'line';}if(isNumber$1(x)&&isNumber$1(y)&&isNumber$1(width)&&isNumber$1(height)){return 'rect';}if(isNumber$1(x)&&isNumber$1(y)){return 'point';}if(Array.isArray(vertices)){return vertices.every(item=>Array.isArray(item))?'geopolygon':'polygon';}return null;}function expandRect(size,rect){return {x:rect.x-size,y:rect.y-size,width:rect.width+size,height:rect.height+size};}// import types from './types';
  /**
   * @ignore
   * @param {Array<DataSource>} dataSources
   * @param {any} { logger }
   * @returns {function}
   */function datasets(dataSources,_ref){let{types,logger}=_ref;const data={};const sets=[];if(!Array.isArray(dataSources)){logger.warn('Deprecated: "data-source" configuration"');sets.push(dataSources);}else {sets.push(...dataSources);}sets.forEach((d,i)=>{let datasetFactory=types(d.type);if(datasetFactory){let key=d.key;if(typeof d.key==='undefined'){logger.warn("Missing key for dataset. Using index '".concat(i,"' as key."));key=i;}let dataset=datasetFactory({key,data:d.data,config:d.config});data[key]=dataset;}});/**
     * Returns the `dataset` which has `key` as identifier
     * @ignore
     * @param {string} key - The dataset identifier
     * @returns {Dataset}
     */const fn=key=>{if(key){return data[key];}return data[Object.keys(data)[0]];};return fn;}/**
   * @typedef {object} DataSource
   * @property {string=} key - Unique identifier for this data source
   * @property {string} type - The dataset type
   * @property {any} data - Data
   */var pi$1=Math.PI,tau$1=2*pi$1,epsilon$1=1e-6,tauEpsilon=tau$1-epsilon$1;function Path$1(){this._x0=this._y0=// start of current subpath
  this._x1=this._y1=null;// end of current subpath
  this._="";}function path(){return new Path$1();}Path$1.prototype=path.prototype={constructor:Path$1,moveTo:function(x,y){this._+="M"+(this._x0=this._x1=+x)+","+(this._y0=this._y1=+y);},closePath:function(){if(this._x1!==null){this._x1=this._x0,this._y1=this._y0;this._+="Z";}},lineTo:function(x,y){this._+="L"+(this._x1=+x)+","+(this._y1=+y);},quadraticCurveTo:function(x1,y1,x,y){this._+="Q"+ +x1+","+ +y1+","+(this._x1=+x)+","+(this._y1=+y);},bezierCurveTo:function(x1,y1,x2,y2,x,y){this._+="C"+ +x1+","+ +y1+","+ +x2+","+ +y2+","+(this._x1=+x)+","+(this._y1=+y);},arcTo:function(x1,y1,x2,y2,r){x1=+x1,y1=+y1,x2=+x2,y2=+y2,r=+r;var x0=this._x1,y0=this._y1,x21=x2-x1,y21=y2-y1,x01=x0-x1,y01=y0-y1,l01_2=x01*x01+y01*y01;// Is the radius negative? Error.
  if(r<0)throw new Error("negative radius: "+r);// Is this path empty? Move to (x1,y1).
  if(this._x1===null){this._+="M"+(this._x1=x1)+","+(this._y1=y1);}// Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
  else if(!(l01_2>epsilon$1));// Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
  // Equivalently, is (x1,y1) coincident with (x2,y2)?
  // Or, is the radius zero? Line to (x1,y1).
  else if(!(Math.abs(y01*x21-y21*x01)>epsilon$1)||!r){this._+="L"+(this._x1=x1)+","+(this._y1=y1);}// Otherwise, draw an arc!
  else {var x20=x2-x0,y20=y2-y0,l21_2=x21*x21+y21*y21,l20_2=x20*x20+y20*y20,l21=Math.sqrt(l21_2),l01=Math.sqrt(l01_2),l=r*Math.tan((pi$1-Math.acos((l21_2+l01_2-l20_2)/(2*l21*l01)))/2),t01=l/l01,t21=l/l21;// If the start tangent is not coincident with (x0,y0), line to.
  if(Math.abs(t01-1)>epsilon$1){this._+="L"+(x1+t01*x01)+","+(y1+t01*y01);}this._+="A"+r+","+r+",0,0,"+ +(y01*x20>x01*y20)+","+(this._x1=x1+t21*x21)+","+(this._y1=y1+t21*y21);}},arc:function(x,y,r,a0,a1,ccw){x=+x,y=+y,r=+r,ccw=!!ccw;var dx=r*Math.cos(a0),dy=r*Math.sin(a0),x0=x+dx,y0=y+dy,cw=1^ccw,da=ccw?a0-a1:a1-a0;// Is the radius negative? Error.
  if(r<0)throw new Error("negative radius: "+r);// Is this path empty? Move to (x0,y0).
  if(this._x1===null){this._+="M"+x0+","+y0;}// Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
  else if(Math.abs(this._x1-x0)>epsilon$1||Math.abs(this._y1-y0)>epsilon$1){this._+="L"+x0+","+y0;}// Is this arc empty? We’re done.
  if(!r)return;// Does the angle go the wrong way? Flip the direction.
  if(da<0)da=da%tau$1+tau$1;// Is this a complete circle? Draw two arcs to complete the circle.
  if(da>tauEpsilon){this._+="A"+r+","+r+",0,1,"+cw+","+(x-dx)+","+(y-dy)+"A"+r+","+r+",0,1,"+cw+","+(this._x1=x0)+","+(this._y1=y0);}// Is this arc non-empty? Draw an arc!
  else if(da>epsilon$1){this._+="A"+r+","+r+",0,"+ +(da>=pi$1)+","+cw+","+(this._x1=x+r*Math.cos(a1))+","+(this._y1=y+r*Math.sin(a1));}},rect:function(x,y,w,h){this._+="M"+(this._x0=this._x1=+x)+","+(this._y0=this._y1=+y)+"h"+ +w+"v"+ +h+"h"+-w+"Z";},toString:function(){return this._;}};function constant$2(x){return function constant(){return x;};}var abs=Math.abs;var atan2=Math.atan2;var cos=Math.cos;var max=Math.max;var min=Math.min;var sin=Math.sin;var sqrt=Math.sqrt;var epsilon=1e-12;var pi=Math.PI;var halfPi=pi/2;var tau=2*pi;function acos(x){return x>1?0:x<-1?pi:Math.acos(x);}function asin(x){return x>=1?halfPi:x<=-1?-halfPi:Math.asin(x);}function arcInnerRadius(d){return d.innerRadius;}function arcOuterRadius(d){return d.outerRadius;}function arcStartAngle(d){return d.startAngle;}function arcEndAngle(d){return d.endAngle;}function arcPadAngle(d){return d&&d.padAngle;// Note: optional!
  }function intersect(x0,y0,x1,y1,x2,y2,x3,y3){var x10=x1-x0,y10=y1-y0,x32=x3-x2,y32=y3-y2,t=y32*x10-x32*y10;if(t*t<epsilon)return;t=(x32*(y0-y2)-y32*(x0-x2))/t;return [x0+t*x10,y0+t*y10];}// Compute perpendicular offset line of length rc.
  // http://mathworld.wolfram.com/Circle-LineIntersection.html
  function cornerTangents(x0,y0,x1,y1,r1,rc,cw){var x01=x0-x1,y01=y0-y1,lo=(cw?rc:-rc)/sqrt(x01*x01+y01*y01),ox=lo*y01,oy=-lo*x01,x11=x0+ox,y11=y0+oy,x10=x1+ox,y10=y1+oy,x00=(x11+x10)/2,y00=(y11+y10)/2,dx=x10-x11,dy=y10-y11,d2=dx*dx+dy*dy,r=r1-rc,D=x11*y10-x10*y11,d=(dy<0?-1:1)*sqrt(max(0,r*r*d2-D*D)),cx0=(D*dy-dx*d)/d2,cy0=(-D*dx-dy*d)/d2,cx1=(D*dy+dx*d)/d2,cy1=(-D*dx+dy*d)/d2,dx0=cx0-x00,dy0=cy0-y00,dx1=cx1-x00,dy1=cy1-y00;// Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if(dx0*dx0+dy0*dy0>dx1*dx1+dy1*dy1)cx0=cx1,cy0=cy1;return {cx:cx0,cy:cy0,x01:-ox,y01:-oy,x11:cx0*(r1/r-1),y11:cy0*(r1/r-1)};}function arc(){var innerRadius=arcInnerRadius,outerRadius=arcOuterRadius,cornerRadius=constant$2(0),padRadius=null,startAngle=arcStartAngle,endAngle=arcEndAngle,padAngle=arcPadAngle,context=null;function arc(){var buffer,r,r0=+innerRadius.apply(this,arguments),r1=+outerRadius.apply(this,arguments),a0=startAngle.apply(this,arguments)-halfPi,a1=endAngle.apply(this,arguments)-halfPi,da=abs(a1-a0),cw=a1>a0;if(!context)context=buffer=path();// Ensure that the outer radius is always larger than the inner radius.
  if(r1<r0)r=r1,r1=r0,r0=r;// Is it a point?
  if(!(r1>epsilon))context.moveTo(0,0);// Or is it a circle or annulus?
  else if(da>tau-epsilon){context.moveTo(r1*cos(a0),r1*sin(a0));context.arc(0,0,r1,a0,a1,!cw);if(r0>epsilon){context.moveTo(r0*cos(a1),r0*sin(a1));context.arc(0,0,r0,a1,a0,cw);}}// Or is it a circular or annular sector?
  else {var a01=a0,a11=a1,a00=a0,a10=a1,da0=da,da1=da,ap=padAngle.apply(this,arguments)/2,rp=ap>epsilon&&(padRadius?+padRadius.apply(this,arguments):sqrt(r0*r0+r1*r1)),rc=min(abs(r1-r0)/2,+cornerRadius.apply(this,arguments)),rc0=rc,rc1=rc,t0,t1;// Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
  if(rp>epsilon){var p0=asin(rp/r0*sin(ap)),p1=asin(rp/r1*sin(ap));if((da0-=p0*2)>epsilon)p0*=cw?1:-1,a00+=p0,a10-=p0;else da0=0,a00=a10=(a0+a1)/2;if((da1-=p1*2)>epsilon)p1*=cw?1:-1,a01+=p1,a11-=p1;else da1=0,a01=a11=(a0+a1)/2;}var x01=r1*cos(a01),y01=r1*sin(a01),x10=r0*cos(a10),y10=r0*sin(a10);// Apply rounded corners?
  if(rc>epsilon){var x11=r1*cos(a11),y11=r1*sin(a11),x00=r0*cos(a00),y00=r0*sin(a00),oc;// Restrict the corner radius according to the sector angle.
  if(da<pi&&(oc=intersect(x01,y01,x00,y00,x11,y11,x10,y10))){var ax=x01-oc[0],ay=y01-oc[1],bx=x11-oc[0],by=y11-oc[1],kc=1/sin(acos((ax*bx+ay*by)/(sqrt(ax*ax+ay*ay)*sqrt(bx*bx+by*by)))/2),lc=sqrt(oc[0]*oc[0]+oc[1]*oc[1]);rc0=min(rc,(r0-lc)/(kc-1));rc1=min(rc,(r1-lc)/(kc+1));}}// Is the sector collapsed to a line?
  if(!(da1>epsilon))context.moveTo(x01,y01);// Does the sector’s outer ring have rounded corners?
  else if(rc1>epsilon){t0=cornerTangents(x00,y00,x01,y01,r1,rc1,cw);t1=cornerTangents(x11,y11,x10,y10,r1,rc1,cw);context.moveTo(t0.cx+t0.x01,t0.cy+t0.y01);// Have the corners merged?
  if(rc1<rc)context.arc(t0.cx,t0.cy,rc1,atan2(t0.y01,t0.x01),atan2(t1.y01,t1.x01),!cw);// Otherwise, draw the two corners and the ring.
  else {context.arc(t0.cx,t0.cy,rc1,atan2(t0.y01,t0.x01),atan2(t0.y11,t0.x11),!cw);context.arc(0,0,r1,atan2(t0.cy+t0.y11,t0.cx+t0.x11),atan2(t1.cy+t1.y11,t1.cx+t1.x11),!cw);context.arc(t1.cx,t1.cy,rc1,atan2(t1.y11,t1.x11),atan2(t1.y01,t1.x01),!cw);}}// Or is the outer ring just a circular arc?
  else context.moveTo(x01,y01),context.arc(0,0,r1,a01,a11,!cw);// Is there no inner ring, and it’s a circular sector?
  // Or perhaps it’s an annular sector collapsed due to padding?
  if(!(r0>epsilon)||!(da0>epsilon))context.lineTo(x10,y10);// Does the sector’s inner ring (or point) have rounded corners?
  else if(rc0>epsilon){t0=cornerTangents(x10,y10,x11,y11,r0,-rc0,cw);t1=cornerTangents(x01,y01,x00,y00,r0,-rc0,cw);context.lineTo(t0.cx+t0.x01,t0.cy+t0.y01);// Have the corners merged?
  if(rc0<rc)context.arc(t0.cx,t0.cy,rc0,atan2(t0.y01,t0.x01),atan2(t1.y01,t1.x01),!cw);// Otherwise, draw the two corners and the ring.
  else {context.arc(t0.cx,t0.cy,rc0,atan2(t0.y01,t0.x01),atan2(t0.y11,t0.x11),!cw);context.arc(0,0,r0,atan2(t0.cy+t0.y11,t0.cx+t0.x11),atan2(t1.cy+t1.y11,t1.cx+t1.x11),cw);context.arc(t1.cx,t1.cy,rc0,atan2(t1.y11,t1.x11),atan2(t1.y01,t1.x01),!cw);}}// Or is the inner ring just a circular arc?
  else context.arc(0,0,r0,a10,a00,cw);}context.closePath();if(buffer)return context=null,buffer+""||null;}arc.centroid=function(){var r=(+innerRadius.apply(this,arguments)+ +outerRadius.apply(this,arguments))/2,a=(+startAngle.apply(this,arguments)+ +endAngle.apply(this,arguments))/2-pi/2;return [cos(a)*r,sin(a)*r];};arc.innerRadius=function(_){return arguments.length?(innerRadius=typeof _==="function"?_:constant$2(+_),arc):innerRadius;};arc.outerRadius=function(_){return arguments.length?(outerRadius=typeof _==="function"?_:constant$2(+_),arc):outerRadius;};arc.cornerRadius=function(_){return arguments.length?(cornerRadius=typeof _==="function"?_:constant$2(+_),arc):cornerRadius;};arc.padRadius=function(_){return arguments.length?(padRadius=_==null?null:typeof _==="function"?_:constant$2(+_),arc):padRadius;};arc.startAngle=function(_){return arguments.length?(startAngle=typeof _==="function"?_:constant$2(+_),arc):startAngle;};arc.endAngle=function(_){return arguments.length?(endAngle=typeof _==="function"?_:constant$2(+_),arc):endAngle;};arc.padAngle=function(_){return arguments.length?(padAngle=typeof _==="function"?_:constant$2(+_),arc):padAngle;};arc.context=function(_){return arguments.length?(context=_==null?null:_,arc):context;};return arc;}function Linear(context){this._context=context;}Linear.prototype={areaStart:function(){this._line=0;},areaEnd:function(){this._line=NaN;},lineStart:function(){this._point=0;},lineEnd:function(){if(this._line||this._line!==0&&this._point===1)this._context.closePath();this._line=1-this._line;},point:function(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;// proceed
  default:this._context.lineTo(x,y);break;}}};function curveLinear(context){return new Linear(context);}function x$1(p){return p[0];}function y$1(p){return p[1];}function line$2(){var x=x$1,y=y$1,defined=constant$2(true),context=null,curve=curveLinear,output=null;function line(data){var i,n=data.length,d,defined0=false,buffer;if(context==null)output=curve(buffer=path());for(i=0;i<=n;++i){if(!(i<n&&defined(d=data[i],i,data))===defined0){if(defined0=!defined0)output.lineStart();else output.lineEnd();}if(defined0)output.point(+x(d,i,data),+y(d,i,data));}if(buffer)return output=null,buffer+""||null;}line.x=function(_){return arguments.length?(x=typeof _==="function"?_:constant$2(+_),line):x;};line.y=function(_){return arguments.length?(y=typeof _==="function"?_:constant$2(+_),line):y;};line.defined=function(_){return arguments.length?(defined=typeof _==="function"?_:constant$2(!!_),line):defined;};line.curve=function(_){return arguments.length?(curve=_,context!=null&&(output=curve(context)),line):curve;};line.context=function(_){return arguments.length?(_==null?context=output=null:output=curve(context=_),line):context;};return line;}function area$5(){var x0=x$1,x1=null,y0=constant$2(0),y1=y$1,defined=constant$2(true),context=null,curve=curveLinear,output=null;function area(data){var i,j,k,n=data.length,d,defined0=false,buffer,x0z=new Array(n),y0z=new Array(n);if(context==null)output=curve(buffer=path());for(i=0;i<=n;++i){if(!(i<n&&defined(d=data[i],i,data))===defined0){if(defined0=!defined0){j=i;output.areaStart();output.lineStart();}else {output.lineEnd();output.lineStart();for(k=i-1;k>=j;--k){output.point(x0z[k],y0z[k]);}output.lineEnd();output.areaEnd();}}if(defined0){x0z[i]=+x0(d,i,data),y0z[i]=+y0(d,i,data);output.point(x1?+x1(d,i,data):x0z[i],y1?+y1(d,i,data):y0z[i]);}}if(buffer)return output=null,buffer+""||null;}function arealine(){return line$2().defined(defined).curve(curve).context(context);}area.x=function(_){return arguments.length?(x0=typeof _==="function"?_:constant$2(+_),x1=null,area):x0;};area.x0=function(_){return arguments.length?(x0=typeof _==="function"?_:constant$2(+_),area):x0;};area.x1=function(_){return arguments.length?(x1=_==null?null:typeof _==="function"?_:constant$2(+_),area):x1;};area.y=function(_){return arguments.length?(y0=typeof _==="function"?_:constant$2(+_),y1=null,area):y0;};area.y0=function(_){return arguments.length?(y0=typeof _==="function"?_:constant$2(+_),area):y0;};area.y1=function(_){return arguments.length?(y1=_==null?null:typeof _==="function"?_:constant$2(+_),area):y1;};area.lineX0=area.lineY0=function(){return arealine().x(x0).y(y0);};area.lineY1=function(){return arealine().x(x0).y(y1);};area.lineX1=function(){return arealine().x(x1).y(y0);};area.defined=function(_){return arguments.length?(defined=typeof _==="function"?_:constant$2(!!_),area):defined;};area.curve=function(_){return arguments.length?(curve=_,context!=null&&(output=curve(context)),area):curve;};area.context=function(_){return arguments.length?(_==null?context=output=null:output=curve(context=_),area):context;};return area;}function descending$1(a,b){return b<a?-1:b>a?1:b>=a?0:NaN;}function identity$2(d){return d;}function pie$1(){var value=identity$2,sortValues=descending$1,sort=null,startAngle=constant$2(0),endAngle=constant$2(tau),padAngle=constant$2(0);function pie(data){var i,n=data.length,j,k,sum=0,index=new Array(n),arcs=new Array(n),a0=+startAngle.apply(this,arguments),da=Math.min(tau,Math.max(-tau,endAngle.apply(this,arguments)-a0)),a1,p=Math.min(Math.abs(da)/n,padAngle.apply(this,arguments)),pa=p*(da<0?-1:1),v;for(i=0;i<n;++i){if((v=arcs[index[i]=i]=+value(data[i],i,data))>0){sum+=v;}}// Optionally sort the arcs by previously-computed values or by data.
  if(sortValues!=null)index.sort(function(i,j){return sortValues(arcs[i],arcs[j]);});else if(sort!=null)index.sort(function(i,j){return sort(data[i],data[j]);});// Compute the arcs! They are stored in the original data's order.
  for(i=0,k=sum?(da-n*pa)/sum:0;i<n;++i,a0=a1){j=index[i],v=arcs[j],a1=a0+(v>0?v*k:0)+pa,arcs[j]={data:data[j],index:i,value:v,startAngle:a0,endAngle:a1,padAngle:p};}return arcs;}pie.value=function(_){return arguments.length?(value=typeof _==="function"?_:constant$2(+_),pie):value;};pie.sortValues=function(_){return arguments.length?(sortValues=_,sort=null,pie):sortValues;};pie.sort=function(_){return arguments.length?(sort=_,sortValues=null,pie):sort;};pie.startAngle=function(_){return arguments.length?(startAngle=typeof _==="function"?_:constant$2(+_),pie):startAngle;};pie.endAngle=function(_){return arguments.length?(endAngle=typeof _==="function"?_:constant$2(+_),pie):endAngle;};pie.padAngle=function(_){return arguments.length?(padAngle=typeof _==="function"?_:constant$2(+_),pie):padAngle;};return pie;}var slice=Array.prototype.slice;function point$3(that,x,y){that._context.bezierCurveTo((2*that._x0+that._x1)/3,(2*that._y0+that._y1)/3,(that._x0+2*that._x1)/3,(that._y0+2*that._y1)/3,(that._x0+4*that._x1+x)/6,(that._y0+4*that._y1+y)/6);}function Basis(context){this._context=context;}Basis.prototype={areaStart:function(){this._line=0;},areaEnd:function(){this._line=NaN;},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN;this._point=0;},lineEnd:function(){switch(this._point){case 3:point$3(this,this._x1,this._y1);// proceed
  case 2:this._context.lineTo(this._x1,this._y1);break;}if(this._line||this._line!==0&&this._point===1)this._context.closePath();this._line=1-this._line;},point:function(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;break;case 2:this._point=3;this._context.lineTo((5*this._x0+this._x1)/6,(5*this._y0+this._y1)/6);// proceed
  default:point$3(this,x,y);break;}this._x0=this._x1,this._x1=x;this._y0=this._y1,this._y1=y;}};function curveBasis(context){return new Basis(context);}function point$2(that,x,y){that._context.bezierCurveTo(that._x1+that._k*(that._x2-that._x0),that._y1+that._k*(that._y2-that._y0),that._x2+that._k*(that._x1-x),that._y2+that._k*(that._y1-y),that._x2,that._y2);}function Cardinal(context,tension){this._context=context;this._k=(1-tension)/6;}Cardinal.prototype={areaStart:function(){this._line=0;},areaEnd:function(){this._line=NaN;},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN;this._point=0;},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:point$2(this,this._x1,this._y1);break;}if(this._line||this._line!==0&&this._point===1)this._context.closePath();this._line=1-this._line;},point:function(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;this._x1=x,this._y1=y;break;case 2:this._point=3;// proceed
  default:point$2(this,x,y);break;}this._x0=this._x1,this._x1=this._x2,this._x2=x;this._y0=this._y1,this._y1=this._y2,this._y2=y;}};var curveCardinal=function custom(tension){function cardinal(context){return new Cardinal(context,tension);}cardinal.tension=function(tension){return custom(+tension);};return cardinal;}(0);function point$1(that,x,y){var x1=that._x1,y1=that._y1,x2=that._x2,y2=that._y2;if(that._l01_a>epsilon){var a=2*that._l01_2a+3*that._l01_a*that._l12_a+that._l12_2a,n=3*that._l01_a*(that._l01_a+that._l12_a);x1=(x1*a-that._x0*that._l12_2a+that._x2*that._l01_2a)/n;y1=(y1*a-that._y0*that._l12_2a+that._y2*that._l01_2a)/n;}if(that._l23_a>epsilon){var b=2*that._l23_2a+3*that._l23_a*that._l12_a+that._l12_2a,m=3*that._l23_a*(that._l23_a+that._l12_a);x2=(x2*b+that._x1*that._l23_2a-x*that._l12_2a)/m;y2=(y2*b+that._y1*that._l23_2a-y*that._l12_2a)/m;}that._context.bezierCurveTo(x1,y1,x2,y2,that._x2,that._y2);}function CatmullRom(context,alpha){this._context=context;this._alpha=alpha;}CatmullRom.prototype={areaStart:function(){this._line=0;},areaEnd:function(){this._line=NaN;},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN;this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0;},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:this.point(this._x2,this._y2);break;}if(this._line||this._line!==0&&this._point===1)this._context.closePath();this._line=1-this._line;},point:function(x,y){x=+x,y=+y;if(this._point){var x23=this._x2-x,y23=this._y2-y;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(x23*x23+y23*y23,this._alpha));}switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;break;case 2:this._point=3;// proceed
  default:point$1(this,x,y);break;}this._l01_a=this._l12_a,this._l12_a=this._l23_a;this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a;this._x0=this._x1,this._x1=this._x2,this._x2=x;this._y0=this._y1,this._y1=this._y2,this._y2=y;}};var curveCatmullRom=function custom(alpha){function catmullRom(context){return alpha?new CatmullRom(context,alpha):new Cardinal(context,0);}catmullRom.alpha=function(alpha){return custom(+alpha);};return catmullRom;}(0.5);function sign(x){return x<0?-1:1;}// Calculate the slopes of the tangents (Hermite-type interpolation) based on
  // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
  // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
  // NOV(II), P. 443, 1990.
  function slope3(that,x2,y2){var h0=that._x1-that._x0,h1=x2-that._x1,s0=(that._y1-that._y0)/(h0||h1<0&&-0),s1=(y2-that._y1)/(h1||h0<0&&-0),p=(s0*h1+s1*h0)/(h0+h1);return (sign(s0)+sign(s1))*Math.min(Math.abs(s0),Math.abs(s1),0.5*Math.abs(p))||0;}// Calculate a one-sided slope.
  function slope2(that,t){var h=that._x1-that._x0;return h?(3*(that._y1-that._y0)/h-t)/2:t;}// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
  // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
  // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
  function point(that,t0,t1){var x0=that._x0,y0=that._y0,x1=that._x1,y1=that._y1,dx=(x1-x0)/3;that._context.bezierCurveTo(x0+dx,y0+dx*t0,x1-dx,y1-dx*t1,x1,y1);}function MonotoneX(context){this._context=context;}MonotoneX.prototype={areaStart:function(){this._line=0;},areaEnd:function(){this._line=NaN;},lineStart:function(){this._x0=this._x1=this._y0=this._y1=this._t0=NaN;this._point=0;},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x1,this._y1);break;case 3:point(this,this._t0,slope2(this,this._t0));break;}if(this._line||this._line!==0&&this._point===1)this._context.closePath();this._line=1-this._line;},point:function(x,y){var t1=NaN;x=+x,y=+y;if(x===this._x1&&y===this._y1)return;// Ignore coincident points.
  switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;break;case 2:this._point=3;point(this,slope2(this,t1=slope3(this,x,y)),t1);break;default:point(this,this._t0,t1=slope3(this,x,y));break;}this._x0=this._x1,this._x1=x;this._y0=this._y1,this._y1=y;this._t0=t1;}};function MonotoneY(context){this._context=new ReflectContext(context);}(MonotoneY.prototype=Object.create(MonotoneX.prototype)).point=function(x,y){MonotoneX.prototype.point.call(this,y,x);};function ReflectContext(context){this._context=context;}ReflectContext.prototype={moveTo:function(x,y){this._context.moveTo(y,x);},closePath:function(){this._context.closePath();},lineTo:function(x,y){this._context.lineTo(y,x);},bezierCurveTo:function(x1,y1,x2,y2,x,y){this._context.bezierCurveTo(y1,x1,y2,x2,y,x);}};function monotoneX(context){return new MonotoneX(context);}function monotoneY(context){return new MonotoneY(context);}function Natural(context){this._context=context;}Natural.prototype={areaStart:function(){this._line=0;},areaEnd:function(){this._line=NaN;},lineStart:function(){this._x=[];this._y=[];},lineEnd:function(){var x=this._x,y=this._y,n=x.length;if(n){this._line?this._context.lineTo(x[0],y[0]):this._context.moveTo(x[0],y[0]);if(n===2){this._context.lineTo(x[1],y[1]);}else {var px=controlPoints(x),py=controlPoints(y);for(var i0=0,i1=1;i1<n;++i0,++i1){this._context.bezierCurveTo(px[0][i0],py[0][i0],px[1][i0],py[1][i0],x[i1],y[i1]);}}}if(this._line||this._line!==0&&n===1)this._context.closePath();this._line=1-this._line;this._x=this._y=null;},point:function(x,y){this._x.push(+x);this._y.push(+y);}};// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
  function controlPoints(x){var i,n=x.length-1,m,a=new Array(n),b=new Array(n),r=new Array(n);a[0]=0,b[0]=2,r[0]=x[0]+2*x[1];for(i=1;i<n-1;++i)a[i]=1,b[i]=4,r[i]=4*x[i]+2*x[i+1];a[n-1]=2,b[n-1]=7,r[n-1]=8*x[n-1]+x[n];for(i=1;i<n;++i)m=a[i]/b[i-1],b[i]-=m,r[i]-=m*r[i-1];a[n-1]=r[n-1]/b[n-1];for(i=n-2;i>=0;--i)a[i]=(r[i]-a[i+1])/b[i];b[n-1]=(x[n]+a[n-1])/2;for(i=0;i<n-1;++i)b[i]=2*x[i+1]-a[i+1];return [a,b];}function curveNatural(context){return new Natural(context);}function Step(context,t){this._context=context;this._t=t;}Step.prototype={areaStart:function(){this._line=0;},areaEnd:function(){this._line=NaN;},lineStart:function(){this._x=this._y=NaN;this._point=0;},lineEnd:function(){if(0<this._t&&this._t<1&&this._point===2)this._context.lineTo(this._x,this._y);if(this._line||this._line!==0&&this._point===1)this._context.closePath();if(this._line>=0)this._t=1-this._t,this._line=1-this._line;},point:function(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;// proceed
  default:{if(this._t<=0){this._context.lineTo(this._x,y);this._context.lineTo(x,y);}else {var x1=this._x*(1-this._t)+x*this._t;this._context.lineTo(x1,this._y);this._context.lineTo(x1,y);}break;}}this._x=x,this._y=y;}};function curveStep(context){return new Step(context,0.5);}function stepBefore(context){return new Step(context,0);}function stepAfter(context){return new Step(context,1);}function stackOffsetNone(series,order){if(!((n=series.length)>1))return;for(var i=1,j,s0,s1=series[order[0]],n,m=s1.length;i<n;++i){s0=s1,s1=series[order[i]];for(j=0;j<m;++j){s1[j][1]+=s1[j][0]=isNaN(s0[j][1])?s0[j][0]:s0[j][1];}}}function stackOrderNone(series){var n=series.length,o=new Array(n);while(--n>=0)o[n]=n;return o;}function stackValue(d,key){return d[key];}function stack(){var keys=constant$2([]),order=stackOrderNone,offset=stackOffsetNone,value=stackValue;function stack(data){var kz=keys.apply(this,arguments),i,m=data.length,n=kz.length,sz=new Array(n),oz;for(i=0;i<n;++i){for(var ki=kz[i],si=sz[i]=new Array(m),j=0,sij;j<m;++j){si[j]=sij=[0,+value(data[j],ki,j,data)];sij.data=data[j];}si.key=ki;}for(i=0,oz=order(sz);i<n;++i){sz[oz[i]].index=i;}offset(sz,oz);return sz;}stack.keys=function(_){return arguments.length?(keys=typeof _==="function"?_:constant$2(slice.call(_)),stack):keys;};stack.value=function(_){return arguments.length?(value=typeof _==="function"?_:constant$2(+_),stack):value;};stack.order=function(_){return arguments.length?(order=_==null?stackOrderNone:typeof _==="function"?_:constant$2(slice.call(_)),stack):order;};stack.offset=function(_){return arguments.length?(offset=_==null?stackOffsetNone:_,stack):offset;};return stack;}function stackOffsetExpand(series,order){if(!((n=series.length)>0))return;for(var i,n,j=0,m=series[0].length,y;j<m;++j){for(y=i=0;i<n;++i)y+=series[i][j][1]||0;if(y)for(i=0;i<n;++i)series[i][j][1]/=y;}stackOffsetNone(series,order);}function stackOffsetDiverging(series,order){if(!((n=series.length)>0))return;for(var i,j=0,d,dy,yp,yn,n,m=series[order[0]].length;j<m;++j){for(yp=yn=0,i=0;i<n;++i){if((dy=(d=series[order[i]][j])[1]-d[0])>=0){d[0]=yp,d[1]=yp+=dy;}else if(dy<0){d[1]=yn,d[0]=yn+=dy;}else {d[0]=yp;}}}}function stackOffsetSilhouette(series,order){if(!((n=series.length)>0))return;for(var j=0,s0=series[order[0]],n,m=s0.length;j<m;++j){for(var i=0,y=0;i<n;++i)y+=series[i][j][1]||0;s0[j][1]+=s0[j][0]=-y/2;}stackOffsetNone(series,order);}function stackOffsetWiggle(series,order){if(!((n=series.length)>0)||!((m=(s0=series[order[0]]).length)>0))return;for(var y=0,j=1,s0,m,n;j<m;++j){for(var i=0,s1=0,s2=0;i<n;++i){var si=series[order[i]],sij0=si[j][1]||0,sij1=si[j-1][1]||0,s3=(sij0-sij1)/2;for(var k=0;k<i;++k){var sk=series[order[k]],skj0=sk[j][1]||0,skj1=sk[j-1][1]||0;s3+=skj0-skj1;}s1+=sij0,s2+=s3*sij0;}s0[j-1][1]+=s0[j-1][0]=y;if(s1)y-=s2/s1;}s0[j-1][1]+=s0[j-1][0]=y;stackOffsetNone(series,order);}function appearance(series){var peaks=series.map(peak);return stackOrderNone(series).sort(function(a,b){return peaks[a]-peaks[b];});}function peak(series){var i=-1,j=0,n=series.length,vi,vj=-Infinity;while(++i<n)if((vi=+series[i][1])>vj)vj=vi,j=i;return j;}function stackOrderAscending(series){var sums=series.map(sum);return stackOrderNone(series).sort(function(a,b){return sums[a]-sums[b];});}function sum(series){var s=0,i=-1,n=series.length,v;while(++i<n)if(v=+series[i][1])s+=v;return s;}function stackOrderInsideOut(series){var n=series.length,i,j,sums=series.map(sum),order=appearance(series),top=0,bottom=0,tops=[],bottoms=[];for(i=0;i<n;++i){j=order[i];if(top<bottom){top+=sums[j];tops.push(j);}else {bottom+=sums[j];bottoms.push(j);}}return bottoms.reverse().concat(tops);}function stackOrderReverse(series){return stackOrderNone(series).reverse();}function registryFactory(parentRegistry){let registerName=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'unspecified';let logger=arguments.length>2?arguments[2]:undefined;let defaultValue;const reg={};const parent=parentRegistry||{get:()=>undefined,has:()=>false,default:()=>undefined};defaultValue=parent.default();/**
     * @private
     * @param {string} key
     * @param {any} value
     * @throws {TypeError} Key must be a non-empty string
     * @returns {boolean} False if the given key already exists, true otherwise
     * @example
     * var r = registry();
     * r.add( "marker", function(args) {
     *   return new markers[args.type](args);
     * });
     *
     */function add(key,value){if(!key||typeof key!=='string'){throw new TypeError('Invalid argument: key must be a non-empty string');}if(key in reg){return false;}reg[key]=value;return true;}function get(key){return reg[key]||parent.get(key);}function has(key){return !!reg[key]||parent.has(key);}function remove(key){const d=reg[key];delete reg[key];return d;}function getKeys(){return Object.keys(reg);}function getValues(){return Object.keys(reg).map(key=>reg[key]);}function deflt(d){if(typeof d!=='undefined'){defaultValue=d;}return defaultValue;}/**
     * Register a `value` with the given `key`. If `value` is omitted, returns the `value` of `key`.
     * @alias registry
     * @param {string} key Name of the type to register
     * @param {any} [value] Value to store in the registry.
     * @returns {any} Registered value
     */function registry(key,value){if(typeof value!=='undefined'){return add(key,value);}const ret=get(key);if(logger&&typeof ret==='undefined'){logger.warn("".concat(key," does not exist in ").concat(registerName," registry"));}return ret||get(defaultValue);}registry.add=add;registry.get=get;registry.has=has;registry.remove=remove;registry.getKeys=getKeys;registry.getValues=getValues;registry.default=deflt;registry.register=add;// deprecated
  return registry;}function formatDecimal(x){return Math.abs(x=Math.round(x))>=1e21?x.toLocaleString("en").replace(/,/g,""):x.toString(10);}// Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimalParts(1.23) returns ["123", 0].
  function formatDecimalParts(x,p){if((i=(x=p?x.toExponential(p-1):x.toExponential()).indexOf("e"))<0)return null;// NaN, ±Infinity
  var i,coefficient=x.slice(0,i);// The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [coefficient.length>1?coefficient[0]+coefficient.slice(2):coefficient,+x.slice(i+1)];}function exponent(x){return x=formatDecimalParts(Math.abs(x)),x?x[1]:NaN;}function formatGroup(grouping,thousands){return function(value,width){var i=value.length,t=[],j=0,g=grouping[0],length=0;while(i>0&&g>0){if(length+g+1>width)g=Math.max(1,width-length);t.push(value.substring(i-=g,i+g));if((length+=g+1)>width)break;g=grouping[j=(j+1)%grouping.length];}return t.reverse().join(thousands);};}function formatNumerals(numerals){return function(value){return value.replace(/[0-9]/g,function(i){return numerals[+i];});};}// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
  var re=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function formatSpecifier(specifier){if(!(match=re.exec(specifier)))throw new Error("invalid format: "+specifier);var match;return new FormatSpecifier({fill:match[1],align:match[2],sign:match[3],symbol:match[4],zero:match[5],width:match[6],comma:match[7],precision:match[8]&&match[8].slice(1),trim:match[9],type:match[10]});}formatSpecifier.prototype=FormatSpecifier.prototype;// instanceof
  function FormatSpecifier(specifier){this.fill=specifier.fill===undefined?" ":specifier.fill+"";this.align=specifier.align===undefined?">":specifier.align+"";this.sign=specifier.sign===undefined?"-":specifier.sign+"";this.symbol=specifier.symbol===undefined?"":specifier.symbol+"";this.zero=!!specifier.zero;this.width=specifier.width===undefined?undefined:+specifier.width;this.comma=!!specifier.comma;this.precision=specifier.precision===undefined?undefined:+specifier.precision;this.trim=!!specifier.trim;this.type=specifier.type===undefined?"":specifier.type+"";}FormatSpecifier.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(this.width===undefined?"":Math.max(1,this.width|0))+(this.comma?",":"")+(this.precision===undefined?"":"."+Math.max(0,this.precision|0))+(this.trim?"~":"")+this.type;};// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
  function formatTrim(s){out:for(var n=s.length,i=1,i0=-1,i1;i<n;++i){switch(s[i]){case".":i0=i1=i;break;case"0":if(i0===0)i0=i;i1=i;break;default:if(!+s[i])break out;if(i0>0)i0=0;break;}}return i0>0?s.slice(0,i0)+s.slice(i1+1):s;}var prefixExponent;function formatPrefixAuto(x,p){var d=formatDecimalParts(x,p);if(!d)return x+"";var coefficient=d[0],exponent=d[1],i=exponent-(prefixExponent=Math.max(-8,Math.min(8,Math.floor(exponent/3)))*3)+1,n=coefficient.length;return i===n?coefficient:i>n?coefficient+new Array(i-n+1).join("0"):i>0?coefficient.slice(0,i)+"."+coefficient.slice(i):"0."+new Array(1-i).join("0")+formatDecimalParts(x,Math.max(0,p+i-1))[0];// less than 1y!
  }function formatRounded(x,p){var d=formatDecimalParts(x,p);if(!d)return x+"";var coefficient=d[0],exponent=d[1];return exponent<0?"0."+new Array(-exponent).join("0")+coefficient:coefficient.length>exponent+1?coefficient.slice(0,exponent+1)+"."+coefficient.slice(exponent+1):coefficient+new Array(exponent-coefficient.length+2).join("0");}var formatTypes={"%":(x,p)=>(x*100).toFixed(p),"b":x=>Math.round(x).toString(2),"c":x=>x+"","d":formatDecimal,"e":(x,p)=>x.toExponential(p),"f":(x,p)=>x.toFixed(p),"g":(x,p)=>x.toPrecision(p),"o":x=>Math.round(x).toString(8),"p":(x,p)=>formatRounded(x*100,p),"r":formatRounded,"s":formatPrefixAuto,"X":x=>Math.round(x).toString(16).toUpperCase(),"x":x=>Math.round(x).toString(16)};function identity$1(x){return x;}var map=Array.prototype.map,prefixes=["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];function formatLocale$1(locale){var group=locale.grouping===undefined||locale.thousands===undefined?identity$1:formatGroup(map.call(locale.grouping,Number),locale.thousands+""),currencyPrefix=locale.currency===undefined?"":locale.currency[0]+"",currencySuffix=locale.currency===undefined?"":locale.currency[1]+"",decimal=locale.decimal===undefined?".":locale.decimal+"",numerals=locale.numerals===undefined?identity$1:formatNumerals(map.call(locale.numerals,String)),percent=locale.percent===undefined?"%":locale.percent+"",minus=locale.minus===undefined?"−":locale.minus+"",nan=locale.nan===undefined?"NaN":locale.nan+"";function newFormat(specifier){specifier=formatSpecifier(specifier);var fill=specifier.fill,align=specifier.align,sign=specifier.sign,symbol=specifier.symbol,zero=specifier.zero,width=specifier.width,comma=specifier.comma,precision=specifier.precision,trim=specifier.trim,type=specifier.type;// The "n" type is an alias for ",g".
  if(type==="n")comma=true,type="g";// The "" type, and any invalid type, is an alias for ".12~g".
  else if(!formatTypes[type])precision===undefined&&(precision=12),trim=true,type="g";// If zero fill is specified, padding goes after sign and before digits.
  if(zero||fill==="0"&&align==="=")zero=true,fill="0",align="=";// Compute the prefix and suffix.
  // For SI-prefix, the suffix is lazily computed.
  var prefix=symbol==="$"?currencyPrefix:symbol==="#"&&/[boxX]/.test(type)?"0"+type.toLowerCase():"",suffix=symbol==="$"?currencySuffix:/[%p]/.test(type)?percent:"";// What format function should we use?
  // Is this an integer type?
  // Can this type generate exponential notation?
  var formatType=formatTypes[type],maybeSuffix=/[defgprs%]/.test(type);// Set the default precision if not specified,
  // or clamp the specified precision to the supported range.
  // For significant precision, it must be in [1, 21].
  // For fixed precision, it must be in [0, 20].
  precision=precision===undefined?6:/[gprs]/.test(type)?Math.max(1,Math.min(21,precision)):Math.max(0,Math.min(20,precision));function format(value){var valuePrefix=prefix,valueSuffix=suffix,i,n,c;if(type==="c"){valueSuffix=formatType(value)+valueSuffix;value="";}else {value=+value;// Determine the sign. -0 is not less than 0, but 1 / -0 is!
  var valueNegative=value<0||1/value<0;// Perform the initial formatting.
  value=isNaN(value)?nan:formatType(Math.abs(value),precision);// Trim insignificant zeros.
  if(trim)value=formatTrim(value);// If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
  if(valueNegative&&+value===0&&sign!=="+")valueNegative=false;// Compute the prefix and suffix.
  valuePrefix=(valueNegative?sign==="("?sign:minus:sign==="-"||sign==="("?"":sign)+valuePrefix;valueSuffix=(type==="s"?prefixes[8+prefixExponent/3]:"")+valueSuffix+(valueNegative&&sign==="("?")":"");// Break the formatted value into the integer “value” part that can be
  // grouped, and fractional or exponential “suffix” part that is not.
  if(maybeSuffix){i=-1,n=value.length;while(++i<n){if(c=value.charCodeAt(i),48>c||c>57){valueSuffix=(c===46?decimal+value.slice(i+1):value.slice(i))+valueSuffix;value=value.slice(0,i);break;}}}}// If the fill character is not "0", grouping is applied before padding.
  if(comma&&!zero)value=group(value,Infinity);// Compute the padding.
  var length=valuePrefix.length+value.length+valueSuffix.length,padding=length<width?new Array(width-length+1).join(fill):"";// If the fill character is "0", grouping is applied after padding.
  if(comma&&zero)value=group(padding+value,padding.length?width-valueSuffix.length:Infinity),padding="";// Reconstruct the final output based on the desired alignment.
  switch(align){case"<":value=valuePrefix+value+valueSuffix+padding;break;case"=":value=valuePrefix+padding+value+valueSuffix;break;case"^":value=padding.slice(0,length=padding.length>>1)+valuePrefix+value+valueSuffix+padding.slice(length);break;default:value=padding+valuePrefix+value+valueSuffix;break;}return numerals(value);}format.toString=function(){return specifier+"";};return format;}function formatPrefix(specifier,value){var f=newFormat((specifier=formatSpecifier(specifier),specifier.type="f",specifier)),e=Math.max(-8,Math.min(8,Math.floor(exponent(value)/3)))*3,k=Math.pow(10,-e),prefix=prefixes[8+e/3];return function(value){return f(k*value)+prefix;};}return {format:newFormat,formatPrefix:formatPrefix};}var locale;var format;var formatPrefix;defaultLocale({thousands:",",grouping:[3],currency:["$",""]});function defaultLocale(definition){locale=formatLocale$1(definition);format=locale.format;formatPrefix=locale.formatPrefix;return locale;}function precisionFixed(step){return Math.max(0,-exponent(Math.abs(step)));}function precisionPrefix(step,value){return Math.max(0,Math.max(-8,Math.min(8,Math.floor(exponent(value)/3)))*3-exponent(Math.abs(step)));}function precisionRound(step,max){step=Math.abs(step),max=Math.abs(max)-step;return Math.max(0,exponent(max)-exponent(step))+1;}function formatter$1$1(pattern,thousand,decimal){let locale,d3format;/**
     * Format a value according to the specified pattern created at construct
     * @private
     *
     * @param  {Number} value   The number to be formatted
     * @return {String}         [description]
     */function format(value){return d3format(value);}/**
     * Set the locale for the formatter
     *
     * @param  {Object} args   Locale object for formatting
     * @return {Undefined}      Returns nothing
     */format.locale=function localeFn(settings){locale=formatLocale$1(settings);d3format=locale.format(pattern);return this;};/**
     * Resets the formatter using format.locale
     * @ignore
     */function reset(){format.locale({decimal:decimal||'.',thousands:thousand||',',grouping:[3],currency:['$','']});}reset();/**
     * Format a value according to a specific pattern
     * that is not the one specified in the constructor
     *
     * @param  {String} p   Pattern
     * @param  {Number} v   Value
     * @param  {String} t   Thousand
     * @param  {String} d   Decimal
     * @return {String}     Formatted value
     */format.format=function formatFn(p,v,t,d){if(t||d){thousand=t;decimal=d;reset();}return locale.format(p)(v);};/**
     * Change the pattern on existing formatter
     *
     * @param  {String} p     Pattern (optional)
     * @return {String}       Returns the pattern
     */format.pattern=function patternFn(p){if(p){pattern=p;d3format=locale.format(p);}return pattern;};return format;}const t0=new Date(),t1=new Date();function timeInterval(floori,offseti,count,field){function interval(date){return floori(date=arguments.length===0?new Date():new Date(+date)),date;}interval.floor=date=>{return floori(date=new Date(+date)),date;};interval.ceil=date=>{return floori(date=new Date(date-1)),offseti(date,1),floori(date),date;};interval.round=date=>{const d0=interval(date),d1=interval.ceil(date);return date-d0<d1-date?d0:d1;};interval.offset=(date,step)=>{return offseti(date=new Date(+date),step==null?1:Math.floor(step)),date;};interval.range=(start,stop,step)=>{const range=[];start=interval.ceil(start);step=step==null?1:Math.floor(step);if(!(start<stop)||!(step>0))return range;// also handles Invalid Date
  let previous;do range.push(previous=new Date(+start)),offseti(start,step),floori(start);while(previous<start&&start<stop);return range;};interval.filter=test=>{return timeInterval(date=>{if(date>=date)while(floori(date),!test(date))date.setTime(date-1);},(date,step)=>{if(date>=date){if(step<0)while(++step<=0){while(offseti(date,-1),!test(date)){}// eslint-disable-line no-empty
  }else while(--step>=0){while(offseti(date,+1),!test(date)){}// eslint-disable-line no-empty
  }}});};if(count){interval.count=(start,end)=>{t0.setTime(+start),t1.setTime(+end);floori(t0),floori(t1);return Math.floor(count(t0,t1));};interval.every=step=>{step=Math.floor(step);return !isFinite(step)||!(step>0)?null:!(step>1)?interval:interval.filter(field?d=>field(d)%step===0:d=>interval.count(0,d)%step===0);};}return interval;}const durationSecond=1000;const durationMinute=durationSecond*60;const durationHour=durationMinute*60;const durationDay=durationHour*24;const durationWeek=durationDay*7;const timeDay=timeInterval(date=>date.setHours(0,0,0,0),(date,step)=>date.setDate(date.getDate()+step),(start,end)=>(end-start-(end.getTimezoneOffset()-start.getTimezoneOffset())*durationMinute)/durationDay,date=>date.getDate()-1);timeDay.range;const utcDay=timeInterval(date=>{date.setUTCHours(0,0,0,0);},(date,step)=>{date.setUTCDate(date.getUTCDate()+step);},(start,end)=>{return (end-start)/durationDay;},date=>{return date.getUTCDate()-1;});utcDay.range;const unixDay=timeInterval(date=>{date.setUTCHours(0,0,0,0);},(date,step)=>{date.setUTCDate(date.getUTCDate()+step);},(start,end)=>{return (end-start)/durationDay;},date=>{return Math.floor(date/durationDay);});unixDay.range;function timeWeekday(i){return timeInterval(date=>{date.setDate(date.getDate()-(date.getDay()+7-i)%7);date.setHours(0,0,0,0);},(date,step)=>{date.setDate(date.getDate()+step*7);},(start,end)=>{return (end-start-(end.getTimezoneOffset()-start.getTimezoneOffset())*durationMinute)/durationWeek;});}const timeSunday=timeWeekday(0);const timeMonday=timeWeekday(1);const timeTuesday=timeWeekday(2);const timeWednesday=timeWeekday(3);const timeThursday=timeWeekday(4);const timeFriday=timeWeekday(5);const timeSaturday=timeWeekday(6);timeSunday.range;timeMonday.range;timeTuesday.range;timeWednesday.range;timeThursday.range;timeFriday.range;timeSaturday.range;function utcWeekday(i){return timeInterval(date=>{date.setUTCDate(date.getUTCDate()-(date.getUTCDay()+7-i)%7);date.setUTCHours(0,0,0,0);},(date,step)=>{date.setUTCDate(date.getUTCDate()+step*7);},(start,end)=>{return (end-start)/durationWeek;});}const utcSunday=utcWeekday(0);const utcMonday=utcWeekday(1);const utcTuesday=utcWeekday(2);const utcWednesday=utcWeekday(3);const utcThursday=utcWeekday(4);const utcFriday=utcWeekday(5);const utcSaturday=utcWeekday(6);utcSunday.range;utcMonday.range;utcTuesday.range;utcWednesday.range;utcThursday.range;utcFriday.range;utcSaturday.range;const timeYear=timeInterval(date=>{date.setMonth(0,1);date.setHours(0,0,0,0);},(date,step)=>{date.setFullYear(date.getFullYear()+step);},(start,end)=>{return end.getFullYear()-start.getFullYear();},date=>{return date.getFullYear();});// An optimized implementation for this simple case.
  timeYear.every=k=>{return !isFinite(k=Math.floor(k))||!(k>0)?null:timeInterval(date=>{date.setFullYear(Math.floor(date.getFullYear()/k)*k);date.setMonth(0,1);date.setHours(0,0,0,0);},(date,step)=>{date.setFullYear(date.getFullYear()+step*k);});};timeYear.range;const utcYear=timeInterval(date=>{date.setUTCMonth(0,1);date.setUTCHours(0,0,0,0);},(date,step)=>{date.setUTCFullYear(date.getUTCFullYear()+step);},(start,end)=>{return end.getUTCFullYear()-start.getUTCFullYear();},date=>{return date.getUTCFullYear();});// An optimized implementation for this simple case.
  utcYear.every=k=>{return !isFinite(k=Math.floor(k))||!(k>0)?null:timeInterval(date=>{date.setUTCFullYear(Math.floor(date.getUTCFullYear()/k)*k);date.setUTCMonth(0,1);date.setUTCHours(0,0,0,0);},(date,step)=>{date.setUTCFullYear(date.getUTCFullYear()+step*k);});};utcYear.range;function ascending(a,b){return a==null||b==null?NaN:a<b?-1:a>b?1:a>=b?0:NaN;}function descending(a,b){return a==null||b==null?NaN:b<a?-1:b>a?1:b>=a?0:NaN;}function bisector(f){let compare1,compare2,delta;// If an accessor is specified, promote it to a comparator. In this case we
  // can test whether the search value is (self-) comparable. We can’t do this
  // for a comparator (except for specific, known comparators) because we can’t
  // tell if the comparator is symmetric, and an asymmetric comparator can’t be
  // used to test whether a single value is comparable.
  if(f.length!==2){compare1=ascending;compare2=(d,x)=>ascending(f(d),x);delta=(d,x)=>f(d)-x;}else {compare1=f===ascending||f===descending?f:zero$1;compare2=f;delta=f;}function left(a,x,lo=0,hi=a.length){if(lo<hi){if(compare1(x,x)!==0)return hi;do{const mid=lo+hi>>>1;if(compare2(a[mid],x)<0)lo=mid+1;else hi=mid;}while(lo<hi);}return lo;}function right(a,x,lo=0,hi=a.length){if(lo<hi){if(compare1(x,x)!==0)return hi;do{const mid=lo+hi>>>1;if(compare2(a[mid],x)<=0)lo=mid+1;else hi=mid;}while(lo<hi);}return lo;}function center(a,x,lo=0,hi=a.length){const i=left(a,x,lo,hi-1);return i>lo&&delta(a[i-1],x)>-delta(a[i],x)?i-1:i;}return {left,center,right};}function zero$1(){return 0;}function number$2(x){return x===null?NaN:+x;}const ascendingBisect=bisector(ascending);const bisectRight=ascendingBisect.right;bisector(number$2).center;var bisect=bisectRight;class InternMap extends Map{constructor(entries,key=keyof){super();Object.defineProperties(this,{_intern:{value:new Map()},_key:{value:key}});if(entries!=null)for(const[key,value]of entries)this.set(key,value);}get(key){return super.get(intern_get(this,key));}has(key){return super.has(intern_get(this,key));}set(key,value){return super.set(intern_set(this,key),value);}delete(key){return super.delete(intern_delete(this,key));}}function intern_get({_intern,_key},value){const key=_key(value);return _intern.has(key)?_intern.get(key):value;}function intern_set({_intern,_key},value){const key=_key(value);if(_intern.has(key))return _intern.get(key);_intern.set(key,value);return value;}function intern_delete({_intern,_key},value){const key=_key(value);if(_intern.has(key)){value=_intern.get(key);_intern.delete(key);}return value;}function keyof(value){return value!==null&&typeof value==="object"?value.valueOf():value;}const e10=Math.sqrt(50),e5=Math.sqrt(10),e2=Math.sqrt(2);function tickSpec(start,stop,count){const step=(stop-start)/Math.max(0,count),power=Math.floor(Math.log10(step)),error=step/Math.pow(10,power),factor=error>=e10?10:error>=e5?5:error>=e2?2:1;let i1,i2,inc;if(power<0){inc=Math.pow(10,-power)/factor;i1=Math.round(start*inc);i2=Math.round(stop*inc);if(i1/inc<start)++i1;if(i2/inc>stop)--i2;inc=-inc;}else {inc=Math.pow(10,power)*factor;i1=Math.round(start/inc);i2=Math.round(stop/inc);if(i1*inc<start)++i1;if(i2*inc>stop)--i2;}if(i2<i1&&0.5<=count&&count<2)return tickSpec(start,stop,count*2);return [i1,i2,inc];}function ticks(start,stop,count){stop=+stop,start=+start,count=+count;if(!(count>0))return [];if(start===stop)return [start];const reverse=stop<start,[i1,i2,inc]=reverse?tickSpec(stop,start,count):tickSpec(start,stop,count);if(!(i2>=i1))return [];const n=i2-i1+1,ticks=new Array(n);if(reverse){if(inc<0)for(let i=0;i<n;++i)ticks[i]=(i2-i)/-inc;else for(let i=0;i<n;++i)ticks[i]=(i2-i)*inc;}else {if(inc<0)for(let i=0;i<n;++i)ticks[i]=(i1+i)/-inc;else for(let i=0;i<n;++i)ticks[i]=(i1+i)*inc;}return ticks;}function tickIncrement(start,stop,count){stop=+stop,start=+start,count=+count;return tickSpec(start,stop,count)[2];}function tickStep(start,stop,count){stop=+stop,start=+start,count=+count;const reverse=stop<start,inc=reverse?tickIncrement(stop,start,count):tickIncrement(start,stop,count);return (reverse?-1:1)*(inc<0?1/-inc:inc);}function range$2(start,stop,step){start=+start,stop=+stop,step=(n=arguments.length)<2?(stop=start,start=0,1):n<3?1:+step;var i=-1,n=Math.max(0,Math.ceil((stop-start)/step))|0,range=new Array(n);while(++i<n){range[i]=start+i*step;}return range;}function localDate(d){if(0<=d.y&&d.y<100){var date=new Date(-1,d.m,d.d,d.H,d.M,d.S,d.L);date.setFullYear(d.y);return date;}return new Date(d.y,d.m,d.d,d.H,d.M,d.S,d.L);}function utcDate(d){if(0<=d.y&&d.y<100){var date=new Date(Date.UTC(-1,d.m,d.d,d.H,d.M,d.S,d.L));date.setUTCFullYear(d.y);return date;}return new Date(Date.UTC(d.y,d.m,d.d,d.H,d.M,d.S,d.L));}function newDate(y,m,d){return {y:y,m:m,d:d,H:0,M:0,S:0,L:0};}function formatLocale(locale){var locale_dateTime=locale.dateTime,locale_date=locale.date,locale_time=locale.time,locale_periods=locale.periods,locale_weekdays=locale.days,locale_shortWeekdays=locale.shortDays,locale_months=locale.months,locale_shortMonths=locale.shortMonths;var periodRe=formatRe(locale_periods),periodLookup=formatLookup(locale_periods),weekdayRe=formatRe(locale_weekdays),weekdayLookup=formatLookup(locale_weekdays),shortWeekdayRe=formatRe(locale_shortWeekdays),shortWeekdayLookup=formatLookup(locale_shortWeekdays),monthRe=formatRe(locale_months),monthLookup=formatLookup(locale_months),shortMonthRe=formatRe(locale_shortMonths),shortMonthLookup=formatLookup(locale_shortMonths);var formats={"a":formatShortWeekday,"A":formatWeekday,"b":formatShortMonth,"B":formatMonth,"c":null,"d":formatDayOfMonth,"e":formatDayOfMonth,"f":formatMicroseconds,"g":formatYearISO,"G":formatFullYearISO,"H":formatHour24,"I":formatHour12,"j":formatDayOfYear,"L":formatMilliseconds,"m":formatMonthNumber,"M":formatMinutes,"p":formatPeriod,"q":formatQuarter,"Q":formatUnixTimestamp,"s":formatUnixTimestampSeconds,"S":formatSeconds,"u":formatWeekdayNumberMonday,"U":formatWeekNumberSunday,"V":formatWeekNumberISO,"w":formatWeekdayNumberSunday,"W":formatWeekNumberMonday,"x":null,"X":null,"y":formatYear,"Y":formatFullYear,"Z":formatZone,"%":formatLiteralPercent};var utcFormats={"a":formatUTCShortWeekday,"A":formatUTCWeekday,"b":formatUTCShortMonth,"B":formatUTCMonth,"c":null,"d":formatUTCDayOfMonth,"e":formatUTCDayOfMonth,"f":formatUTCMicroseconds,"g":formatUTCYearISO,"G":formatUTCFullYearISO,"H":formatUTCHour24,"I":formatUTCHour12,"j":formatUTCDayOfYear,"L":formatUTCMilliseconds,"m":formatUTCMonthNumber,"M":formatUTCMinutes,"p":formatUTCPeriod,"q":formatUTCQuarter,"Q":formatUnixTimestamp,"s":formatUnixTimestampSeconds,"S":formatUTCSeconds,"u":formatUTCWeekdayNumberMonday,"U":formatUTCWeekNumberSunday,"V":formatUTCWeekNumberISO,"w":formatUTCWeekdayNumberSunday,"W":formatUTCWeekNumberMonday,"x":null,"X":null,"y":formatUTCYear,"Y":formatUTCFullYear,"Z":formatUTCZone,"%":formatLiteralPercent};var parses={"a":parseShortWeekday,"A":parseWeekday,"b":parseShortMonth,"B":parseMonth,"c":parseLocaleDateTime,"d":parseDayOfMonth,"e":parseDayOfMonth,"f":parseMicroseconds,"g":parseYear,"G":parseFullYear,"H":parseHour24,"I":parseHour24,"j":parseDayOfYear,"L":parseMilliseconds,"m":parseMonthNumber,"M":parseMinutes,"p":parsePeriod,"q":parseQuarter,"Q":parseUnixTimestamp,"s":parseUnixTimestampSeconds,"S":parseSeconds,"u":parseWeekdayNumberMonday,"U":parseWeekNumberSunday,"V":parseWeekNumberISO,"w":parseWeekdayNumberSunday,"W":parseWeekNumberMonday,"x":parseLocaleDate,"X":parseLocaleTime,"y":parseYear,"Y":parseFullYear,"Z":parseZone,"%":parseLiteralPercent};// These recursive directive definitions must be deferred.
  formats.x=newFormat(locale_date,formats);formats.X=newFormat(locale_time,formats);formats.c=newFormat(locale_dateTime,formats);utcFormats.x=newFormat(locale_date,utcFormats);utcFormats.X=newFormat(locale_time,utcFormats);utcFormats.c=newFormat(locale_dateTime,utcFormats);function newFormat(specifier,formats){return function(date){var string=[],i=-1,j=0,n=specifier.length,c,pad,format;if(!(date instanceof Date))date=new Date(+date);while(++i<n){if(specifier.charCodeAt(i)===37){string.push(specifier.slice(j,i));if((pad=pads[c=specifier.charAt(++i)])!=null)c=specifier.charAt(++i);else pad=c==="e"?" ":"0";if(format=formats[c])c=format(date,pad);string.push(c);j=i+1;}}string.push(specifier.slice(j,i));return string.join("");};}function newParse(specifier,Z){return function(string){var d=newDate(1900,undefined,1),i=parseSpecifier(d,specifier,string+="",0),week,day;if(i!=string.length)return null;// If a UNIX timestamp is specified, return it.
  if("Q"in d)return new Date(d.Q);if("s"in d)return new Date(d.s*1000+("L"in d?d.L:0));// If this is utcParse, never use the local timezone.
  if(Z&&!("Z"in d))d.Z=0;// The am-pm flag is 0 for AM, and 1 for PM.
  if("p"in d)d.H=d.H%12+d.p*12;// If the month was not specified, inherit from the quarter.
  if(d.m===undefined)d.m="q"in d?d.q:0;// Convert day-of-week and week-of-year to day-of-year.
  if("V"in d){if(d.V<1||d.V>53)return null;if(!("w"in d))d.w=1;if("Z"in d){week=utcDate(newDate(d.y,0,1)),day=week.getUTCDay();week=day>4||day===0?utcMonday.ceil(week):utcMonday(week);week=utcDay.offset(week,(d.V-1)*7);d.y=week.getUTCFullYear();d.m=week.getUTCMonth();d.d=week.getUTCDate()+(d.w+6)%7;}else {week=localDate(newDate(d.y,0,1)),day=week.getDay();week=day>4||day===0?timeMonday.ceil(week):timeMonday(week);week=timeDay.offset(week,(d.V-1)*7);d.y=week.getFullYear();d.m=week.getMonth();d.d=week.getDate()+(d.w+6)%7;}}else if("W"in d||"U"in d){if(!("w"in d))d.w="u"in d?d.u%7:"W"in d?1:0;day="Z"in d?utcDate(newDate(d.y,0,1)).getUTCDay():localDate(newDate(d.y,0,1)).getDay();d.m=0;d.d="W"in d?(d.w+6)%7+d.W*7-(day+5)%7:d.w+d.U*7-(day+6)%7;}// If a time zone is specified, all fields are interpreted as UTC and then
  // offset according to the specified time zone.
  if("Z"in d){d.H+=d.Z/100|0;d.M+=d.Z%100;return utcDate(d);}// Otherwise, all fields are in local time.
  return localDate(d);};}function parseSpecifier(d,specifier,string,j){var i=0,n=specifier.length,m=string.length,c,parse;while(i<n){if(j>=m)return -1;c=specifier.charCodeAt(i++);if(c===37){c=specifier.charAt(i++);parse=parses[c in pads?specifier.charAt(i++):c];if(!parse||(j=parse(d,string,j))<0)return -1;}else if(c!=string.charCodeAt(j++)){return -1;}}return j;}function parsePeriod(d,string,i){var n=periodRe.exec(string.slice(i));return n?(d.p=periodLookup.get(n[0].toLowerCase()),i+n[0].length):-1;}function parseShortWeekday(d,string,i){var n=shortWeekdayRe.exec(string.slice(i));return n?(d.w=shortWeekdayLookup.get(n[0].toLowerCase()),i+n[0].length):-1;}function parseWeekday(d,string,i){var n=weekdayRe.exec(string.slice(i));return n?(d.w=weekdayLookup.get(n[0].toLowerCase()),i+n[0].length):-1;}function parseShortMonth(d,string,i){var n=shortMonthRe.exec(string.slice(i));return n?(d.m=shortMonthLookup.get(n[0].toLowerCase()),i+n[0].length):-1;}function parseMonth(d,string,i){var n=monthRe.exec(string.slice(i));return n?(d.m=monthLookup.get(n[0].toLowerCase()),i+n[0].length):-1;}function parseLocaleDateTime(d,string,i){return parseSpecifier(d,locale_dateTime,string,i);}function parseLocaleDate(d,string,i){return parseSpecifier(d,locale_date,string,i);}function parseLocaleTime(d,string,i){return parseSpecifier(d,locale_time,string,i);}function formatShortWeekday(d){return locale_shortWeekdays[d.getDay()];}function formatWeekday(d){return locale_weekdays[d.getDay()];}function formatShortMonth(d){return locale_shortMonths[d.getMonth()];}function formatMonth(d){return locale_months[d.getMonth()];}function formatPeriod(d){return locale_periods[+(d.getHours()>=12)];}function formatQuarter(d){return 1+~~(d.getMonth()/3);}function formatUTCShortWeekday(d){return locale_shortWeekdays[d.getUTCDay()];}function formatUTCWeekday(d){return locale_weekdays[d.getUTCDay()];}function formatUTCShortMonth(d){return locale_shortMonths[d.getUTCMonth()];}function formatUTCMonth(d){return locale_months[d.getUTCMonth()];}function formatUTCPeriod(d){return locale_periods[+(d.getUTCHours()>=12)];}function formatUTCQuarter(d){return 1+~~(d.getUTCMonth()/3);}return {format:function(specifier){var f=newFormat(specifier+="",formats);f.toString=function(){return specifier;};return f;},parse:function(specifier){var p=newParse(specifier+="",false);p.toString=function(){return specifier;};return p;},utcFormat:function(specifier){var f=newFormat(specifier+="",utcFormats);f.toString=function(){return specifier;};return f;},utcParse:function(specifier){var p=newParse(specifier+="",true);p.toString=function(){return specifier;};return p;}};}var pads={"-":"","_":" ","0":"0"},numberRe=/^\s*\d+/,// note: ignores next directive
  percentRe=/^%/,requoteRe=/[\\^$*+?|[\]().{}]/g;function pad$2(value,fill,width){var sign=value<0?"-":"",string=(sign?-value:value)+"",length=string.length;return sign+(length<width?new Array(width-length+1).join(fill)+string:string);}function requote(s){return s.replace(requoteRe,"\\$&");}function formatRe(names){return new RegExp("^(?:"+names.map(requote).join("|")+")","i");}function formatLookup(names){return new Map(names.map((name,i)=>[name.toLowerCase(),i]));}function parseWeekdayNumberSunday(d,string,i){var n=numberRe.exec(string.slice(i,i+1));return n?(d.w=+n[0],i+n[0].length):-1;}function parseWeekdayNumberMonday(d,string,i){var n=numberRe.exec(string.slice(i,i+1));return n?(d.u=+n[0],i+n[0].length):-1;}function parseWeekNumberSunday(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.U=+n[0],i+n[0].length):-1;}function parseWeekNumberISO(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.V=+n[0],i+n[0].length):-1;}function parseWeekNumberMonday(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.W=+n[0],i+n[0].length):-1;}function parseFullYear(d,string,i){var n=numberRe.exec(string.slice(i,i+4));return n?(d.y=+n[0],i+n[0].length):-1;}function parseYear(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.y=+n[0]+(+n[0]>68?1900:2000),i+n[0].length):-1;}function parseZone(d,string,i){var n=/^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i,i+6));return n?(d.Z=n[1]?0:-(n[2]+(n[3]||"00")),i+n[0].length):-1;}function parseQuarter(d,string,i){var n=numberRe.exec(string.slice(i,i+1));return n?(d.q=n[0]*3-3,i+n[0].length):-1;}function parseMonthNumber(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.m=n[0]-1,i+n[0].length):-1;}function parseDayOfMonth(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.d=+n[0],i+n[0].length):-1;}function parseDayOfYear(d,string,i){var n=numberRe.exec(string.slice(i,i+3));return n?(d.m=0,d.d=+n[0],i+n[0].length):-1;}function parseHour24(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.H=+n[0],i+n[0].length):-1;}function parseMinutes(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.M=+n[0],i+n[0].length):-1;}function parseSeconds(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.S=+n[0],i+n[0].length):-1;}function parseMilliseconds(d,string,i){var n=numberRe.exec(string.slice(i,i+3));return n?(d.L=+n[0],i+n[0].length):-1;}function parseMicroseconds(d,string,i){var n=numberRe.exec(string.slice(i,i+6));return n?(d.L=Math.floor(n[0]/1000),i+n[0].length):-1;}function parseLiteralPercent(d,string,i){var n=percentRe.exec(string.slice(i,i+1));return n?i+n[0].length:-1;}function parseUnixTimestamp(d,string,i){var n=numberRe.exec(string.slice(i));return n?(d.Q=+n[0],i+n[0].length):-1;}function parseUnixTimestampSeconds(d,string,i){var n=numberRe.exec(string.slice(i));return n?(d.s=+n[0],i+n[0].length):-1;}function formatDayOfMonth(d,p){return pad$2(d.getDate(),p,2);}function formatHour24(d,p){return pad$2(d.getHours(),p,2);}function formatHour12(d,p){return pad$2(d.getHours()%12||12,p,2);}function formatDayOfYear(d,p){return pad$2(1+timeDay.count(timeYear(d),d),p,3);}function formatMilliseconds(d,p){return pad$2(d.getMilliseconds(),p,3);}function formatMicroseconds(d,p){return formatMilliseconds(d,p)+"000";}function formatMonthNumber(d,p){return pad$2(d.getMonth()+1,p,2);}function formatMinutes(d,p){return pad$2(d.getMinutes(),p,2);}function formatSeconds(d,p){return pad$2(d.getSeconds(),p,2);}function formatWeekdayNumberMonday(d){var day=d.getDay();return day===0?7:day;}function formatWeekNumberSunday(d,p){return pad$2(timeSunday.count(timeYear(d)-1,d),p,2);}function dISO(d){var day=d.getDay();return day>=4||day===0?timeThursday(d):timeThursday.ceil(d);}function formatWeekNumberISO(d,p){d=dISO(d);return pad$2(timeThursday.count(timeYear(d),d)+(timeYear(d).getDay()===4),p,2);}function formatWeekdayNumberSunday(d){return d.getDay();}function formatWeekNumberMonday(d,p){return pad$2(timeMonday.count(timeYear(d)-1,d),p,2);}function formatYear(d,p){return pad$2(d.getFullYear()%100,p,2);}function formatYearISO(d,p){d=dISO(d);return pad$2(d.getFullYear()%100,p,2);}function formatFullYear(d,p){return pad$2(d.getFullYear()%10000,p,4);}function formatFullYearISO(d,p){var day=d.getDay();d=day>=4||day===0?timeThursday(d):timeThursday.ceil(d);return pad$2(d.getFullYear()%10000,p,4);}function formatZone(d){var z=d.getTimezoneOffset();return (z>0?"-":(z*=-1,"+"))+pad$2(z/60|0,"0",2)+pad$2(z%60,"0",2);}function formatUTCDayOfMonth(d,p){return pad$2(d.getUTCDate(),p,2);}function formatUTCHour24(d,p){return pad$2(d.getUTCHours(),p,2);}function formatUTCHour12(d,p){return pad$2(d.getUTCHours()%12||12,p,2);}function formatUTCDayOfYear(d,p){return pad$2(1+utcDay.count(utcYear(d),d),p,3);}function formatUTCMilliseconds(d,p){return pad$2(d.getUTCMilliseconds(),p,3);}function formatUTCMicroseconds(d,p){return formatUTCMilliseconds(d,p)+"000";}function formatUTCMonthNumber(d,p){return pad$2(d.getUTCMonth()+1,p,2);}function formatUTCMinutes(d,p){return pad$2(d.getUTCMinutes(),p,2);}function formatUTCSeconds(d,p){return pad$2(d.getUTCSeconds(),p,2);}function formatUTCWeekdayNumberMonday(d){var dow=d.getUTCDay();return dow===0?7:dow;}function formatUTCWeekNumberSunday(d,p){return pad$2(utcSunday.count(utcYear(d)-1,d),p,2);}function UTCdISO(d){var day=d.getUTCDay();return day>=4||day===0?utcThursday(d):utcThursday.ceil(d);}function formatUTCWeekNumberISO(d,p){d=UTCdISO(d);return pad$2(utcThursday.count(utcYear(d),d)+(utcYear(d).getUTCDay()===4),p,2);}function formatUTCWeekdayNumberSunday(d){return d.getUTCDay();}function formatUTCWeekNumberMonday(d,p){return pad$2(utcMonday.count(utcYear(d)-1,d),p,2);}function formatUTCYear(d,p){return pad$2(d.getUTCFullYear()%100,p,2);}function formatUTCYearISO(d,p){d=UTCdISO(d);return pad$2(d.getUTCFullYear()%100,p,2);}function formatUTCFullYear(d,p){return pad$2(d.getUTCFullYear()%10000,p,4);}function formatUTCFullYearISO(d,p){var day=d.getUTCDay();d=day>=4||day===0?utcThursday(d):utcThursday.ceil(d);return pad$2(d.getUTCFullYear()%10000,p,4);}function formatUTCZone(){return "+0000";}function formatLiteralPercent(){return "%";}function formatUnixTimestamp(d){return +d;}function formatUnixTimestampSeconds(d){return Math.floor(+d/1000);}function formatter$2(pattern){// eslint-disable-line import/prefer-default-export
  let locale=formatLocale({dateTime:'%x, %X',date:'%-m/%-d/%Y',time:'%-I:%M:%S %p',periods:['AM','PM'],days:['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],shortDays:['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],months:['January','February','March','April','May','June','July','August','September','October','November','December'],shortMonths:['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']});let d3format=locale.format(pattern);/**
     * Format a value according to the specified pattern created at construct
     *
     * @param  {Date} value   The number to be formatted
     * @return {String}         [description]
     * @private
     */function format(value){return d3format(value);}/**
     * Format a value according to a specific pattern
     * that is not the one specified in the constructor
     *
     * @param  {String} p   Pattern
     * @param  {Date} v   Value
     * @return {String}     Formatted value
     */format.format=function formatFn(p,v){return locale.format(p)(v);};/**
     * Set the locale for the formatter
     *
     * @param  {Object} args   Locale object for formatting
     * @return {Undefined}      Returns nothing
     */format.locale=function localeFn(){locale=formatLocale(...arguments);d3format=locale.format(pattern);return this;};/**
     * Parse a string to a date according to a pattern
     *
     * @param  {String} p   Pattern
     * @param  {String} v   Value
     * @return {Date}     Date
     */format.parse=function parse(p,v){return locale.parse(p)(v);};/**
     * Returns a parser that parses strings to date according to the pattern
     *
     * @param  {String} p   Pattern
     * @return {Function}   Parser
     */format.parsePattern=function parsePattern(p){return locale.parse(p);};return format;}/**
   * @typedef {function} formatter
   * @returns {any} Returns a formatted value
   */ /**
   * @typedef {object} FormatterDefinition
   * @property {string} [formatter] Name of the formatter
   * @property {string} [type] Type of formatter
   * @property {string} [format] Format string
   * @property {DataExtraction|DataFieldExtraction} [data] The data to create formatter from
   */const formatterRegistry=registryFactory();formatterRegistry('d3-number',formatter$1$1);formatterRegistry('d3-time',formatter$2);/* eslint no-return-assign: 0 */ // TODO - decide whether usage of .call() is appropriate when invoking accessors, if yes then arrow functions are not allowed!
  const getFormatter=data=>{if(typeof data.formatter==='function'){return data.formatter();}const f=data.formatter||{};return formatterRegistry(f.type||'d3-number')(f.format||'');};const accessors={id:data=>"".concat(data.source,"/").concat(data.key||data.title),key:data=>String(data.key||data.title),tags:data=>data.tags,min:data=>data.min,max:data=>data.max,type:data=>data.type,title:data=>String(data.title),values:data=>data.values,value:v=>v,label:v=>v,formatter:data=>getFormatter(data)};/**
   * Create a new field with default settings
   * @ignore
   * @return {Field} Data field
   */function field(data){let{id=accessors.id,key=accessors.key,min=accessors.min,max=accessors.max,type=accessors.type,tags=accessors.tags,title=accessors.title,values=accessors.values,value=accessors.value,label=accessors.label,formatter=accessors.formatter}=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};/**
     * @alias Field
     */const f={/**
       * Returns this field's id
       * @returns {string}
       */id:()=>id(data),/**
       * Returns this field's key
       * @returns {string}
       */key:()=>key(data),/**
       * Returns the input data
       * @returns {any}
       */raw:()=>data,/**
       * Returns the tags.
       * @return {Array<string>}
       */tags:()=>tags(data),/**
       * Returns this field's type: 'dimension' or 'measure'.
       * @return {string}
       */type:()=>type(data),/**
       * Returns the min value of this field.
       * @return {number}
       */min:()=>min(data),/**
       * Returns the max value of this field.
       * @return {number}
       */max:()=>max(data),/**
       * Returns this field's title.
       * @return {string}
       */title:()=>title(data),/**
       * Returns the values of this field.
       * @return {Array<DatumExtract>}
       */items:()=>values(data),/**
       * Returns a formatter adapted to the content of this field.
       */formatter:()=>formatter(data),value,label};return f;}function findField$1(query,_ref){let{cache}=_ref;if(typeof query==='number'){return cache.fields[query];}// Find by key first
  for(let i=0;i<cache.fields.length;i++){if(cache.fields[i].key()===query){return cache.fields[i];}}// find by title
  for(let i=0;i<cache.fields.length;i++){if(cache.fields[i].title()===query){return cache.fields[i];}}return null;}const filters$1={numeric:values=>values.filter(v=>typeof v==='number'&&!isNaN(v))};const unfilteredReducers={sum:values=>values.reduce((a,b)=>a+b,0)};// function isPrimitive(x) {
  //   const type = typeof x;
  //   return (type !== 'object' && type !== 'function');
  // }
  /**
   * [reducers description]
   * @type {Object}
   * @private
   */const reducers={first:values=>values[0],last:values=>values[values.length-1],min:values=>{const filtered=filters$1.numeric(values);return !filtered.length?NaN:Math.min.apply(null,filtered);},max:values=>{const filtered=filters$1.numeric(values);return !filtered.length?NaN:Math.max.apply(null,filtered);},sum:values=>{const filtered=filters$1.numeric(values);return !filtered.length?NaN:filtered.reduce((a,b)=>a+b,0);},avg:values=>{const filtered=filters$1.numeric(values);const len=filtered.length;return !len?NaN:unfilteredReducers.sum(filtered)/len;}};function normalizeProperties(cfg,dataset,dataProperties,main){// console.log('======', cfg, main, dataset);
  const props={};const mainField=main.field||(typeof cfg.field!=='undefined'?dataset.field(cfg.field):null);Object.keys(dataProperties).forEach(key=>{const pConfig=dataProperties[key];const prop=props[key]={};if(['number','string','boolean'].indexOf(typeof pConfig)!==-1){prop.type='primitive';prop.value=pConfig;}else if(typeof pConfig==='function'){prop.type='function';prop.value=pConfig;prop.label=pConfig;prop.field=mainField;}else if(typeof pConfig==='object'){if(pConfig.fields){prop.fields=pConfig.fields.map(ff=>normalizeProperties(cfg,dataset,{main:ff},main).main);}else if(typeof pConfig.field!=='undefined'){prop.type='field';prop.field=dataset.field(pConfig.field);prop.value=prop.field.value;prop.label=prop.field.label;}else if(mainField){prop.value=mainField.value;prop.label=mainField.label;prop.field=mainField;}if(typeof pConfig.filter==='function'){prop.filter=pConfig.filter;}if(typeof pConfig.value!=='undefined'){prop.value=pConfig.value;}if(typeof pConfig.label!=='undefined'){prop.label=pConfig.label;}if(typeof pConfig.reduce==='function'){prop.reduce=pConfig.reduce;}else if(pConfig.reduce){prop.reduce=reducers[pConfig.reduce];}else if(prop.field&&prop.field.reduce){prop.reduce=typeof prop.field.reduce==='string'?reducers[prop.field.reduce]:prop.field.reduce;}if(typeof pConfig.reduceLabel==='function'){prop.reduceLabel=pConfig.reduceLabel;}else if(pConfig.reduceLabel){prop.reduceLabel=reducers[pConfig.reduceLabel];}else if(prop.field&&prop.field.reduceLabel){prop.reduceLabel=typeof prop.field.reduceLabel==='string'?reducers[prop.field.reduceLabel]:prop.field.reduceLabel;}}});return props;}/*
  example of configuration input
  cfg = {
    field: 'State', // the 'top level' values are extracted from field state
    value: d => d.qText, // the value of the output
    props: { // additional data properties ammended to each item
      a: 3, // constant value
      b: d => d.qElemNumber, // function will receive the original field value
      c: {
        field: 'Country', // reference to another field
        value: d => d.qText // extract the qText value from the referenced field
      },
      d: {
        value: d => d.qRow //  extract qRow from field 'State'
      }
    }
  }

  // output
  [{
    value: 'CA', source: { field: 'State' },
    a: { value: 3 },
    b: { value: 26, source: 'State' },
    c: { value: 'USA', source: 'Country' },
    d: { value: 131, source: 'State' }
  },
  ...]
  */function getPropsInfo(cfg,dataset){// console.log('222', cfg);
  const{main}=normalizeProperties(cfg,dataset,{main:{value:cfg.value,label:cfg.label,reduce:cfg.reduce,filter:cfg.filter}},{});const props=normalizeProperties(cfg,dataset,cfg.props||{},main);return {props,main};}function collectItems(items,cfg,formatter,prop){const values=Array(items.length);const labels=Array(items.length);let it;for(let i=0;i<items.length;i++){it=prop?items[i][prop]:items[i];values[i]=it.value;labels[i]=it.label;}const reduce=cfg.reduce;const reduceLabel=cfg.reduceLabel;const v=reduce?reduce(values):values;const b=reduceLabel?reduceLabel(labels,v):formatter?formatter(v):String(v);// eslint-disable-line no-nested-ternary
  // // ret[prop].label = String(propsFormatters[prop](ret[prop].value));
  const ret={value:v,label:b};if(prop&&items[0][prop].source){ret.source=items[0][prop].source;return ret;}if(!prop&&items[0].source){ret.source=items[0].source;return ret;}return ret;}// collect items that have been grouped and reduce per group and property
  function collect(trackedItems,_ref2){let{main,propsArr,props}=_ref2;let dataItems=[];const mainFormatter=main.field.formatter();// || (v => v);
  const propsFormatters={};propsArr.forEach(prop=>{propsFormatters[prop]=props[prop].field?props[prop].field.formatter():v=>v;});dataItems.push(...trackedItems.map(t=>{const ret=collectItems(t.items,main,mainFormatter);propsArr.forEach(prop=>{ret[prop]=collectItems(t.items,props[prop],propsFormatters[prop],prop);});return ret;}));return dataItems;}function track(_ref3){let{cfg,itemData,obj,target,tracker,trackType}=_ref3;const trackId=trackType==='function'?cfg.trackBy(itemData):itemData[cfg.trackBy];let trackedItem=tracker[trackId];if(!trackedItem){trackedItem=tracker[trackId]={items:[],id:trackId};target.push(trackedItem);}trackedItem.items.push(obj);}const ARRAY_MAX_SIZE=10000;function getMax(values){if(values.length<ARRAY_MAX_SIZE){return Math.max(...values);}let max=-Infinity;const len=values.length;for(let i=0;i<len;i++){if(max<values[i]){max=values[i];}}return max;}function getMin(values){if(values.length<ARRAY_MAX_SIZE){return Math.min(...values);}let min=Infinity;const len=values.length;for(let i=0;i<len;i++){if(min>values[i]){min=values[i];}}return min;}const OFFSETS={diverging:stackOffsetDiverging,none:stackOffsetNone,silhouette:stackOffsetSilhouette,expand:stackOffsetExpand,wiggle:stackOffsetWiggle};const ORDERS={ascending:stackOrderAscending,insideout:stackOrderInsideOut,none:stackOrderNone,reverse:stackOrderReverse};function stacked(data,config,ds){const stackIds={};const stackFn=config.stackKey;const valueFn=config.value;const startProp=config.startProp||'start';const endProp=config.endProp||'end';const offset=config.offset||'none';const order=config.order||'none';const valueRef=config.valueRef||'';let maxStackCount=0;let valueFields={};for(let i=0;i<data.items.length;i++){let p=data.items[i];let sourceField=valueRef?p[valueRef]:null;if(sourceField&&sourceField.source){let ff="".concat(sourceField.source.key||'',"/").concat(sourceField.source.field);if(!valueFields[ff]){valueFields[ff]=sourceField.source;}}let sid=stackFn(p);stackIds[sid]=stackIds[sid]||{items:[]};stackIds[sid].items.push(p);maxStackCount=Math.max(maxStackCount,stackIds[sid].items.length);}const keys=Array.apply(null,{length:maxStackCount}).map(Number.call,Number);// eslint-disable-line
  const matrix=Object.keys(stackIds).map(sid=>stackIds[sid].items);const d3Stack=stack().keys(keys).value((s,key)=>s[key]?valueFn(s[key]):0).order(ORDERS[order]).offset(OFFSETS[offset]);let series=d3Stack(matrix);let values=[];for(let i=0;i<series.length;i++){let serie=series[i];for(let s=0;s<serie.length;s++){let range=serie[s];let item=serie[s].data[serie.key];if(!item){continue;}item[startProp]={value:range[0]};item[endProp]={value:range[1]};values.push(range[0],range[1]);}}let stackedFields=Object.keys(valueFields).map(f=>{let dSource=ds(valueFields[f].key);return dSource?dSource.field(valueFields[f].field):null;}).filter(f=>!!f);const field$1=field({title:stackedFields.map(f=>f.title()).join(', '),min:getMin(values),max:getMax(values),type:'measure',formatter:stackedFields[0]?stackedFields[0].formatter:undefined});data.fields.push(field$1);}function extract$1$1(dataConfig){let data=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let opts=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};let extracted={// items: [],
  // fields: [],
  // source: null,
  // value: null,
  // label: null,
  // children: null,
  // root: null,
  // graph: null
  };const logger=opts.logger;if(Array.isArray(dataConfig)){// if data is an array, assume it's manual data input -> normalize
  extracted.items=dataConfig.map(v=>({value:v,label:String(v)}));}else if(dataConfig){if('collection'in dataConfig){extracted=_objectSpread2$1({},data.collection(dataConfig.collection));}else {const source=data.dataset?data.dataset(dataConfig.source):null;let valueFn=dataConfig.value||(d=>d);let labelFn=dataConfig.label||(d=>d);if(dataConfig.groupBy||dataConfig.mapTo){// DEPRECATION
  logger.warn('Deprecated "data" configuration',dataConfig);extracted.items=[];}else if(dataConfig.hierarchy){extracted.root=source.hierarchy?source.hierarchy(dataConfig.hierarchy):null;extracted.fields=source.fields();}else if(dataConfig.items){extracted.items=dataConfig.items.map(v=>({value:valueFn(v),label:String(labelFn(v))}));}else if(dataConfig.extract){const extractionsConfigs=Array.isArray(dataConfig.extract)?dataConfig.extract:[dataConfig.extract];extracted.items=[];const sourceFields=[];extractionsConfigs.forEach(cfg=>{const s=cfg.source?data.dataset(cfg.source):source;if(!s){return;}extracted.items=[...extracted.items,...s.extract(cfg)];if(typeof cfg.field!=='undefined'){sourceFields.push(s.field(cfg.field));}});if(sourceFields.length){extracted.fields=sourceFields;}if(dataConfig.amend&&Array.isArray(dataConfig.amend)){extracted.items=[...extracted.items,...dataConfig.amend];}}else if(typeof dataConfig.field!=='undefined'&&source){const f=source.field(dataConfig.field);if(f){if(!extracted.fields){extracted.fields=[];}extracted.fields.push(f);if(!('value'in dataConfig)){valueFn=f.value||(v=>v);labelFn=f.label||(v=>v);extracted.value=valueFn;}extracted.items=f.items().map(v=>({value:valueFn(v),label:String(labelFn(v)),source:{field:dataConfig.field}}));// TODO - add source: { key: dataConfig.source, field: dataConfig.field, data: v }
  }}else if(dataConfig.fields){dataConfig.fields.forEach(obj=>{const s=typeof obj==='object'&&obj.source?data.dataset(obj.source):source;if(!s){return;}let f;if(typeof obj==='object'&&typeof obj.field!=='undefined'){f=s.field(obj.field);}else {f=s.field(obj);}if(f){if(!extracted.fields){extracted.fields=[];}extracted.fields.push(f);}});}if(extracted.items&&dataConfig.map){extracted.items=extracted.items.map(dataConfig.map);}}if(dataConfig&&dataConfig.stack){stacked(extracted,dataConfig.stack,data.dataset);}}if(dataConfig&&!Array.isArray(dataConfig)&&typeof dataConfig.filter==='function'&&extracted.items){extracted.items=extracted.items.filter(dataConfig.filter);}if(dataConfig&&!Array.isArray(dataConfig)&&typeof dataConfig.sort==='function'&&extracted.items){extracted.items=extracted.items.sort(dataConfig.sort);}return extracted;}/**
   * @interface CollectionSettings
   * @property {string} key Unique key for the collection
   * @property {DataExtraction} data Data configuration
   * @example
   * {
      key: 'my-collection',
      data: {
        extract: [{
          source: 'Products',
          field: 'Product',
          value: d => d.name,
          label: d => `<${d.name}>`
          props: {
            year: { field: 'Year' }
            num: { field: 'Sales' }
          }
        }],
        filter: d => d.label !== 'Sneakers', // extract everything except Sneakers
        sort: (a, b) => a.label > b.label ? -1 : 1, // sort descending
      }
   * }
   */function create$p(config,d,opts){let extractor=arguments.length>3&&arguments[3]!==undefined?arguments[3]:extract$1$1;const collections={};(config||[]).forEach(cfg=>{if(!cfg.key){throw new Error('Data collection is missing "key" property');}if(typeof cfg.data==='object'&&'collection'in cfg.data){throw new Error('Data config for collections may not reference other collections');}collections[cfg.key]=()=>extractor(cfg.data,d,opts);});const fn=key=>{let k;let cfg;if(typeof key==='string'){k=key;}else if(typeof key==='object'){k=key.key;cfg=key;}if(!(k in collections)){throw new Error("Unknown data collection: ".concat(k));}if(typeof collections[k]==='function'){collections[k]=collections[k]();}let coll=collections[k];if(cfg){if(cfg.fields&&cfg.fields.filter){let filtered=coll.fields.filter(cfg.fields.filter);if(coll.fields.length!==filtered.length){coll=extend$1(coll,{fields:filtered});}}}return coll;};return fn;}function create$o(options,data,deps){let extractor=arguments.length>3&&arguments[3]!==undefined?arguments[3]:extract$1$1;if(options.data){const d=extractor(options.data,data,deps);if(d&&d.fields&&d.fields[0]){// TODO Have some magic to handle and merge formatters from multiple sources
  return d.fields[0].formatter();}}let formatterType;if(options.formatter){formatterType="".concat(options.formatter,"-").concat(options.type||'number');}else {formatterType=options.type||'d3-number';}if(deps.formatter.has(formatterType)){const f=deps.formatter.get(formatterType)(options.format||'');return f;}throw new Error("Formatter of type '".concat(formatterType,"' was not found"));}function collection$1(formattersConfig,data,deps){let fn=arguments.length>3&&arguments[3]!==undefined?arguments[3]:create$o;const formatters={};return {get(def){let key;if(typeof def==='string'&&formattersConfig[def]){key=def;}else if(typeof def==='object'&&'formatter'in def&&formattersConfig[def.formatter]){key=def.formatter;}else if(typeof def==='object'&&'type'in def&&formattersConfig[def.type]){key=def.type;}if(key){formatters[key]=formatters[key]||fn(formattersConfig[key],data,deps);return formatters[key];}return fn(def||{},data,deps);},all(){Object.keys(formattersConfig).forEach(this.get);return formatters;}};}function initRange(domain,range){switch(arguments.length){case 0:break;case 1:this.range(domain);break;default:this.range(range).domain(domain);break;}return this;}const implicit=Symbol("implicit");function ordinal$1(){var index=new InternMap(),domain=[],range=[],unknown=implicit;function scale(d){let i=index.get(d);if(i===undefined){if(unknown!==implicit)return unknown;index.set(d,i=domain.push(d)-1);}return range[i%range.length];}scale.domain=function(_){if(!arguments.length)return domain.slice();domain=[],index=new InternMap();for(const value of _){if(index.has(value))continue;index.set(value,domain.push(value)-1);}return scale;};scale.range=function(_){return arguments.length?(range=Array.from(_),scale):range.slice();};scale.unknown=function(_){return arguments.length?(unknown=_,scale):unknown;};scale.copy=function(){return ordinal$1(domain,range).unknown(unknown);};initRange.apply(scale,arguments);return scale;}function band(){var scale=ordinal$1().unknown(undefined),domain=scale.domain,ordinalRange=scale.range,r0=0,r1=1,step,bandwidth,round=false,paddingInner=0,paddingOuter=0,align=0.5;delete scale.unknown;function rescale(){var n=domain().length,reverse=r1<r0,start=reverse?r1:r0,stop=reverse?r0:r1;step=(stop-start)/Math.max(1,n-paddingInner+paddingOuter*2);if(round)step=Math.floor(step);start+=(stop-start-step*(n-paddingInner))*align;bandwidth=step*(1-paddingInner);if(round)start=Math.round(start),bandwidth=Math.round(bandwidth);var values=range$2(n).map(function(i){return start+step*i;});return ordinalRange(reverse?values.reverse():values);}scale.domain=function(_){return arguments.length?(domain(_),rescale()):domain();};scale.range=function(_){return arguments.length?([r0,r1]=_,r0=+r0,r1=+r1,rescale()):[r0,r1];};scale.rangeRound=function(_){return [r0,r1]=_,r0=+r0,r1=+r1,round=true,rescale();};scale.bandwidth=function(){return bandwidth;};scale.step=function(){return step;};scale.round=function(_){return arguments.length?(round=!!_,rescale()):round;};scale.padding=function(_){return arguments.length?(paddingInner=Math.min(1,paddingOuter=+_),rescale()):paddingInner;};scale.paddingInner=function(_){return arguments.length?(paddingInner=Math.min(1,_),rescale()):paddingInner;};scale.paddingOuter=function(_){return arguments.length?(paddingOuter=+_,rescale()):paddingOuter;};scale.align=function(_){return arguments.length?(align=Math.max(0,Math.min(1,_)),rescale()):align;};scale.copy=function(){return band(domain(),[r0,r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);};return initRange.apply(rescale(),arguments);}function define(constructor,factory,prototype){constructor.prototype=factory.prototype=prototype;prototype.constructor=constructor;}function extend$2(parent,definition){var prototype=Object.create(parent.prototype);for(var key in definition)prototype[key]=definition[key];return prototype;}function Color(){}var darker=0.7;var brighter=1/darker;var reI="\\s*([+-]?\\d+)\\s*",reN="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",reP="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",reHex=/^#([0-9a-f]{3,8})$/,reRgbInteger=new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),reRgbPercent=new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),reRgbaInteger=new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),reRgbaPercent=new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),reHslPercent=new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),reHslaPercent=new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);var named={aliceblue:0xf0f8ff,antiquewhite:0xfaebd7,aqua:0x00ffff,aquamarine:0x7fffd4,azure:0xf0ffff,beige:0xf5f5dc,bisque:0xffe4c4,black:0x000000,blanchedalmond:0xffebcd,blue:0x0000ff,blueviolet:0x8a2be2,brown:0xa52a2a,burlywood:0xdeb887,cadetblue:0x5f9ea0,chartreuse:0x7fff00,chocolate:0xd2691e,coral:0xff7f50,cornflowerblue:0x6495ed,cornsilk:0xfff8dc,crimson:0xdc143c,cyan:0x00ffff,darkblue:0x00008b,darkcyan:0x008b8b,darkgoldenrod:0xb8860b,darkgray:0xa9a9a9,darkgreen:0x006400,darkgrey:0xa9a9a9,darkkhaki:0xbdb76b,darkmagenta:0x8b008b,darkolivegreen:0x556b2f,darkorange:0xff8c00,darkorchid:0x9932cc,darkred:0x8b0000,darksalmon:0xe9967a,darkseagreen:0x8fbc8f,darkslateblue:0x483d8b,darkslategray:0x2f4f4f,darkslategrey:0x2f4f4f,darkturquoise:0x00ced1,darkviolet:0x9400d3,deeppink:0xff1493,deepskyblue:0x00bfff,dimgray:0x696969,dimgrey:0x696969,dodgerblue:0x1e90ff,firebrick:0xb22222,floralwhite:0xfffaf0,forestgreen:0x228b22,fuchsia:0xff00ff,gainsboro:0xdcdcdc,ghostwhite:0xf8f8ff,gold:0xffd700,goldenrod:0xdaa520,gray:0x808080,green:0x008000,greenyellow:0xadff2f,grey:0x808080,honeydew:0xf0fff0,hotpink:0xff69b4,indianred:0xcd5c5c,indigo:0x4b0082,ivory:0xfffff0,khaki:0xf0e68c,lavender:0xe6e6fa,lavenderblush:0xfff0f5,lawngreen:0x7cfc00,lemonchiffon:0xfffacd,lightblue:0xadd8e6,lightcoral:0xf08080,lightcyan:0xe0ffff,lightgoldenrodyellow:0xfafad2,lightgray:0xd3d3d3,lightgreen:0x90ee90,lightgrey:0xd3d3d3,lightpink:0xffb6c1,lightsalmon:0xffa07a,lightseagreen:0x20b2aa,lightskyblue:0x87cefa,lightslategray:0x778899,lightslategrey:0x778899,lightsteelblue:0xb0c4de,lightyellow:0xffffe0,lime:0x00ff00,limegreen:0x32cd32,linen:0xfaf0e6,magenta:0xff00ff,maroon:0x800000,mediumaquamarine:0x66cdaa,mediumblue:0x0000cd,mediumorchid:0xba55d3,mediumpurple:0x9370db,mediumseagreen:0x3cb371,mediumslateblue:0x7b68ee,mediumspringgreen:0x00fa9a,mediumturquoise:0x48d1cc,mediumvioletred:0xc71585,midnightblue:0x191970,mintcream:0xf5fffa,mistyrose:0xffe4e1,moccasin:0xffe4b5,navajowhite:0xffdead,navy:0x000080,oldlace:0xfdf5e6,olive:0x808000,olivedrab:0x6b8e23,orange:0xffa500,orangered:0xff4500,orchid:0xda70d6,palegoldenrod:0xeee8aa,palegreen:0x98fb98,paleturquoise:0xafeeee,palevioletred:0xdb7093,papayawhip:0xffefd5,peachpuff:0xffdab9,peru:0xcd853f,pink:0xffc0cb,plum:0xdda0dd,powderblue:0xb0e0e6,purple:0x800080,rebeccapurple:0x663399,red:0xff0000,rosybrown:0xbc8f8f,royalblue:0x4169e1,saddlebrown:0x8b4513,salmon:0xfa8072,sandybrown:0xf4a460,seagreen:0x2e8b57,seashell:0xfff5ee,sienna:0xa0522d,silver:0xc0c0c0,skyblue:0x87ceeb,slateblue:0x6a5acd,slategray:0x708090,slategrey:0x708090,snow:0xfffafa,springgreen:0x00ff7f,steelblue:0x4682b4,tan:0xd2b48c,teal:0x008080,thistle:0xd8bfd8,tomato:0xff6347,turquoise:0x40e0d0,violet:0xee82ee,wheat:0xf5deb3,white:0xffffff,whitesmoke:0xf5f5f5,yellow:0xffff00,yellowgreen:0x9acd32};define(Color,color,{copy(channels){return Object.assign(new this.constructor(),this,channels);},displayable(){return this.rgb().displayable();},hex:color_formatHex,// Deprecated! Use color.formatHex.
  formatHex:color_formatHex,formatHex8:color_formatHex8,formatHsl:color_formatHsl,formatRgb:color_formatRgb,toString:color_formatRgb});function color_formatHex(){return this.rgb().formatHex();}function color_formatHex8(){return this.rgb().formatHex8();}function color_formatHsl(){return hslConvert(this).formatHsl();}function color_formatRgb(){return this.rgb().formatRgb();}function color(format){var m,l;format=(format+"").trim().toLowerCase();return (m=reHex.exec(format))?(l=m[1].length,m=parseInt(m[1],16),l===6?rgbn(m)// #ff0000
  :l===3?new Rgb(m>>8&0xf|m>>4&0xf0,m>>4&0xf|m&0xf0,(m&0xf)<<4|m&0xf,1)// #f00
  :l===8?rgba(m>>24&0xff,m>>16&0xff,m>>8&0xff,(m&0xff)/0xff)// #ff000000
  :l===4?rgba(m>>12&0xf|m>>8&0xf0,m>>8&0xf|m>>4&0xf0,m>>4&0xf|m&0xf0,((m&0xf)<<4|m&0xf)/0xff)// #f000
  :null// invalid hex
  ):(m=reRgbInteger.exec(format))?new Rgb(m[1],m[2],m[3],1)// rgb(255, 0, 0)
  :(m=reRgbPercent.exec(format))?new Rgb(m[1]*255/100,m[2]*255/100,m[3]*255/100,1)// rgb(100%, 0%, 0%)
  :(m=reRgbaInteger.exec(format))?rgba(m[1],m[2],m[3],m[4])// rgba(255, 0, 0, 1)
  :(m=reRgbaPercent.exec(format))?rgba(m[1]*255/100,m[2]*255/100,m[3]*255/100,m[4])// rgb(100%, 0%, 0%, 1)
  :(m=reHslPercent.exec(format))?hsla(m[1],m[2]/100,m[3]/100,1)// hsl(120, 50%, 50%)
  :(m=reHslaPercent.exec(format))?hsla(m[1],m[2]/100,m[3]/100,m[4])// hsla(120, 50%, 50%, 1)
  :named.hasOwnProperty(format)?rgbn(named[format])// eslint-disable-line no-prototype-builtins
  :format==="transparent"?new Rgb(NaN,NaN,NaN,0):null;}function rgbn(n){return new Rgb(n>>16&0xff,n>>8&0xff,n&0xff,1);}function rgba(r,g,b,a){if(a<=0)r=g=b=NaN;return new Rgb(r,g,b,a);}function rgbConvert(o){if(!(o instanceof Color))o=color(o);if(!o)return new Rgb();o=o.rgb();return new Rgb(o.r,o.g,o.b,o.opacity);}function rgb$1(r,g,b,opacity){return arguments.length===1?rgbConvert(r):new Rgb(r,g,b,opacity==null?1:opacity);}function Rgb(r,g,b,opacity){this.r=+r;this.g=+g;this.b=+b;this.opacity=+opacity;}define(Rgb,rgb$1,extend$2(Color,{brighter(k){k=k==null?brighter:Math.pow(brighter,k);return new Rgb(this.r*k,this.g*k,this.b*k,this.opacity);},darker(k){k=k==null?darker:Math.pow(darker,k);return new Rgb(this.r*k,this.g*k,this.b*k,this.opacity);},rgb(){return this;},clamp(){return new Rgb(clampi(this.r),clampi(this.g),clampi(this.b),clampa(this.opacity));},displayable(){return -0.5<=this.r&&this.r<255.5&&-0.5<=this.g&&this.g<255.5&&-0.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1;},hex:rgb_formatHex,// Deprecated! Use color.formatHex.
  formatHex:rgb_formatHex,formatHex8:rgb_formatHex8,formatRgb:rgb_formatRgb,toString:rgb_formatRgb}));function rgb_formatHex(){return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}`;}function rgb_formatHex8(){return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}${hex$1((isNaN(this.opacity)?1:this.opacity)*255)}`;}function rgb_formatRgb(){const a=clampa(this.opacity);return `${a===1?"rgb(":"rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a===1?")":`, ${a})`}`;}function clampa(opacity){return isNaN(opacity)?1:Math.max(0,Math.min(1,opacity));}function clampi(value){return Math.max(0,Math.min(255,Math.round(value)||0));}function hex$1(value){value=clampi(value);return (value<16?"0":"")+value.toString(16);}function hsla(h,s,l,a){if(a<=0)h=s=l=NaN;else if(l<=0||l>=1)h=s=NaN;else if(s<=0)h=NaN;return new Hsl(h,s,l,a);}function hslConvert(o){if(o instanceof Hsl)return new Hsl(o.h,o.s,o.l,o.opacity);if(!(o instanceof Color))o=color(o);if(!o)return new Hsl();if(o instanceof Hsl)return o;o=o.rgb();var r=o.r/255,g=o.g/255,b=o.b/255,min=Math.min(r,g,b),max=Math.max(r,g,b),h=NaN,s=max-min,l=(max+min)/2;if(s){if(r===max)h=(g-b)/s+(g<b)*6;else if(g===max)h=(b-r)/s+2;else h=(r-g)/s+4;s/=l<0.5?max+min:2-max-min;h*=60;}else {s=l>0&&l<1?0:h;}return new Hsl(h,s,l,o.opacity);}function hsl(h,s,l,opacity){return arguments.length===1?hslConvert(h):new Hsl(h,s,l,opacity==null?1:opacity);}function Hsl(h,s,l,opacity){this.h=+h;this.s=+s;this.l=+l;this.opacity=+opacity;}define(Hsl,hsl,extend$2(Color,{brighter(k){k=k==null?brighter:Math.pow(brighter,k);return new Hsl(this.h,this.s,this.l*k,this.opacity);},darker(k){k=k==null?darker:Math.pow(darker,k);return new Hsl(this.h,this.s,this.l*k,this.opacity);},rgb(){var h=this.h%360+(this.h<0)*360,s=isNaN(h)||isNaN(this.s)?0:this.s,l=this.l,m2=l+(l<0.5?l:1-l)*s,m1=2*l-m2;return new Rgb(hsl2rgb(h>=240?h-240:h+120,m1,m2),hsl2rgb(h,m1,m2),hsl2rgb(h<120?h+240:h-120,m1,m2),this.opacity);},clamp(){return new Hsl(clamph(this.h),clampt(this.s),clampt(this.l),clampa(this.opacity));},displayable(){return (0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1;},formatHsl(){const a=clampa(this.opacity);return `${a===1?"hsl(":"hsla("}${clamph(this.h)}, ${clampt(this.s)*100}%, ${clampt(this.l)*100}%${a===1?")":`, ${a})`}`;}}));function clamph(value){value=(value||0)%360;return value<0?value+360:value;}function clampt(value){return Math.max(0,Math.min(1,value||0));}/* From FvD 13.37, CSS Color Module Level 3 */function hsl2rgb(h,m1,m2){return (h<60?m1+(m2-m1)*h/60:h<180?m2:h<240?m1+(m2-m1)*(240-h)/60:m1)*255;}var constant$1=x=>()=>x;function linear$1(a,d){return function(t){return a+t*d;};}function exponential(a,b,y){return a=Math.pow(a,y),b=Math.pow(b,y)-a,y=1/y,function(t){return Math.pow(a+t*b,y);};}function gamma(y){return (y=+y)===1?nogamma:function(a,b){return b-a?exponential(a,b,y):constant$1(isNaN(a)?b:a);};}function nogamma(a,b){var d=b-a;return d?linear$1(a,d):constant$1(isNaN(a)?b:a);}var rgb=function rgbGamma(y){var color=gamma(y);function rgb(start,end){var r=color((start=rgb$1(start)).r,(end=rgb$1(end)).r),g=color(start.g,end.g),b=color(start.b,end.b),opacity=nogamma(start.opacity,end.opacity);return function(t){start.r=r(t);start.g=g(t);start.b=b(t);start.opacity=opacity(t);return start+"";};}rgb.gamma=rgbGamma;return rgb;}(1);function numberArray(a,b){if(!b)b=[];var n=a?Math.min(b.length,a.length):0,c=b.slice(),i;return function(t){for(i=0;i<n;++i)c[i]=a[i]*(1-t)+b[i]*t;return c;};}function isNumberArray$1(x){return ArrayBuffer.isView(x)&&!(x instanceof DataView);}function genericArray$1(a,b){var nb=b?b.length:0,na=a?Math.min(nb,a.length):0,x=new Array(na),c=new Array(nb),i;for(i=0;i<na;++i)x[i]=interpolate$1$1(a[i],b[i]);for(;i<nb;++i)c[i]=b[i];return function(t){for(i=0;i<na;++i)c[i]=x[i](t);return c;};}function date(a,b){var d=new Date();return a=+a,b=+b,function(t){return d.setTime(a*(1-t)+b*t),d;};}function number$1(a,b){return a=+a,b=+b,function(t){return a*(1-t)+b*t;};}function object$1(a,b){var i={},c={},k;if(a===null||typeof a!=="object")a={};if(b===null||typeof b!=="object")b={};for(k in b){if(k in a){i[k]=interpolate$1$1(a[k],b[k]);}else {c[k]=b[k];}}return function(t){for(k in i)c[k]=i[k](t);return c;};}var reA=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,reB=new RegExp(reA.source,"g");function zero(b){return function(){return b;};}function one(b){return function(t){return b(t)+"";};}function string(a,b){var bi=reA.lastIndex=reB.lastIndex=0,// scan index for next number in b
  am,// current match in a
  bm,// current match in b
  bs,// string preceding current number in b, if any
  i=-1,// index in s
  s=[],// string constants and placeholders
  q=[];// number interpolators
  // Coerce inputs to strings.
  a=a+"",b=b+"";// Interpolate pairs of numbers in a & b.
  while((am=reA.exec(a))&&(bm=reB.exec(b))){if((bs=bm.index)>bi){// a string precedes the next number in b
  bs=b.slice(bi,bs);if(s[i])s[i]+=bs;// coalesce with previous string
  else s[++i]=bs;}if((am=am[0])===(bm=bm[0])){// numbers in a & b match
  if(s[i])s[i]+=bm;// coalesce with previous string
  else s[++i]=bm;}else {// interpolate non-matching numbers
  s[++i]=null;q.push({i:i,x:number$1(am,bm)});}bi=reB.lastIndex;}// Add remains of b.
  if(bi<b.length){bs=b.slice(bi);if(s[i])s[i]+=bs;// coalesce with previous string
  else s[++i]=bs;}// Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length<2?q[0]?one(q[0].x):zero(b):(b=q.length,function(t){for(var i=0,o;i<b;++i)s[(o=q[i]).i]=o.x(t);return s.join("");});}function interpolate$1$1(a,b){var t=typeof b,c;return b==null||t==="boolean"?constant$1(b):(t==="number"?number$1:t==="string"?(c=color(b))?(b=c,rgb):string:b instanceof color?rgb:b instanceof Date?date:isNumberArray$1(b)?numberArray:Array.isArray(b)?genericArray$1:typeof b.valueOf!=="function"&&typeof b.toString!=="function"||isNaN(b)?object$1:number$1)(a,b);}function interpolateRound(a,b){return a=+a,b=+b,function(t){return Math.round(a*(1-t)+b*t);};}function constants(x){return function(){return x;};}function number(x){return +x;}var unit=[0,1];function identity(x){return x;}function normalize$1(a,b){return (b-=a=+a)?function(x){return (x-a)/b;}:constants(isNaN(b)?NaN:0.5);}function clamper(a,b){var t;if(a>b)t=a,a=b,b=t;return function(x){return Math.max(a,Math.min(b,x));};}// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
  // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
  function bimap(domain,range,interpolate){var d0=domain[0],d1=domain[1],r0=range[0],r1=range[1];if(d1<d0)d0=normalize$1(d1,d0),r0=interpolate(r1,r0);else d0=normalize$1(d0,d1),r0=interpolate(r0,r1);return function(x){return r0(d0(x));};}function polymap(domain,range,interpolate){var j=Math.min(domain.length,range.length)-1,d=new Array(j),r=new Array(j),i=-1;// Reverse descending domains.
  if(domain[j]<domain[0]){domain=domain.slice().reverse();range=range.slice().reverse();}while(++i<j){d[i]=normalize$1(domain[i],domain[i+1]);r[i]=interpolate(range[i],range[i+1]);}return function(x){var i=bisect(domain,x,1,j)-1;return r[i](d[i](x));};}function copy(source,target){return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());}function transformer(){var domain=unit,range=unit,interpolate=interpolate$1$1,transform,untransform,unknown,clamp=identity,piecewise,output,input;function rescale(){var n=Math.min(domain.length,range.length);if(clamp!==identity)clamp=clamper(domain[0],domain[n-1]);piecewise=n>2?polymap:bimap;output=input=null;return scale;}function scale(x){return x==null||isNaN(x=+x)?unknown:(output||(output=piecewise(domain.map(transform),range,interpolate)))(transform(clamp(x)));}scale.invert=function(y){return clamp(untransform((input||(input=piecewise(range,domain.map(transform),number$1)))(y)));};scale.domain=function(_){return arguments.length?(domain=Array.from(_,number),rescale()):domain.slice();};scale.range=function(_){return arguments.length?(range=Array.from(_),rescale()):range.slice();};scale.rangeRound=function(_){return range=Array.from(_),interpolate=interpolateRound,rescale();};scale.clamp=function(_){return arguments.length?(clamp=_?true:identity,rescale()):clamp!==identity;};scale.interpolate=function(_){return arguments.length?(interpolate=_,rescale()):interpolate;};scale.unknown=function(_){return arguments.length?(unknown=_,scale):unknown;};return function(t,u){transform=t,untransform=u;return rescale();};}function continuous(){return transformer()(identity,identity);}function tickFormat(start,stop,count,specifier){var step=tickStep(start,stop,count),precision;specifier=formatSpecifier(specifier==null?",f":specifier);switch(specifier.type){case"s":{var value=Math.max(Math.abs(start),Math.abs(stop));if(specifier.precision==null&&!isNaN(precision=precisionPrefix(step,value)))specifier.precision=precision;return formatPrefix(specifier,value);}case"":case"e":case"g":case"p":case"r":{if(specifier.precision==null&&!isNaN(precision=precisionRound(step,Math.max(Math.abs(start),Math.abs(stop)))))specifier.precision=precision-(specifier.type==="e");break;}case"f":case"%":{if(specifier.precision==null&&!isNaN(precision=precisionFixed(step)))specifier.precision=precision-(specifier.type==="%")*2;break;}}return format(specifier);}function linearish(scale){var domain=scale.domain;scale.ticks=function(count){var d=domain();return ticks(d[0],d[d.length-1],count==null?10:count);};scale.tickFormat=function(count,specifier){var d=domain();return tickFormat(d[0],d[d.length-1],count==null?10:count,specifier);};scale.nice=function(count){if(count==null)count=10;var d=domain();var i0=0;var i1=d.length-1;var start=d[i0];var stop=d[i1];var prestep;var step;var maxIter=10;if(stop<start){step=start,start=stop,stop=step;step=i0,i0=i1,i1=step;}while(maxIter-->0){step=tickIncrement(start,stop,count);if(step===prestep){d[i0]=start;d[i1]=stop;return domain(d);}else if(step>0){start=Math.floor(start/step)*step;stop=Math.ceil(stop/step)*step;}else if(step<0){start=Math.ceil(start*step)/step;stop=Math.floor(stop*step)/step;}else {break;}prestep=step;}return scale;};return scale;}function linear(){var scale=continuous();scale.copy=function(){return copy(scale,linear());};initRange.apply(scale,arguments);return linearish(scale);}function threshold$2(){var domain=[0.5],range=[0,1],unknown,n=1;function scale(x){return x!=null&&x<=x?range[bisect(domain,x,0,n)]:unknown;}scale.domain=function(_){return arguments.length?(domain=Array.from(_),n=Math.min(domain.length,range.length-1),scale):domain.slice();};scale.range=function(_){return arguments.length?(range=Array.from(_),n=Math.min(domain.length,range.length-1),scale):range.slice();};scale.invertExtent=function(y){var i=range.indexOf(y);return [domain[i-1],domain[i]];};scale.unknown=function(_){return arguments.length?(unknown=_,scale):unknown;};scale.copy=function(){return threshold$2().domain(domain).range(range).unknown(unknown);};return initRange.apply(scale,arguments);}function applyFormat(formatter){return typeof formatter==='undefined'?t=>t:t=>formatter(t);}function clamp$1(val){return Math.max(0,Math.min(1,val));}function isObject(obj){return typeof obj==='object';}function minorTicksGenerator(count,start,end){const r=Math.abs(start-end);const interval=r/(count+1);const ticks=[];for(let i=1;i<=count;i++){const v=i*interval;ticks.push(start<end?start+v:start-v);}return ticks;}function appendMinorTicks(majorTicks,minorCount,scale){if(majorTicks.length===1){return majorTicks;}const ticks=majorTicks.concat([]);for(let i=0;i<majorTicks.length;i++){let start=majorTicks[i];let end=majorTicks[i+1];if(i===0&&start!==scale.start()){// Before and after first major tick
  ticks.push(...minorTicksGenerator(minorCount,start,end));start-=end-start;end=majorTicks[i];ticks.push(...minorTicksGenerator(minorCount,start,end));}else if(i===majorTicks.length-1&&end!==scale.end()){// After last major tick
  end=start+(start-majorTicks[i-1]);ticks.push(...minorTicksGenerator(minorCount,start,end));}else {ticks.push(...minorTicksGenerator(minorCount,start,end));}}return ticks.filter(t=>t>=scale.min()&&t<=scale.max());}/**
   * Generate ticks based on a distance, for each 100th unit, one additional tick may be added
   * @private
   * @param  {Number} distance       Distance between each tick
   * @param  {Number} scale         The scale instance
   * @param  {Number} [minorCount=0]     Number of tick added between each distance
   * @param  {Number} [unitDivider=100]   Number to divide distance with
   * @return {Array}               Array of ticks
   */function looseDistanceBasedGenerator(_ref){let{distance,scale,minorCount=0,unitDivider=100,formatter=undefined}=_ref;const step=!notNumber(unitDivider)&&!notNumber(distance)?Math.max(distance/unitDivider,2):2;const count=Math.min(1000,Math.round(step));// safe guard against huge numbers
  let majorTicks=scale.ticks(count);if(majorTicks.length<=1){majorTicks=scale.ticks(count+1);}const ticks=minorCount>0?appendMinorTicks(majorTicks,minorCount,scale):majorTicks;ticks.sort((a,b)=>a-b);const ticksFormatted=ticks.map(applyFormat(formatter));return ticks.map((tick,i)=>{const position=scale(tick);return {position,start:position,end:position,label:ticksFormatted[i],value:tick,isMinor:majorTicks.indexOf(tick)===-1};});}/**
   * Generate ticks based on a distance, for each 100th unit, one additional tick may be added.
   * Will attempt to round the bounds of domain to even values and generate ticks hitting the domain bounds.
   * @private
   * @param  {Number} distance       Distance between each tick
   * @param  {Number} scale         The scale instance
   * @param  {Number} [minorCount=0]     Number of tick added between each distance
   * @param  {Number} [unitDivider=100]   Number to divide distance with
   * @return {Array}               Array of ticks
   */function tightDistanceBasedGenerator(_ref2){let{distance,scale,minorCount=0,unitDivider=100,formatter=undefined}=_ref2;const step=!notNumber(unitDivider)&&!notNumber(distance)?Math.max(distance/unitDivider,2):2;const count=Math.min(1000,Math.round(step));// safe guard against huge numbers
  const n=count>10?10:count;scale.nice(n);const majorTicks=scale.ticks(count);const ticks=minorCount>0?appendMinorTicks(majorTicks,minorCount,scale):majorTicks;ticks.sort((a,b)=>a-b);const ticksFormatted=ticks.map(applyFormat(formatter));return ticks.map((tick,i)=>{const position=scale(tick);return {position,start:position,end:position,label:ticksFormatted[i],value:tick,isMinor:majorTicks.indexOf(tick)===-1};});}function ticksByCount(_ref3){let{count,minorCount,scale,formatter}=_ref3;return scale.ticks((count-1)*minorCount+count).map((tick,i)=>{const position=scale(tick);return {position,start:position,end:position,label:formatter(tick),isMinor:i%(minorCount+1)!==0,value:tick};});}function ticksByValue(_ref4){let{values,scale,formatter=v=>v}=_ref4;return values.sort((a,b)=>(isObject(a)?a.value:a)-(isObject(b)?b.value:b)).filter((v,i,ary)=>{const val=isObject(v)?v.value:v;return val<=scale.max()&&val>=scale.min()&&ary.indexOf(v)===i;}).map(v=>{const isObj=isObject(v);const value=isObj?v.value:v;const position=scale(value);return {position,value,label:isObj&&typeof v.label!=='undefined'?v.label:formatter(value),isMinor:isObj?!!v.isMinor:false,start:isObj&&!isNaN(v.start)?clamp$1(scale(v.start)):position,// TODOHandle end < start?
  end:isObj&&!isNaN(v.end)?clamp$1(scale(v.end)):position// TODO Handle start > end?
  };});}function forceTicksAtBounds(ticks,scale,formatter){const ticksP=ticks.map(t=>t.position);const range=scale.range();if(ticksP.indexOf(range[0])===-1){ticks.splice(0,0,{position:range[0],start:range[0],end:range[0],label:formatter(scale.start()),isMinor:false,value:scale.start()});}else if(ticks[0]&&ticks[0].isMinor){ticks[0].isMinor=false;// Convert to major tick
  }const lastTick=ticks[ticks.length-1];if(ticksP.indexOf(range[1])===-1){ticks.push({position:range[1],start:range[1],end:range[1],label:formatter(scale.end()),isMinor:false,value:scale.end()});}else if(lastTick&&lastTick.isMinor){lastTick.isMinor=false;// Convert to major tick
  }}function generateContinuousTicks(_ref5){let{settings,scale,distance,formatter=val=>val}=_ref5;let ticks;const minorCount=settings.minorTicks&&!notNumber(settings.minorTicks.count)?Math.min(100,settings.minorTicks.count):0;if(Array.isArray(settings.ticks.values)){const values=settings.ticks.values.filter(v=>typeof v==='object'?!notNumber(v.value):!notNumber(v));ticks=ticksByValue({values,scale:scale.copy(),formatter});}else if(!notNumber(settings.ticks.count)){const count=Math.min(1000,settings.ticks.count);ticks=ticksByCount({count,minorCount,scale:scale.copy(),formatter});}else {const tickGen=settings.ticks.tight?tightDistanceBasedGenerator:looseDistanceBasedGenerator;ticks=tickGen({distance,minorCount,unitDivider:settings.ticks.distance,scale,formatter});if(settings.ticks.forceBounds){forceTicksAtBounds(ticks,scale,formatter);}}return ticks;}function generateDiscreteTicks(_ref6){let{scale}=_ref6;const domain=scale.domain();const values=domain;const dataItems=scale.data().items;const labels=scale.labels?scale.labels():values;const bandwidth=scale.bandwidth();return values.map((d,i)=>{const start=scale(d);return {position:start+bandwidth/2,label:"".concat(labels[i]),data:dataItems?dataItems[i]:undefined,start,end:start+bandwidth};});}function resolveSettings$2(){let settings=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let defaultSettings=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let context=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const stngs={};Object.keys(defaultSettings).forEach(key=>{const type=typeof settings[key];if(type==='function'){stngs[key]=settings[key](context);}else if(type==='undefined'){stngs[key]=defaultSettings[key];}else {stngs[key]=settings[key];}});return stngs;}const DEFAULT_SETTINGS$8={min:NaN,max:NaN,expand:NaN,include:[],invert:false};const DEFAULT_TICKS_SETTINGS$1={tight:false,forceBounds:false,values:undefined,count:NaN,distance:100};const DEFAULT_MINORTICKS_SETTINGS={count:NaN};/**
   * @typedef {object} ScaleLinear
   * @property {string} [type='linear']
   * @property {number} [expand] - Expand the output range
   * @property {boolean} [invert=false] - Invert the output range
   * @property {number[]} [include] - Include specified numbers in the output range
   * @property {object} [ticks]
   * @property {boolean} [ticks.tight = false]
   * @property {boolean} [ticks.forceBounds = false]
   * @property {number} [ticks.distance = 100]  - Approximate distance between each tick
   * @property {number[]|object[]} [ticks.values] - If set, ticks are no longer generated but instead equal to this set
   * @property {number} [ticks.count]
   * @property {object} [minorTicks]
   * @property {number} [minorTicks.count = 3]
   * @property {number} [min] - Set an explicit minimum value
   * @property {number} [max] - Set an explicit maximum value
   */function getMinMax$2(settings,fields){const min=+settings.min;const max=+settings.max;let fieldMin=0;let fieldMax=1;if(fields&&fields[0]){const minValues=fields.map(m=>m.min()).filter(v=>!isNaN(v));const maxValues=fields.map(m=>m.max()).filter(v=>!isNaN(v));fieldMin=minValues.length?Math.min(...minValues):Number.NaN;fieldMax=maxValues.length?Math.max(...maxValues):Number.NaN;if(isNaN(fieldMin)||isNaN(fieldMax)){fieldMin=-1;fieldMax=1;}else if(fieldMin===fieldMax&&fieldMin===0){fieldMin=-1;fieldMax=1;}else if(fieldMin===fieldMax&&fieldMin){fieldMin-=Math.abs(fieldMin*0.1);fieldMax+=Math.abs(fieldMax*0.1);}else if(!isNaN(settings.expand)){const range=fieldMax-fieldMin;fieldMin-=range*settings.expand;fieldMax+=range*settings.expand;}if(Array.isArray(settings.include)){const i=settings.include.filter(n=>!isNaN(n));fieldMin=Math.min(...i,fieldMin);fieldMax=Math.max(...i,fieldMax);}}return {mini:!isNaN(min)?min:fieldMin,maxi:!isNaN(max)?max:fieldMax};}function initNormScale$1(normScale,scale){if(normScale.instance){return;}normScale.instance=scale.copy();normScale.instance.domain([scale.start(),scale.end()]);normScale.instance.clamp(true);normScale.instance.range(normScale.invert?[1,0]:[0,1]);}/**
   * @alias scaleLinear
   * @private
   * @param { object } settings
   * @param { field[] } [fields]
   * @return { linear }
   */function scaleLinear(){let settings=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let data=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let resources=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const d3Scale=linear();const normScale={instance:null,invert:false};const ctx={data,resources};const stgns=resolveSettings$2(settings,DEFAULT_SETTINGS$8,ctx);stgns.ticks=resolveSettings$2(settings.ticks,DEFAULT_TICKS_SETTINGS$1,ctx);stgns.minorTicks=resolveSettings$2(settings.minorTicks,DEFAULT_MINORTICKS_SETTINGS,ctx);let tickCache;/**
     * @alias linear
     * @private
     * @param { Object } value
     * @return { number }
     */function fn(v){if(notNumber(v)){return NaN;}return d3Scale(v);}fn.data=()=>data;/**
     * {@link https://github.com/d3/d3-scale#continuous_invert }
     * @param { number } value The inverted value
     * @return { number } The inverted scaled value
     */fn.invert=function invert(value){return d3Scale.invert(value);};/**
     * {@link https://github.com/d3/d3-scale#continuous_rangeRound }
     * @param { number[] } values Range values
     * @return { linear } The instance this method was called on
     */fn.rangeRound=function rangeRound(values){d3Scale.rangeRound(values);return fn;};/**
     * {@link https://github.com/d3/d3-scale#continuous_clamp }
     * @param { boolean } [ value=true ] TRUE if clamping should be enabled
     * @return { linear } The instance this method was called on
     */fn.clamp=function clamp(){let value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;d3Scale.clamp(value);return fn;};/**
     * Get cached ticks (if any)
     * @return { number | undefined }
     */fn.cachedTicks=function fnCachedTicks(){return tickCache;};/**
     * Clear the tick cache
     * @return {number | undefined}
     */fn.clearTicksCache=function fnClearTicks(){tickCache=undefined;return this;};/**
     * {@link https://github.com/d3/d3-scale#continuous_ticks }
     * @param { Object } input Number of ticks to generate or an object passed to tick generator
     * @return { number[] | Object } Array of ticks or any type the custom tick generator returns
     */fn.ticks=function ticks(input){if(input!==null&&typeof input==='object'){input.settings=input.settings||{};// TODO Discontinue support for custom ticks settings as argument
  input.settings=extend$1(true,{},stgns,input.settings);input.scale=fn;tickCache=generateContinuousTicks(input);return tickCache;}tickCache=d3Scale.ticks(input);return tickCache;};/**
     * {@link https://github.com/d3/d3-scale#continuous_nice }
     * @param { number } count
     * @return { linear } The instance this method was called on
     */fn.nice=function nice(count){d3Scale.nice(count);return fn;};// TODO Support this?
  fn.tickFormat=function tickFormat(count,format){return d3Scale.tickFormat(count,format);};// TODO Support this?
  fn.interpolate=function interpolate(func){d3Scale.interpolate(func);return fn;};/**
     * @param { number[] } [values] Set or Get domain values
     * @return { linear | Number[] } The instance this method was called on if a parameter is provided, otherwise the current domain is returned
     */fn.domain=function domain(values){if(arguments.length){d3Scale.domain(values);if(normScale.instance){normScale.instance.domain([fn.start(),fn.end()]);}return fn;}return d3Scale.domain();};/**
     * @param { number[] } [values] Set or Get range values
     * @return { linear | number[] } The instance this method was called on if a parameter is provided, otherwise the current range is returned
     */fn.range=function range(values){if(arguments.length){d3Scale.range(values);return fn;}return d3Scale.range();};/**
     * Get the first value of the domain
     * @return { number }
     */fn.start=function start(){return fn.domain()[0];};/**
     * Get the last value of the domain
     * @return { number }
     */fn.end=function end(){return fn.domain()[this.domain().length-1];};/**
     * Get the minimum value of the domain
     * @return { number }
     */fn.min=function min(){return Math.min(this.start(),this.end());};/**
     * Get the maximum value of the domain
     * @return { number }
     */fn.max=function max(){return Math.max(this.start(),this.end());};/**
     * Divides the domain and range into uniform segments, based on start and end value
     * @param  { number } segments The number of segments
     * @return { function } The instance this method was called on
     * @example
     * let s = linear();
     * s.domain([0, 10]);
     * s.range([0, 1]);
     * s.classify( 2 );
     * s.domain(); // [10, 5, 5, 0]
     * s.range(); // [0.75, 0.75, 0.25, 0.25]
     */fn.classify=function classify(segments){let valueRange=(fn.start()-fn.end())/segments,domain=[fn.end()],range=[],samplePos=valueRange/2;for(let i=0;i<segments;i++){let lastVal=domain[domain.length-1]||0,calIntervalPos=lastVal+valueRange,calSamplePos=lastVal+samplePos,sampleColValue=fn(calSamplePos);domain.push(...[calIntervalPos,calIntervalPos]);range.push(...[sampleColValue,sampleColValue]);}domain.pop();fn.domain(domain);fn.range(range);return fn;};fn.copy=function copy(){const cop=scaleLinear(settings,data,resources);cop.domain(fn.domain());cop.range(fn.range());cop.clamp(d3Scale.clamp());return cop;};/**
     * @param {number} d - A domain value
     * @return {number} A normalized range output given in range 0-1
     * @example
     * const scale = scaleLinear().domain([0, 10]).range([0, 10000]);
     * scale.norm(5); // Returns 0.5
     * scale(5); // Returns 5000
     *
     * scale.domain([0, 2, 10]);
     * scale.norm(5); // Returns 0.5
     */fn.norm=function norm(d){initNormScale$1(normScale,fn);return normScale.instance(d);};/**
     * @param {number} d - A normalized value in range 0-1
     * @return {number} A corresponding domain value
     * @example
     * const scale = scaleLinear().domain([0, 10]).range([0, 10000]);
     * scale.normInvert(0.5); // Returns 5
     * scale.invert(5000); // Returns 5
     */fn.normInvert=function norm(t){initNormScale$1(normScale,fn);return normScale.instance.invert(t);};const{mini,maxi}=getMinMax$2(stgns,data?data.fields:[]);fn.domain([mini,maxi]);fn.range(stgns.invert?[1,0]:[0,1]);normScale.invert=stgns.invert;return fn;}const DEFAULT_SETTINGS$7={padding:0,paddingInner:NaN,paddingOuter:NaN,align:0.5,invert:false,maxPxStep:NaN,range:[0,1]};/**
   * @typedef {object} ScaleBand
   * @property {string} [type='band']
   * @property {number} [padding=0] - Sets both inner and outer padding to the same value
   * @property {number} [paddingInner=0] - Inner padding
   * @property {number} [paddingOuter=0] - Outer padding
   * @property {number} [align=0.5] -  Control how the outer padding should be distributed, where 0.5 would distribute the padding equally on both sides
   * @property {boolean} [invert=false] - Invert the output range
   * @property {number} [maxPxStep] - Explicitly limit the bandwidth to a pixel value
   * @property {function} [label] - Callback label function, applied on each datum
   * @property {function} [value] - Callback value function, applied on each datum
   * @property {number[]|function} [range=[0, 1]] - Set range explicitly (ignored when maxPxStep takes effect)
   */ /**
   * @alias scaleBand
   * @memberof picasso
   * @private
   * @param { Object } settings
   * @param { fields[] } [fields]
   * @param { dataset } [dataset]
   * @return { band }
   */function scaleBand(){let settings=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let data=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let resources=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const ctx={data,resources};const stgns=resolveSettings$2(settings,DEFAULT_SETTINGS$7,ctx);const items=data.items||[];const domainToDataMapping={};const values=[];const labels=[];// I would like to define this outside of scaleBand but it cause the documentation to be in the wrong order
  function augmentScaleBand(band,fsettings){band.data=()=>data;band.datum=domainValue=>items[domainToDataMapping[domainValue]];/**
       * Get the first value of the domain
       * @return { number }
       */band.start=function start(){return band.domain()[0];};/**
       * Get the last value of the domain
       * @return { number }
       */band.end=function end(){return band.domain()[band.domain().length-1];};band.labels=()=>labels;/**
       * Generate discrete ticks
       * @return {Object[]} Array of ticks
       */band.ticks=function ticks(){let input=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};input.scale=band;return generateDiscreteTicks(input,fsettings.trackBy||'label');};}/**
     * An augmented {@link https://github.com/d3/d3-scale#_band|d3 band scale}
     * @alias band
     * @private
     * @kind function
     * @param { Object } value
     * @return { number }
     */const band$1=band();augmentScaleBand(band$1,settings);/**
     * if required creates a new scale with a restricted range
     * so that step size is at most maxPxStep
     * otherwise it returns itself
     * @param { number } size
     * @return { band }
     */band$1.pxScale=function pxScale(size){const max=stgns.maxPxStep;if(isNaN(max)){return band$1;}const n=band$1.domain().length;const sizeRelativeToStep=Math.max(1,n-band$1.paddingInner()+2*band$1.paddingOuter());if(sizeRelativeToStep*max>=size){return band$1;}const newBand=band$1.copy();newBand.type=band$1.type;augmentScaleBand(newBand,settings);const t=sizeRelativeToStep*max/size;const offset=(1-t)*band$1.align();newBand.range(stgns.invert?[t+offset,offset]:[offset,t+offset]);return newBand;};const valueFn=typeof settings.value==='function'?settings.value:d=>d.datum.value;const labelFn=typeof settings.label==='function'?settings.label:d=>d.datum.label;for(let i=0;i<items.length;i++){const arg=extend$1({datum:items[i]},ctx);const v=valueFn(arg,i);if(values.indexOf(v)===-1){values.push(v);labels.push(labelFn(arg,i));domainToDataMapping[v]=i;}}band$1.domain(values);band$1.range(stgns.invert?stgns.range.slice().reverse():stgns.range);band$1.padding(isNaN(stgns.padding)?0:stgns.padding);if(!isNaN(stgns.paddingInner)){band$1.paddingInner(stgns.paddingInner);}if(!isNaN(stgns.paddingOuter)){band$1.paddingOuter(stgns.paddingOuter);}band$1.align(isNaN(stgns.align)?0.5:stgns.align);return band$1;}const DEFAULT_TICKS_SETTINGS={depth:0};function keyGen(node,valueFn,ctx){return node.ancestors().map(a=>valueFn(extend$1({datum:a.data},ctx))).reverse().slice(1)// Delete root node
  .toString();}function flattenTree$1(rootNode,settings,ctx){const ticksDepth=settings.ticks.depth;const valueFn=settings.value;const labelFn=settings.label;const values=[];const labels=[];const items={};const ticks=[];let expando=0;if(!rootNode){return {values,labels,items,ticks};}rootNode.eachAfter(node=>{if(node.depth>0){const key=keyGen(node,valueFn,ctx);const leaves=node.leaves()||[node];// If leaf node returns itself
  const value=valueFn(extend$1({datum:node.data},ctx));const label=labelFn(extend$1({datum:node.data},ctx));const isBranch=Array.isArray(node.children);const item={key,count:leaves.length,value,label,leftEdge:keyGen(leaves[0],valueFn,ctx),rightEdge:keyGen(leaves[Math.max(leaves.length-1,0)],valueFn,ctx),node// isTick: ticksDepth === null ? !isBranch : node.depth === ticksDepth
  };if(isBranch){values.push("SPACER_".concat(expando,"_SPACER"));expando++;}else {values.push(key);labels.push(label);}if(ticksDepth<=0&&!isBranch||node.depth===ticksDepth){ticks.push(item);}items[key]=item;}});const spill=rootNode.height-1;if(spill>0){values.splice(-spill);}return {values,labels,items,ticks};}/**
   * @typedef {object} scale-hBand.settings
   * @private
   * @property {number} [padding=0] - Exposes {@link https://github.com/d3/d3-scale#band_padding}
   * @property {boolean} [paddingOuter=0] - Exposes {@link https://github.com/d3/d3-scale#band_paddingOuter}
   * @property {number[]} [paddingInner=0] - Exposes {@link https://github.com/d3/d3-scale#band_paddingInner}
   * @property {object} [align=0.5] - Exposes {@link https://github.com/d3/d3-scale#band_align}
   * @property {boolean} [invert=false] - Invert the output range
   */ /**
   * Hierarchical band scale, that is an augmented band scale, that takes hierarchical data as input
   * @alias scaleHierarchicalBand
   * @private
   * @param { Object } settings
   * @param { fields[] } [fields]
   * @param { dataset } [dataset] - With a root property that is an instance of D3.js Hierarchy
   * @return { h-band }
   */function scaleHierarchicalBand(){let settings=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let data=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let resources=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const ctx={data,resources};const stgns=resolveSettings$2(settings,DEFAULT_SETTINGS$7,ctx);stgns.ticks=resolveSettings$2(settings.ticks,DEFAULT_TICKS_SETTINGS,ctx);stgns.value=typeof settings.value==='function'?settings.value:d=>d.datum.value;stgns.label=typeof settings.label==='function'?settings.label:d=>d.datum.value;let bandInstance=scaleBand(stgns);const{values,labels,items,ticks}=flattenTree$1(data.root,stgns,ctx);/**
     * @alias h-band
     * @private
     * @kind function
     * @param { Object[] } value - Array where each value is a reference to a node, going from depth 1 to n.
     * @return { number }
     */const hBand=function fn(val){const strVal=String(val);const item=items[strVal];if(item){return bandInstance(stgns.invert?item.rightEdge:item.leftEdge);}return bandInstance(strVal);};extend$1(true,hBand,bandInstance);/**
     * Wrapped {@link https://github.com/d3/d3-scale#band_bandwidth}
     * @param { Object[] } [val] - Array where each value is a reference to a node, going from depth 1 to n. If omitted, bandwidth for the leaf nodes is return.
     * @return { number }
     */hBand.bandwidth=function bandwidth(val){const item=items[String(val)];const bw=bandInstance.bandwidth();if(item&&!item.isLeaf){const left=hBand(item.leftEdge);const right=hBand(item.rightEdge);return Math.abs(left-right)+bw;}return bw;};/**
     * Wrapped {@link https://github.com/d3/d3-scale#band_step}
     * @param { Object[] } [val] - Array where each value is a reference to a node, going from depth 1 to n. If omitted, step size for the leaf nodes is return.
     * @return { number }
     */hBand.step=function step(val){const item=items[String(val)];const leafCount=item?item.count:1;let stepSize=bandInstance.step();stepSize*=leafCount;return stepSize;};/**
     * @return { dataset }
     */hBand.data=()=>data;/**
     * Return datum for a given node
     * @param { Object[] } val - Array where each value is a reference to a node, going from depth 1 to n.
     * @return { Object } The datum
     */hBand.datum=val=>{const item=items[String(val)];if(item){return item.node.data;}return null;};hBand.copy=()=>scaleHierarchicalBand(settings,data,resources);/**
     * @return { Object[] } Labels for each leaf node
     */hBand.labels=()=>labels;/**
     * Generate discrete ticks
     * @return { Object[] } Ticks for each leaf node
     */hBand.ticks=()=>// eslint-disable-line arrow-body-style
  ticks.map(item=>{const start=hBand(item.key);const bandwidth=hBand.bandwidth(item.key);return {position:start+bandwidth/2,label:item.label,data:item.node.data,start,end:start+bandwidth};});const orgPxScale=bandInstance.pxScale;hBand.pxScale=function pxScale(size){bandInstance=orgPxScale(size);return hBand;};hBand.domain(values);return hBand;}const minAccessor=v=>v.min();const maxAccessor=v=>v.max();/**
   * Calculate the min/max value based on various inputs.
   *
   * Provided min/max setting takes presedence over all other inputs. If not provided, the respective values are calculated
   * from the given arr input, where each item in the array is expected to have a min/max accessor.
   *
   * @private
   * @param {object} [settings]
   * @param {number} [settings.min] The minimum value. Defaults to 0 if not provided.
   * @param {number} [settings.max] The maximum value. Defaults to 1 if not provided.
   * @param {object} [arr]
   * @returns { object[] } An array containing the min and max values.
   *
   * @example
   * minmax(); // [0, 1]
   *
   * minmax({}, [
   * { min: () => 13, max: () => 15 },
   * { min: () => NaN, max: () => 17 },
   * ]); // [13, 17]
   *
   * minmax({ min: -5, max: 4 }, [
   * { min: () => -20, max: () => 15 },
   * ]); // [-5, 4]
   */function minmax(settings,arr){// const definedMin = settings && typeof settings.min !== 'undefined';
  // const definedMax = settings && typeof settings.max !== 'undefined';
  const definedMin=settings&&!isNaN(settings.min);const definedMax=settings&&!isNaN(settings.max);let min=definedMin?+settings.min:0;let max=definedMax?+settings.max:1;if(arr&&arr.length){if(!definedMin){const arrMin=arr.map(minAccessor).filter(isNumber$1);min=arrMin.length?Math.min(...arrMin):min;}if(!definedMax){const arrMax=arr.map(maxAccessor).filter(isNumber$1);max=arrMax.length?Math.max(...arrMax):max;}}return [min,max];}const DEFAULT_SETTINGS$6={domain:[],range:[],invert:false,min:NaN,max:NaN};function generateDomain$1(range,min,max){const len=range.length;if(len===2){return [min,max];}const domain=[];const part=(max-min)/(len-1);domain.push(min);for(let i=1;i<len-1;i++){domain.push(min+part*i);}domain.push(max);return domain;}/**
   * @typedef {object} ScaleSequentialColor
   * @property {string} [type='sequential-color']
   * @property {string[]} [range] - CSS color values of the output range
   * @property {boolean} [invert=false] - Invert range
   * @property {number} [min] - Set an explicit minimum value
   * @property {number} [max] - Set an explicit maximum value
   */ /**
   * @alias scaleSequentialColor
   * @private
   * @param { Object } [settings] Settings for this scale. If both range and domain are specified, they have to fulfill range.length === domain.length, otherwise they will be overriden.
   * @param { number[] } [settings.domain] Numeric values indicating stop limits between start and end values.
   * @param { color[] } [settings.range] CSS color values indicating stop colors between start and end values.
   * @param { field[] } [fields] Fields to dynamically calculate the domain extent.
   * @return { sequentialColor }
   *
   * @example
   * picasso.scaleSequentialColor({
   *  range: ['red', '#fc6', 'green'],
   *  domain: [-40, 0, 100]
   * });
   */function scaleSequentialColor(){let settings=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let data=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let resources=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const s=scaleLinear(settings,data,resources).clamp(true).interpolate(rgb);const stgns=resolveSettings$2(settings,DEFAULT_SETTINGS$6,{data,resources});const isDomain=Array.isArray(stgns.domain)&&stgns.domain.length;const isRange=Array.isArray(stgns.range)&&stgns.range.length;/**
     * @alias sequentialColor
     * @private
     * @kind function
     * @param { Object } v Object containing a 'value' property
     * @return { string } The blended color
     */const fn=s;extend$1(true,fn,s);const[min,max]=minmax(stgns,data?data.fields:[]);const num=isDomain?stgns.domain.length:-1;const DEFAULT_COLORS=resources.theme?resources.theme.palette('sequential',num>0?num:2):[];const range=isRange?stgns.range:DEFAULT_COLORS;fn.range(stgns.invert?range.slice().reverse():range.slice());fn.domain(isDomain?stgns.domain:generateDomain$1(fn.range(),min,max));return fn;}// const DEFAULT_COLORS = ['rgb(180,221,212)', 'rgb(34, 83, 90)'];
  const DEFAULT_SETTINGS$5={domain:[],range:[],invert:false,min:NaN,max:NaN,nice:false};function generateDomain(range,min,max){const len=range.length;if(len===2){return [min+(max-min)/2];}const domain=[];const part=(max-min)/len;for(let i=1;i<len;i++){domain.push(min+part*i);}return domain;}function getBreaks(domain){const ret=[];for(let i=0;i<domain.length-1;i++){ret.push((domain[i]+domain[i+1])/2);}return ret;}function generateRange(domain,colors,min,max){min=domain[0];max=domain&&domain.length>=2?domain[domain.length-1]:max;const seq=scaleSequentialColor().domain([min,max]).range(colors);const values=[min,...getBreaks(domain),max];return values.map(v=>seq(v));}function generateNiceDomain(range,min,max){const numPoints=range.length===2?10:Math.max(1,range.length);const lin=linear().domain([min,max]).nice(numPoints);const domain=lin.ticks(numPoints);if(!range||!range.length){return domain;}// remove values from endpoints
  const num=Math.max(0,range.length-1);while(domain.length>num){if(domain[0]-min<=max-domain[domain.length-1]){domain.shift();}else {domain.pop();}}return domain;}/**
   * @typedef {object} ScaleThresholdColor
   * @property {string} [type='threshold-color']
   * @property {number[]} [domain] Values defining the thresholds
   * @property {string[]} [range] - CSS color values of the output range
   * @property {boolean} [invert=false] - Invert range
   * @property {number} [min] - Set an explicit minimum value
   * @property {number} [max] - Set an explicit maximum value
   * @property {boolean} [nice=false] If set to true, will generate 'nice' domain values. Ignored if domain is set.
   */ /**
   * @alias scaleThresholdColor
   * @private
   * @param { object } [settings] Settings for this scale. If both domain and range are specified, they have to fulfill domain.length === range.length + 1,  otherwise they will be overriden.
   * @param { number[] } [settings.domain] Values defining the thresholds.
   * @param { color[] } [settings.range] CSS color values of the output range.
   * @param { boolean } [settings.nice=false] If set to true, will generate 'nice' domain values. Ignored if domain is set.
   * @param { number } [settings.min] Minimum value to generate domain extent from. Ignored if domain is set.
   * @param { number } [settings.max] Maximum value to generate domain extend from. Ignored if domain is set.
   * @param { field[] } [fields] Fields to dynamically calculate the domain extent from. Ignored if min/max are set.
   * @return { thresholdColor }
   *
   * @example
   * let t = threshold({
   *   range: ['black', 'white'],
   *   domain: [25,50,75],
   *   max: 100,
   *   min: 0
   * });
   * t.domain(); // [25,50,75]
   * t.range(); // Generates from colors and domain: ['rgb(0,0,0)','rgb(85,85,85)','rgb(170,170,170)','rgb(255,255,255)']
   */function scaleThresholdColor(){let settings=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let data=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let resources=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const d3Scale=threshold$2();const stgns=resolveSettings$2(settings,DEFAULT_SETTINGS$5,{data,resources});const isDomain=Array.isArray(stgns.domain)&&stgns.domain.length;const isRange=Array.isArray(stgns.range)&&stgns.range.length;/**
     * @alias thresholdColor
     * @private
     * @param { object } v Object literal containing a 'value' property.
     * @return { string } A CSS color from the scale's range.
     */function fn(v){if(notNumber(v)){return NaN;}return d3Scale(v);}Object.keys(d3Scale).forEach(key=>fn[key]=d3Scale[key]);const fields=data.fields;const[min,max]=minmax(stgns,fields);const num=isDomain?stgns.domain.length:-1;const DEFAULT_COLORS=resources.theme?resources.theme.palette('sequential',num>0?num:2):[];let range=isRange?stgns.range:DEFAULT_COLORS;let domain=[];if(isDomain){domain=stgns.domain;}else if(stgns.nice){domain=generateNiceDomain(range,min,max);}else {domain=[min+(max-min)/2];}if(range.length>domain.length+1){// Generate limits from range
  domain=generateDomain(range,min,max);}else if(range.length<domain.length+1){// Generate additional colors
  range=generateRange(domain,range,min,max);}fn.data=()=>data;fn.range(stgns.invert?range.slice().reverse():range);fn.domain(domain);return fn;}const DEFAULT_SETTINGS$4={domain:[],range:[]};/**
   * @alias scaleOrdinal
   * @private
   * @param { Object } settings
   * @param { field[] } [fields]
   * @param { dataset } data
   * @return { ordinal }
   */function ordinal(){let settings=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let data=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let resources=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};/**
     * An augmented {@link https://github.com/d3/d3-scale#_ordinal|d3 ordinal scale}
     * @private
     * @alias ordinal
     * @param { Object }
     * @return { number }
     */const fn=ordinal$1();const ctx={data,resources};const stgns=resolveSettings$2(settings,DEFAULT_SETTINGS$4,ctx);const valueFn=typeof settings.value==='function'?settings.value:d=>d.datum.value;const labelFn=typeof settings.label==='function'?settings.label:d=>d.datum.label;const items=data.items||[];const domainToDataMapping={};const values=[];const labels=[];for(let i=0;i<items.length;i++){const arg=extend$1({datum:items[i]},ctx);const v=valueFn(arg,i);if(values.indexOf(v)===-1){values.push(v);labels.push(labelFn(arg,i));domainToDataMapping[v]=i;}}fn.data=()=>data;fn.labels=()=>labels;fn.label=domainValue=>labels[values.indexOf(domainValue)];fn.datum=domainValue=>items[domainToDataMapping[domainValue]];fn.range(stgns.range);if(Array.isArray(stgns.domain)&&stgns.domain.length){fn.domain(stgns.domain);}else {fn.domain(values);}return fn;}const DEFAULT_SETTINGS$3={domain:[],range:[],unknown:undefined};const DEFAULT_EXPLICIT_SETTINGS={domain:[],range:[],override:false};/**
   * @typedef {object} ScaleCategoricalColor
   * @property {string} [type='categorical-color']
   * @property {string[]} [range=false] - CSS color values of the output range
   * @property {string} [unknown] - Value to return when input value is unknown
   * @property {object} [explicit] - Explicitly bind values to an output
   * @property {object[]} [explicit.domain[]] - Values to bind
   * @property {string[]} [explicit.range[]] - Output range
   */ /**
   * An ordinal scale with the output range set to default colors, as defined by *scaleCategorical.range*
   * @alias scaleCategorical
   * @private
   * @param { Object } settings
   * @param { field[] } [fields]
   * @param { dataset } [dataset]
   * @return { ordinal }
   */function scaleCategorical(){let settings=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let data=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let resources=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const s=ordinal(settings,data,resources);const theme=resources.theme;const stgns=resolveSettings$2(settings,DEFAULT_SETTINGS$3,{data,resources});stgns.explicit=resolveSettings$2(settings.explicit,DEFAULT_EXPLICIT_SETTINGS,{data,resources});let range;if(!Array.isArray(stgns.range)||stgns.range.length===0){range=theme?theme.palette('categorical',s.domain().length).slice():[];}else {range=stgns.range.slice();}if(stgns.unknown){s.unknown(stgns.unknown);}else if(theme&&theme.palette('unknown')){let un=theme.palette('unknown');s.unknown(un[0]);}if(Array.isArray(stgns.explicit.domain)&&stgns.explicit.domain.length){const domain=s.domain().slice();const explicitDomain=stgns.explicit.domain;const explicitRange=Array.isArray(stgns.explicit.range)?stgns.explicit.range:[];// duplicate range values to cover entire domain
  const numCopies=Math.floor(domain.length/range.length);for(let i=1;i<numCopies+1;i*=2){range=range.concat(range);}if(stgns.explicit.override){for(let i=0;i<explicitDomain.length;i++){const index=domain.indexOf(explicitDomain[i]);if(index>-1){range[index]=explicitRange[i];}}}else {// inject explicit colors
  const order=explicitDomain.map((d,i)=>[domain.indexOf(d),d,explicitRange[i]]).sort((a,b)=>a[0]-b[0]);order.forEach(v=>{const idx=domain.indexOf(v[1]);if(idx!==-1){range.splice(idx,0,v[2]);}});}// cutoff excess range values
  range.length=domain.length;}s.range(range);return s;}/**
   * Definition for creating a scale. Additional properties, specific for a type of scale, can be added as key/value pairs
   * @typedef {object} ScaleDefinition
   * @property {string} [type] Type of scale
   * @property {DataExtraction|DataFieldExtraction} [data] Data configuration
   */ /**
   * Scale instance
   * @typedef {object} Scale
   * @interface
   * @property {string} type Type of scale
   */const scaleRegistry=registryFactory();scaleRegistry('linear',scaleLinear);scaleRegistry('band',scaleBand);scaleRegistry('h-band',scaleHierarchicalBand);scaleRegistry('sequential-color',scaleSequentialColor);scaleRegistry('threshold-color',scaleThresholdColor);scaleRegistry('categorical-color',scaleCategorical);function getTypeFromMeta(fields){const types=fields.map(field=>field.type()==='dimension'?'band':'linear');return types.indexOf('linear')!==-1?'linear':'band';}function deduceScaleTypeFromData(data){if(data.root){return 'h-band';}if(data.fields&&data.fields[0]){return getTypeFromMeta(data.fields);}return 'linear';}function create$n(options,d,deps){let dataSourceConfig=options.data;if(options.source){// DEPRECATION
  deps.logger.warn('Deprecated: Scale data source configuration');dataSourceConfig={extract:[]};(Array.isArray(options.source)?options.source:[options.source]).forEach(source=>{dataSourceConfig.extract.push({field:source});});}const data=extract$1$1(dataSourceConfig,d,deps);let type=options.type||deduceScaleTypeFromData(data);let s;if(type==='color'){if(data.fields&&data.fields[0]&&data.fields[0].type()==='dimension'){type='categorical-color';}else {type='sequential-color';}}if(deps.scale.has(type)){s=deps.scale.get(type);s=s(options,data,{theme:deps.theme,logger:deps.logger});s.type=type;}return s;}function collection(scalesConfig,data,deps){let fn=arguments.length>3&&arguments[3]!==undefined?arguments[3]:create$n;const scales={};return {get(def){let key;if(typeof def==='string'&&scalesConfig[def]){key=def;}else if(typeof def==='object'&&'scale'in def&&scalesConfig[def.scale]){key=def.scale;}if(key){scales[key]=scales[key]||fn(scalesConfig[key],data,deps);return scales[key];}return fn(def,data,deps);},all(){Object.keys(scalesConfig).forEach(this.get);return scales;}};}/**
   * Utility functions
   */var util$1={};util$1.isObject=function isObject(arg){return typeof arg==='object'&&arg!==null;};util$1.isNumber=function isNumber(arg){return typeof arg==='number';};util$1.isUndefined=function isUndefined(arg){return arg===void 0;};util$1.isFunction=function isFunction(arg){return typeof arg==='function';};/**
   * EventEmitter class
   */function EventEmitter$1$1(){EventEmitter$1$1.init.call(this);}var nodeEventEmitter$1=EventEmitter$1$1;// Backwards-compat with node 0.10.x
  EventEmitter$1$1.EventEmitter=EventEmitter$1$1;EventEmitter$1$1.prototype._events=undefined;EventEmitter$1$1.prototype._maxListeners=undefined;// By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  EventEmitter$1$1.defaultMaxListeners=10;EventEmitter$1$1.init=function(){this._events=this._events||{};this._maxListeners=this._maxListeners||undefined;};// Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter$1$1.prototype.setMaxListeners=function(n){if(!util$1.isNumber(n)||n<0||isNaN(n))throw TypeError('n must be a positive number');this._maxListeners=n;return this;};EventEmitter$1$1.prototype.emit=function(type){var er,handler,len,args,i,listeners;if(!this._events)this._events={};// If there is no 'error' event listener then throw.
  if(type==='error'&&!this._events.error){er=arguments[1];if(er instanceof Error){throw er;// Unhandled 'error' event
  }else {throw Error('Uncaught, unspecified "error" event.');}}handler=this._events[type];if(util$1.isUndefined(handler))return false;if(util$1.isFunction(handler)){switch(arguments.length){// fast cases
  case 1:handler.call(this);break;case 2:handler.call(this,arguments[1]);break;case 3:handler.call(this,arguments[1],arguments[2]);break;// slower
  default:len=arguments.length;args=new Array(len-1);for(i=1;i<len;i++)args[i-1]=arguments[i];handler.apply(this,args);}}else if(util$1.isObject(handler)){len=arguments.length;args=new Array(len-1);for(i=1;i<len;i++)args[i-1]=arguments[i];listeners=handler.slice();len=listeners.length;for(i=0;i<len;i++)listeners[i].apply(this,args);}return true;};EventEmitter$1$1.prototype.addListener=function(type,listener){var m;if(!util$1.isFunction(listener))throw TypeError('listener must be a function');if(!this._events)this._events={};// To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if(this._events.newListener)this.emit('newListener',type,util$1.isFunction(listener.listener)?listener.listener:listener);if(!this._events[type])// Optimize the case of one listener. Don't need the extra array object.
  this._events[type]=listener;else if(util$1.isObject(this._events[type]))// If we've already got an array, just append.
  this._events[type].push(listener);else// Adding the second element, need to change to array.
  this._events[type]=[this._events[type],listener];// Check for listener leak
  if(util$1.isObject(this._events[type])&&!this._events[type].warned){var m;if(!util$1.isUndefined(this._maxListeners)){m=this._maxListeners;}else {m=EventEmitter$1$1.defaultMaxListeners;}if(m&&m>0&&this._events[type].length>m){this._events[type].warned=true;if(util$1.isFunction(console.error)){console.error('(node) warning: possible EventEmitter memory '+'leak detected. %d listeners added. '+'Use emitter.setMaxListeners() to increase limit.',this._events[type].length);}if(util$1.isFunction(console.trace))console.trace();}}return this;};EventEmitter$1$1.prototype.on=EventEmitter$1$1.prototype.addListener;EventEmitter$1$1.prototype.once=function(type,listener){if(!util$1.isFunction(listener))throw TypeError('listener must be a function');var fired=false;function g(){this.removeListener(type,g);if(!fired){fired=true;listener.apply(this,arguments);}}g.listener=listener;this.on(type,g);return this;};// emits a 'removeListener' event iff the listener was removed
  EventEmitter$1$1.prototype.removeListener=function(type,listener){var list,position,length,i;if(!util$1.isFunction(listener))throw TypeError('listener must be a function');if(!this._events||!this._events[type])return this;list=this._events[type];length=list.length;position=-1;if(list===listener||util$1.isFunction(list.listener)&&list.listener===listener){delete this._events[type];if(this._events.removeListener)this.emit('removeListener',type,listener);}else if(util$1.isObject(list)){for(i=length;i-->0;){if(list[i]===listener||list[i].listener&&list[i].listener===listener){position=i;break;}}if(position<0)return this;if(list.length===1){list.length=0;delete this._events[type];}else {list.splice(position,1);}if(this._events.removeListener)this.emit('removeListener',type,listener);}return this;};EventEmitter$1$1.prototype.removeAllListeners=function(type){var key,listeners;if(!this._events)return this;// not listening for removeListener, no need to emit
  if(!this._events.removeListener){if(arguments.length===0)this._events={};else if(this._events[type])delete this._events[type];return this;}// emit removeListener for all listeners on all events
  if(arguments.length===0){for(key in this._events){if(key==='removeListener')continue;this.removeAllListeners(key);}this.removeAllListeners('removeListener');this._events={};return this;}listeners=this._events[type];if(util$1.isFunction(listeners)){this.removeListener(type,listeners);}else if(Array.isArray(listeners)){// LIFO order
  while(listeners.length)this.removeListener(type,listeners[listeners.length-1]);}delete this._events[type];return this;};EventEmitter$1$1.prototype.listeners=function(type){var ret;if(!this._events||!this._events[type])ret=[];else if(util$1.isFunction(this._events[type]))ret=[this._events[type]];else ret=this._events[type].slice();return ret;};EventEmitter$1$1.listenerCount=function(emitter,type){var ret;if(!emitter._events||!emitter._events[type])ret=0;else if(util$1.isFunction(emitter._events[type]))ret=1;else ret=emitter._events[type].length;return ret;};var EventEmitter$2={/**
     * Function used to add event handling to objects passed in.
     * @private
     * @param {Object} obj Object instance that will get event handling.
     */mixin(obj){Object.keys(nodeEventEmitter$1.prototype).forEach(key=>{obj[key]=nodeEventEmitter$1.prototype[key];});nodeEventEmitter$1.init(obj);return obj;}};function scrollApi(){let min=0;let max=0;let start=0;let viewSize=0;start=start||min;/**
     * The scroll api
     * @private
     * @alias scroll
     */const s={/**
       * Move the current scroll
       * @param {number} value
       * @emits update
       */move(value){this.moveTo(start+value);},/**
       * Change the current scroll to a specific value
       * @param {number} value
       * @emits update
       */moveTo(value){const newStart=Math.max(min,Math.min(max-viewSize,value));if(start!==newStart){start=newStart;s.emit('update');}},/**
       * Update scroll settings
       * @param {number} [settings.min]
       * @param {number} [settings.max]
       * @param {number} [settings.viewSize]
       * @emits update
       */update(settings){let triggerUpdate=false;({min=min,max=max}=settings);if(settings.viewSize!==undefined&&settings.viewSize!==viewSize){viewSize=settings.viewSize;triggerUpdate=true;}// update scroll to be within the new bounds
  const newStart=Math.max(min,Math.min(max-viewSize,start));if(start!==newStart){start=newStart;triggerUpdate=true;}if(triggerUpdate){s.emit('update');}},/**
       * Get the current scroll state
       * @return {object} with min, max, start & viewSize
       */getState(){return {min,max,start,viewSize};}};EventEmitter$2.mixin(s);return s;}function createOrUpdate(options,oldApi){const min=options.min||0;const max=options.max||0;const viewSize=options.viewSize||0;const s=oldApi||scrollApi();s.update({min,max,viewSize});return s;}function builder(obj,oldScrollApis){const scrollApis={};for(const n in obj){if(Object.prototype.hasOwnProperty.call(obj,n)){scrollApis[n]=createOrUpdate(obj[n],oldScrollApis?oldScrollApis[n]:null);}}return scrollApis;}function getOrCreateScrollApi(v,scrollApis){if(!scrollApis[v]){scrollApis[v]=scrollApi();}return scrollApis[v];}function lessThanOrEqual(value,limit){return value<=limit;}function lessThan(value,limit){return value<limit;}function index(boundaries,point,after){let i=0;while(i<boundaries.length&&point>boundaries[i]){++i;}if(boundaries[i]===point&&after){++i;}return i;}function contains$3(boundaries,point,minCondition,maxCondition){const len=boundaries.length;for(let i=1;i<len;i+=2){if(minCondition(boundaries[i-1],point)&&maxCondition(point,boundaries[i])){return true;}}return false;}function rangeCollection(){let config=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let maxCondition;let minCondition;let boundaries=[];function fn(){}fn.configure=function(){let c=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{includeMax=true,includeMin=true}=c;maxCondition=includeMax?lessThanOrEqual:lessThan;minCondition=includeMin?lessThanOrEqual:lessThan;};fn.add=_ref=>{let{min,max}=_ref;const i0=index(boundaries,min);const i1=index(boundaries,max,true);const args=[i0,i1-i0];if(i0%2===0){args.push(min);}if(i1%2===0){args.push(max);}const before=boundaries.join(',');boundaries.splice(...args);const after=boundaries.join(',');return before!==after;};fn.remove=_ref2=>{let{min,max}=_ref2;const i0=index(boundaries,min);const i1=index(boundaries,max,true);const args=[i0,i1-i0];if(i0%2===1){args.push(min);}if(i1%2===1){args.push(max);}const before=boundaries.join(',');boundaries.splice(...args);const after=boundaries.join(',');return before!==after;};fn.set=range=>{const before=boundaries.join(',');boundaries=[];if(Array.isArray(range)){range.forEach(fn.add);}else {fn.add(range);}const after=boundaries.join(',');return before!==after;};fn.clear=()=>{const before=boundaries.length>0;boundaries=[];return before;};fn.containsValue=value=>contains$3(boundaries,value,minCondition,maxCondition);fn.containsRange=_ref3=>{let{min,max}=_ref3;const i0=index(boundaries,min,true);const i1=index(boundaries,max);return i0===i1&&i1%2===1;};fn.toggle=range=>{if(fn.containsRange(range)){return fn.remove(range);}return fn.add(range);};fn.ranges=()=>{const collection=[];for(let i=1;i<boundaries.length;i+=2){collection.push({min:boundaries[i-1],max:boundaries[i]});}return collection;};fn.configure(config);return fn;}function valueCollection(){let values=[];function vc(){}vc.add=value=>{if(values.indexOf(value)===-1){values.push(value);return true;}return false;};vc.remove=value=>{const idx=values.indexOf(value);if(idx!==-1){values.splice(idx,1);return true;}return false;};vc.contains=value=>values.indexOf(value)!==-1;vc.values=()=>values.slice();vc.clear=()=>values=[];vc.toString=()=>values.join(';');return vc;}/**
   * @typedef {object} BrushConfig
   * @property {Array<BrushConfig~Ranges>} [ranges] - Range configurations
   */ /**
   * @typedef {object}
   * @alias BrushConfig~Ranges
   */const DEFAULT_RANGE_CONFIG={/**
     * An identifier that represents the data source of the value
     * @type {string=}
     */key:undefined,/**
     * Whether or not the minimum value of a range should be included when determining if a value is brushed.
     * @type {boolean=} */includeMin:true,/**
     * Whether or not the maximum value of a range should be included when determining if a value is brushed.
     * @type {boolean=} */includeMax:true};function add$1(_ref){let{items,collection,vc}=_ref;const changedMap={};const changed=[];let key;let values;for(let i=0,num=items.length;i<num;i++){key=items[i].key;if(!collection[key]){collection[key]=vc();}values=items[i].values||[items[i].value];for(let vi=0;vi<values.length;vi++){if(collection[key].add(values[vi])){changedMap[key]=changedMap[key]||[];changedMap[key].push(values[vi]);}}}const keys=Object.keys(changedMap);for(let i=0,num=keys.length;i<num;i++){key=keys[i];changed.push({id:key,values:changedMap[key]});}return changed;}function remove$1(_ref2){let{items,collection}=_ref2;const changedMap={};const changed=[];let key;let values;for(let i=0,num=items.length;i<num;i++){key=items[i].key;if(!collection[key]){continue;}values=items[i].values||[items[i].value];for(let vi=0;vi<values.length;vi++){if(collection[key].remove(values[vi])){changedMap[key]=changedMap[key]||[];changedMap[key].push(values[vi]);}}}const keys=Object.keys(changedMap);for(let i=0,num=keys.length;i<num;i++){key=keys[i];changed.push({id:key,values:changedMap[key]});}return changed;}function collectUnique(items){const filteredSet={};let key;let values;for(let i=0,num=items.length;i<num;i++){key=items[i].key;values=items[i].values||[items[i].value];if(!filteredSet[key]){filteredSet[key]=[];}for(let vi=0;vi<values.length;vi++){const idx=filteredSet[key].indexOf(values[vi]);if(idx===-1){filteredSet[key].push(values[vi]);}}}return filteredSet;}function createValueCollection(_ref3){let{key,collection,obj,fn,value}=_ref3;if(!collection[key]){collection[key]=fn();}obj[key]=obj[key]||[];obj[key].push(value);collection[key].add(value);}function toggle(_ref4){let{items,values,vc}=_ref4;const addedMap={};const removedMap={};const added=[];const removed=[];const filteredSet=collectUnique(items);let key;let value;let fs;const setKeys=Object.keys(filteredSet);for(let i=0,num=setKeys.length;i<num;i++){key=setKeys[i];fs=filteredSet[key];for(let k=0,len=fs.length;k<len;k++){value=fs[k];if(!values[key]||!values[key].contains(value)){createValueCollection({key,value,collection:values,obj:addedMap,fn:vc});}else if(values[key]&&values[key].contains(value)){removedMap[key]=removedMap[key]||[];removedMap[key].push(value);values[key].remove(value);}}}const addedKeys=Object.keys(addedMap);for(let i=0,num=addedKeys.length;i<num;i++){key=addedKeys[i];added.push({id:key,values:addedMap[key]});}const removedKeys=Object.keys(removedMap);for(let i=0,num=removedKeys.length;i<num;i++){key=removedKeys[i];removed.push({id:key,values:removedMap[key]});}return [added,removed];}function diff$1(old,current){const changed=[];const keys=Object.keys(old);let key;let changedValues;const filterFn=v=>current[key].indexOf(v)===-1;for(let i=0,num=keys.length;i<num;i++){key=keys[i];if(!current[key]){changed.push({id:key,values:old[key]});}else {changedValues=old[key].filter(filterFn);if(changedValues.length){changed.push({id:key,values:changedValues});}}}return changed;}function set(_ref5){let{items,vCollection,vc}=_ref5;const addedMap={};const filteredSet=collectUnique(items);let added=[];let removed=[];let key;const oldMap={};const vcKeys=Object.keys(vCollection);for(let i=0,num=vcKeys.length;i<num;i++){key=vcKeys[i];oldMap[key]=vCollection[key].values().slice();delete vCollection[key];}const createValueCollectionFn=value=>{if(!vCollection[key]||!vCollection[key].contains(value)){createValueCollection({key,value,collection:vCollection,obj:addedMap,fn:vc});}};const fsKeys=Object.keys(filteredSet);for(let i=0,num=fsKeys.length;i<num;i++){key=fsKeys[i];filteredSet[key].forEach(createValueCollectionFn);}removed=diff$1(oldMap,addedMap);added=diff$1(addedMap,oldMap);return [added,removed];}function applyAliases(items,aliases){if(!Object.keys(aliases).length){return items;}const len=items.length;const its=Array(len);for(let i=0;i<len;i++){its[i]=items[i].key in aliases?extend$1({},items[i],{key:aliases[items[i].key]}):items[i];}return its;}function intercept(handlers,items,aliases){const its=applyAliases(items,aliases);return handlers&&handlers.length?handlers.reduce((value,interceptor)=>interceptor(value),its):its;}function toCamelCase(s){return s.replace(/(-[a-z])/g,$1=>$1.toUpperCase().replace('-',''));}function toSnakeCase(s){return s.replace(/([A-Z])/g,$1=>"-".concat($1.toLowerCase()));}function updateRange(items,action,_ref6){let{ranges,interceptors,rc,aliases,rangeConfig}=_ref6;const inter="".concat(action,"Ranges");const its=intercept(interceptors[inter],items,aliases);let changed=false;its.forEach(item=>{const key=item.key;if(!ranges[key]){ranges[key]=rc(rangeConfig.sources[key]||rangeConfig.default);}if(action==='set'){changed=ranges[key][action](item.ranges||item.range)||changed;}else {const rangeValues=item.ranges||[item.range];for(let i=0;i<rangeValues.length;i++){changed=ranges[key][action](rangeValues[i])||changed;}}});return changed;}function brush(){let{vc=valueCollection,rc=rangeCollection}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let activated=false;let ranges={};let values={};let aliases={};let rangeConfig={sources:{},default:extend$1({},DEFAULT_RANGE_CONFIG)};const interceptors={addValues:[],removeValues:[],toggleValues:[],setValues:[],addRanges:[],setRanges:[],removeRanges:[],toggleRanges:[]};const getState=()=>{const state={values:{},ranges:{}};Object.keys(values).forEach(key=>{state.values[key]=values[key].values();});Object.keys(ranges).forEach(key=>{state.ranges[key]=ranges[key].ranges();});return state;};const links={ls:[],clear(){this.ls.forEach(b=>b.clear());},start(){this.ls.forEach(b=>b.start());},end(){this.ls.forEach(b=>b.end());},update(){const s=getState();this.ls.forEach(b=>b._state(s));},updateValues(){const s=getState();this.ls.forEach(b=>b._state({values:s.values}));},updateRanges(){const s=getState();this.ls.forEach(b=>b._state({ranges:s.ranges}));}};/**
     * A brush context
     * @alias Brush
     * @interface
     */const fn={};/**
     * Triggered when this brush is activated
     * @event Brush#start
     * @type {string}
     */ /**
     * Triggered when this brush is updated
     * @event Brush#update
     * @type {string}
     * @param {Array<object>} added - The added items
     * @param {Array<object>} removed - The removed items
     */ /**
     * Triggered when this brush is deactivated
     * @event Brush#end
     * @type {string}
     */ /**
     * Configure the brush instance.
     *
     * @param {BrushConfig} config
     * @example
     * brushInstance.configure({
     *   ranges: [
     *     { key: 'some key', includeMax: false },
     *     { includeMax: true, includeMin: true },
     *   ]
     * })
     */fn.configure=function(){let config=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(Array.isArray(config.ranges)&&config.ranges.length){rangeConfig={sources:{},default:extend$1({},DEFAULT_RANGE_CONFIG)};config.ranges.forEach(cfg=>{const c={};Object.keys(DEFAULT_RANGE_CONFIG).filter(attr=>attr!=='key').forEach(attr=>{c[attr]=typeof cfg[attr]!=='undefined'?cfg[attr]:DEFAULT_RANGE_CONFIG[attr];});if(typeof cfg.key!=='undefined'){rangeConfig.sources[cfg.key]=c;}else {rangeConfig.default=c;}});Object.keys(ranges).forEach(key=>ranges[key].configure(rangeConfig.sources[key]||rangeConfig.default));// TODO only emit update if config has changed
  fn.emit('update',[],[]);}};/**
     * Link this brush to another brush instance.
     *
     * When linked, the `target` will receive updates whenever this brush changes.
     * @param {Brush} target - The brush instance to link to
     */fn.link=target=>{if(fn===target){throw new Error("Can't link to self");}links.ls.push(target);target._state(getState());};fn._state=s=>{if(!s){return getState();}if(s.values){const arr=[];Object.keys(s.values).forEach(key=>{if(!values[key]||s.values[key].join(';')!==values[key].toString()){arr.push({key,values:s.values[key]});}});Object.keys(values).forEach(key=>{if(!s.values[key]){arr.push({key,values:[]});}});if(arr.length){fn.setValues(arr);}}if(s.ranges){const arr=[];Object.keys(s.ranges).forEach(key=>{if(!ranges[key]||s.ranges[key].join(';')!==ranges[key].toString()){arr.push({key,ranges:s.ranges[key]});}});Object.keys(ranges).forEach(key=>{if(!s.ranges[key]){arr.push({key,ranges:[]});}});if(arr.length){fn.setRanges(arr);}}return undefined;};/**
     * Starts this brush context
     *
     * Starts this brush context and emits a 'start' event if it is not already started.
     * @param {...any} args - arguments to be passed to 'start' listeners
     * @emits Brush#start
     */fn.start=function(){if(!activated){activated=true;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}fn.emit('start',...args);links.start();}};/**
     * Ends this brush context
     *
     * Ends this brush context and emits an 'end' event if it is not already ended.
     * @param {...any} args - arguments to be passed to 'end' listeners
     * @emits Brush#end
     */fn.end=function(){if(!activated){return;}activated=false;ranges={};values={};for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}fn.emit('end',...args);links.end();};/**
     * Checks if this brush is activated
     *
     * Returns true if started, false otherwise
     * @return {boolean}
     */fn.isActive=()=>activated;/**
     * Clears this brush context
     */fn.clear=()=>{const removed=fn.brushes().filter(b=>b.type==='value'&&b.brush.values().length).map(b=>({id:b.id,values:b.brush.values()}));const hasChanged=Object.keys(ranges).length>0||removed.length;ranges={};values={};if(hasChanged){fn.emit('update',[],removed);// TODO - do not emit update if state hasn't changed
  links.clear();}};/**
     * Returns all brushes within this context
     * @return {object}
     */fn.brushes=()=>{let result=[];result=result.concat(Object.keys(ranges).map(key=>({type:'range',id:key,brush:ranges[key]})));result=result.concat(Object.keys(values).map(key=>({type:'value',id:key,brush:values[key]})));return result;};/**
     * Adds a primitive value to this brush context
     *
     * If this brush context is not started, a 'start' event is emitted.
     * If the state of the brush changes, ie. if the added value does not already exist, an 'update' event is emitted.
     *
     * @param {string} key  An identifier that represents the data source of the value
     * @param {string|number} value The value to add
     * @emits Brush#start
     * @emits Brush#update
     * @example
     * brush.addValue('countries', 'Sweden');
     * brush.addValue('/qHyperCube/qDimensionInfo/0', 3);
     */fn.addValue=(key,value)=>{fn.addValues([{key,value}]);};/**
     * @param {object[]} items Items to add
     */fn.addValues=items=>{const its=intercept(interceptors.addValues,items,aliases);const added=add$1({vc,collection:values,items:its});fn.emit('add-values',its);if(added.length){if(!activated){activated=true;fn.emit('start');}fn.emit('update',added,[]);links.updateValues();}};/**
     * @param {object[]} items Items to set
     */fn.setValues=items=>{const its=intercept(interceptors.setValues,items,aliases);const changed=set({items:its,vCollection:values,vc});fn.emit('set-values',its);if(changed[0].length>0||changed[1].length>0){if(!activated){activated=true;fn.emit('start');}fn.emit('update',changed[0],changed[1]);links.updateValues();}};/**
     * Removes a primitive values from this brush context
     *
     * If the state of the brush changes, ie. if the removed value does exist, an 'update' event is emitted.
     *
     * @param  {string} key  An identifier that represents the data source of the value
     * @param  {string|number} value The value to remove
     * @example
     * brush.removeValue('countries', 'Sweden');
     */fn.removeValue=(key,value)=>{fn.removeValues([{key,value}]);};/**
     * @param {object[]} items Items to remove
     */fn.removeValues=items=>{const its=intercept(interceptors.removeValues,items,aliases);const removed=remove$1({collection:values,items:its});fn.emit('remove-values',its);if(removed.length){fn.emit('update',[],removed);links.updateValues();// TODO - emit 'end' event if there are no remaining active brushes
  }};/**
     * Add and remove values in a single operation
     * almost the same as calling addValues and removeValues but only triggers one 'update' event
     *
     * If the state of the brush changes, an 'update' event is emitted.
     *
     * @param {object[]} addItems Items to add
     * @param {object[]} removeItems Items to remove
     */fn.addAndRemoveValues=(addItems,removeItems)=>{const addIts=intercept(interceptors.addValues,addItems,aliases);const removeIts=intercept(interceptors.removeValues,removeItems,aliases);const added=add$1({vc,collection:values,items:addIts});const removed=remove$1({collection:values,items:removeIts});fn.emit('add-values',addIts);fn.emit('remove-values',removeIts);if(added.length||removed.length){if(!activated){activated=true;fn.emit('start');}fn.emit('update',added,removed);links.updateValues();}};/**
     * Toggles a primitive value in this brush context
     *
     * If the given value exists in this brush context, it will be removed. If it does not exist it will be added.
     *
     * @param  {string} key  An identifier that represents the data source of the value
     * @param  {string|number} value The value to toggle
     * @example
     * brush.toggleValue('countries', 'Sweden');
     */fn.toggleValue=(key,value)=>{fn.toggleValues([{key,value}]);};/**
     * @param {object[]} items Items to toggle
     */fn.toggleValues=items=>{const its=intercept(interceptors.toggleValues,items,aliases);const toggled=toggle({items:its,values,vc});fn.emit('toggle-values',its);if(toggled[0].length>0||toggled[1].length>0){if(!activated){activated=true;fn.emit('start');}fn.emit('update',toggled[0],toggled[1]);links.updateValues();}};/**
     * Checks if a certain value exists in this brush context
     *
     * Returns true if the values exists for the provided key, returns false otherwise.
     *
     * @param  {string} key  An identifier that represents the data source of the value
     * @param  {string|number} value The value to check for
     * @return {boolean}
     * @example
     * brush.addValue('countries', 'Sweden');
     * brush.containsValue('countries', 'Sweden'); // true
     * brush.toggleValue('countries', 'Sweden'); // remove 'Sweden'
     * brush.containsValue('countries', 'Sweden'); // false
     */fn.containsValue=(key,value)=>{let k=aliases[key]||key;if(!values[k]){return false;}return values[k].contains(value);};/**
     * Adds a numeric range to this brush context
     *
     * @param {string} key - An identifier that represents the data source of the range
     * @param {object} range - The range to add to this brush
     * @param {number} range.min - Min value of the range
     * @param {number} range.max - Max value of the range
     * @example
     * brush.addRange('Sales', { min: 20, max: 50 });
     */fn.addRange=(key,range)=>{fn.addRanges([{key,range}]);};/**
     * @see {brush.addRange}
     * @param {object[]} items - Items containing the ranges to remove
     * @param {string} items[].key
     * @param {object} items[].range
     */fn.addRanges=items=>{const changed=updateRange(items,'add',{ranges,rc,interceptors,aliases,rangeConfig});if(!changed){return;}if(!activated){activated=true;fn.emit('start');}fn.emit('update',[],[]);links.updateRanges();};/**
     * Removes a numeric range from this brush context
     *
     * @param {string} key - An identifier that represents the data source of the range
     * @param {object} range - The range to remove from this brush
     * @param {number} range.min - Min value of the range
     * @param {number} range.max - Max value of the range
     */fn.removeRange=(key,range)=>{fn.removeRanges([{key,range}]);};/**
     * @see {brush.removeRange}
     * @param {object[]} items - Items containing the ranges to remove
     */fn.removeRanges=items=>{const changed=updateRange(items,'remove',{ranges,rc,interceptors,aliases,rangeConfig});if(!changed){return;}if(!activated){activated=true;fn.emit('start');}fn.emit('update',[],[]);links.updateRanges();};/**
     * Sets a numeric range to this brush context
     *
     * Overwrites any active ranges identified by `key`
     *
     * @param {string} key - An identifier that represents the data source of the range
     * @param {object} range - The range to set on this brush
     * @param {number} range.min - Min value of the range
     * @param {number} range.max - Max value of the range
     */fn.setRange=(key,range)=>{fn.setRanges([{key,range}]);};/**
     * @see {brush.setRange}
     * @param {object[]} items - Items containing the ranges to set
     */fn.setRanges=items=>{const changed=updateRange(items,'set',{ranges,rc,interceptors,aliases,rangeConfig});if(!changed){return;}if(!activated){activated=true;fn.emit('start');}fn.emit('update',[],[]);links.updateRanges();};/**
     * Toggles a numeric range in this brush context
     *
     * Removes the range if it's already contained within the given identifier,
     * otherwise the given range is added to the brush.
     *
     * @param {string} key - An identifier that represents the data source of the range
     * @param {object} range - The range to toggle in this brush
     * @param {number} range.min - Min value of the range
     * @param {number} range.max - Max value of the range
     */fn.toggleRange=(key,range)=>{fn.toggleRanges([{key,range}]);};/**
     * @see {brush.toggleRange}
     * @param {object[]} items - Items containing the ranges to toggle
     */fn.toggleRanges=items=>{const changed=updateRange(items,'toggle',{ranges,rc,interceptors,aliases,rangeConfig});if(!changed){return;}if(!activated){activated=true;fn.emit('start');}fn.emit('update',[],[]);links.updateRanges();};/**
     * Checks if a value is contained within a range in this brush context
     *
     * Returns true if the values exists for the provided key, returns false otherwise.
     *
     * @param  {string} key - An identifier that represents the data source of the value
     * @param  {number} value - The value to check for
     * @return {boolean}
     * @example
     * brush.addRange('Sales', { min: 10, max: 50 });
     * brush.containsRangeValue('Sales', 30); // true
     * brush.containsRangeValue('Sales', 5); // false
     */fn.containsRangeValue=(key,value)=>{let k=aliases[key]||key;if(!ranges[k]){return false;}return ranges[k].containsValue(value);};/**
     * Checks if a range segment is contained within this brush context
     *
     * Returns true if the range segment exists for the provided key, returns false otherwise.
     *
     * @param {string} key - An identifier that represents the data source of the value
     * @param {object} range - The range to check for
     * @param {number} range.min - Min value of the range
     * @param {number} range.max - Max value of the range
     * @return {boolean}
     * @example
     * brush.addRange('Sales', { min: 10, max: 50 });
     * brush.containsRange('Sales', { min: 15, max: 20 }); // true - the range segment is fully contained within [10, 50]
     * brush.containsRange('Sales', { min: 5, max: 20 }); // false - part of the range segment is outside [10, 50]
     * brush.containsRange('Sales', { min: 30, max: 80 }); // false - part of the range segment is outside [10, 50]
     */fn.containsRange=(key,range)=>{let k=aliases[key]||key;if(!ranges[k]){return false;}return ranges[k].containsRange(range);};fn.containsMappedData=(d,props,mode)=>{let status=[];const keys=Object.keys(d);let key;let item;let source;let value;for(let i=0,num=keys.length;i<num;i++){key=keys[i];if(key==='value'){item=d;status[i]={key:'',i,bool:false};}else if(key==='source'){continue;}else {item=d[key];status[i]={key,i,bool:false};}source=item.source&&item.source.field;if(typeof source==='undefined'){continue;}if(typeof item.source.key!=='undefined'){source="".concat(item.source.key,"/").concat(source);}if(source in aliases){source=aliases[source];}value=item.value;if(ranges[source]){status[i].bool=Array.isArray(value)?ranges[source].containsRange({min:value[0],max:value[1]}):ranges[source].containsValue(value);}else if(values[source]&&values[source].contains(value)){status[i].bool=true;}}if(props){status=status.filter(b=>props.indexOf(b.key)!==-1);if(mode==='and'){return !!status.length&&!status.some(s=>s.bool===false);}if(mode==='xor'){return !!status.length&&status.some(s=>s.bool)&&status.some(s=>s.bool===false);}// !mode || mode === 'or'
  return status.some(s=>s.bool);}return status.some(s=>s.bool);};/**
     * Adds an event interceptor
     *
     * @param {string} name Name of the event to intercept
     * @param {function} ic Handler to call before event is triggered
     * @example
     * brush.intercept('add-values', items => {
     *  console.log('about to add the following items', items);
     *  return items;
     * });
     */fn.intercept=(name,ic)=>{const s=toCamelCase(name);if(!interceptors[s]){return;}interceptors[s].push(ic);};/**
     * Removes an interceptor
     *
     * @param {string} name Name of the event to intercept
     * @param {function} ic Handler to remove
     */fn.removeInterceptor=(name,ic)=>{const s=toCamelCase(name);if(!interceptors[s]){return;}const idx=interceptors[s].indexOf(ic);if(idx!==-1){interceptors[s].splice(idx,1);}};/**
     * Removes all interceptors
     *
     * @param {string} [name] Name of the event to remove interceptors for. If not provided, removes all interceptors.
     */fn.removeAllInterceptors=name=>{const toRemove=[];if(name){const s=toCamelCase(name);if(interceptors[s]&&interceptors[s].length){toRemove.push({name,handlers:interceptors[s]});}}else {Object.keys(interceptors).forEach(n=>{if(interceptors[n].length){toRemove.push({name:toSnakeCase(n),handlers:interceptors[n]});}});}toRemove.forEach(ic=>{const interceptorHandlers=ic.handlers.slice();interceptorHandlers.forEach(handler=>fn.removeInterceptor(ic.name,handler));});};/**
     * Adds an alias to the given key
     *
     * @param {string} key - Value to be replaced
     * @param {string} alias - Value to replace key with
     * @example
     * brush.addKeyAlias('BadFieldName', 'Region');
     * brush.addValue('BadFieldName', 'Sweden'); // 'BadFieldName' will be stored as 'Region'
     * brush.containsValue('Region', 'Sweden'); // true
     * brush.containsValue('BadFieldName', 'Sweden'); // true
     */fn.addKeyAlias=(key,alias)=>{aliases[key]=alias;};/**
     * Removes an alias
     *
     * This will only remove the key to alias mapping for new manipulations of the brush,
     * no changes will be made to the current state of this brush.
     *
     * @param {string} key - Value to remove as alias
     * @example
     * brush.removeKeyAlias('BadFieldName');
     */fn.removeKeyAlias=key=>{delete aliases[key];};EventEmitter$2.mixin(fn);return fn;}registryFactory();function cubicIn(t){return t*t*t;}function cubicOut(t){return --t*t*t+1;}function cubicInOut(t){return ((t*=2)<=1?t*t*t:(t-=2)*t*t+2)/2;}/* eslint-disable no-cond-assign */const colorKeys=['stroke','fill','color','backgroundColor','thumbColor'];function constant(x){return ()=>x;}function isNumberArray(x){return ArrayBuffer.isView(x)&&!(x instanceof DataView);}function genericArray(a,b){const nb=b?b.length:0;const na=a?Math.min(nb,a.length):0;const x=new Array(na);const c=new Array(nb);let i;for(i=0;i<na;++i){x[i]=value(a[i],b[i]);}for(;i<nb;++i){c[i]=b[i];}return function interplolate(t){for(i=0;i<na;++i){c[i]=x[i](t);}return c;};}function value(a,b,k){const t=typeof b;let c;return b==null||t==='boolean'?constant(b):(t==='number'?number$1:t==='string'?(c=color(b))&&colorKeys.includes(k)?(b=c,rgb):string:b instanceof color?rgb:b instanceof Date?date:isNumberArray(b)?numberArray:Array.isArray(b)?genericArray:typeof b.valueOf!=='function'&&typeof b.toString!=='function'||isNaN(b)?object:number$1)(a,b);}function object(a,b){const i={};const c={};let k;if(a===null||typeof a!=='object'){a={};}if(b===null||typeof b!=='object'){b={};}for(k in b){if(k in a){i[k]=value(a[k],b[k],k);}else {c[k]=b[k];}}return function interplolate(t){// eslint-disable-next-line guard-for-in
  for(k in i){c[k]=i[k](t);}return c;};}/* globals window */function nodeId(node,i){if(node.data){return node.data.value;}if(node.type==='text'){return node.text;}return i;}function findCommonPointsFromTwoLines(oldLine,currentLine){const oldPoints=oldLine.points.filter(point=>!point.dummy);const currentPoints=currentLine.points.filter(point=>!point.dummy);const currentPointsValues=currentPoints.map(point=>point.data.major.value);const commonPointsValues=oldPoints.filter(point=>currentPointsValues.includes(point.data.major.value)).map(point=>point.data.major.value);const oldCommonPoints=oldPoints.filter(point=>commonPointsValues.includes(point.data.major.value));const currentCommonPoints=currentPoints.filter(point=>commonPointsValues.includes(point.data.major.value));return {old:oldCommonPoints,current:currentCommonPoints};}function tween(_ref,_ref2,config,chartStorage){let{old,current}=_ref;let{renderer}=_ref2;let ticker;// let staticNodes = [];
  let toBeUpdated=[];let entered={nodes:[],ips:[]};let exited={nodes:[],ips:[]};let updated={nodes:[],ips:[]};let stages=[];let targetScene=null;const trackBy=config.trackBy||nodeId;const tweener={start(){let ids={};old.forEach((node,i)=>{let id=trackBy(node,i);ids[id]=node;});current.forEach((node,i)=>{let id=trackBy(node,i);if(ids[id]){if(node.type==='path'&&node.points&&node.points.length>0&&node.data.source.key!=='trend'){const common=findCommonPointsFromTwoLines(ids[id],node);updated.ips.push(object(extend$1({},ids[id],{points:common.old}),extend$1({},node,{points:common.current})));toBeUpdated.push(extend$1({},ids[id],{commonPoints:common.old}));}else {updated.ips.push(object(ids[id],node));toBeUpdated.push(ids[id]);}updated.nodes.push(node);ids[id]=false;}else {entered.nodes.push(node);entered.ips.push(object(extend$1({},node,{r:0.001,opacity:0}),node));}});Object.keys(ids).forEach(key=>{if(ids[key]){exited.nodes.push(ids[key]);exited.ips.push(object(ids[key],extend$1({},ids[key],{r:0.0001,opacity:0})));}});// Obsolete nodes exiting
  stages.push({name:'exiting',easing:cubicIn,duration:200,tweens:exited.ips,nodes:[...toBeUpdated]});// Existing nodes updating
  stages.push({name:'updating',easing:cubicInOut,duration:400,tweens:updated.ips,nodes:[]});// New nodes entering
  stages.push({name:'entering',easing:cubicOut,duration:200,tweens:entered.ips,nodes:[...updated.nodes]});if(config.isMainComponent){var _config$isMainCompone;const filterFn=(_config$isMainCompone=config.isMainComponent)===null||_config$isMainCompone===void 0?void 0:_config$isMainCompone.filterFn;const nUpdatingNodes=filterFn?toBeUpdated.filter(filterFn).length:toBeUpdated.length;const{isInit,shouldBeRemoved}=chartStorage.getValue('animations.updatingStageMeta');if(isInit===false){chartStorage.setValue('animations.updatingStageMeta.shouldBeRemoved',nUpdatingNodes===0);chartStorage.setValue('animations.updatingStageMeta.isInit',true);}else {chartStorage.setValue('animations.updatingStageMeta.shouldBeRemoved',shouldBeRemoved&&nUpdatingNodes===0);}}// console.log(stages);
  if(stages.length){targetScene=renderer.getScene(current);stages[0].started=Date.now();if(typeof window!=='undefined'){ticker=window.requestAnimationFrame(tweener.tick);}}},tick(){let currentStage=stages[0];if(!currentStage){tweener.stop();}if(!currentStage.started){currentStage.started=Date.now();}let t=(Date.now()-currentStage.started)/currentStage.duration;let currentNodes=[];let tweenedNodes=currentStage.tweens.map(ip=>ip(currentStage.easing(Math.min(1,t))));currentNodes.push(...tweenedNodes);currentNodes.push(...currentStage.nodes);// currentNodes.push(...staticNodes);
  // stages.slice(1).forEach(stage => currentNodes.push(...stage.nodes));
  renderer.render(currentNodes);if(t>=1){// staticNodes.push(...currentStage.nodes);
  stages.shift();const{isInit,shouldBeRemoved}=chartStorage.getValue('animations.updatingStageMeta');if(!stages.length){if(isInit===true){chartStorage.setValue('animations.updatingStageMeta.isInit',false);}tweener.stop();}else if(stages[0].name==='updating'&&shouldBeRemoved){stages.shift();}}if(ticker){ticker=window.requestAnimationFrame(tweener.tick);}},stop(){if(ticker){window.cancelAnimationFrame(ticker);ticker=false;}},inProgress(){return !!ticker;},get targetScene(){return targetScene;}};return tweener;}const GLOBAL_DEFAULTS={fontFamily:'Arial',fontSize:'13px',color:'#595959',backgroundColor:'#ffffff',stroke:'#000000',strokeWidth:0,$fill:'#333333'};const REF_RX=/^\$/;function isPrimitive(x){const type=typeof x;return type!=='object'&&type!=='function'&&type!=='undefined';}/**
   * Callback function
   * @callback datumAccessor
   * @param {DatumExtract} d datum
   * @example
   * (d) => Math.min(0, d.value);
   */ /**
   * @typedef {object} DatumConfig
   * @property {string} [scale] - Name of a scale
   * @property {datumAccessor} [fn]
   * @property {string} [ref] - A reference to a DatumExtract property
   * @example
   * // Implicitly resolve the datum by passing a referenced data through the scale
   * {
   *  scale: '<name-of-scale>',
   *  ref: '<data-property>'
   * }
   *
   * // or explicitly resolve the datum using callback function
   * {
   *  fn: (d) => Math.min(0, d.datum.x.value);
   * }
   */ /**
   * Custom type that is either a string, DatumConfig or a datumAccessor
   * @typedef {string|DatumConfig|datumAccessor} DatumString
   */ /**
   * Custom type that is either a number, DatumConfig or a datumAccessor
   * @typedef {number|DatumConfig|datumAccessor} DatumNumber
   */ /**
   * Custom type that is either a boolean, DatumConfig or a datumAccessor
   * @typedef {boolean|DatumConfig|datumAccessor} DatumBoolean
   */ /**
   * Normalizes property settings
   *
   * @ignore
   * @export
   * @param {any} settings
   * @param {any} defaults
   * @param {any} chart
   * @returns {any}
   */function normalizeSettings(settings,defaults,chart){const composition=extend$1({},settings);const defs=extend$1({},defaults);Object.keys(composition).forEach(key=>{defs[key]={};const v=composition[key];const vType=typeof v;if(typeof v==='function'){defs[key].fn=v;}else if(isPrimitive(v)){let defaultValue=defaults[key];if(typeof defaultValue==='string'&&REF_RX.test(defaultValue)){defaultValue=GLOBAL_DEFAULTS[defaultValue];}const defaultType=typeof defaultValue;if(defaultType==='undefined'){// if property has no default, assign provided value
  defs[key]=v;}else {// assign provided value if it's of same type as default, otherwise use default
  defs[key]=defaultType===vType?v:defaultValue;}}else if(v&&typeof v==='object'){if(typeof v.fn==='function'){defs[key].fn=v.fn;}if(typeof v.scale!=='undefined'){defs[key].scale=chart.scale(v.scale);}if(typeof v.ref==='string'){defs[key].ref=v.ref;}}});Object.keys(defaults).forEach(key=>{if(key in composition){// don't process same props again
  return;}const v=defaults[key];const defaultType=typeof v;if(defaultType==='string'&&REF_RX.test(v)){defs[key]=GLOBAL_DEFAULTS[v];}else {defs[key]=v;}});return defs;}function resolveForItem(context,normalized,idx){const ret={};const keys=Object.keys(normalized);const len=keys.length;const fallbackData=context.datum;const datum=context.datum;for(let i=0;i<len;i++){const key=keys[i];const normalizedProp=normalized[key];const exists=typeof datum==='object'&&typeof normalizedProp!=='undefined';const hasExplicitDataProp=exists&&typeof normalizedProp.ref==='string';const hasImplicitDataProp=exists&&key in datum;const propData=hasExplicitDataProp?datum[normalizedProp.ref]:hasImplicitDataProp?datum[key]:fallbackData;// eslint-disable-line
  if(isPrimitive(normalizedProp)){ret[key]=normalizedProp;}else if(exists&&normalizedProp.fn){// callback function
  if(normalizedProp.scale){context.scale=normalizedProp.scale;}ret[key]=normalizedProp.fn.call(null,context,idx);}else if(exists&&normalizedProp.scale&&propData){ret[key]=normalizedProp.scale(propData.value);if(normalizedProp.scale.bandwidth){ret[key]+=normalizedProp.scale.bandwidth()/2;}}else if(hasExplicitDataProp&&propData){ret[key]=propData.value;}else if(normalizedProp.fn){ret[key]=normalizedProp.fn.call(null,context,idx);}else {ret[key]=normalizedProp;}}return ret;}function updateScaleSize(object,path,size){const o=object[path];if(o&&o.scale&&o.scale.pxScale){o.scale=o.scale.pxScale(size);}else if(o&&o.pxScale){object[path]=o.pxScale(size);}}function scaleWithSize(scale,size){return scale.pxScale?scale.pxScale(size):scale;}const externals={normalizeSettings,resolveForItem,updateScaleSize};function settingsResolver(resources){let deps=arguments.length>1&&arguments[1]!==undefined?arguments[1]:externals;let cache={};function resolve(_ref){let{data,settings,defaults={},scaled}=_ref;const norm=cache.norm=deps.normalizeSettings(settings,defaults,resources.chart);const res={scale:resources.chart.scale,formatter:resources.chart.formatter};if(scaled){Object.keys(scaled).forEach(key=>{if(norm[key]){deps.updateScaleSize(norm,key,scaled[key]);}});}const resolved=[];if(data&&Array.isArray(data.items)){let context;for(let i=0,len=data.items.length;i<len;i++){context={datum:data.items[i],data,resources:res};let obj=deps.resolveForItem(context,cache.norm,i);obj.data=data.items[i];resolved.push(obj);}}else {const context={data,resources:res};let obj=deps.resolveForItem(context,cache.norm,-1);return {settings:cache.norm,item:obj};}return {settings:cache.norm,items:resolved};}return {resolve};}/**
   * Flatten the array of nodes by removing any containers as they do not support styling, thus unable to brush them.
   * @param {array} nodes
   * @ignore
   */function reduceToLeafNodes(){let nodes=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];return nodes.reduce((ary,node)=>{if(Array.isArray(node.children)){ary.push(...reduceToLeafNodes(node.children));return ary;}ary.push(node);return ary;},[]);}function styler(obj,_ref){let{context,data,style,filter,mode}=_ref;const brusher=obj.chart.brush(context);const dataProps=data;const active=style.active||{};const inactive=style.inactive||{};const styleProps=[];Object.keys(active).forEach(key=>{styleProps.push(key);});Object.keys(inactive).forEach(key=>{if(styleProps.indexOf(key)===-1){styleProps.push(key);}});const activeNodes=[];let globalActivation=false;// track when we need to loop through all nodes, not just the active ones
  const getNodes=()=>{let nodes=reduceToLeafNodes(obj.nodes);if(typeof filter==='function'){nodes=nodes.filter(filter);}return nodes;};const update=()=>{// TODO - render nodes only once, i.e. don't render for each brush, update nodes for all brushes and then render
  const nodes=getNodes();const len=nodes.length;let nodeData;let globalChanged=false;const evaluatedDataProps=typeof dataProps==='function'?dataProps({brush:brusher}):dataProps;// To calculate active nodes
  for(let i=0;i<len;i++){// TODO - update only added and removed nodes
  nodeData=nodes[i].data;if(!nodeData){continue;}if(!nodes[i].__style){nodes[i].__style={};styleProps.forEach(s=>{nodes[i].__style[s]=nodes[i][s];// store original value
  });}const isActive=brusher.containsMappedData(nodeData,evaluatedDataProps,mode);const activeIdx=activeNodes.indexOf(nodes[i]);let changed=false;if(isActive&&activeIdx===-1){// activated
  activeNodes.push(nodes[i]);changed=true;}else if(!isActive&&activeIdx!==-1){// was active
  activeNodes.splice(activeIdx,1);changed=true;}nodes[i].needToUpdate=changed||globalActivation;nodes[i].isActive=isActive;}// To calculate style
  for(let i=0;i<len;i++){// TODO - update only added and removed nodes
  nodeData=nodes[i].data;if(!nodeData){continue;}if(nodes[i].needToUpdate){const original=extend$1({},nodes[i],nodes[i].__style);const isActive=nodes[i].isActive;styleProps.forEach(s=>{if(isActive&&s in active){nodes[i][s]=typeof active[s]==='function'?active[s].call(null,original,activeNodes):active[s];}else if(!isActive&&s in inactive){nodes[i][s]=typeof inactive[s]==='function'?inactive[s].call(null,original,activeNodes):inactive[s];}else {nodes[i][s]=nodes[i].__style[s];}});globalChanged=true;}delete nodes[i].needToUpdate;}globalActivation=false;return globalChanged;};const onStart=function(){let opts=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{suppressRender:false};const{suppressRender}=opts;const nodes=getNodes();const len=nodes.length;for(let i=0;i<len;i++){if(!nodes[i].data){continue;}nodes[i].__style=nodes[i].__style||{};styleProps.forEach(s=>{nodes[i].__style[s]=nodes[i][s];// store original value
  if(s in inactive){nodes[i][s]=typeof inactive[s]==='function'?inactive[s].call(null,nodes[i]):inactive[s];}});}globalActivation=true;activeNodes.length=0;if(!suppressRender){obj.renderer.render(obj.nodes);}};const onEnd=function(){let opts=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{suppressRender:false};const{suppressRender}=opts;const nodes=getNodes();const len=nodes.length;for(let i=0;i<len;i++){if(nodes[i].__style){Object.keys(nodes[i].__style).forEach(s=>{nodes[i][s]=nodes[i].__style[s];});nodes[i].__style=undefined;}}activeNodes.length=0;if(!suppressRender){obj.renderer.render(obj.nodes);}};const onUpdate=()=>{const changed=update();if(changed){const renderedNodes=typeof obj.config.sortNodes==='function'?obj.config.sortNodes(obj):obj.nodes;if(typeof obj.config.customRender==='function'){obj.config.customRender({render:obj.renderer.render,nodes:renderedNodes});}else {obj.renderer.render(renderedNodes);}}};const externalUpdate=()=>{activeNodes.length=0;globalActivation=true;update();};brusher.on('start',onStart);brusher.on('end',onEnd);brusher.on('update',onUpdate);function cleanUp(){brusher.removeListener('start',onStart);brusher.removeListener('end',onEnd);brusher.removeListener('update',onUpdate);}return {isActive(){return brusher.isActive();},update:externalUpdate,cleanUp};}function brushDataPoints(_ref2){let{dataPoints,action,chart,trigger}=_ref2;if(!trigger){return;}const dataProps=trigger.data||[''];let rangeBrush={items:[],actionFn:'toggleRanges'};let valueBrush={items:[],actionFn:'toggleValues'};if(['add','remove','set','toggle'].indexOf(action)!==-1){rangeBrush.actionFn="".concat(action,"Ranges");valueBrush.actionFn="".concat(action,"Values");}for(let i=0;i<dataPoints.length;i++){const dataPoint=dataPoints[i];if(!dataPoint){continue;}dataProps.forEach(p=>{let d=dataPoint&&!p?dataPoint:dataPoint[p];if(d){let it={key:d.source.field};if(typeof d.source.key!=='undefined'){it.key="".concat(d.source.key,"/").concat(d.source.field);}if(Array.isArray(d.value)){it.range={min:d.value[0],max:d.value[1]};rangeBrush.items.push(it);}else {it.value=d.value;valueBrush.items.push(it);}}});}trigger.contexts.forEach(c=>{if(rangeBrush.items.length){chart.brush(c)[rangeBrush.actionFn](rangeBrush.items);}else {chart.brush(c)[valueBrush.actionFn](valueBrush.items);// call action even if there are items to potentially clear what is currently in the brush
  }});}function brushFromSceneNodes(_ref3){let{nodes,action,chart,trigger}=_ref3;const dataPoints=[];for(let i=0;i<nodes.length;i++){const node=nodes[i];let nodeData=node.data;if(nodeData!==null){dataPoints.push(nodeData);}}brushDataPoints({dataPoints,action,chart,trigger});}function resolveEvent(_ref4){let{collisions,t,config,action}=_ref4;let brushCollisions=[];let resolved=false;if(collisions.length>0){brushCollisions=collisions;resolved=true;if(t.propagation==='stop'){brushCollisions=[collisions[collisions.length-1]];}}const nodes=brushCollisions.map(c=>c.node);brushFromSceneNodes({nodes,action,chart:config.chart,data:config.data,trigger:t});return resolved;}function touchSingleContactPoint(e,rect){if(e.changedTouches.length!==1){return null;}return {x:e.changedTouches[0].clientX-rect.left,y:e.changedTouches[0].clientY-rect.top};}function singleContactPoint(e,rect){return {x:e.clientX-rect.left,y:e.clientY-rect.top};}function resolveCollisions(e,t,renderer){const rect=renderer.element().getBoundingClientRect();let p=isTouchEvent(e)?touchSingleContactPoint(e,rect):singleContactPoint(e,rect);if(p===null||p.x<0||p.y<0||p.x>rect.width||p.y>rect.height){// TODO include radius in this check?
  return [];}if(t.touchRadius>0&&isTouchEvent(e)){p={cx:p.x,cy:p.y,r:t.touchRadius// TODO Use touch event radius/width value (Need to handle dpi scaling as well)
  };}else if(t.mouseRadius>0&&!isTouchEvent(e)){p={cx:p.x,cy:p.y,r:t.mouseRadius};}return renderer.itemsAt(p);}function resolveAction(action,e,def){if(action){if(typeof action==='function'){return action(e);}return action;}return def;}function resolveTapEvent(_ref5){let{e,t,config}=_ref5;const collisions=resolveCollisions(e,t,config.renderer);return resolveEvent({collisions,t,config,action:resolveAction(t.action,e,'toggle')});}function resolveOverEvent(_ref6){let{e,t,config}=_ref6;const collisions=resolveCollisions(e,t,config.renderer);return resolveEvent({collisions,t,config,action:resolveAction(t.action,e,'set')});}/**
   * A list of supported attributes in lower camelCase notation mapped to corresponding kebab-case notation.
   * The kebab-case notations are a sub-set of SVG attributes (https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute).
   * @ignore
   * @private
   */const mappedAttributes={fill:'fill',stroke:'stroke',opacity:'opacity',strokeWidth:'stroke-width',strokeLinejoin:'stroke-linejoin',fontFamily:'font-family',fontSize:'font-size',fontWeight:'font-weight',baseline:'dominant-baseline',// Special case where we have defined our own attribute name
  dominantBaseline:'dominant-baseline',anchor:'text-anchor',// Special case where we have defined our own attribute name
  textAnchor:'text-anchor',maxWidth:'maxWidth',transform:'transform',strokeDasharray:'stroke-dasharray',id:'id'};/**
   * Takes a target object and assign each supported attribute from a source object to that target.
   * Each supported attributes is converted to a mapped kebab-case notation.
   * @ignore
   * @private
   * @param {object} target - Target object on which to assign mapped attribute values
   * @param {object} source - Source object
   */function assignMappedAttribute(target,source){Object.keys(mappedAttributes).forEach(key=>{const sourceValue=source[key];if(typeof sourceValue!=='undefined'){const mappedKey=mappedAttributes[key];target[mappedKey]=sourceValue;}});}/**
   * @private
   * @extends Symbol
   * @typedef {object} SymbolCircle
   */function circle(options){return {type:'circle',fill:'black',cx:options.x,cy:options.y,r:options.size/2};}function pointsToPath(points){let close=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;let d='';for(let i=0;i<points.length;i++){const p=points[i];if(i===0){d+="M".concat(p.x," ").concat(p.y);}else {d+="L".concat(p.x," ").concat(p.y);}d+=' ';}if(close){d+='Z';}return d;}/**
   * @private
   * @extends Symbol
   * @typedef {object} SymbolDiamond
   */function diamond(options){const size=options.size;const left=options.x-size/2;const top=options.y-size/2;const points=[{x:left,y:top+size/2},{x:left+size/2,y:top},{x:left+size,y:top+size/2},{x:left+size/2,y:top+size},{x:left,y:top+size/2}];return {type:'path',fill:'black',d:pointsToPath(points)};}function generateCrossPoints(x,y,size,barWidth){const r=size/2;const innerLeft=x-barWidth/2;const innerTop=y-barWidth/2;const left=x-r;const top=y-r;return [{x:innerLeft,y:innerTop},// Top
  {x:innerLeft,y:top},{x:innerLeft+barWidth,y:top},{x:innerLeft+barWidth,y:innerTop},// Right
  {x:left+size,y:innerTop},{x:left+size,y:innerTop+barWidth},{x:innerLeft+barWidth,y:innerTop+barWidth},// Bottom
  {x:innerLeft+barWidth,y:top+size},{x:innerLeft,y:top+size},{x:innerLeft,y:innerTop+barWidth},// Left
  {x:left,y:innerTop+barWidth},{x:left,y:innerTop}];}/**
   * @private
   * @extends Symbol
   * @typedef {object} SymbolCross
   * @property {number} [width] - Width of the diagonals
   */function cross(options){const x=options.x;const y=options.y;const r=options.size/2;const width=isNaN(options.width)?r/2:options.width;const barWidth=Math.min(width,r);const points=generateCrossPoints(x,y,options.size,barWidth);return {type:'path',fill:'black',d:pointsToPath(points)};}/**
   * Get x1, y1, x2, y2 point from angle
   * Source: {@link https://codepen.io/NV/pen/jcnmK}
   * @private
   *
   * @param  {number} angle Radians
   * @return {object}       Point with x1, y2, x2, y2.
   */function angleToPoints(angle){let segment=Math.floor(angle/Math.PI*2)+2;let diagonal=(0.5*segment+0.25)*Math.PI;let op=Math.cos(Math.abs(diagonal-angle))*Math.sqrt(2);let x=op*Math.cos(angle);let y=op*Math.sin(angle);return {x1:x<0?1:0,y1:y<0?1:0,x2:x>=0?x:x+1,y2:y>=0?y:y+1};}/**
   * Turns degrees into radians
   * @private
   *
   * @param  {number} degrees Degrees
   * @return {number}         Radians
   */function toRadians(d){return -d/180*Math.PI;}/**
   * Get x1, y1, x2, y2 point from degree
   * @private
   *
   * @param  {number} d Degree
   * @return {object}   Point with x1, y2, x2, y2.
   */function degreesToPoints(d){return angleToPoints(toRadians(d));}function add(v1,v2){return {x:v1.x+v2.x,y:v1.y+v2.y};}function sub(v1,v2){return {x:v1.x-v2.x,y:v1.y-v2.y};}function scalarMultiply(v,s){return {x:v.x*s,y:v.y*s};}function distanceX(v1,v2){return v1.x-v2.x;}function distanceY(v1,v2){return v1.y-v2.y;}function sqrDistance(v1,v2){return distanceX(v1,v2)**2+distanceY(v1,v2)**2;}function distance(v1,v2){return Math.sqrt(sqrDistance(v1,v2));}function dot(v1,v2){return v1.x*v2.x+v1.y*v2.y;}function projectOnto(v1,v2){const m=dot(v1,v2)/dot(v2,v2)||1;return {x:v2.x*m,y:v2.y*m};}function rotate(v,radians){let origin=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{x:0,y:0};const cos=Math.cos(radians);const sin=Math.sin(radians);const t1=sub(v,origin);const t2={x:cos*t1.x-sin*t1.y,y:sin*t1.x+cos*t1.y};return add(t2,origin);}/**
   * @private
   * @extends Symbol
   * @typedef {object} SymbolSaltire
   * @property {number} [width] - Width of the diagonals
   */function saltire(options){const radians=toRadians(45);const r=options.size/2;const width=isNaN(options.width)?r/2:options.width;const barWidth=Math.min(width,r);let adjustedSize=options.size;// Adjust for the barwidth and rotation angle, so that the visual part is always inside the symbol area
  const h=Math.sin(Math.asin(-radians))*(barWidth/2);const c=r/Math.sin(-radians);adjustedSize+=(c-r)*2;adjustedSize-=h*2;const centroid={x:options.x,y:options.y};const points=generateCrossPoints(options.x,options.y,adjustedSize,barWidth).map(p=>rotate(p,radians,centroid));return {type:'path',fill:'black',d:pointsToPath(points)};}/**
   * @private
   * @extends Symbol
   * @typedef {object} SymbolSquare
   */function square(options){const size=options.size;return {type:'rect',fill:'black',x:options.x-size/2,y:options.y-size/2,width:size,height:size};}const DIRECTION_TO_ANGLE={up:0,down:180,left:90,right:-90};/**
   * @private
   * @extends Symbol
   * @typedef {object} SymbolTriangle
   * @property {string} [direction='up'] - Direction of the triangle ('up'|'down'|'left'|'right')
   */function triangle(options){const size=options.size;const p={x:options.x,y:options.y};const directionAngle=DIRECTION_TO_ANGLE[options.direction]||0;const halfSize=size/2;const left=options.x-halfSize;const top=options.y-halfSize;let points=[{x:left,y:top+size},{x:left+halfSize,y:top},{x:left+size,y:top+size},{x:left,y:top+size}];const radians=toRadians(directionAngle);points=points.map(pp=>rotate(pp,radians,p));return {type:'path',fill:'black',d:pointsToPath(points)};}function createRectCollider(_ref){let{x,y,size}=_ref;const r=size/2;return {type:'rect',x:x-r,y:y-r,width:size,height:size};}/**
   * @private
   * @extends Symbol
   * @typedef {object} SymbolLine
   * @property {string} [direction='horizontal'] - Direction of line ('horizontal'|'vertical').
   */function line$1(options){const isVertical=options.direction==='vertical';const r=options.size/2;const x=options.x;const y=options.y;return {type:'line',stroke:'black',strokeWidth:1,x1:x-(isVertical?0:r),y1:y-(isVertical?r:0),x2:x+(isVertical?0:r),y2:y+(isVertical?r:0),collider:createRectCollider(options)// TODO Use visual collider?
  };}/**
   * @private
   * @extends Symbol
   * @typedef {object} SymbolStar
   * @property {number} [points=5] - Number of points on the star
   * @property {number} [startAngle=90] - Start drawing angle
   * @property {number} [innerRadius=size/2] - Size of the star core. My not exceed size of symbol.
   */function star(options){const size=options.size;const points=[];const outerRadius=size/2;const drawPoints=options.points||5;const innerRadius=Math.min(options.innerRadius||size/2,size)/2;const startAngle=isNaN(options.startAngle)?90:options.startAngle;const angle=360/drawPoints;for(let i=1;i<=drawPoints;i++){const pAngle=angle*i+startAngle;const radians=toRadians(pAngle);const innerRadians=toRadians(pAngle+angle/2);const y=Math.sin(radians);const x=Math.cos(radians);const iy=Math.sin(innerRadians);const ix=Math.cos(innerRadians);points.push({x:options.x+x*outerRadius,y:options.y+y*outerRadius});points.push({x:options.x+ix*innerRadius,y:options.y+iy*innerRadius});}return {type:'path',fill:'black',d:pointsToPath(points)};}/**
   * @private
   * @extends Symbol
   * @typedef {object} SymbolPolygon
   * @property {object} [sides=6] - Number of sides on the regular polygon
   * @property {object} [startAngle=0] - Start drawing angle
   */function nPolygon(options){const points=[];const radius=options.size/2;const drawPoints=Math.max(isNaN(options.sides)?6:options.sides,3);const angle=360/drawPoints;const startAngle=isNaN(options.startAngle)?0:options.startAngle;for(let i=1;i<=drawPoints;i++){const radians=toRadians(angle*i+startAngle);const y=Math.sin(radians);const x=Math.cos(radians);points.push({x:options.x+x*radius,y:options.y+y*radius});}return {type:'path',fill:'black',d:pointsToPath(points)};}/**
   * @private
   * @extends Symbol
   * @typedef {object} SymbolBar
   * @property {string} [direction='horizontal'] - Direction of bar ('horizontal'|'vertical').
   */function bar(options){const p={x:options.x,y:options.y};const isVertical=options.direction==='vertical';const r=options.size/2;const width=r/2;const halfWidth=width/2;let points=[{x:p.x-r,y:p.y+halfWidth},{x:p.x-r,y:p.y-halfWidth},{x:p.x+r,y:p.y-halfWidth},{x:p.x+r,y:p.y+halfWidth}];if(isVertical){const radians=toRadians(90);points=points.map(pp=>rotate(pp,radians,p));}const rect=pointsToRect(points);rect.type='rect';rect.fill='black';return rect;}/**
   * @private
   * @extends Symbol
   * @typedef {object} SymbolRect
   */function rect(options){const{x,y,size}=options;const width=typeof options.width==='undefined'?size:options.width;const height=typeof options.height==='undefined'?size:options.height;return {type:'rect',fill:'black',x:x-width/2,y:y-height/2,width,height};}const parentReg=registryFactory();parentReg.add('circle',circle);parentReg.add('diamond',diamond);parentReg.add('saltire',saltire);parentReg.add('square',square);parentReg.add('triangle',triangle);parentReg.add('line',line$1);parentReg.add('star',star);parentReg.add('n-polygon',nPolygon);parentReg.add('cross',cross);parentReg.add('bar',bar);parentReg.add('rect',rect);function applyOpts(obj){let opts=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};Object.keys(opts).forEach(key=>{if(typeof mappedAttributes[key]!=='undefined'&&key!=='transform'){obj[key]=opts[key];}});}/**
   * Factory function for symbols.
   * Options object is passed to symbols function.
   * @private
   * @param {SymbolRect|SymbolBar|SymbolCircle|SymbolCross|SymbolDiamond|SymbolLine|SymbolPolygon|SymbolSaltire|SymbolSquare|SymbolStar|SymbolTriangle} options - Options definition may contain any of the supported display-object attributes
   * @returns {object} A node definition
   */const create$m=function(){let reg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:parentReg;return function(){let options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};// TODO handle reserverd properties x, y, size, data, etc..
  const fn=reg.get(options.type);if(fn){const s=fn(options);applyOpts(s,options);if(typeof options.data!=='undefined'){s.data=options.data;}return s;}return fn;};};/**
   * Mandatory symbol config
   * @private
   * @typedef {object} Symbol
   * @property {object} options - Options definition may contain any of the supported display-object attributes
   * @property {string} options.type - Type of symbol
   * @property {number} options.x - x-coordinate
   * @property {number} options.y - y-coordinate
   * @property {number} options.size
   * @property {object} [options.data]
   */ /**
   * Initilize a new dock configuration
   * @private
   * @param {object} [settings] - Settings object
   * @returns {object} A dock configuration instance
   * @example
   * let instance = create({
   *  dock: 'left',
   *  displayOrder: 2,
   *  prioOrder: 1,
   *  preferredSize: 33,
   *  minimumLayoutMode: 'L',
   *  show: true
   * });
   */function create$l(){let settings=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let callbackContext=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let{dock='center',displayOrder=0,prioOrder=0,preferredSize=0,minimumLayoutMode,show=true}=settings;// avoid empty string dock
  dock=dock||'center';/**
     * @private
     * @alias dockConfig
     * @interface
     */const dockConfig={/**
       * Returns the preferred size of a component.
       * The return value of the function can either be a number representing the required size in the dock direction
       * or an object with a `size` and `edgeBleed` property.
       * @param {object} [inner]
       * @param {object} [outer]
       * @returns {number|object} Returns the computed preferred size
       * @example
       * dockConfig.computePreferredSize(() => 150); // Require a size of 150 in the dock direction
       *
       * dockConfig.computePreferredSize(() => ({
       *  size: 150,
       *  edgeBleed: {
       *    left: 50,
       *    right: 50
       *  }
       * })); // Require a size of 150 in the dock direction and a bleed size of 50 to the left and right dock direction
       */computePreferredSize(_ref){let{inner,outer,children}=_ref;if(typeof preferredSize==='function'){return preferredSize({inner,outer,children,dock:this.dock()},callbackContext);}return preferredSize;},/**
       * Set the dock direction, supported values are left | right | top | bottom. Any other value will be interpreted as center dock.
       * @param {string} [val=''] - Dock direction
       * @returns {this} The current context
       * @example
       * dockConfig.dock('left');
       */dock(val){if(typeof val!=='undefined'){dock=val;return this;}return typeof dock==='function'?dock(callbackContext):dock;},/**
       * The `displayOrder` property is used by the layout engine to lay out components.
       * Components are interpreted in the ascending order of the `displayOrder` value. The layout engine apply the value in two ways,
       * the first is the order in which components are rendererd. The second is the area components are laid out in
       * when they have a direction, i.e. docked to either top, bottom, left or right.
       *
       * If docked at the same area, the component with a higher `displayOrder` will be rendered
       * on top of the component with a lower `displayOrder`. It can be seen as defining a z-index.
       * A lower `displayOrder` also means that a component will be laid out first in a given direction,
       * i.e. laid out closer to the central area (non-directional area) then a component with a higher `displayOrder`.
       * It can in this case be seen as the x-index or y-index.
       * @param {number} [val=0] - The display order
       * @returns {this|number} The current context or display order
       * @example
       * dockConfig.displayOrder(99);
       */displayOrder(val){if(typeof val!=='undefined'){displayOrder=val;return this;}return typeof displayOrder==='function'?displayOrder(callbackContext):displayOrder;},/**
       * The `prioOrder` property is used to define the order in which components are added to the layout engine,
       * this is done before any components are laid out. When there is not enough space to add any more components
       * to a given area, all components not all ready added, are then discarded. The `prioOrder` is interpreted
       * in the ascending order. Such that a lower value is added to the layout engine first.
       * @param {number} [val=0] - The prio order
       * @returns {this|number} The current context or prio order
       * @example
       * dockConfig.prioOrder(-1);
       */prioOrder(val){if(typeof val!=='undefined'){prioOrder=val;return this;}return typeof prioOrder==='function'?prioOrder(callbackContext):prioOrder;},/**
       * Ger or set the minimumLayoutMode
       * @param {string|object} [val] - The minimum layout mode
       * @returns {string|object|this} If no parameter is passed the current context is returned, else the current layout mode.
       * @example
       * dockConfig.minimumLayoutMode('L');
       * dockConfig.minimumLayoutMode({ width: 'S', height: 'L' });
       */minimumLayoutMode(val){if(typeof val!=='undefined'){minimumLayoutMode=val;return this;}return typeof minimumLayoutMode==='function'?minimumLayoutMode(callbackContext):minimumLayoutMode;},/**
       * Set the component visibility. If false the component is not added to the layout engine.
       * @param {boolean} [val=true] - Toggle visibility
       * @returns {this|boolean} The current context or show
       */show(val){if(typeof val!=='undefined'){show=val;return this;}return typeof show==='function'?show(callbackContext):show;}};return dockConfig;}const isReservedProperty=prop=>['on','preferredSize','created','beforeMount','mounted','resize','beforeUpdate','updated','beforeRender','render','beforeUnmount','beforeDestroy','destroyed','defaultSettings','data','settings','formatter','scale','chart','dockConfig','mediator','style','resolver','registries','_DO_NOT_USE_getInfo','symbol','isVisible'].some(name=>name===prop);function prepareContext(ctx,definition,opts){const{require=[]}=definition;const mediatorSettings=definition.mediator||{};const{settings,formatter,scale,data,renderer,chart,dockConfig,mediator,instance,rect,style,registries,resolver,update,_DO_NOT_USE_getInfo,symbol,isVisible}=opts;ctx.emit=()=>{};if(isVisible){ctx.isVisible=isVisible;}// TODO add setters and log warnings / errors to console
  Object.defineProperty(ctx,'settings',{get:settings});Object.defineProperty(ctx,'data',{get:data});Object.defineProperty(ctx,'formatter',{get:formatter});Object.defineProperty(ctx,'scale',{get:scale});Object.defineProperty(ctx,'mediator',{get:mediator});Object.defineProperty(ctx,'style',{get:style});Object.defineProperty(ctx,'registries',{get:registries});if(rect){Object.defineProperty(ctx,'rect',{get:rect});}// TODO _DO_NOT_USE_getInfo is a temporary solution to expose info from a component
  // It should replace ASAP with a proper solution.
  // The only component activaly in need of it is the legend-cat
  if(_DO_NOT_USE_getInfo){ctx._DO_NOT_USE_getInfo=_DO_NOT_USE_getInfo;}Object.keys(definition).forEach(key=>{if(!isReservedProperty(key)){// Add non-lifecycle methods to the context
  if(typeof definition[key]==='function'){ctx[key]=definition[key].bind(ctx);}else {ctx[key]=definition[key];}}});// Add properties to context
  require.forEach(req=>{if(req==='renderer'){Object.defineProperty(ctx,'renderer',{get:renderer});}else if(req==='chart'){Object.defineProperty(ctx,'chart',{get:chart});}else if(req==='dockConfig'){Object.defineProperty(ctx,'dockConfig',{get:dockConfig});}else if(req==='instance'){Object.defineProperty(ctx,'instance',{get:instance});}else if(req==='update'&&update){Object.defineProperty(ctx,'update',{get:update});}else if(req==='resolver'){Object.defineProperty(ctx,'resolver',{get:resolver});}else if(req==='symbol'){Object.defineProperty(ctx,'symbol',{get:symbol});}});Object.keys(mediatorSettings).forEach(eventName=>{ctx.mediator.on(eventName,mediatorSettings[eventName].bind(ctx));});}function createDockDefinition(settings,preferredSize,logger){const getLayoutProperty=propName=>{if(settings[propName]){logger.warn("Deprecation Warning the ".concat(propName," property should be moved into layout: {} property"));// eslint-disable-line no-console
  return settings[propName];}return settings.layout?settings.layout[propName]:undefined;};const def={};def.displayOrder=getLayoutProperty('displayOrder');def.dock=getLayoutProperty('dock');def.prioOrder=getLayoutProperty('prioOrder');def.minimumLayoutMode=getLayoutProperty('minimumLayoutMode');// move layout properties to layout object
  settings.layout=settings.layout||{};settings.layout.displayOrder=typeof def.displayOrder!=='undefined'?def.displayOrder:settings.layout.displayOrder;settings.layout.prioOrder=typeof def.prioOrder!=='undefined'?def.prioOrder:settings.layout.prioOrder;settings.layout.dock=def.dock||settings.layout.dock;settings.layout.minimumLayoutMode=def.minimumLayoutMode||settings.layout.minimumLayoutMode;// not directly a dock layout property
  def.show=settings.show;def.preferredSize=preferredSize;return def;}function setUpEmitter(ctx,emitter,settings){// Object.defineProperty(ctx, 'emitter', )
  Object.keys(settings.on||{}).forEach(event=>{ctx.eventListeners=ctx.eventListeners||[];const listener=settings.on[event].bind(ctx);ctx.eventListeners.push({event,listener});emitter.on(event,listener);});ctx.emit=function(name){for(var _len=arguments.length,event=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){event[_key-1]=arguments[_key];}return emitter.emit(name,...event);};}function tearDownEmitter(ctx,emitter){if(ctx.eventListeners){ctx.eventListeners.forEach(_ref=>{let{event,listener}=_ref;emitter.removeListener(event,listener);});ctx.eventListeners.length=0;}ctx.emit=()=>{};}// First render
  // preferredSize -> resize -> beforeRender -> render -> mounted
  // Normal update
  // beforeUpdate -> preferredSize -> resize -> beforeRender -> render -> updated
  // Update without relayout
  // beforeUpdate -> beforeRender -> render -> updated
  // TODO support es6 classes
  function componentFactory(definition){let context=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{defaultSettings={},_DO_NOT_USE_getInfo=()=>({})}=definition;const{chart,container,mediator,registries,theme,renderer// Used by tests
  }=context;const emitter=EventEmitter$2.mixin({});let config=context.settings||{};let settings=extend$1(true,{},defaultSettings,config);let data=[];let scale;let formatter;let element;let size;let style;let resolver=settingsResolver({chart});let isVisible=false;const brushArgs={nodes:[],chart,config:settings.brush||{},renderer:null};const brushTriggers={tap:[],over:[]};const brushStylers=[];const definitionContext={};const instanceContext=extend$1({},config);// Create a callback that calls lifecycle functions in the definition and config (if they exist).
  function createCallback(method){let defaultMethod=arguments.length>1&&arguments[1]!==undefined?arguments[1]:()=>{};let canBeValue=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;return function cb(){const inDefinition=typeof definition[method]!=='undefined';const inConfig=typeof config[method]!=='undefined';let returnValue;for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}if(inDefinition){if(typeof definition[method]==='function'){returnValue=definition[method].call(definitionContext,...args);}else if(canBeValue){returnValue=definition[method];}}if(inConfig){if(typeof config[method]==='function'){returnValue=config[method].call(instanceContext,...args);}else if(canBeValue){returnValue=config[method];}}if(!inDefinition&&!inConfig){returnValue=defaultMethod.call(definitionContext,...args);}return returnValue;};}const preferredSize=createCallback('preferredSize',()=>0,true);const resize=createCallback('resize',_ref2=>{let{inner}=_ref2;return inner;});const created=createCallback('created');const beforeMount=createCallback('beforeMount');const mounted=createCallback('mounted');const beforeUnmount=createCallback('beforeUnmount');const beforeUpdate=createCallback('beforeUpdate');const updated=createCallback('updated');const beforeRender=createCallback('beforeRender');const beforeDestroy=createCallback('beforeDestroy');const destroyed=createCallback('destroyed');const render=definition.render;// Do not allow overriding of this function
  const addBrushStylers=()=>{if(settings.brush){(settings.brush.consume||[]).forEach(b=>{if(b.context&&b.style){brushStylers.push(styler(brushArgs,b));}});}};const addBrushTriggers=()=>{if(settings.brush){(settings.brush.trigger||[]).forEach(t=>{if(t.on==='over'){brushTriggers.over.push(t);}else {brushTriggers.tap.push(t);}});}};Object.defineProperty(brushArgs,'data',{get:()=>data});const rendString=settings.renderer||definition.renderer;const rend=rendString?renderer||registries.renderer(rendString)():renderer||registries.renderer()();if(typeof rend.settings==='function'){rend.settings(settings.rendererSettings);}brushArgs.renderer=rend;const dockConfigCallbackContext={resources:chart.logger?{logger:chart.logger()}:{}};let dockConfig=create$l(createDockDefinition(settings,preferredSize,chart.logger()),dockConfigCallbackContext);const appendComponentMeta=node=>{node.key=settings.key;node.element=rend.element();};const fn=()=>{};fn.dockConfig=()=>dockConfig;// Set new settings - will trigger mapping of data and creation of scale / formatter.
  fn.set=function(){let opts=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(opts.settings){config=opts.settings;settings=extend$1(true,{},defaultSettings,opts.settings);dockConfig=create$l(createDockDefinition(settings,preferredSize,chart.logger()),dockConfigCallbackContext);brushArgs.config=settings.brush||{};}if(settings.scale){scale=chart.scale(settings.scale);}if(settings.data){const{rendererSettings}=settings;const progressive=typeof(rendererSettings===null||rendererSettings===void 0?void 0:rendererSettings.progressive)==='function'&&rendererSettings.progressive();const extracted=extract$1$1(settings.data,{dataset:chart.dataset,collection:chart.dataCollection},{logger:chart.logger()},chart.dataCollection);if(!progressive){data=extracted;}else if(progressive.isFirst){data=extracted;if(data.items){data.items=[...extracted.items];}}else if(data.items){data.items=[...data.items,...(extracted.items||[])];}}else if(scale){data=scale.data();}else {data=[];}if(typeof settings.formatter==='string'){formatter=chart.formatter(settings.formatter);}else if(typeof settings.formatter==='object'){formatter=chart.formatter(settings.formatter);}else if(scale&&scale.data().fields){formatter=scale.data().fields[0].formatter();}style=theme.style(settings.style||{});};fn.resize=function(){let inner=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let outer=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const newSize=resize({inner,outer});if(newSize){size=rend.size(newSize);}else {size=rend.size(inner);}instanceContext.rect=extend$1(true,{computedPhysical:size.computedPhysical,computedOuter:outer.computed||outer,computedInner:inner.computed||inner},inner);size=extend$1(true,{computedOuter:outer.computed||outer,computedInner:inner.computed||inner},size);};fn.getRect=()=>instanceContext.rect;const getRenderArgs=()=>{const renderArgs=rend.renderArgs?rend.renderArgs.slice(0):[];const{rendererSettings}=settings;let d=data;const progressive=typeof(rendererSettings===null||rendererSettings===void 0?void 0:rendererSettings.progressive)==='function'&&rendererSettings.progressive();if(data.items&&progressive){d=_objectSpread2$1(_objectSpread2$1({},data),{},{items:data.items.slice(progressive.start,progressive.end)});}renderArgs.push({data:d});return renderArgs;};fn.beforeMount=beforeMount;fn.beforeRender=()=>{beforeRender({size});};let currentNodes;let preComputedRect;function updateBrushNodes(nodes){const{rendererSettings}=settings;const progressive=typeof(rendererSettings===null||rendererSettings===void 0?void 0:rendererSettings.progressive)==='function'&&rendererSettings.progressive();if(!progressive){brushArgs.nodes=nodes;}else if(progressive.isFirst){brushArgs.nodes=[...(nodes||[])];}else if(brushArgs.nodes){brushArgs.nodes=[...brushArgs.nodes,...(nodes||[])];}}fn.render=()=>{const nodes=render.call(definitionContext,...getRenderArgs());updateBrushNodes(nodes);rend.render(nodes);currentNodes=nodes;preComputedRect=instanceContext.rect.computed;};fn.hide=()=>{fn.unmount();rend.size({x:0,y:0,width:0,height:0});rend.clear();};fn.beforeUpdate=()=>{beforeUpdate({settings,data});};let currentTween;fn.update=()=>{if(currentTween){currentTween.stop();}const{rendererSettings,brush,animations}=settings;if(typeof(rendererSettings===null||rendererSettings===void 0?void 0:rendererSettings.transform)==='function'&&rendererSettings.transform()){rend.render();currentNodes=null;return;}const nodes=render.call(definitionContext,...getRenderArgs());updateBrushNodes(nodes);// Reset brush stylers and triggers
  brushStylers.forEach(b=>b.cleanUp());brushStylers.length=0;brushTriggers.tap=[];brushTriggers.over=[];if(brush){addBrushStylers();addBrushTriggers();}brushStylers.forEach(bs=>{if(bs.isActive()){bs.update();}});if(currentNodes&&animations&&(typeof animations.enabled==='function'?animations.enabled():animations.enabled)){/* The issue: as soon as animation begins, the layout changes immediately to a new layout while the displaying nodes' positions are still calculated relative to the old layout.
        This makes the nodes "jump" at the beginning of the animations. To fix this, we can compesate for the layout changes by adjusting the relative positions of the displaying nodes.
        For example, if the new layout of the point component (the central area) jumps 10px to the left compared to the old layout, we shift the points 10px to the right, making the absolute positions of the points stay the same. */if(animations.compensateForLayoutChanges){animations.compensateForLayoutChanges({currentNodes,currentRect:instanceContext.rect.computed,previousRect:preComputedRect});}currentTween=tween({old:currentNodes,current:nodes},{renderer:rend},animations,chart.storage);currentTween.start();}else {rend.render(nodes);}currentNodes=nodes;preComputedRect=instanceContext.rect.computed;if(rend.setKey&&typeof config.key==='string'){rend.setKey(config.key);}};fn.updated=updated;fn.destroy=()=>{fn.unmount();beforeDestroy(element);rend.destroy();destroyed();element=null;};/**
     * Update active nodes. For now this can be used as a way update and apply brushing on nodes.
     * Ex: if a component have changed the nodes since its initial render.
     * @param {Nodes[]} nodes
     * @deprecated
     * @ignore
     */const updateNodes=nodes=>{brushArgs.nodes=nodes;brushStylers.forEach(bs=>{if(bs.isActive()){bs.update();}});rend.render(nodes);};// Set contexts, note that the definition and instance need different contexts (for example if they have different 'require' props)
  prepareContext(definitionContext,definition,{settings:()=>settings,data:()=>data,scale:()=>scale,formatter:()=>formatter,renderer:()=>rend,chart:()=>chart,dockConfig:()=>dockConfig,mediator:()=>mediator,instance:()=>instanceContext,rect:()=>instanceContext.rect,style:()=>style,update:()=>updateNodes,registries:()=>registries,resolver:()=>resolver,symbol:()=>create$m(registries.symbol)});/**
     * Component instance
     * @typedef {object} Component
     * @property {string} type Type of component
     * @property {string} key Key of the component
     */prepareContext(instanceContext,config,{settings:()=>settings,data:()=>data,scale:()=>scale,formatter:()=>formatter,renderer:()=>rend,chart:()=>chart,dockConfig:()=>dockConfig,mediator:()=>mediator,style:()=>style,_DO_NOT_USE_getInfo:_DO_NOT_USE_getInfo.bind(definitionContext),isVisible:()=>isVisible});fn.getBrushedShapes=function getBrushedShapes(brushCtx,mode,props){const shapes=[];if(settings.brush&&settings.brush.consume){const brusher=chart.brush(brushCtx);const sceneNodes=rend.findShapes('*');settings.brush.consume.filter(t=>t.context===brushCtx).forEach(consume=>{for(let i=0;i<sceneNodes.length;i++){const node=sceneNodes[i];if(node.data&&brusher.containsMappedData(node.data,props||consume.data,mode)){appendComponentMeta(node);shapes.push(node);sceneNodes.splice(i,1);i--;}}});}return shapes;};fn.findShapes=selector=>{var _currentTween;const shapes=((_currentTween=currentTween)!==null&&_currentTween!==void 0&&_currentTween.inProgress()?currentTween.targetScene:rend).findShapes(selector);for(let i=0,num=shapes.length;i<num;i++){appendComponentMeta(shapes[i]);}return shapes;};fn.shapesAt=function(shape){let opts=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const items=rend.itemsAt(shape);let shapes;if(opts&&opts.propagation==='stop'&&items.length>0){shapes=[items.pop().node];}else {shapes=items.map(i=>i.node);}for(let i=0,num=shapes.length;i<num;i++){appendComponentMeta(shapes[i]);}return shapes;};fn.brushFromShapes=function(shapes){let trigger=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};trigger.contexts=Array.isArray(trigger.contexts)?trigger.contexts:[];const action=trigger.action||'toggle';brushFromSceneNodes({nodes:shapes,action,trigger,chart,data:brushArgs.data});};fn.mount=()=>{element=rend.element&&rend.element()?element:rend.appendTo(container);if(rend.setKey&&typeof config.key==='string'){rend.setKey(config.key);}if(settings.brush){addBrushStylers();addBrushTriggers();}setUpEmitter(instanceContext,emitter,config);setUpEmitter(definitionContext,emitter,definition);isVisible=true;};fn.mounted=()=>mounted(element);fn.unmount=()=>{[instanceContext,definitionContext].forEach(ctx=>{tearDownEmitter(ctx,emitter);});brushTriggers.tap=[];brushTriggers.over=[];brushStylers.forEach(bs=>{bs.cleanUp();});brushStylers.length=0;beforeUnmount();isVisible=false;};fn.onBrushTap=e=>{brushTriggers.tap.forEach(t=>{if(resolveTapEvent({e,t,config:brushArgs})&&t.globalPropagation==='stop'){chart.toggleBrushing(true);}});};fn.onBrushOver=e=>{brushTriggers.over.forEach(t=>{if(resolveOverEvent({e,t,config:brushArgs})&&t.globalPropagation==='stop'){chart.toggleBrushing(true);}});};/**
     * Expose definition on instance
     * @private
     * @experimental
     */fn.def=definitionContext;/**
     * Expose instanceCtx on "instance"
     * @private
     * @experimental
     */fn.ctx=instanceContext;fn.renderer=()=>rend;fn.set({settings:config});created();return fn;}function mediator(){const instance={};EventEmitter$2.mixin(instance);return instance;}// getValue({ person: { name: 'John Doe' } }, 'person.name');
  // => 'John Doe'
  //  getValue({ person: { name: undefined } }, 'person.name', 'John Doe');
  // => 'John Doe'
  function getValue(object,path,fallback){if(object===undefined||path===undefined){return fallback;}const steps=path.split('.');let scoped=object;for(let i=0;i<steps.length;++i){const step=steps[i];if(scoped[step]===undefined){return fallback;}scoped=scoped[step];}return scoped;}// const object = { person: { name: undefined };
  // setValue(object, 'person.name', 'John Doe');
  // console.log(object.person.name);
  // => 'John Doe'
  function setValue(object,path,value){if(object===undefined||path===undefined){return;}const steps=path.split('.');const propertyName=steps[steps.length-1];let scoped=object;for(let i=0;i<steps.length-1;++i){const step=steps[i];if(scoped[step]===undefined){scoped[step]=Number.isNaN(+steps[i+1])?{}:[];}scoped=scoped[step];}if(value===undefined){delete scoped[propertyName];return;}scoped[propertyName]=value;}function createStorage(source){const content=extend$1(true,{},source);const api={getAll:()=>content,getValue:(reference,fallback)=>getValue(content,reference,fallback),setValue:(reference,value)=>setValue(content,reference,value)};return api;}const EPSILON$2=1e-12;function closestPointToLine(start,end,p){const startToPoint=sub(p,start);const startToEnd=sub(end,start);const pointOnLine=add(projectOnto(startToPoint,startToEnd),start);return pointOnLine;}function isPointOnLine(start,end,p){return distance(start,p)+distance(end,p)-distance(start,end)<EPSILON$2;}/**
   * Check if rectangle a is located inside rectangle b or if they are the same rectangle.
   * @param {Rect} a - An rect containing (x,y) coordinates, width and height. The origin is assumed to be top left.
   * @param {Rect} b - An rect containing (x,y) coordinates, width and height. The origin is assumed to be top left.
   * @ignore
   */function rectContainsRect(a,b){return a.x>=b.x&&a.x+a.width<=b.x+b.width&&a.y>=b.y&&a.y+a.height<=b.y+b.height;}/* eslint no-use-before-define: ["error", { "functions": false }] */function lineHasNoLength(line){return line.x1===line.x2&&line.y1===line.y2;}function rectHasNoSize(rect){return rect.width<=0||rect.height<=0;}function circleHasNoSize(circle){return circle.r<=0;}function toFewEdges(polygon){return polygon.edges.length<=2;}// Only when the polygon1's bounds is not inside the polygon2's bounds
  function testPolygonPolygonSubCase(polygon1,polygon2){let intersects=false;for(let i=0,len=polygon2.edges.length;i<len;i++){intersects=testPolygonLine(polygon1,pointsToLine(polygon2.edges[i]));if(intersects===true){return true;}}return false;}// Only when the geopolygon's bounds is not inside the polygon's bounds
  function testGeoPolygonPolygonCase1(geopolygon,polygon){let intersects=false;for(let i=0,len=polygon.edges.length;i<len;i++){intersects=testGeoPolygonLine(geopolygon,pointsToLine(polygon.edges[i]));if(intersects===true){return true;}}return false;}// Only when the geopolygon's bounds is inside the polygon's bounds
  function testGeoPolygonPolygonCase2(geopolygon,polygon){let intersects=false;const{numPolygons,polygons}=geopolygon;for(let n=0;n<numPolygons;n++){intersects=testPolygonPolygon(polygon,polygons[n]);if(intersects===true){return true;}}return false;}// Only when the geopolygon1's bounds is not inside the geopolygon2's bounds
  function testGeoPolygonGeoPolygonSubCase(geopolygon1,geopolygon2){let intersects=false;const{numPolygons,polygons}=geopolygon2;for(let n=0;n<numPolygons;n++){let polygon=polygons[n];intersects=testGeoPolygonPolygon(geopolygon1,polygon);if(intersects===true){return true;}}return false;}/**
   * Test if a Circle contains a point. If so, returns true and false otherwise.
   * Circle muse have a radius greater then 0.
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} point
   * @param {number} point.x - x-coordinate
   * @param {number} point.y - y-coordinate
   * @return {boolean} true if circle contains point
   */function testCirclePoint(circle,point){if(circleHasNoSize(circle)){return false;}const center={x:circle.cx,y:circle.cy};const sqrDist=sqrDistance(center,point);if(sqrDist<=circle.r**2){return true;}return false;}/**
   * Test if a Circle collide with a rectangle. If so, returns true and false otherwise.
   * Circle muse have a radius greater then 0.
   * Rectangle must have a width and height greather then 0.
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @return {boolean} true if circle collide with rectangle
   */function testCircleRect(circle,rect){if(rectHasNoSize(rect)||circleHasNoSize(circle)){return false;}const rX=rect.width/2;const rY=rect.height/2;const rcX=rect.x+rX;const rcY=rect.y+rY;const r=circle.r;const cx=circle.cx;const cy=circle.cy;const dX=Math.abs(cx-rcX);const dY=Math.abs(cy-rcY);if(dX>rX+r||dY>rY+r){return false;}if(dX<=rX||dY<=rY){return true;}const sqrDist=(dX-rX)**2+(dY-rY)**2;return sqrDist<=r**2;}/**
   * Test if a Circle collide with a line segment. If so, returns true and false otherwise.
   * Circle muse have a radius greater then 0.
   * Line must have a length greater then 0.
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @return {boolean} true if circle collide with line
   */function testCircleLine(circle,line){if(circleHasNoSize(circle)||lineHasNoLength(line)){return false;}const[p1,p2]=lineToPoints(line);if(testCirclePoint(circle,p1)||testCirclePoint(circle,p2)){return true;}const center={x:circle.cx,y:circle.cy};const pointOnLine=closestPointToLine(p1,p2,center);const dist=sqrDistance(pointOnLine,center);return dist<=circle.r**2&&isPointOnLine(p1,p2,pointOnLine);}/**
   * Test if a Circle collide with another Circle. If so, returns true and false otherwise.
   * Both circles muse have a radius greater then 0.
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @return {boolean} true if circle collide with circle
   */function testCircleCircle(circle1,circle2){if(circleHasNoSize(circle1)||circleHasNoSize(circle2)){return false;}const dx=circle1.cx-circle2.cx;const dy=circle1.cy-circle2.cy;const sqrDist=dx**2+dy**2;if(sqrDist<=(circle1.r+circle2.r)**2){return true;}return false;}/**
   * Test if a Circle collide with Polygon. If so, returns true and false otherwise.
   * Circle muse have a radius greater then 0.
   * Polygon must contain at least 2 vertices
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} polygon
   * @param {Array} polygon.vertices - Array of vertices
   * @param {object} polygon.vertices.vertex
   * @param {number} polygon.vertices.vertex.x - x-coordinate
   * @param {number} polygon.vertices.vertex.y - y-coordinate
   * @param {Array} polygon.edges - Array of edges
   * @param {Array} polygon.edges.edge - Array of points
   * @param {object} polygon.edges.edge.point
   * @param {number} polygon.edges.edge.point.x - x-coordinate
   * @param {number} polygon.edges.edge.point.y - y-coordinate
   * @return {boolean} true if circle collide with polygon
   */function testCirclePolygon(circle,polygon){// TODO handle polygon that is a straight line, current impl will interrept it is a true, if radius is extended onto any of the edges
  if(toFewEdges(polygon)||circleHasNoSize(circle)){return false;}const center={x:circle.cx,y:circle.cy};if(testPolygonPoint(polygon,center)){return true;}const num=polygon.edges.length;for(let i=0;i<num;i++){const edge=pointsToLine(polygon.edges[i]);if(testCircleLine(circle,edge)){return true;}}return false;}/**
   * Test if a Polygon contains a Point. If so, returns true and false otherwise.
   * Polygon must contain at least 2 vertices
   * @private
   * @param {object} polygon
   * @param {Array} polygon.vertices - Array of vertices
   * @param {object} polygon.vertices.vertex
   * @param {number} polygon.vertices.vertex.x - x-coordinate
   * @param {number} polygon.vertices.vertex.y - y-coordinate
   * @param {Array} polygon.edges - Array of edges
   * @param {Array} polygon.edges.edge - Array of points
   * @param {object} polygon.edges.edge.point
   * @param {number} polygon.edges.edge.point.x - x-coordinate
   * @param {number} polygon.edges.edge.point.y - y-coordinate
   * @param {object} point
   * @param {number} point.x - x-coordinate
   * @param {number} point.y - y-coordinate
   * @return {boolean} true if polygon conatins point
   */function testPolygonPoint(polygon,point){// TODO handle polygon that is a straight line, current impl gives a non-deterministic output, that is depending on number of vertices
  if(toFewEdges(polygon)||!testRectPoint(polygon.boundingRect(),point)){return false;}const{x,y}=point;const vertices=polygon.vertices;let inside;let l;let j;let i;let tx;for(inside=false,i=-1,l=vertices.length,j=l-1;++i<l;j=i){if(vertices[i].x===x&&vertices[i].y===y){// polygon vertice
  return true;}if(vertices[i].y===vertices[j].y&&vertices[i].y===y&&(x-vertices[i].x)*(x-vertices[j].x)<=0){// on horizontal edge of polygon
  return true;}if(vertices[i].y<y&&y<=vertices[j].y||vertices[j].y<y&&y<=vertices[i].y){tx=(vertices[j].x-vertices[i].x)*(y-vertices[i].y)/(vertices[j].y-vertices[i].y)+vertices[i].x;if(x===tx){// on polygon edge
  return true;}if(x<tx){inside=!inside;}}}return inside;}/**
   * Test if a Polygon collider with a line. If so, returns true and false otherwise.
   * Polygon must contain at least 3 edges.
   * Line must have length greater then 0.
   * @private
   * @param {object} polygon
   * @param {Array} polygon.vertices - Array of vertices
   * @param {object} polygon.vertices.vertex
   * @param {number} polygon.vertices.vertex.x - x-coordinate
   * @param {number} polygon.vertices.vertex.y - y-coordinate
   * @param {Array} polygon.edges - Array of edges
   * @param {Array} polygon.edges.edge - Array of points
   * @param {object} polygon.edges.edge.point
   * @param {number} polygon.edges.edge.point.x - x-coordinate
   * @param {number} polygon.edges.edge.point.y - y-coordinate
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @return {boolean} true if polygon collider with line
   */function testPolygonLine(polygon,line){// TODO handle polygon that is a straight line, current impl gives a non-deterministic output, that is depending on number of vertices
  if(toFewEdges(polygon)){return false;}for(let i=0,num=polygon.edges.length;i<num;i++){const edge=pointsToLine(polygon.edges[i]);if(testLineLine(line,edge)){return true;}}const[p1,p2]=lineToPoints(line);return testPolygonPoint(polygon,p1)||testPolygonPoint(polygon,p2);}/**
   * Test if a Polygon collider with a rectangle. If so, returns true and false otherwise.
   * Polygon must contain at least 3 edges.
   * Rectangle must width and height greater then 0.
   * @private
   * @param {object} polygon
   * @param {Array} polygon.vertices - Array of vertices
   * @param {object} polygon.vertices.vertex
   * @param {number} polygon.vertices.vertex.x - x-coordinate
   * @param {number} polygon.vertices.vertex.y - y-coordinate
   * @param {Array} polygon.edges - Array of edges
   * @param {Array} polygon.edges.edge - Array of points
   * @param {object} polygon.edges.edge.point
   * @param {number} polygon.edges.edge.point.x - x-coordinate
   * @param {number} polygon.edges.edge.point.y - y-coordinate
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @return {boolean} true if polygon collider with rect
   */function testPolygonRect(polygon,rect){// TODO handle polygon that is a straight line, current impl gives a non-deterministic output, that is depending on number of vertices
  if(toFewEdges(polygon)){return false;}for(let i=0,num=polygon.edges.length;i<num;i++){const edge=pointsToLine(polygon.edges[i]);if(testRectLine(rect,edge)){return true;}}const[p1,p2,p3,p4]=rectToPoints(rect);return testPolygonPoint(polygon,p1)||testPolygonPoint(polygon,p2)||testPolygonPoint(polygon,p3)||testPolygonPoint(polygon,p4);}/**
   * Test if a Rectangle collide with another rectangle. If so, returns true and false otherwise.
   * Both rectangles must have a width and height greather then 0.
   * @private
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @return {boolean} true if rectangle collide with rectangle
   */function testRectRect(rect1,rect2){if(rectHasNoSize(rect1)||rectHasNoSize(rect2)){return false;}return rect1.x<=rect2.x+rect2.width&&rect2.x<=rect1.x+rect1.width&&rect1.y<=rect2.y+rect2.height&&rect2.y<=rect1.y+rect1.height;}/**
   * Test if a rectangle contains  another rectangle. If so, returns true and false otherwise.
   * Both rectangles must have a width and height greather then 0.
   * @private
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @return {boolean} true if rectangle collide with rectangle
   */function testRectContainsRect(rect1,rect2){if(rectHasNoSize(rect1)||rectHasNoSize(rect2)){return false;}const points=[{x:rect2.x,y:rect2.y},{x:rect2.x+rect2.width,y:rect2.y},{x:rect2.x+rect2.width,y:rect2.y+rect2.height},{x:rect2.x,y:rect2.y+rect2.height}];return points.every(p=>testRectPoint(rect1,p));}/**
   * Test if a Rectangle contains a Point. If so, returns true and false otherwise.
   * Rectangle must have a width and height greather then 0.
   * @private
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @param {object} point
   * @param {number} point.x - x-coordinate
   * @param {number} point.y - y-coordinate
   * @return {boolean} true if rectangle contains point
   */function testRectPoint(rect,point){if(rectHasNoSize(rect)){return false;}return point.x>=rect.x&&point.x<=rect.x+rect.width&&point.y>=rect.y&&point.y<=rect.y+rect.height;}/**
   * Test if a Rectangle collider with a line. If so, returns true and false otherwise.
   * Rectangle must have a width and height greather then 0.
   * Line must have length greater then 0.
   * @private
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @return {boolean} true if rectangle collide with line
   */function testRectLine(rect,line){if(lineHasNoLength(line)||rectHasNoSize(rect)){return false;}const[p1,p2]=lineToPoints(line);if(testRectPoint(rect,p1)||testRectPoint(rect,p2)){return true;}const rectEdges=rectToPoints(rect);let num=rectEdges.length;for(let i=0;i<num;i++){const edge=pointsToLine([rectEdges[i],rectEdges[i!==3?i+1:0]]);if(testLineLine(edge,line)){return true;}}return false;}/**
   * Test if a Line collider with another line. If so, returns true and false otherwise.
   * Both lines must have length greater then 0.
   * @private
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @return {boolean} true if line collide with line
   */function testLineLine(line1,line2){const[p1,p2]=lineToPoints(line1);const[p3,p4]=lineToPoints(line2);const dx1=distanceX(p2,p1);const dy1=distanceY(p2,p1);const dx2=distanceX(p4,p3);const dy2=distanceY(p4,p3);const dx3=distanceX(p1,p3);const dy3=distanceY(p1,p3);let ub=dy2*dx1-dx2*dy1;const uat=dx2*dy3-dy2*dx3;const ubt=dx1*dy3-dy1*dx3;let t1;let t2;if(dx1===0&&dy1===0){// Line segment has no length
  return false;}if(dx2===0&&dy2===0){// Line segment has no length
  return false;}if(ub===0){if(uat===0&&ubt===0){// COINCIDENT;
  if(dx1===0){if(dy1===0){// p1 = p2
  return p1.x===p2.x&&p1.y===p2.y;}t1=distanceY(p3,p1)/dy1;t2=distanceY(p4,p1)/dy1;}else {t1=(p3.x-p1.x)/dx1;t2=(p4.x-p1.x)/dx1;}if(t1<0&&t2<0||t1>1&&t2>1){return false;}return true;}return false;// PARALLEL;
  }const ua=uat/ub;ub=ubt/ub;if(ua>=0.0&&ua<=1.0&&ub>=0.0&&ub<=1.0){return true;}return false;}/**
   * Test if a Line contains a Point. If so, returns true and false otherwise.
   * Line must have length greater then 0.
   * @private
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {object} point
   * @param {number} point.x - x-coordinate
   * @param {number} point.y - y-coordinate
   * @return {boolean} true if line contains point
   */function testLinePoint(line,point){if(lineHasNoLength(line)){return false;}const[p1,p2]=lineToPoints(line);return isPointOnLine(p1,p2,point);}/**
   * Test if a polygon intersects another polygon.
   * Supports convex, concave and self-intersecting polygons (filled area).
   * @private
   * @param {object} polygon
   * @param {object} polygon
   * @returns {boolean} True if there is an intersection, false otherwise
   */function testPolygonPolygon(polygon1,polygon2){const rect1=polygon1.boundingRect();const rect2=polygon2.boundingRect();if(!testRectRect(rect1,rect2)){return false;}if(testRectContainsRect(rect1,rect2)){return testPolygonPolygonSubCase(polygon1,polygon2);}return testPolygonPolygonSubCase(polygon2,polygon1);}/**
   * Test if a geopolygon intersects a polygon.
   * @private
   * @param {object} geopolygon
   * @param {object} polygon
   * @returns {boolean} True if there is an intersection, false otherwise
   */function testGeoPolygonPolygon(geopolygon,polygon){const rect1=geopolygon.boundingRect();const rect2=polygon.boundingRect();if(!testRectRect(rect1,rect2)){return false;}if(testRectContainsRect(rect2,rect1)){return testGeoPolygonPolygonCase2(geopolygon,polygon);}return testGeoPolygonPolygonCase1(geopolygon,polygon);}/**
   * Test if a geopolygon intersects another geopolygon.
   * @private
   * @param {object} geopolygon
   * @param {object} geopolygon
   * @returns {boolean} True if there is an intersection, false otherwise
   */function testGeoPolygonGeoPolygon(geopolygon1,geopolygon2){const rect1=geopolygon1.boundingRect();const rect2=geopolygon2.boundingRect();if(!testRectRect(rect1,rect2)){return false;}if(testRectContainsRect(rect2,rect1)){return testGeoPolygonGeoPolygonSubCase(geopolygon2,geopolygon1);}return testGeoPolygonGeoPolygonSubCase(geopolygon1,geopolygon2);}/**
   * Test if a Circle collide with GeoPolygon. If so, returns true and false otherwise.
   * Circle muse have a radius greater then 0.
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} geopolygon
   * @param {Array} geopolygon.polygons - Array of polygons
   * @return {boolean} true if circle collide with polygon
   */function testCircleGeoPolygon(circle,geopolygon){if(circleHasNoSize(circle)){return false;}const center={x:circle.cx,y:circle.cy};if(testGeoPolygonPoint(geopolygon,center)){return true;}const{numPolygons,polygons}=geopolygon;for(let n=0;n<numPolygons;n++){const polygon=polygons[n];const num=polygon.edges.length;for(let i=0;i<num;i++){const edge=pointsToLine(polygon.edges[i]);if(testCircleLine(circle,edge)){return true;}}}return false;}/**
   * Test if a GeoPolygon contains a Point. If so, returns true and false otherwise.
   * @private
   * @param {object} geopolygon
   * @param {Array} geopolygon.vertices - Array of of arrays of vertices
   * @param {object} point
   * @param {number} point.x - x-coordinate
   * @param {number} point.y - y-coordinate
   * @return {boolean} true if polygon conatins point
   */function testGeoPolygonPoint(geopolygon,point){if(!testRectPoint(geopolygon.boundingRect(),point)){return false;}const{x,y}=point;const numPolygons=geopolygon.numPolygons;let inside=false;let vertices;let n;let l;let j;let i;let tx;for(n=0;n<numPolygons;n++){vertices=geopolygon.vertices[n];for(i=-1,l=vertices.length,j=l-1;++i<l;j=i){if(vertices[i].x===x&&vertices[i].y===y){// polygon vertice
  return true;}if(vertices[i].y===vertices[j].y&&vertices[i].y===y&&(x-vertices[i].x)*(x-vertices[j].x)<=0){// on horizontal edge of polygon
  return true;}if(vertices[i].y<y&&y<=vertices[j].y||vertices[j].y<y&&y<=vertices[i].y){tx=(vertices[j].x-vertices[i].x)*(y-vertices[i].y)/(vertices[j].y-vertices[i].y)+vertices[i].x;if(x===tx){// on polygon edge
  return true;}if(x<tx){inside=!inside;}}}}return inside;}/**
   * Test if a GeoPolygon collider with a line. If so, returns true and false otherwise.
   * Line must have length greater then 0.
   * @private
   * @param {object} geopolygon
   * @param {Array} geopolygon.polygons - Array of polygons
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @return {boolean} true if polygon collider with line
   */function testGeoPolygonLine(geopolygon,line){const[p1,p2]=lineToPoints(line);if(testGeoPolygonPoint(geopolygon,p1)||testGeoPolygonPoint(geopolygon,p2)){return true;}const{numPolygons,polygons}=geopolygon;for(let n=0;n<numPolygons;n++){const polygon=polygons[n];for(let i=0,num=polygon.edges.length;i<num;i++){const edge=pointsToLine(polygon.edges[i]);if(testLineLine(line,edge)){return true;}}}return false;}/**
   * Test if a GeoPolygon collider with a rectangle. If so, returns true and false otherwise.
   * Rectangle must have width and height greater than 0.
   * @private
   * @param {object} geopolygon
   * @param {Array} geopolygon.polygons - Array of polygons
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @return {boolean} true if polygon collider with rect
   */function testGeoPolygonRect(geopolygon,rect){const[p1,p2,p3,p4]=rectToPoints(rect);if(testGeoPolygonPoint(geopolygon,p1)||testGeoPolygonPoint(geopolygon,p2)||testGeoPolygonPoint(geopolygon,p3)||testGeoPolygonPoint(geopolygon,p4)){return true;}const{numPolygons,polygons}=geopolygon;for(let n=0;n<numPolygons;n++){const polygon=polygons[n];for(let i=0,num=polygon.edges.length;i<num;i++){const edge=pointsToLine(polygon.edges[i]);if(testRectLine(rect,edge)){return true;}}}return false;}const VARIABLE_RX=/^\$/;const EXTEND='@extend';function throwCyclical(s){throw new Error("Cyclical reference for \"".concat(s,"\""));}function res(style,references,path){if(typeof style==='string'){let value=references[style];if(path.indexOf(style)!==-1){throwCyclical(style);}if(VARIABLE_RX.test(value)){path.push(style);return res(value,references,path);}return value;}let computed=style;const refs=extend$1(true,{},references,style);const s={};if(style[EXTEND]){const extendFrom=style[EXTEND];if(path.indexOf(extendFrom)!==-1){throwCyclical(extendFrom);}let pext=path.slice();pext.push(extendFrom);computed=extend$1(true,{},res(refs[extendFrom],references,pext),style);}Object.keys(computed).forEach(key=>{let p=path.slice();if(key===EXTEND||VARIABLE_RX.test(key)){return;}s[key]=computed[key];let value=s[key];if(VARIABLE_RX.test(value)&&value in refs){if(path.indexOf(value)!==-1){throwCyclical(value);}p.push(value);value=refs[value];if(typeof value==='object'){s[key]=res(value,refs,p);}else if(VARIABLE_RX.test(value)&&value in refs){s[key]=res(value,refs,p);}else {s[key]=value;}}else if(typeof value==='object'){s[key]=res(value,refs,p);}});return s;}/**
   * Resolve style references
   * @private
   * @param {style-object} style
   * @param {style-object} references
   * @returns {object} The resolved style
   * @example
   * resolve({
   *   label: '$label--big'
   * }, {
   *   '$size--m': '12px',
   *   '$label--big': {
   *     fontFamily: 'Arial',
   *     fontSize: '$size--m'
   *   }
   * }); // { label: { fontFamily: 'Arial', fontSize: '12px' } }
   */function resolve$1(style,references){return res(style,references,[]);}function themeFn(){let style=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let palettes=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];let pals={};let internalStyle=style;const setPalettes=p=>{p.forEach(palette=>{const pal=Array.isArray(palette.colors[0])?palette.colors:[palette.colors];pals[palette.key]={colors:pal,sizes:pal.map(colors=>colors?colors.length:0)};});};const getPalette=(key,num)=>{const palette=pals[key];if(!palette){return [];}const sizes=palette.sizes;// find the first color set containing at least 'num' colors
  for(let i=0;i<sizes.length;i++){if(num<=sizes[i]){return palette.colors[i];}}return palette.colors[sizes.length-1];};/**
     * Theme API
     * @private
     * @experimental
     */const theme={/**
       * Get an array of colors
       * @param {string} name - Name of the color palette
       * @param {number} [num] - The minimum number of colors to get from the palette
       */palette:(name,num)=>getPalette(name,num),setPalettes,/**
       * Resolve style references
       * @param {style-object} s - Object containing style
       */style:s=>resolve$1(s,internalStyle),/**
       * Set custom style
       * @param {style-object} s - Object containing style
       */setStyle:s=>{internalStyle=extend$1({},style,s);}};setPalettes(palettes);return theme;}function roundRect(rect){rect.x=Math.floor(rect.x);rect.y=Math.floor(rect.y);rect.width=Math.floor(rect.width);rect.height=Math.floor(rect.height);}function resolveContainerRects(rect,settings){const containerRect={x:0,y:0,width:0,height:0};const logicalContainerRect={x:0,y:0,width:0,height:0};// Check input object for size
  containerRect.width=rect.width||0;containerRect.height=rect.height||0;if(typeof settings.size!=='undefined'){containerRect.width=isNaN(settings.size.width)?containerRect.width:settings.size.width;containerRect.height=isNaN(settings.size.height)?containerRect.height:settings.size.height;}if(typeof settings.logicalSize!=='undefined'){logicalContainerRect.width=isNaN(settings.logicalSize.width)?containerRect.width:settings.logicalSize.width;logicalContainerRect.height=isNaN(settings.logicalSize.height)?containerRect.height:settings.logicalSize.height;logicalContainerRect.align=isNaN(settings.logicalSize.align)?0.5:Math.min(Math.max(settings.logicalSize.align,0),1);logicalContainerRect.preserveAspectRatio=settings.logicalSize.preserveAspectRatio;}else {logicalContainerRect.width=containerRect.width;logicalContainerRect.height=containerRect.height;logicalContainerRect.preserveAspectRatio=false;}roundRect(logicalContainerRect);roundRect(containerRect);return {logicalContainerRect,containerRect};}function resolveSettings$1(s){const settings={center:{minWidthRatio:0.5,minHeightRatio:0.5,minWidth:0,minHeight:0}};extend$1(true,settings,s);settings.center.minWidthRatio=Math.min(Math.max(settings.center.minWidthRatio,0),1);// Only accept value between 0-1
  settings.center.minHeightRatio=Math.min(Math.max(settings.center.minHeightRatio,0),1);// Only accept value between 0-1
  settings.center.minWidth=Math.max(settings.center.minWidth,0);// Consider <= 0 to be falsy and fallback to ratio
  settings.center.minHeight=Math.max(settings.center.minHeight,0);// Consider <= 0 to be falsy and fallback to ratio
  return settings;}function createRect(x,y,width,height,margin){return {x:isNaN(x)?0:x,y:isNaN(x)?0:y,width:isNaN(x)?0:width,height:isNaN(x)?0:height,margin:isNaN(margin)?0:margin};}function cacheSize(c,reducedRect,layoutRect){if(typeof c.cachedSize==='undefined'){const dock=c.config.dock();let size=c.comp.preferredSize({inner:reducedRect,outer:layoutRect,dock});// backwards compatibility
  if(!isNaN(size)){size={width:size,height:size};}else if(size&&!isNaN(size.size)){size.width=size.size;size.height=size.size;}let relevantSize;if(dock==='top'||dock==='bottom'){relevantSize=size.height;}else if(dock==='right'||dock==='left'){relevantSize=size.width;}else {relevantSize=Math.max(size.width,size.height);}c.cachedSize=Math.ceil(relevantSize);c.edgeBleed=size.edgeBleed||0;}return c.cachedSize;}function validateReduceRect(rect,reducedRect,settings){// Absolute value for width/height should have predence over relative value
  const minReduceWidth=Math.min(settings.center.minWidth,rect.width)||Math.max(rect.width*settings.center.minWidthRatio,1);const minReduceHeight=Math.min(settings.center.minHeight,rect.height)||Math.max(rect.height*settings.center.minHeightRatio,1);return reducedRect.width>=minReduceWidth&&reducedRect.height>=minReduceHeight;}function reduceDocRect(reducedRect,c){switch(c.config.dock()){case'top':reducedRect.y+=c.cachedSize;reducedRect.height-=c.cachedSize;break;case'bottom':reducedRect.height-=c.cachedSize;break;case'left':reducedRect.x+=c.cachedSize;reducedRect.width-=c.cachedSize;break;case'right':reducedRect.width-=c.cachedSize;break;}}function addEdgeBleed(currentEdgeBleed,c){const edgeBleed=c.edgeBleed;if(!edgeBleed){return;}currentEdgeBleed.left=Math.max(currentEdgeBleed.left,edgeBleed.left||0);currentEdgeBleed.right=Math.max(currentEdgeBleed.right,edgeBleed.right||0);currentEdgeBleed.top=Math.max(currentEdgeBleed.top,edgeBleed.top||0);currentEdgeBleed.bottom=Math.max(currentEdgeBleed.bottom,edgeBleed.bottom||0);}function reduceEdgeBleed(layoutRect,reducedRect,edgeBleed){if(reducedRect.x<edgeBleed.left){reducedRect.width-=edgeBleed.left-reducedRect.x;reducedRect.x=edgeBleed.left;}const reducedRectRightBoundary=layoutRect.width-(reducedRect.x+reducedRect.width);if(reducedRectRightBoundary<edgeBleed.right){reducedRect.width-=edgeBleed.right-reducedRectRightBoundary;}if(reducedRect.y<edgeBleed.top){reducedRect.height-=edgeBleed.top-reducedRect.y;reducedRect.y=edgeBleed.top;}const reducedRectBottomBoundary=layoutRect.height-(reducedRect.y+reducedRect.height);if(reducedRectBottomBoundary<edgeBleed.bottom){reducedRect.height-=edgeBleed.bottom-reducedRectBottomBoundary;}}function reduceSingleLayoutRect(layoutRect,reducedRect,edgeBleed,c,settings){const newReduceRect=extend$1({},reducedRect);const newEdgeBleed=extend$1({},edgeBleed);reduceDocRect(newReduceRect,c);addEdgeBleed(newEdgeBleed,c);reduceEdgeBleed(layoutRect,newReduceRect,newEdgeBleed);const isValid=validateReduceRect(layoutRect,newReduceRect,settings);if(!isValid){return false;}reduceDocRect(reducedRect,c);addEdgeBleed(edgeBleed,c);return true;}/**
   * Updates the visible and hidden components based on components that are docked to other components.
   * For example, assume a component called myRect:
   * {
   *  key: 'myRect',
   *  type: 'rect',
   *  dock: 'bottom'
   * }
   * and a component called myLine:
   * {
   *  key: 'myLine',
   *  type: 'line',
   *  dock: '@myRect'
   * }
   * if the layout engine decides to hide myRect, then myLine should be hidden as well.
   * @param {Array} visible - Components to be decided if they should be hidden or not.
   * @param {Array} hidden - Components that are already hidden.
   * @returns {Object} containing the new visible components and additional components to be hidden.
   * @ignore
   */function filterReferencedDocks(visible,hidden){if(hidden.length===0){return;}for(let i=0;i<visible.length;++i){let v=visible[i];if(v.referencedDocks.length){const isAllHidden=v.referencedDocks.every(refDock=>hidden.some(h=>h.key===refDock));if(isAllHidden){hidden.push(visible.splice(i,1)[0]);}}}}function reduceLayoutRect(_ref){let{layoutRect,visible,hidden,settings}=_ref;const reducedRect=createRect(layoutRect.x,layoutRect.y,layoutRect.width,layoutRect.height);const edgeBleed={left:0,right:0,top:0,bottom:0};const sortedComponents=visible.slice();sortedComponents.sort((a,b)=>a.config.prioOrder()-b.config.prioOrder());// lower prioOrder will have higher prio
  for(let i=0;i<sortedComponents.length;++i){const c=sortedComponents[i];cacheSize(c,reducedRect,layoutRect);if(!reduceSingleLayoutRect(layoutRect,reducedRect,edgeBleed,c,settings)){hidden.push(sortedComponents.splice(i,1)[0]);--i;}}filterReferencedDocks(visible,hidden);const filteredUnsortedComps=visible.filter(c=>sortedComponents.indexOf(c)!==-1);visible.length=0;visible.push(...filteredUnsortedComps);reduceEdgeBleed(layoutRect,reducedRect,edgeBleed);return reducedRect;}function computeRect(rect){return {x:rect.margin.left+rect.x*rect.scaleRatio.x,y:rect.margin.top+rect.y*rect.scaleRatio.y,width:rect.width*rect.scaleRatio.x,height:rect.height*rect.scaleRatio.y};}function appendScaleRatio(rect,outerRect,layoutRect,containerRect){const scaleRatio={x:containerRect.width/layoutRect.width,y:containerRect.height/layoutRect.height};const margin={left:0,top:0};if(layoutRect.preserveAspectRatio){const xLessThenY=scaleRatio.x<scaleRatio.y;// To preserve the aspect ratio, take the smallest ratio and apply in both directions to "meet" the size of the container
  const minRatio=Math.min(scaleRatio.x,scaleRatio.y);scaleRatio.x=minRatio;scaleRatio.y=minRatio;const area=xLessThenY?'height':'width';const spread=(containerRect[area]-layoutRect[area]*scaleRatio.x)*layoutRect.align;margin.left=xLessThenY?0:spread;margin.top=xLessThenY?spread:0;}rect.scaleRatio=scaleRatio;rect.margin=margin;outerRect.scaleRatio=scaleRatio;outerRect.margin=margin;layoutRect.scaleRatio=scaleRatio;layoutRect.margin=margin;}function boundingBox(rects){const points=[].concat(...rects.map(rectToPoints));return pointsToRect(points);}function positionComponents(_ref2){let{visible,layoutRect,reducedRect,containerRect,translation}=_ref2;const vRect=createRect(reducedRect.x,reducedRect.y,reducedRect.width,reducedRect.height);const hRect=createRect(reducedRect.x,reducedRect.y,reducedRect.width,reducedRect.height);const referencedComponents={};const referenceArray=visible.slice();const elementOrder=referenceArray.slice().sort((a,b)=>a.config.displayOrder()-b.config.displayOrder());visible.sort((a,b)=>{if(a.referencedDocks.length>0&&b.referencedDocks.length>0){return 0;}if(b.referencedDocks.length>0){return -1;}if(a.referencedDocks.length>0){return 1;}const diff=a.config.displayOrder()-b.config.displayOrder();if(diff===0){return referenceArray.indexOf(a)-referenceArray.indexOf(b);}return diff;}).forEach(c=>{let outerRect={};let rect={};const d=c.config.dock();switch(d){case'top':outerRect.height=rect.height=c.cachedSize;outerRect.width=layoutRect.width;rect.width=vRect.width;outerRect.x=layoutRect.x;rect.x=vRect.x;outerRect.y=rect.y=vRect.y-c.cachedSize;vRect.y-=c.cachedSize;vRect.height+=c.cachedSize;break;case'bottom':outerRect.x=layoutRect.x;rect.x=vRect.x;outerRect.y=rect.y=vRect.y+vRect.height;outerRect.width=layoutRect.width;rect.width=vRect.width;outerRect.height=rect.height=c.cachedSize;vRect.height+=c.cachedSize;break;case'left':outerRect.x=rect.x=hRect.x-c.cachedSize;outerRect.y=layoutRect.y;rect.y=hRect.y;outerRect.width=rect.width=c.cachedSize;outerRect.height=layoutRect.height;rect.height=hRect.height;hRect.x-=c.cachedSize;hRect.width+=c.cachedSize;break;case'right':outerRect.x=rect.x=hRect.x+hRect.width;outerRect.y=layoutRect.y;rect.y=hRect.y;outerRect.width=rect.width=c.cachedSize;outerRect.height=layoutRect.height;rect.height=hRect.height;hRect.width+=c.cachedSize;break;case'center':outerRect.x=rect.x=reducedRect.x;outerRect.y=rect.y=reducedRect.y;outerRect.width=rect.width=reducedRect.width;outerRect.height=rect.height=reducedRect.height;break;default:if(c.referencedDocks.length>0){const refs=c.referencedDocks.map(ref=>referencedComponents[ref]).filter(ref=>!!ref);if(refs.length>0){outerRect=boundingBox(refs.map(ref=>ref.outerRect));rect=boundingBox(refs.map(ref=>ref.r));}}break;}if(c.key){referencedComponents[c.key]={// store the size of this component
  r:rect,outerRect};}appendScaleRatio(rect,outerRect,layoutRect,containerRect);rect.edgeBleed=c.edgeBleed;rect.computed=computeRect(rect);outerRect.edgeBleed=c.edgeBleed;outerRect.computed=computeRect(outerRect);rect.x+=translation.x;rect.y+=translation.y;outerRect.x+=translation.x;outerRect.y+=translation.y;c.comp.resize(rect,outerRect);c.cachedSize=undefined;c.edgeBleed=undefined;});return elementOrder;}function checkShowSettings(strategySettings,dockSettings,logicalContainerRect){const layoutModes=strategySettings.layoutModes||{};const minimumLayoutMode=dockSettings.minimumLayoutMode();let show=dockSettings.show();if(show&&typeof minimumLayoutMode==='object'){show=layoutModes[minimumLayoutMode.width]&&layoutModes[minimumLayoutMode.height]&&logicalContainerRect.width>=layoutModes[minimumLayoutMode.width].width&&logicalContainerRect.height>=layoutModes[minimumLayoutMode.height].height;}else if(show&&minimumLayoutMode!==undefined){show=layoutModes[minimumLayoutMode]&&logicalContainerRect.width>=layoutModes[minimumLayoutMode].width&&logicalContainerRect.height>=layoutModes[minimumLayoutMode].height;}return show;}function validateComponent(component){if(!component.resize||typeof component.resize!=='function'){throw new Error('Component is missing resize function');}if(!component.dockConfig&&!component.preferredSize){throw new Error('Component is missing preferredSize function');}}function filterComponents(components,settings,rect){const visible=[];const hidden=[];// check show settings
  for(let i=0;i<components.length;++i){const comp=components[i];validateComponent(comp);// backwards compatibility
  let config=comp.dockConfig;const key=comp.key;const d=config.dock();const referencedDocks=/@/.test(d)?d.split(',').map(s=>s.replace(/^\s*@/,'')):[];if(checkShowSettings(settings,config,rect)){visible.push({comp,key,config,referencedDocks});}else {hidden.push({comp,key,config,referencedDocks});}}return [visible,hidden];}/**
   * Dock layout settings
   * @typedef {object} DockLayoutSettings
   * @property {object} [logicalSize] - Logical size
   * @property {number} [logicalSize.width] - Width in pixels
   * @property {number} [logicalSize.height] - Height in pixels
   * @property {boolean} [logicalSize.preserveAspectRatio=false] - If true, takes the smallest ratio of width/height between logical and physical size ( physical / logical )
   * @property {number} [logicalSize.align=0.5] - Normalized value between 0-1. Defines how the space around the scaled axis is spread in the container, with 0.5 meaning the spread is equal on both sides. Only applicable if preserveAspectRatio is set to true
   * @property {object} [center] - Define how much space the center dock area requires
   * @property {number} [center.minWidthRatio=0.5] - Value between 0 and 1
   * @property {number} [center.minHeightRatio=0.5] - Value between 0 and 1
   * @property {number} [center.minWidth] - Width in pixels
   * @property {number} [center.minHeight] - Height in pixels
   * @property {object<string, DockLayoutSettings~LayoutMode>} [layoutModes] Dictionary with named sizes
   * @property {object} [size] - Size is equal to that of the container (element) of the chart by default. It's possible to overwrite it by explicitly setting width or height
   * @property {number} [size.width] - Width in pixels
   * @property {number} [size.height] - Height in pixels
   */ /**
   * @typedef {object} DockLayoutSettings~LayoutMode
   * @property {number} width
   * @property {number} height
   */function dockLayout(initialSettings){let settings=resolveSettings$1(initialSettings);const docker={};docker.layout=function layout(rect){let components=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];if(!rect||isNaN(rect.x)||isNaN(rect.y)||isNaN(rect.width)||isNaN(rect.height)){throw new Error('Invalid rect');}if(!components.length){return {visible:[],hidden:[],ordered:[]};}const{logicalContainerRect,containerRect}=resolveContainerRects(rect,settings);const[visible,hidden]=filterComponents(components,settings,logicalContainerRect);const reducedRect=reduceLayoutRect({layoutRect:logicalContainerRect,visible,hidden,settings});const translation={x:rect.x,y:rect.y};const ordered=positionComponents({visible,layoutRect:logicalContainerRect,reducedRect,containerRect,translation});hidden.forEach(c=>{c.comp.visible=false;// set empty rects on hidden components
  const r=createRect();c.comp.resize(r,r);});return {visible:visible.map(v=>v.comp),hidden:hidden.map(h=>h.comp),ordered:ordered.map(h=>h.comp)};};docker.settings=function settingsFn(s){settings=resolveSettings$1(s);};return docker;}const findComponentByKeyInList=(list,key)=>{for(let i=0;i<list.length;i++){const currComp=list[i];if(currComp.hasKey&&currComp.key===key){return list[i];}}return null;};const wrapChildren=children=>children===null||children===void 0?void 0:children.map(c=>{const dockConfig=c.instance.dockConfig();return {preferredSize(opts){return dockConfig.computePreferredSize(_objectSpread2$1(_objectSpread2$1({},opts),{},{children:wrapChildren(c.children)}));}};});const hideAll=(rect,components)=>({visible:[],hidden:components,ordered:[]});const customLayout=fn=>(rect,components)=>{var _fn;const vcomponents=components.map((c,i)=>{const dockConfig=c.instance.dockConfig();return {index:i,key:c.key,dockConfig,resize:c.instance.resize,preferredSize(opts){return dockConfig.computePreferredSize(_objectSpread2$1(_objectSpread2$1({},opts),{},{children:wrapChildren(c.children)}));}};});const mapBack=c=>components[c.index];const{visible=vcomponents,hidden=[],ordered=visible}=(_fn=fn(rect,vcomponents))!==null&&_fn!==void 0?_fn:{};return {visible:visible.map(mapBack),hidden:hidden.map(mapBack),ordered:ordered.map(mapBack)};};const normalLayout=layoutSettings=>{const dockLayout$1=dockLayout(layoutSettings);return customLayout((rect,vcomponents)=>dockLayout$1.layout(rect,vcomponents));};const getLayoutFn=strategy=>typeof strategy==='function'?customLayout(strategy):normalLayout(strategy);function collectionFn(_ref){let{createComponent}=_ref;const instance={};let allComponents=[];let topComponents=[];const createComp=compSettings=>{const component=createComponent(compSettings);if(component){allComponents.push(component);if(compSettings.components){component.children=compSettings.components.map(childSettings=>createComp(childSettings)).filter(c=>!!c);}}return component;};const removeFromAllComponents=component=>{const index=allComponents.indexOf(component);if(index!==-1){allComponents.splice(index,1);}};const removeDeleted=(compList,settingsList)=>{for(let i=compList.length-1;i>=0;i--){const currComp=compList[i];// TODO warn when there is no key
  const currSettings=settingsList.find(c=>currComp.hasKey&&currComp.key===c.key);if(!currSettings){// Component is removed
  compList.splice(i,1);removeFromAllComponents(currComp);if(currComp.children){removeDeleted(currComp.children,[]);}currComp.instance.destroy();}else if(currComp.children&&currSettings.components){removeDeleted(currComp.children,currSettings.components);}}};const addAndUpdate=_ref2=>{let{compList,data,excludeFromUpdate,formatters,scales,settingsList}=_ref2;return(// Let the "components" array determine order of components
  settingsList.map(comp=>{const component=findComponentByKeyInList(compList,comp.key);// Component should not be updated
  if(excludeFromUpdate.indexOf(comp.key)>-1){// TODO: decide if to skip children
  delete component.updateWith;return component;}if(!component){// Component is added
  return createComp(comp);}if(comp.rendererSettings&&typeof component.instance.renderer().settings==='function'){component.instance.renderer().settings(comp.rendererSettings);}// Only apply transform, no need for an update
  if(comp.rendererSettings&&typeof comp.rendererSettings.transform==='function'&&comp.rendererSettings.transform()){component.applyTransform=true;return component;}// Component is (potentially) updated
  component.updateWith={formatters,scales,data,settings:comp};if(comp.components){component.children=addAndUpdate({compList:component.children||[],data,excludeFromUpdate,formatters,scales,settingsList:comp.components});}return component;}).filter(c=>!!c));};const recLayout=_ref3=>{let{components,hidden,layoutFn,ordered,rect,visible}=_ref3;const{visible:v,hidden:h,ordered:o}=layoutFn(rect,components);visible.push(...v);hidden.push(...h);ordered.push(...o);v.forEach(c=>{if(c.children){var _c$settings$strategy,_c$settings;const lFn=getLayoutFn((_c$settings$strategy=(_c$settings=c.settings)===null||_c$settings===void 0?void 0:_c$settings.strategy)!==null&&_c$settings$strategy!==void 0?_c$settings$strategy:{});recLayout({components:c.children,hidden,layoutFn:lFn,ordered,rect:c.instance.getRect(),visible});}});h.forEach(c=>{if(c.children){recLayout({components:c.children,hidden,layoutFn:hideAll,ordered,rect:null,visible});}});};instance.destroy=()=>{allComponents.forEach(comp=>comp.instance.destroy());allComponents=[];topComponents=[];};instance.findComponentByKey=key=>findComponentByKeyInList(allComponents,key);instance.forEach=fn=>{allComponents.forEach(fn);};instance.layout=_ref4=>{let{layoutSettings,rect}=_ref4;const visible=[];const hidden=[];const ordered=[];const layoutFn=getLayoutFn(layoutSettings);recLayout({components:topComponents,hidden,layoutFn,ordered,rect,visible});return {visible,hidden,ordered};};instance.set=_ref5=>{let{components}=_ref5;topComponents=components.map(compSettings=>createComp(compSettings)).filter(c=>!!c);};instance.update=_ref6=>{let{components,data,excludeFromUpdate,formatters,scales}=_ref6;// remove deleted
  removeDeleted(topComponents,components);// Update and add new
  topComponents=addAndUpdate({compList:topComponents,data,excludeFromUpdate,formatters,scales,settingsList:components});};return instance;}/**
   * @callback customLayoutFunction
   * @param {Rect} rect
   * @param {object[]} components
   * @param {string} components[].key
   * @param {object} components[].dockConfig
   * @param {function} components[].resize
   * @param {function} components[].preferredSize
   */ /**
   * Called when the chart has been created
   * @callback ChartDefinition~created
   */ /**
   * Called before the chart has been mounted
   * @callback ChartDefinition~beforeMount
   */ /**
   * Called after the chart has been mounted
   * @callback ChartDefinition~mounted
   * @param {HTMLElement} element The element the chart been mounted to
   */ /**
   * Called before the chart has been rendered
   * @callback ChartDefinition~beforeRender
   */ /**
   * Called before the chart has been updated
   * @callback ChartDefinition~beforeUpdate
   */ /**
   * Called after the chart has been updated
   * @callback ChartDefinition~updated
   */ /**
   * Called before the chart has been destroyed
   * @callback ChartDefinition~beforeDestroy
   */ /**
   * Called after the chart has been destroyed
   * @callback ChartDefinition~destroyed
   */ /**
   * @typedef {ComponentAxis | ComponentBox | ComponentBrushArea | ComponentBrushAreaDir | ComponentBrushLasso | ComponentBrushRange | ComponentContainer | ComponentGridLine | ComponentLabels | ComponentLegendCat | ComponentLegendSeq | ComponentLine | ComponentPie | ComponentPoint | ComponentRefLine | ComponentText | ComponentTooltip} ComponentTypes
   */ /**
   * @typedef {object} ChartSettings
   * @property {ComponentTypes[]} [components] Components
   * @property {object.<string, ScaleDefinition>} [scales] Dictionary with scale definitions
   * @property {object.<string, FormatterDefinition>} [formatters] Dictionary with formatter definitions
   * @property {DockLayoutSettings} [strategy] Dock layout strategy
   * @property {InteractionSettings[]} [interactions] Interaction handlers
   * @property {CollectionSettings[]} [collections] Collections
   */ /**
   * Generic settings available to all components
   * @interface ComponentSettings
   * @property {string} type - Component type (ex: axis, point, ...)
   * @property {function} [preferredSize] - Function returning the preferred size
   * @property {function} [created] Called when the component has been created
   * @property {function} [beforeMount] Called before the component has been mounted
   * @property {function} [mounted] Called after the component has been mounted
   * @property {function} [beforeUpdate] Called before the component has been updated
   * @property {function} [updated] Called after the component has been updated
   * @property {function} [beforeRender] Called before the component has been rendered
   * @property {function} [beforeDestroy] Called before the component has been destroyed
   * @property {function} [destroyed] Called after the component has been destroyed
   * @property {object} [brush] Brush settings
   * @property {BrushTriggerSettings[]} [brush.trigger] Trigger settings
   * @property {BrushConsumeSettings[]} [brush.consume] Consume settings
   * @property {function} [brush.sortNodes] Sorting function for nodes. Should return sorted nodes.
   * @property {object} [layout] Layout settings
   * @property {number} [layout.displayOrder = 0]
   * @property {number} [layout.prioOrder = 0]
   * @property {string | {width: string, height: string}} [layout.minimumLayoutMode] Refer to layout sizes defined by layoutModes in `strategy`
   * @property {string} [layout.dock] left, right, top or bottom
   * @property {boolean} [show = true] If the component should be rendered
   * @property {string} [scale] Named scale. Will be provided to the component if it asks for it.
   * @property {string} [formatter] Named formatter. Fallback to create formatter from scale. Will be provided to the component if it asks for it.
   * @property {ComponentSettings[]} [components] Optional list of child components
   * @property {DockLayoutSettings|customLayoutFunction} [strategy] Layout strategy used for child components.
   * @property {DataExtraction|DataFieldExtraction} [data] Extracted data that should be available to the component
   * @property {RendererSettings} [rendererSettings] Settings for the renderer used to render the component
   * @property {string} [key] Component key
   */ // mark strategy as experimental
  /**
   * @type {DockLayoutSettings|customLayoutFunction}
   * @name strategy
   * @memberof ComponentSettings
   * @experimental
   */ // mark components as experimental
  /**
   * @type {ComponentSettings[]}
   * @name components
   * @memberof ComponentSettings
   * @experimental
   */ /**
   * @typedef {object} BrushTriggerSettings
   * @property {string} [on] Type of interaction to trigger brush on
   * @property {string} [action] Type of interaction to respond with
   * @property {string[]} [contexts] Name of the brushing contexts to affect
   * @property {string[]} [data] The mapped data properties to add to the brush
   * @property {string} [propagation] Control the event propagation when multiple shapes are tapped. Disabled by default
   * @property {string} [globalPropagation] Control the event propagation between components. Disabled by default
   * @property {number} [touchRadius] Extend contact area for touch events. Disabled by default
   * @property {number} [mouseRadius] Extend contact area for regular mouse events. Disabled by default
   * @example
   * {
   *    on: 'tap',
   *    action: 'toggle',
   *    contexts: ['selection', 'tooltip'],
   *    data: ['x'],
   *    propagation: 'stop', // 'stop' => prevent trigger from propagating further than the first shape
   *    globalPropagation: 'stop', // 'stop' => prevent trigger of same type to be triggered on other components
   *    touchRadius: 24,
   *    mouseRadius: 10
   *  }
   */ /**
   * @typedef {object} BrushConsumeSettings
   * @property {string} [context] Name of the brush context to observe
   * @property {string[]} [data] The mapped data properties to observe
   * @property {string} [mode] Data properties operator: and, or, xor.
   * @property {function} [filter] Filtering function
   * @property {object} [style] The style to apply to the shapes of the component
   * @property {object.<string, any>} [style.active] The style of active data points
   * @property {object.<string, any>} [style.inactive] The style of inactive data points
   * @example
   * {
   *    context: 'selection',
   *    data: ['x'],
   *    filter: (shape) => shape.type === 'circle',
   *    style: {
   *      active: {
   *        fill: 'red',
   *        stroke: '#333',
   *        strokeWidth: (shape) => shape.strokeWidth * 2,
   *      },
   *      inactive: {},
   *    },
   * }
   */ /**
   * @typedef {object} RendererSettings
   * @property {RendererSettings~TransformFunction} [transform] Setting for applying transform without re-rendering the whole component completely.
   * @property {RendererSettings~CanvasBufferSize} [canvasBufferSize] Specifies the size of buffer canvas (used together with transform setting).
   * @property {RendererSettings~Progressive} [progressive] Setting for applying progressive rendering to a canvas renderer
   * @experimental
   */ /**
   * Should return a transform object if transformation should be applied, otherwise undefined or a falsy value.
   * Transforms can be applied with the canvas, svg and dom renderer.
   * Transform is applied when running chart.update, see example.
   * !Important: When a transform is applied to a component, the underlaying node representations are not updated with the new positions/sizes, which
   * can cause problems for operations that relies on the positioning of the shapes/nodes (such as tooltips, selections etc). An extra chart update
   * without a transform is therefore needed to make sure the node position information is in sync with the visual representation again.
   * @typedef {function} RendererSettings~TransformFunction
   * @returns {TransformObject}
   * @experimental
   * @example
   * const pointComponentDef = {
   *   type: 'point',
   *   rendererSettings: {
   *     tranform() {
   *       if(shouldApplyTransform) {
   *         return {
   *           horizontalScaling: 1,
   *           horizontalSkewing: 0,
   *           verticalSkewing: 0,
   *           verticalScaling: 1,
   *           horizontalMoving: x,
   *           verticalMoving: y
   *         };
   *       }
   *     }
   *   }
   *   data: {
   * // ............
   *
   * chart.update({ partialData: true });
   */ /**
   * An object containing width and height of the canvas buffer or a function returning an object on that format.
   * Gets a rect object as input parameter.
   * @typedef {function|object} RendererSettings~CanvasBufferSize
   * @experimental
   */ /**
   * A format to represent a transformation.
   * @typedef {object} TransformObject
   * @property {number} horizontalScaling
   * @property {number} horizontalSkewing
   * @property {number} verticalSkewing
   * @property {number} verticalScaling
   * @property {number} horizontalMoving
   * @property {number} verticalMoving
   */ /**
   * A function which returns either (1) false (to specify no progressive rendering used) or an object specifing the data chunk rendered.
   *  This is only applied to a canvas renderer.
   * @typedef {function} RendererSettings~Progressive
   * @returns {ProgressiveObject|boolean}
   * @experimental
   */ /**
   * A format to represent a data chunk to be rendered.
   * @typedef {object} ProgressiveObject
   * @property {number} start - Start index of a data chunk.
   * @property {number} end - End index of a data chunk.
   * @property {boolean} isFirst - If it is the first data chunk rendered. This helps to clear a canvas before rendering.
   * @property {boolean} isLast - If it is the last data chunk rendered. This helps to update other components depending on a component with progressive rendering.
   * @experimental
   */ /**
   * @typedef {object} BrushTargetConfig
   * @property {string} key - Component key
   * @property {string[]} [contexts] - Name of the brushing contexts to affect
   * @property {string[]} [data] - The mapped data properties to add to the brush
   * @property {string} [action='set'] - Type of action to respond with
   */function addComponentDelta(shape,containerBounds,componentBounds){const dx=containerBounds.left-componentBounds.left;const dy=containerBounds.top-componentBounds.top;const type=getShapeType(shape);const deltaShape=extend$1(true,{},shape);switch(type){case'circle':deltaShape.cx+=dx;deltaShape.cy+=dy;break;case'polygon':for(let i=0,num=deltaShape.vertices.length;i<num;i++){const v=deltaShape.vertices[i];v.x+=dx;v.y+=dy;}break;case'geopolygon':// vertices is 2D array
  for(let n=0;n<deltaShape.vertices.length;n++){const vertices=deltaShape.vertices[n];for(let i=0,num=vertices.length;i<num;i++){const v=vertices[i];v.x+=dx;v.y+=dy;}}break;case'line':deltaShape.x1+=dx;deltaShape.y1+=dy;deltaShape.x2+=dx;deltaShape.y2+=dy;break;case'point':case'rect':deltaShape.x+=dx;deltaShape.y+=dy;break;}return deltaShape;}const moveToPosition=(element,comp,index)=>{const el=comp.instance.renderer().element();if(isNaN(index)||!el||!element||!element.children){return;}const nodes=element.children;const i=Math.max(0,index);const node=nodes[i];if(el===node){return;}const additionalEl=comp.instance.def.additionalElements&&comp.instance.def.additionalElements().filter(Boolean);if(element.insertBefore&&typeof node!=='undefined'){element.insertBefore(el,node);if(additionalEl){additionalEl.forEach(ae=>{element.insertBefore(ae,el);});}}else {if(additionalEl){additionalEl.forEach(ae=>{element.appendChild(ae,el);});}element.appendChild(el);}};function orderComponents(element,ordered){const elToIdx=[];let numElements=0;ordered.forEach(comp=>{elToIdx.push(numElements);// assume each component has at least one element
  numElements++;// check additional elements
  const additionalEl=comp.instance.def.additionalElements&&comp.instance.def.additionalElements();if(additionalEl){numElements+=additionalEl.length;}});ordered.forEach((comp,i)=>moveToPosition(element,comp,elToIdx[i]));}function chartFn(definition,context){/**
     * @typedef {object} ChartDefinition
     * @property {ChartDefinition~beforeDestroy} [beforeDestroy]
     * @property {ChartDefinition~beforeMount} [beforeMount]
     * @property {ChartDefinition~beforeRender} [beforeRender]
     * @property {ChartDefinition~beforeUpdate} [beforeUpdate]
     * @property {ChartDefinition~created} [created]
     * @property {ChartDefinition~destroyed} [destroyed]
     * @property {ChartDefinition~mounted} [mounted]
     * @property {ChartDefinition~updated} [updated]
     */let{/**
       * Element to attach chart to
       * @type {HTMLElement}
       * @memberof ChartDefinition
       */element,/**
       * Chart data
       * @type {Array<DataSource>|DataSource}
       * @memberof ChartDefinition
       */data=[],/**
       * Chart settings
       * @type {ChartSettings}
       * @memberof ChartDefinition
       */settings={},on={}}=definition;const registries=context.registries;const logger=context.logger;const theme=themeFn(context.style,context.palettes);const listeners=[];/**
     * Chart instance
     * @alias Chart
     * @interface
     */const instance=extend$1({},definition);const mediator$1=mediator();let visibleComponents=[];let currentScales=null;// Built scales
  let currentFormatters=null;// Built formatters
  let currentScrollApis=null;// Build scroll apis
  let currentInteractions=[];let dataset=()=>{};let dataCollection=()=>{};const brushes={};let stopBrushing=false;const createComponent=compSettings=>{if(!registries.component.has(compSettings.type)){logger.warn("Unknown component: ".concat(compSettings.type));return false;}const componentDefinition=registries.component(compSettings.type);const compInstance=componentFactory(componentDefinition,{settings:compSettings,chart:instance,mediator:mediator$1,registries,theme,container:element});return {instance:compInstance,settings:extend$1(true,{},compSettings),key:compSettings.key,hasKey:typeof compSettings.key!=='undefined'};};const componentsC=collectionFn({createComponent});// Create a callback that calls lifecycle functions in the definition and config (if they exist).
  function createCallback(method){let defaultMethod=arguments.length>1&&arguments[1]!==undefined?arguments[1]:()=>{};return function cb(){const inDefinition=typeof definition[method]==='function';let returnValue;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}if(inDefinition){returnValue=definition[method].call(instance,...args);}else {returnValue=defaultMethod.call(instance,...args);}return returnValue;};}function getElementRect(el){if(typeof el.getBoundingClientRect==='function'){const{width,height}=el.getBoundingClientRect();return {x:0,y:0,width,height};}return {x:0,y:0,width:0,height:0};}const layout=()=>{let layoutSettings;if(settings.dockLayout){logger.warn('Deprecation Warning: "dockLayout" property should be renamed to "strategy"');layoutSettings=settings.dockLayout;}else {layoutSettings=settings.strategy;}const rect=getElementRect(element);return componentsC.layout({layoutSettings,rect});};const created=createCallback('created');const beforeMount=createCallback('beforeMount');const mounted=createCallback('mounted');const beforeUpdate=createCallback('beforeUpdate');const updated=createCallback('updated');const beforeRender=createCallback('beforeRender');const beforeDestroy=createCallback('beforeDestroy');const destroyed=createCallback('destroyed');const set=function(_data,_settings){let{partialData}=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const{formatters={},scales={},scroll={}}=_settings;dataset=datasets(_data,{logger,types:registries.data});if(!partialData){Object.keys(brushes).forEach(b=>brushes[b].clear());}if(_settings.palettes){theme.setPalettes(_settings.palettes);}if(_settings.style){theme.setStyle(_settings.style);}dataCollection=create$p(_settings.collections,{dataset},{logger});const deps={theme,logger};currentScales=collection(scales,{dataset,collection:dataCollection},_objectSpread2$1(_objectSpread2$1({},deps),{},{scale:registries.scale}));currentFormatters=collection$1(formatters,{dataset,collection:dataCollection},_objectSpread2$1(_objectSpread2$1({},deps),{},{formatter:registries.formatter}));currentScrollApis=builder(scroll,currentScrollApis);};const render=()=>{const{components=[]}=settings;beforeRender();set(data,settings);componentsC.set({components});const{visible,hidden,ordered}=layout();visibleComponents=visible;hidden.forEach(comp=>{comp.instance.hide();comp.visible=false;});visible.forEach(comp=>comp.instance.beforeMount());visible.forEach(comp=>comp.instance.mount());visible.forEach(comp=>comp.instance.beforeRender());visible.forEach(comp=>comp.instance.render());visible.forEach(comp=>comp.instance.mounted());visible.forEach(comp=>{comp.visible=true;});orderComponents(element,ordered);};function setInteractions(){let interactions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];const current={};const newKeys=interactions.filter(it=>!!it.key).map(it=>it.key);currentInteractions.forEach(cit=>{if(cit.key&&newKeys.indexOf(cit.key)!==-1){// keep old instance
  current[cit.key]=cit;}else {cit.destroy();}});currentInteractions=interactions.map(intSettings=>{const intDefinition=intSettings.key&&current[intSettings.key]?current[intSettings.key]:registries.interaction(intSettings.type)(instance,mediator$1,element);intDefinition.set(intSettings);return intDefinition;});}const componentsFromPoint=p=>{const br=element.getBoundingClientRect();const x='clientX'in p?p.clientX:p.x;const y='clientY'in p?p.clientY:p.y;const tp={x:x-br.left,y:y-br.top};const ret=[];visibleComponents.forEach(c=>{const r=c.instance.getRect();// Do test on physical rect and use computed rect if available, otherwise fallback to computing a new rect for legacy support
  if(testRectPoint(r.computedPhysical?r.computedPhysical:{x:r.margin.left+r.x*r.scaleRatio.x,y:r.margin.top+r.y*r.scaleRatio.y,width:r.width*r.scaleRatio.x,height:r.height*r.scaleRatio.y},tp)){ret.push(c);}});return ret;};const addDefaultEventListeners=()=>{if(listeners.length||!element){return;}Object.keys(on).forEach(key=>{const listener=on[key].bind(instance);element.addEventListener(key,listener);listeners.push({key,listener});});const eventInfo={};const onTapDown=e=>{if(e.touches){eventInfo.x=e.touches[0].clientX;eventInfo.y=e.touches[0].clientY;eventInfo.multiTouch=e.touches.length>1;}else {eventInfo.x=e.clientX;eventInfo.y=e.clientY;eventInfo.multiTouch=false;}eventInfo.time=Date.now();eventInfo.comps=componentsFromPoint(eventInfo);};const onBrushTap=e=>{const comps=eventInfo.comps||componentsFromPoint(e);if(comps.every(c=>c.instance.def.disableTriggers)){return;}if(e.type==='touchend'){e.preventDefault();}if(!isValidTapEvent(e,eventInfo)){return;}for(let i=comps.length-1;i>=0;i--){const comp=comps[i];comp.instance.onBrushTap(e);if(stopBrushing){stopBrushing=false;break;}}};const onBrushOver=e=>{const comps=componentsFromPoint(e);for(let i=comps.length-1;i>=0;i--){const comp=comps[i];comp.instance.onBrushOver(e);if(stopBrushing){stopBrushing=false;break;}}};const brushEventList=[];brushEventList.push({key:'mousedown',listener:onTapDown});brushEventList.push({key:'mouseup',listener:onBrushTap});if(detectTouchSupport(element)){brushEventList.push({key:'touchstart',listener:onTapDown});brushEventList.push({key:'touchend',listener:onBrushTap});}brushEventList.push({key:'mousemove',listener:onBrushOver});brushEventList.forEach(event=>{element.addEventListener(event.key,event.listener);listeners.push(event);});};const removeDefaultEventListeners=()=>{listeners.forEach(_ref=>{let{key,listener}=_ref;return element.removeEventListener(key,listener);});listeners.length=0;};// Browser only
  const mount=()=>{element.innerHTML='';render();addDefaultEventListeners();setInteractions(settings.interactions);};const unmount=()=>{removeDefaultEventListeners();setInteractions();};/**
     * Layout the chart with new settings and / or data
     * @param {object} [def] - New chart definition
     * @param {Array<DataSource>|DataSource} [def.data] Chart data
     * @param {ChartSettings} [def.settings] Chart settings
     * @param {string[]} [def.excludeFromUpdate=[]] Keys of components to not include in the layout
     * @experimental
     */instance.layoutComponents=function(){let newProps=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{excludeFromUpdate=[]}=newProps;if(newProps.data){data=newProps.data;}if(newProps.settings){settings=newProps.settings;setInteractions(newProps.settings.interactions);}beforeUpdate();set(data,settings);const{formatters,scales,components=[]}=settings;componentsC.update({components,data,excludeFromUpdate,formatters,scales});componentsC.forEach(comp=>{if(comp.updateWith){comp.instance.set(comp.updateWith);}});componentsC.forEach(comp=>{if(comp.updateWith){comp.instance.beforeUpdate();}});layout();// Relayout
  };/**
     * Update the chart with new settings and / or data
     * @param {object} [def] - New chart definition
     * @param {Array<DataSource>|DataSource} [def.data] Chart data
     * @param {ChartSettings} [def.settings] Chart settings
     * @param {boolean} [def.partialData=false] If set to true, will trigger a data update only. Meaning the layout will not be updated
     * @param {string[]} [def.excludeFromUpdate=[]] Keys of components to not include in the update
     */instance.update=function(){let newProps=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{partialData,excludeFromUpdate=[]}=newProps;let visibleOrdered;if(newProps.data){data=newProps.data;}if(newProps.settings){settings=newProps.settings;setInteractions(newProps.settings.interactions);}beforeUpdate();set(data,settings,{partialData});const{formatters,scales,components=[]}=settings;componentsC.update({components,data,excludeFromUpdate,formatters,scales});componentsC.forEach(comp=>{if(comp.updateWith){comp.instance.set(comp.updateWith);}});componentsC.forEach(comp=>{if(comp.updateWith){comp.instance.beforeUpdate();}});const toUpdate=[];const toRender=[];let toRenderOrUpdate;if(partialData){componentsC.forEach(comp=>{if((comp.updateWith||comp.applyTransform)&&comp.visible){toUpdate.push(comp);}});toRenderOrUpdate=toUpdate;}else {const{visible,hidden,ordered}=layout();// Relayout
  visibleComponents=visible;toRenderOrUpdate=visible;visibleOrdered=ordered;visible.forEach(comp=>{if(comp.updateWith&&comp.visible){toUpdate.push(comp);}else {toRender.push(comp);}});hidden.forEach(comp=>{comp.instance.hide();comp.visible=false;delete comp.updateWith;comp.applyTransform=false;});}toRender.forEach(comp=>comp.instance.beforeMount());toRender.forEach(comp=>comp.instance.mount());toRenderOrUpdate.forEach(comp=>comp.instance.beforeRender());toRenderOrUpdate.forEach(comp=>{if((comp.updateWith||comp.applyTransform)&&comp.visible){comp.instance.update();}else {comp.instance.render();}});// Ensure that displayOrder is keept, only do so on re-layout update.
  // Which is only the case if partialData is false.
  if(!partialData){orderComponents(element,visibleOrdered);}toRender.forEach(comp=>comp.instance.mounted());toUpdate.forEach(comp=>comp.instance.updated());visibleComponents.forEach(comp=>{delete comp.updateWith;comp.visible=true;comp.applyTransform=false;});updated();};/**
     * Destroy the chart instance.
     */instance.destroy=()=>{beforeDestroy();componentsC.destroy();unmount();delete instance.update;delete instance.destroy;destroyed();};/**
     * Get all shapes associated with the provided context
     * @param {string} context The brush context
     * @param {string} mode Property comparison mode.
     * @param {Array<string>} props Which specific data properties to compare
     * @param {string} key Which component to get shapes from. Default gives shapes from all components.
     * @return {Array<object>} Array of objects containing shape and parent element
     */instance.getAffectedShapes=function(ctx){let mode=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'and';let props=arguments.length>2?arguments[2]:undefined;let key=arguments.length>3?arguments[3]:undefined;let shapes=[];visibleComponents.filter(comp=>key===undefined||key===null||comp.key===key).forEach(comp=>{const brushedShapes=comp.instance.getBrushedShapes(ctx,mode,props);shapes=[...shapes,...brushedShapes];});return shapes;};/**
     * Get all nodes matching the provided selector
     * @param {string} selector CSS selector [type, attribute, universal, class]
     * @returns {Array<SceneNode>} Array of objects containing matching nodes
     *
     * @example
     * chart.findShapes('Circle') // [<CircleNode>, <CircleNode>]
     * chart.findShapes('Circle[fill="red"][stroke!="black"]') // [CircleNode, CircleNode]
     * chart.findShapes('Container Rect') // [Rect, Rect]
     */instance.findShapes=selector=>{let shapes=[];visibleComponents.forEach(c=>{const matchedShapes=c.instance.findShapes(selector);shapes=[...shapes,...matchedShapes];});return shapes;};/**
     * Get components overlapping a point.
     * @param {Point} p - Point with x- and y-coordinate. The coordinate is relative to the browser viewport.
     * @returns {Array<Component>} Array of component contexts
     */instance.componentsFromPoint=p=>componentsFromPoint(p).map(comp=>comp.instance.ctx);/**
     * Get all nodes colliding with a geometrical shape (circle, line, rectangle, point, polygon, geopolygon).
     *
     * The input shape is identified based on the geometrical attributes in the following order: circle => line => rectangle => point => polygon => geopolygon.
     * Note that not all nodes on a scene have collision detection enabled.
     * @param {Line|Rect|Point|Circle} shape - A geometrical shape. Coordinates are relative to the top-left corner of the chart instance container.
     * @param {object} opts - Options
     * @param {object[]} [opts.components] - Array of components to include in the lookup. If no components are specified, all components will be included.
     * @param {string} [opts.components[].component.key] - Component key
     * @param {string} [opts.components[].component.propagation] - if set to `stop`, will start lookup on top visible shape and propagate downwards until a shape is found.
     * @param {string} [opts.propagation] - if set to `stop`, will start lookup on top visible component and propagate downwards until a component has at least a match.
     * @returns {Array<SceneNode>} Array of objects containing colliding nodes
     *
     * @example
     * chart.shapesAt(
     *  {
     *    x: 0,
     *    y: 0,
     *    width: 100,
     *    height: 100
     *  },
     *  {
     *    components: [
     *      { key: 'key1', propagation: 'stop' },
     *      { key: 'key2' }
     *    ],
     *    propagation: 'stop'
     *  }
     * );
     */instance.shapesAt=function(shape){let opts=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let result=[];const containerBounds=element.getBoundingClientRect();let comps=visibleComponents;// Assume that visibleComponents is ordererd according to displayOrder
  if(Array.isArray(opts.components)&&opts.components.length>0){const compKeys=opts.components.map(c=>c.key);comps=visibleComponents.filter(c=>compKeys.indexOf(c.key)!==-1).map(c=>({instance:c.instance,opts:opts.components[compKeys.indexOf(c.key)]}));}for(let i=comps.length-1;i>=0;i--){const c=comps[i];const componentBounds=c.instance.renderer().element().getBoundingClientRect();const deltaShape=addComponentDelta(shape,containerBounds,componentBounds);const shapes=c.instance.shapesAt(deltaShape,c.opts);const stopPropagation=shapes.length>0&&opts.propagation==='stop';result=[...result,...shapes];if(result.length>0&&stopPropagation){return result;}}return result;};/**
     * Brush data by providing a collection of data bound shapes.
     * @param {SceneNode[]} shapes - An array of data bound shapes.
     * @param {object} config - Options
     * @param {BrushTargetConfig[]} config.components - Array of components to include in the lookup
     *
     * @example
     * const shapes = chartInstance.shapesAt(...);
     * const config = {
     *  components:[
     *    {
     *      key: 'key1',
     *      contexts: ['myContext'],
     *      data: [''],
     *      action: 'add'
     *    }
     *  ]
     * };
     * chartInstance.brushFromShapes(shapes, config);
     */instance.brushFromShapes=function(shapes){let config=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{components:[]};for(let i=0;i<config.components.length;i++){const iKey=config.components[i].key;visibleComponents.filter(c=>iKey===c.key).forEach(c=>{let compShapes=shapes.filter(shape=>shape.key===c.key);c.instance.brushFromShapes(compShapes,config.components[i]);});}};/**
     * @private
     * @param {string} name - Name of scroll api
     * @returns {object}
     */instance.scroll=function scroll(){let name=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'default';return getOrCreateScrollApi(name,currentScrollApis);};/**
     * Get
     * @param {string} key - Get the dataset identified by `key`
     * @returns {Dataset}
     */instance.dataset=key=>dataset(key);instance.dataCollection=key=>dataCollection(key);/**
     * Get all registered scales
     * @returns {Object<string,Scale>}
     */instance.scales=function scales(){return currentScales.all();};/**
     * Get all registered formatters
     * @returns {Object<string,formatter>}
     */instance.formatters=function formatters(){return currentFormatters.all();};/**
     * Get or create brush context for this chart
     * @param {string} name - Name of the brush context. If no match is found, a new brush context is created and returned.
     * @returns {Brush}
     */instance.brush=function brushFn(){let name=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'default';if(!brushes[name]){brushes[name]=brush();}return brushes[name];};/**
     * Get or create a scale for this chart
     * @param {string|object} v - Scale reference or scale options
     * @returns {Scale}
     * @example
     * instance.scale('nameOfMyScale'); // Fetch an existing scale by name
     * instance.scale({ scale: 'nameOfMyScale' }); // Fetch an existing scale by name
     * instance.scale({ source: '0/1', type: 'linear' }); // Create a new scale
     */instance.scale=function scale(v){return currentScales.get(v);};/**
     * Get or create a formatter for this chart
     * @param {string|object} v - Formatter reference or formatter options
     * @returns {formatter}
     * @example
     * instance.formatter('nameOfMyFormatter'); // Fetch an existing formatter by name
     * instance.formatter({ formatter: 'nameOfMyFormatter' }); // Fetch an existing formatter by name
     * instance.formatter({ type: 'q' }); // Fetch an existing formatter by type
     * instance.formatter({
     *  formatter: 'd3',
     *  type: 'number',
     *  format: '1.0.%'
     * }); // Create a new formatter
     */instance.formatter=function formatter(v){return currentFormatters.get(v);};/**
     * @param {boolean} [val] - Toggle brushing on or off. If value is omitted, a toggle action is applied to the current state.
     */instance.toggleBrushing=function toggleBrushing(val){if(typeof val!=='undefined'){stopBrushing=val;}else {stopBrushing=!stopBrushing;}};/**
     * Get a component context
     * @param {string} key - Component key
     * @returns {Component} Component context
     */instance.component=key=>{const component=componentsC.findComponentByKey(key);return component===null||component===void 0?void 0:component.instance.ctx;};instance.logger=()=>logger;instance.theme=()=>theme;instance.storage=createStorage({animations:{updatingStageMeta:{isInit:false,shouldBeRemoved:false}}});/**
     * Interaction instance
     * @typedef {object} Interaction
     * @property {function} on Enable interaction
     * @property {function} off Disable interaction
     * @property {function} destroy Destroy interaction
     * @property {string} key Interaction identifier
     */ /**
     * Get all interaction instances
     * @name Chart.interactions
     * @type {object}
     * @example
     * chart.interactions.instances; // Array of all interaction instances
     * chart.interactions.on(); // Toggle on all interactions instances
     * chart.interactions.off(); // Toggle off all interactions instances
     */Object.defineProperty(instance,'interactions',{get(){return/** @lends Chart.interactions */{/** @type Array<Interaction> */instances:currentInteractions,/** Enable all interaction instances */on(){addDefaultEventListeners();currentInteractions.forEach(i=>i.on());},/** Disable all interaction instances */off(){removeDefaultEventListeners();currentInteractions.forEach(i=>i.off());}};}});created();if(element){beforeMount();mount();mounted(element);instance.element=element;}return instance;}const rendererRegistry=reg=>{let f=registryFactory(reg);f.prio=p=>p?f.default(p[0]):[f.default()];f.types=()=>f.getKeys();return f;};var componentRegistry=registryFactory();function datumExtract$2(propCfg,cell,_ref){let{key}=_ref;const datum={value:typeof propCfg.value==='function'// eslint-disable-line no-nested-ternary
  ?propCfg.value(cell):typeof propCfg.value!=='undefined'?propCfg.value:cell};datum.label=typeof propCfg.label==='function'// eslint-disable-line no-nested-ternary
  ?propCfg.label(cell):typeof propCfg.label!=='undefined'?String(propCfg.label):String(datum.value);if(propCfg.field){datum.source={key,field:propCfg.field.key()};}return datum;}function extract$2(config,dataset){const cfgs=Array.isArray(config)?config:[config];let dataItems=[];cfgs.forEach(cfg=>{if(typeof cfg.field!=='undefined'){const f=dataset.field(cfg.field);const sourceKey=dataset.key();if(!f){throw Error("Field '".concat(cfg.field,"' not found"));}const{props,main}=getPropsInfo(cfg,dataset);const propsArr=Object.keys(props);const track$1=!!cfg.trackBy;const trackType=typeof cfg.trackBy;const tracker={};const trackedItems=[];const items=f.items();const mapped=[];for(let idx=0;idx<items.length;idx++){const mainCell=items[idx];const exclude=main.filter&&!main.filter(mainCell);if(exclude){continue;}const ret=datumExtract$2(main,mainCell,{key:sourceKey});// loop through all props that need to be mapped and
  // assign 'value' and 'source' to each property
  propsArr.forEach(prop=>{const p=props[prop];let propCell=p.field?p.field.items()[idx]:mainCell;ret[prop]=datumExtract$2(p,propCell,{key:sourceKey});});// collect items based on the trackBy value
  // items with the same trackBy value are placed in an array and reduced later
  if(track$1){track({cfg,itemData:mainCell,obj:ret,target:trackedItems,tracker,trackType});}mapped.push(ret);}// reduce if items have been grouped
  if(track$1){dataItems=[...dataItems,...collect(trackedItems,{main,propsArr,props})];}else {dataItems=[...dataItems,...mapped];}}});return dataItems;}const filters={numeric:values=>values.filter(v=>typeof v==='number'&&!isNaN(v))};function createFields$1(_ref){let{source,data,cache,config}=_ref;let headers;let content=data;const parse=config&&config.parse;if(Array.isArray(data[0])){// assume 2d matrix of data
  if(parse&&parse.headers===false){headers=data[0].map((v,i)=>i);}else {headers=data[0];content=data.slice(1);}}else {headers=Object.keys(data[0]);}const rowFn=!!parse&&typeof parse.row==='function'&&parse.row;let flds=headers;if(parse&&typeof parse.fields==='function'){flds=parse.fields(flds.slice());}else {flds=headers.map(h=>({key:h,title:h}));}let fieldValues;if(Array.isArray(data[0])){fieldValues=flds.map(()=>[]);}else {fieldValues={};flds.forEach(f=>{fieldValues[f.key]=[];});}for(let r=0;r<content.length;r++){const row=rowFn?rowFn(content[r],r,flds):content[r];if(!row){continue;}if(Array.isArray(row)){for(let c=0;c<flds.length;c++){fieldValues[c].push(row[c]);}}else {for(let c=0;c<flds.length;c++){fieldValues[flds[c].key].push(row[flds[c].key]);}}}const fv=Array.isArray(fieldValues)?i=>fieldValues[i]:i=>fieldValues[flds[i].key];for(let c=0;c<flds.length;c++){const values=fv(c);const numericValues=filters.numeric(values);const isMeasure=numericValues.length>0;const type=isMeasure?'measure':'dimension';const min=isMeasure?Math.min(...numericValues):NaN;const max=isMeasure?Math.max(...numericValues):NaN;cache.fields.push(field(extend$1({source,key:c,title:flds[c].title,values,min,max,type},flds[c]),{value:flds[c].value,label:flds[c].label}));}}const dsv=_ref2=>{let{data,config}=_ref2;const rows=data.split('\n');const row0=rows[0];const row1=rows[1];let delimiter=',';if(config&&config.parse&&config.parse.delimiter){delimiter=config.parse.delimiter;}else if(row0){// guess delimiter
  const guesses=[/,/,/\t/,/;/];for(let i=0;i<guesses.length;i++){const d=guesses[i];if(row0&&row1){if(d.test(row0)&&d.test(row1)&&row0.split(d).length===row1.split(d).length){delimiter=d;break;}}else if(d.test(row0)){delimiter=d;}}}return rows.map(row=>row.split(delimiter));};const parseData=_ref3=>{let{key,data,cache,config}=_ref3;if(!data){return;}let dd=data;if(typeof dd==='string'){// assume dsv
  dd=dsv({data,config});}if(!Array.isArray(dd)){return;// warn?
  }createFields$1({data:dd,cache,source:key,config});};/**
   * Create a new dataset with default settings
   * @private
   * @return {Dataset}
   */function ds(){let{key,data,config}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const cache={fields:[]};/**
     * @alias Dataset
     * @interface
     */const dataset={/**
       * Get the key identifying this dataset
       * @returns {string}
       */key:()=>key,/**
       * Get the raw data
       * @returns {any}
       */raw:()=>data,/**
       * Find a field within this dataset
       * @param {string} query - The field to find
       * @returns {Field}
       */field:query=>findField$1(query,{cache,matrix:data}),/**
       * Get all fields within this dataset
       * @returns {Array<Field>}
       */fields:()=>cache.fields.slice(),/**
       * Extract data items from this dataset
       * @param {DataExtraction~Extract|DataFieldExtraction} config
       * @returns {Array<DatumExtract>}
       */extract:cfg=>extract$2(cfg,dataset),/**
       * @returns {null}
       */hierarchy:()=>null};parseData({key,data,config,cache});return dataset;}ds.util={normalizeConfig:getPropsInfo,collect,track};/**
   * Callback function. Should return the key to stack by
   * @callback
   * @typedef {function} DataExtraction~StackKeyCallback
   * @param {DatumExtract} datum The extracted datum
   * @returns {any} The data value to stack by
   */ /**
   * Callback function. Should return the data value to stack with
   * @callback
   * @typedef {function} DataExtraction~StackValueCallback
   * @param {DatumExtract} datum The extracted datum
   * @returns {any} The data value to stack with
   */ /**
   * Callback function to filter the extracted data items
   * @callback
   * @typedef {function} DataExtraction~FilterCallback
   * @param {DatumExtract} datum The extracted datum
   * @returns {boolean} Return true if the datum should be included in the final data set
   */ /**
   * Callback function to sort the extracted data items
   * @callback
   * @typedef {function} DataExtraction~SortCallback
   * @param {DatumExtract} a The extracted datum
   * @param {DatumExtract} b The extracted datum
   * @returns {number} If less than 0, sort a before b. If greater than 0, sort b before a
   */ /**
   * Used to extract data from a `DataSource`
   * @typedef {object} DataExtraction
   * @property {DataExtraction~Extract|DataExtraction~Extract[]} extract Extract definition
   * @property {object} [stack] If provided, defines how the data should be stacked
   * @property {DataExtraction~StackKeyCallback} stack.stackKey Callback function. Should return the key to stack by
   * @property {DataExtraction~StackValueCallback} stack.value Callback function. Should return the data value to stack with
   * @property {DataExtraction~FilterCallback} [filter] Callback function to filter the extracted data items
   * @property {DataExtraction~SortCallback} [sort] Callback function to sort the extracted data items
   * @example
  {
    extract: [{
      source: 'Products',
      field: 'Product',
      value: d => d.name,
      label: d => `<${d.name}>`
      props: {
        year: { field: 'Year' }
        num: { field: 'Sales' }
      }
    }],
    filter: d => d.label !== 'Sneakers', // extract everything except Sneakers
    sort: (a, b) => a.label > b.label ? -1 : 1, // sort descending
  }
   */ /**
   * @typedef {object} DataFieldExtraction
   * @property {string} source - Which data source to extract from
   * @property {string} field - The field to extract data from
   * @property {DataExtraction~Extract~ValueFn|string|number|boolean} [value] - The field value accessor
   * @property {DataExtraction~Extract~LabelFn|string|number|boolean} [label] - The field label accessor
   * @example
   * {
   *  source: 'Products',
   *  field: 'Sales',
   *  value: (val) => Math.round(val),
   *  label: (val) => `<${val}>`
   * }
   */ /**
   * Data extraction definition. Define how and what kind of data should be extracted from a `DataSource`.
   * @typedef {object} DataExtraction~Extract
   * @property {string} source - Which data source to extract from
   * @property {string} field - The field to extract data from
   * @property {DataExtraction~Extract~ValueFn|string|number|boolean} [value] - The field value accessor
   * @property {DataExtraction~Extract~LabelFn|string|number|boolean} [label] - The field label accessor
   * @property {DataExtraction~Extract~TrackByFn} [trackBy] - Track by value accessor
   * @property {DataExtraction~Extract~ReduceFn|string} [reduce] - Reducer function
   * @property {DataExtraction~Extract~ReduceLabelFn|string} [reduceLabel] - Label reducer function
   * @property {DataExtraction~Extract~FilterFn} [filter] - Filter function
   * @property {object.<string, DataExtraction~Extract~Props>} [props] - Additional properties to add to the extracted item
   * @example
   * {
      source: 'Products',
      field: 'Product',
      value: (val) => val,
      label: (val) => `<${val}>`
      props: {
        year: { field: 'Year' }
        num: { field: 'Sales' }
      }
    }
   */ /**
   * @typedef {object} DataExtraction~Extract~Props
   * @property {string} field - The field to extract data from
   * @property {DataExtraction~Extract~ValueFn|string|number|boolean} [value] - The field value accessor
   * @property {DataExtraction~Extract~LabelFn|string|number|boolean} [label] - The field label accessor
   * @example
   * {
   *  field: 'Sales',
   *  value: (val) => Math.round(val),
   *  label: (val) => `<${val}>`
   * }
   */ /**
   * Value callback function
   * @callback DataExtraction~Extract~ValueFn
   * @param {any} cell The field cell
   * @returns {any}
   */ /**
   * Label callback function
   * @callback DataExtraction~Extract~LabelFn
   * @param {any} cell The field cell
   * @returns {string}
   */ /**
   * Filter callback function
   * @callback DataExtraction~Extract~FilterFn
   * @param {any} cell The field cell
   * @returns {boolean}
   */ /**
   * TrackBy callback function
   * @callback DataExtraction~Extract~TrackByFn
   * @param {any} cell The field cell
   * @returns {any}
   */ /**
   * Reduce callback function
   * @callback DataExtraction~Extract~ReduceFn
   * @param {any[]} values The collected values to reduce
   * @returns {any}
   */ /**
   * ReduceLabel callback function
   * @callback DataExtraction~Extract~ReduceLabelFn
   * @param {any[]} labels The collected labels to reduce
   * @param {any} value Reduced value
   * @returns {string}
   */ /**
   * @typedef {object} DatumExtract
   * @property {any} value - The extracted value
   * @property {string} label - The extracted value as a string
   * @property {object} source - The data source of the extracted data
   * @property {string} source.key - The data-source key
   * @property {string} source.field - The source field
   */const dataRegistry=registryFactory();dataRegistry.default('matrix');dataRegistry('matrix',ds);dataRegistry('default',ds);// deprecated
  /**
   * Manages event handlers for native events
   * @private
   */function native(chart,mediator,element){let instance={chart,mediator,element};let nativeEvents=[];let settings;let itKey;let isOn=true;/**
     * Set default settings
     * @private
     */function setDefaultSettings(newSettings){itKey=newSettings.key;settings=newSettings;settings.events=settings.events||[];if(settings.enable===undefined){settings.enable=true;}}/**
     * Add native events based on settings
     * @private
     */function addEvents(){if(typeof settings.enable==='function'){settings.enable=settings.enable.bind(instance)();}if(!settings.enable){return;// interaction is disabled
  }Object.keys(settings.events).forEach(key=>{const listener=settings.events[key].bind(instance);element.addEventListener(key,listener);nativeEvents.push({key,listener});});}/**
     * Removes all added native events
     * @private
     */function removeAddedEvents(){// remove added native events
  nativeEvents.forEach(_ref=>{let{key,listener}=_ref;element.removeEventListener(key,listener);});nativeEvents=[];}return {/**
       * Getter for the key.
       * @private
       */get key(){return itKey;},/**
       * Updates this with new settings
       * @private
       * @param {object} newSettings
       * @param {string} [newSettings.type] - The interaction type. Is 'native' for this component
       * @param {boolean|function} [newSettings.enable=true] - Should the interactions defined here be enabled or not.
       * This is only run when adding event handlers. In effect at startup, update or during on/off.
       * It does not run during every event loop.
       * @param {array} [newSettings.gestures] - The keys in this object is the names of native events
       * that should be added to the chart element and they should all point to function which
       * will be the corresponding event handler.
       */set(newSettings){setDefaultSettings(newSettings);removeAddedEvents();if(isOn){addEvents();}},/**
       * Turns off interactions
       * @private
       */off(){isOn=false;removeAddedEvents();},/**
       * Turns off interactions
       * @private
       */on(){isOn=true;if(nativeEvents.length===0){addEvents();}},/**
       * Destroys and unbinds all event handlers
       * @private
       */destroy(){removeAddedEvents();instance=null;settings=null;}};}/**
   * @interface InteractionSettings
   * @property {string} type Type of interaction handler
   * @property {string} [key] Unique key identifying the handler
   * @property {function|boolean} enable Enable or disable the interaction handler. If a callback function is provided, it must return either true or false
   * @example
   * {
   *  type: 'native',
   *  key: 'nativeHandler',
   *  enable: () => true,
   *  events: { // "events" is a property specific to the native handler
   *    mousemove: (e) => console.log('mousemove', e),
   *  }
   * }
   */const reg$3=registryFactory();reg$3('native',native);/**
   * Short-hand for max(min())
   *
   * @param {number} min Minimum allowed value
   * @param {number} max Maximum allowed value
   * @param {number} value The actual value to cap
   * @ignore
   */function cap(min,max,value){return Math.max(min,Math.min(max,value));}/**
   * Resolve a diff, i.e. resolveDiff(0.2, 0.6, 1, 100) = 20
   *
   * @param {object} params parameters
   * @param {number} params.start Normalized start value
   * @param {number} params.end Normalized end value
   * @param {number} params.minPx The minimum number of pixels
   * @param {number} params.maxPx Maximum number of pixels, i.e. the width or height
   * @ignore
   */function resolveDiff(_ref){let{start,end,minPx=0.1,maxPx=1}=_ref;const high=Math.max(start,end);const low=Math.min(start,end);const highModified=cap(-0.1,1.2,high);const lowModified=cap(-0.1,1.2,low);const wantedDiff=highModified*maxPx-lowModified*maxPx;const actualDiff=Math.max(minPx,wantedDiff);const startModifier=(actualDiff-wantedDiff)/2;const actualLow=lowModified*maxPx-startModifier;return {actualDiff,startModifier,actualLow};}/**
   * Out of bounds shape
   * @param {object} params parameters
   * @param {object} params.item Resolved styling item from box component with item.major
   * @param {number} params.value 0 or 1 depending on where to render the oob shape
   * @param {number} params.boxWidth Un-calculated box width in relative/normalized format
   * @param {number} params.boxPadding Un-calculated box padding in relative/normalized format
   * @param {number} params.rendWidth The pixel width of the area to render upon
   * @param {number} params.rendHeight The pixel height of the area to render upon
   * @param {boolean} params.flipXY Wether or not to flip X and Y coordinates together with Width and Height
   * @param {function} params.symbol Symbol library function from component
   * @ignore
   */function oob(_ref){let{item,value,boxCenter,rendWidth,rendHeight,flipXY,symbol}=_ref;let x='x';let y='y';let calcwidth=rendWidth;let calcheight=rendHeight;let startAngle=value<0.5?90:-90;if(flipXY){x='y';y='x';calcwidth=rendHeight;calcheight=rendWidth;startAngle=value<0.5?180:0;}return symbol(extend$1({},item.oob,{[x]:boxCenter*calcwidth,[y]:Math.max(item.oob.size/2,Math.min(value*calcheight,calcheight-item.oob.size/2)),startAngle}));}/**
   * Box shape calculation function
   * @param {object} params parameters
   * @param {object} params.item Resolved styling item from box component with item.major
   * @param {number} params.boxWidth Un-calculated box width in relative/normalized format
   * @param {number} params.boxPadding Un-calculated box padding in relative/normalized format
   * @param {number} params.rendWidth The pixel width of the area to render upon
   * @param {number} params.rendHeight The pixel height of the area to render upon
   * @param {boolean} params.flipXY wether or not to flip X and Y coordinates together with Width and Height
   * @ignore
   */function box$1(_ref2){let{item,boxWidth,boxPadding,rendWidth,rendHeight,flipXY}=_ref2;let x='x';let y='y';let width='width';let height='height';let calcwidth=rendWidth;let calcheight=rendHeight;if(flipXY){x='y';y='x';width='height';height='width';calcwidth=rendHeight;calcheight=rendWidth;}const{actualDiff,actualLow}=resolveDiff({start:item.start,end:item.end,minPx:item.box.minHeightPx,maxPx:calcheight});return extend$1({},item.box,{type:'rect',[x]:(boxPadding+item.major)*calcwidth,[y]:actualLow,[height]:actualDiff,[width]:boxWidth*calcwidth,data:item.data||{},collider:{type:null}});}/**
   * A vertical line shape (for start - min, end - max values)
   * @param {object} params parameters
   * @param {object} params.item Resolved styling item from box component with item.major
   * @param {number} params.from Normalized from value
   * @param {number} params.to Normalized to value
   * @param {number} params.boxCenter Center coordinate for the box
   * @param {number} params.rendWidth The pixel width of the area to render upon
   * @param {number} params.rendHeight The pixel height of the area to render upon
   * @param {boolean} params.flipXY wether or not to flip X and Y coordinates together with Width and Height
   * @ignore
   */function verticalLine(_ref3){let{item,from,to,boxCenter,rendWidth,rendHeight,flipXY}=_ref3;let x1='x1';let y1='y1';let x2='x2';let y2='y2';let calcwidth=rendWidth;let calcheight=rendHeight;if(flipXY){x1='y1';y1='x1';x2='y2';y2='x2';calcwidth=rendHeight;calcheight=rendWidth;}return extend$1({},item.line,{type:'line',[y2]:Math.floor(from*calcheight),[x1]:boxCenter*calcwidth,[y1]:Math.floor(to*calcheight),[x2]:boxCenter*calcwidth,data:item.data||{},collider:{type:null}});}/**
   * A horizontal line shape (for median and whiskers)
   * @param {object} params parameters
   * @param {object} params.item Resolved styling item from box component with item.major
   * @param {string} params.key Which key to use as style base in the item object
   * @param {number} params.position At which "height" (X) to position the horizontal line
   * @param {number} params.width Width of the horizontal line (i.e. box width or a multiple of it)
   * @param {number} params.boxCenter Center coordinate for the box
   * @param {number} params.rendWidth The pixel width of the area to render upon
   * @param {number} params.rendHeight The pixel height of the area to render upon
   * @param {boolean} params.flipXY wether or not to flip X and Y coordinates together with Width and Height
   * @ignore
   */function horizontalLine(_ref4){let{item,key,position,width,boxCenter,rendWidth,rendHeight,flipXY}=_ref4;let x1='x1';let y1='y1';let x2='x2';let y2='y2';let calcwidth=rendWidth;let calcheight=rendHeight;if(flipXY){x1='y1';y1='x1';x2='y2';y2='x2';calcwidth=rendHeight;calcheight=rendWidth;}const halfWidth=width/2;return extend$1({type:'line'},item[key],{[y1]:Math.floor(position*calcheight),[x1]:(boxCenter-halfWidth)*calcwidth,[y2]:Math.floor(position*calcheight),[x2]:(boxCenter+halfWidth)*calcwidth,r:halfWidth*calcwidth,cx:boxCenter*calcwidth,cy:position*calcheight,width:width*calcwidth,data:item.data||{},collider:{type:null}});}/**
   * A horizontal line shape (for median and whiskers)
   * @param {number} bandwidth The current bandwidth for this item
   * @param {object} item A resolved style item to render with major and box width variables, minWidthPx and maxWidthPx
   * @param {number} maxMajorWidth The actual maximum major width
   * @ignore
   */function getBoxWidth(bandwidth,item,maxMajorWidth){const{width,maxWidthPx,minWidthPx}=item.box;const sign=bandwidth>=0?1:-1;let boxWidth=Math.min(sign*bandwidth*width,isNaN(maxWidthPx)?maxMajorWidth:maxWidthPx/maxMajorWidth);boxWidth=isNaN(minWidthPx)?boxWidth:Math.max(minWidthPx/maxMajorWidth,boxWidth);return boxWidth*sign;}function buildShapes(_ref){let{width,height,flipXY,resolved,keys,symbol}=_ref;// if (!settings || !settings.major || !settings.major.scale || !settings.minor || !settings.minor.scale) {
  //   return [];
  // }
  const output=[];const majorItems=resolved.major.items;if(!majorItems.length){return output;}const rendWidth=width;const rendHeight=height;const maxMajorWidth=flipXY?height:width;const majorSettings=resolved.major.settings;const minorProps=['start','end','min','max','med'].filter(prop=>typeof resolved.minor.settings[prop]!=='undefined');const numMinorProps=minorProps.length;const nonOobKeys=keys.filter(key=>key!=='oob');let children;let major;let minorItem;let boxWidth;let boxPadding;let boxCenter;let isLowerOutOfBounds;let isHigherOutOfBounds;let isOutOfBounds;const numKeys=keys?keys.length:0;const numNonOobKeys=nonOobKeys?nonOobKeys.length:0;function addBox(){/* THE BOX */if(minorItem.box&&isNumber$1(minorItem.start)&&isNumber$1(minorItem.end)){children.push(box$1({item:minorItem,boxWidth,boxPadding,rendWidth,rendHeight,flipXY}));}}function addLine(){/* LINES MIN - START, END - MAX */if(isNumber$1(minorItem.min)&&isNumber$1(minorItem.start)){children.push(verticalLine({item:minorItem,from:minorItem.min,to:minorItem.start,boxCenter,rendWidth,rendHeight,flipXY}));}if(isNumber$1(minorItem.max)&&isNumber$1(minorItem.end)){children.push(verticalLine({item:minorItem,from:minorItem.max,to:minorItem.end,boxCenter,rendWidth,rendHeight,flipXY}));}}function addMedian(){/* MEDIAN */if(minorItem.median&&isNumber$1(minorItem.med)){children.push(horizontalLine({item:minorItem,key:'median',position:minorItem.med,width:boxWidth,boxCenter,rendWidth,rendHeight,flipXY}));}}function addWhisker(){/* WHISKERS */if(minorItem.whisker){const whiskerWidth=boxWidth*minorItem.whisker.width;if(isNumber$1(minorItem.min)){children.push(horizontalLine({item:minorItem,key:'whisker',position:minorItem.min,width:whiskerWidth,boxCenter,rendWidth,rendHeight,flipXY}));}if(isNumber$1(minorItem.max)){children.push(horizontalLine({item:minorItem,key:'whisker',position:minorItem.max,width:whiskerWidth,boxCenter,rendWidth,rendHeight,flipXY}));}}}function addOutOfBounds(){/* OUT OF BOUNDS */if(isLowerOutOfBounds){children.push(oob({item:minorItem,value:0,boxCenter,rendWidth,rendHeight,flipXY,symbol}));}else if(isHigherOutOfBounds){children.push(oob({item:minorItem,value:1,boxCenter,rendWidth,rendHeight,flipXY,symbol}));}}const addMarkerList={box:addBox,line:addLine,median:addMedian,whisker:addWhisker};function checkOutOfBounds(){let value;let max=-Number.MAX_VALUE;let min=Number.MAX_VALUE;for(let n=0;n<numMinorProps;n++){value=minorItem[minorProps[n]];if(isNumber$1(value)){if(max<value){max=value;}if(min>value){min=value;}}}isLowerOutOfBounds=max<0&&max!==-Number.MAX_VALUE;isHigherOutOfBounds=min>1&&min!==Number.MAX_VALUE;isOutOfBounds=isLowerOutOfBounds||isHigherOutOfBounds;}for(let i=0,len=majorItems.length;i<len;i++){children=[];major=null;const majorItem=majorItems[i];const d=majorItem.data;let majorVal=null;let majorEndVal=null;if(typeof majorSettings.binStart!=='undefined'){// if start and end is defined
  majorVal=majorItem.binStart;majorEndVal=majorItem.binEnd;major=majorSettings.binStart.scale;}else {major=majorSettings.major.scale;majorVal=major?majorItem.major:0;}let bandwidth=0;if(!major){bandwidth=1;}else if(major.bandwidth){bandwidth=major.bandwidth();majorVal-=bandwidth/2;}else {bandwidth=majorEndVal-majorVal;}minorItem=extend$1({},{major:majorVal,majorEnd:majorEndVal},resolved.minor.items[i]);for(let j=0;j<numKeys;j++){minorItem[keys[j]]=resolved[keys[j]].items[i];}boxWidth=getBoxWidth(bandwidth,minorItem,maxMajorWidth);boxPadding=(bandwidth-boxWidth)/2;boxCenter=boxPadding+minorItem.major+boxWidth/2;checkOutOfBounds();if(!isOutOfBounds){for(let k=0;k<numNonOobKeys;k++){if(minorItem[nonOobKeys[k]]&&minorItem[nonOobKeys[k]].show===false){continue;}addMarkerList[nonOobKeys[k]]();}}else if(minorItem.oob){addOutOfBounds();}const container={type:'container',data:d,collider:{type:'bounds'},children};output.push(container);}return output;}/**
   * Resolve a complex object using the built-in resolver from this.resolver in component
   * @ignore
   */function complexResolver(_ref){let{keys,data,defaultSettings,style,settings,width,height,resolver}=_ref;const defaults=extend$1(true,{},defaultSettings||{},style||{});const scaled={major:settings.orientation==='horizontal'?height:width,minor:settings.orientation==='horizontal'?width:height};const majorSettings=settings.major;let majorResolved;if(typeof majorSettings==='object'&&typeof majorSettings.ref==='object'&&typeof majorSettings.ref.start!=='undefined'&&typeof majorSettings.ref.end!=='undefined'){// temporary backwards compatibility
  majorResolved=resolver.resolve({data,defaults:{start:0,end:1},scaled,settings:extend$1(true,{},{binStart:{scale:settings.major.scale,ref:settings.major.ref.start},binEnd:{scale:settings.major.scale,ref:settings.major.ref.end}})});}else if(typeof majorSettings==='object'&&typeof majorSettings.binStart!=='undefined'&&typeof majorSettings.binEnd!=='undefined'){majorResolved=resolver.resolve({data,defaults:{start:0,end:1},scaled,settings:extend$1(true,{},{binStart:{scale:settings.major.scale,ref:'binStart'},binEnd:{scale:settings.major.scale,ref:'binEnd'}},settings.major)});}else {majorResolved=resolver.resolve({data,scaled,defaults:{major:0.5},settings:{major:settings.major}});}const minorSettings=settings.minor||{};const defaultMinorSettings={};['start','end','min','max','med'].forEach(prop=>{if(minorSettings[prop]||data.items&&data.items.length&&data.items[0][prop]){defaultMinorSettings[prop]={scale:minorSettings.scale,ref:prop};}});const minorResolved=resolver.resolve({data,defaults:{start:0,end:1},scaled,settings:extend$1(true,{},defaultMinorSettings,minorSettings)});let key;let ext={major:majorResolved,minor:minorResolved};for(let ki=0,len=keys.length;ki<len;ki++){if(!settings[key]||settings[key].show!==false){key=keys[ki];ext[key]=resolver.resolve({data,defaults:defaults[key],settings:settings[key],scaled});}}return ext;}const DEFAULT_DATA_SETTINGS$2={oob:{show:true,type:'n-polygon',fill:'#999',stroke:'#000',strokeWidth:0,size:10,sides:3,startAngle:-90},box:{show:true,fill:'#fff',stroke:'#000',strokeWidth:1,strokeLinejoin:'miter',width:1,maxWidthPx:undefined,minWidthPx:1,minHeightPx:1},line:{show:true,stroke:'#000',strokeWidth:1},median:{show:true,stroke:'#000',strokeWidth:1},whisker:{show:true,stroke:'#000',strokeWidth:1,fill:'',type:'line',width:1}};const dataKeys=Object.keys(DEFAULT_DATA_SETTINGS$2);const component$3={require:['chart','resolver','symbol'],defaultSettings:{settings:{},data:{},style:{box:'$shape',line:'$shape-guide',whisker:'$shape-guide',median:'$shape-guide--inverted'}},created(){this.state={};},render(_ref){let{data}=_ref;const{width,height}=this.rect;const flipXY=this.settings.settings.orientation==='horizontal';const{style,resolver,symbol}=this;const keys=dataKeys.filter(key=>!this.settings.settings[key]||this.settings.settings[key].show!==false);const defaultSettings={};keys.forEach(key=>defaultSettings[key]=DEFAULT_DATA_SETTINGS$2[key]);const resolved=complexResolver({keys,data,defaultSettings,style,settings:this.settings.settings,width,height,resolver});const{settings,items}=resolved;const shapes=buildShapes({items,settings,width,height,flipXY,resolved,keys,symbol});return shapes;}};function box(picasso){picasso.component('box',component$3);picasso.component('box-marker',component$3);// temporary backwards compatibility - DEPRECATED
  }/**
   * @typedef {object} ComponentBox
   * @extends ComponentSettings
   * @property {'box'} type component type
   * @example
   * {
   *   type: "box",
   *   data: {
   *    mapTo: {
   *      min: { source: "/qHyperCube/qMeasureInfo/0" },
   *      start: { source: "/qHyperCube/qMeasureInfo/1" },
   *      med: { source: "/qHyperCube/qMeasureInfo/2" },
   *      end: { source: "/qHyperCube/qMeasureInfo/3" },
   *      max: { source: "/qHyperCube/qMeasureInfo/4" },
   *    },
   *    groupBy: {
   *      source: "/qHyperCube/qDimensionInfo/0"
   *    }
   *  },
   *  settings: {
   *    major: {
   *      scale: { source: "/qHyperCube/qDimensionInfo/0" }
   *    },
   *    minor: {
   *      scale: { source: ["/qHyperCube/qMeasureInfo/0",
   *               "/qHyperCube/qMeasureInfo/1",
   *               "/qHyperCube/qMeasureInfo/2",
   *               "/qHyperCube/qMeasureInfo/3",
   *               "/qHyperCube/qMeasureInfo/4"] }
   *    }
   *  }
   * }
   */ /**
   * @typedef {object} ComponentBox.settings
   * @property {object} major
   * @property {string} major.scale The scale to use along the major (dimension) axis
   * @property {string|ComponentBox~MajorReference} [major.ref='self'] Reference to the data property along the major axis
   * @property {object} minor
   * @property {string} minor.scale The scale to use along the minor (measure) axis
   * @property {string} [orientation='vertical'] Which orientation to use (vertical or horizontal)
   * @property {object} [box] Visual properties for the box shape in the box marker
   * @property {boolean} [box.show=true] Boolean for showing the box shape
   * @property {string} [box.fill='#fff']
   * @property {string} [box.stroke='#000']
   * @property {number} [box.strokeWidth=1]
   * @property {string} [box.strokeLinejoin='miter']
   * @property {number} [box.width=1]
   * @property {number} [box.maxWidthPx=100] Maximum width of the box in pixels (not applicable when using major start and end)
   * @property {number} [box.minWidthPx=1] Minimum width of the box in pixels (not applicable when using major start and end)
   * @property {number} [box.minHeightPx=1] Minimum height of the box shape
   * @property {object} [line] Visual properties for lines between min-start, end-max.
   * @property {boolean} [line.show=true]
   * @property {string} [line.stroke='#000']
   * @property {number} [line.strokeWidth=1]
   * @property {object} [whisker] All the visual properties for whiskers at min and max.
   * @property {boolean} [whisker.show=true]
   * @property {string} [whisker.stroke='#000']
   * @property {number} [whisker.strokeWidth=1]
   * @property {number} [whisker.width=1]
   * @property {object} [median] Visual properties for the median
   * @property {boolean} [median.show=true]
   * @property {string} [median.stroke='#000']
   * @property {number} [median.strokeWidth=1]
   * @property {object} [oob] EXPERIMENTAL: Out of bounds symbol utilizing the symbol API
   * @property {boolean} [oob.show=true]
   * @property {string} [oob.type='n-polygon'] Type of the symbol to be used
   * @property {string} [oob.fill='#999'] Fill color of the symbol
   * @property {string} [oob.stroke='#000'] Stroke color
   * @property {number} [oob.strokeWidth=0] Stroke width
   * @property {number} [oob.size=10] Size/width of the symbol in pixels
   * @property {number} [oob.sides=3] Number of sides for a n-polygon (3 for triangle)
   */ /**
   * @typedef {object} ComponentBox~MajorReference
   * @property {string} start Reference to the data property of the start value along the major axis
   * @property {string} end Reference to the data property of the end value along the major axis
   */ /**
   * @typedef {object} ComponentBox.data
   * @property {number} [min] Min
   * @property {number} [max] Max
   * @property {number} [start] Start of box
   * @property {number} [end] End of box
   * @property {number} [med] Median
   */const DEFAULT_ERROR_SETTINGS={errorShape:{shape:'saltire',width:2,size:0.5,fill:'#333',stroke:'#333',strokeWidth:0}};const PX_RX=/px$/;/**
   * Component settings
   * @typedef {object=}
   * @alias ComponentPoint.settings
   */const DEFAULT_DATA_SETTINGS$1={/** Type of shape
     * @type {DatumString=} */shape:'circle',/** Label
     * @type {DatumString=} */label:'',/** Fill color
     * @type {DatumString=} */fill:'#333',/** Stroke color
     * @type {DatumString=} */stroke:'#ccc',/** Stroke dash array
     * @type {DatumString=} */strokeDasharray:'',/** Stroke width
     * @type {DatumNumber=} */strokeWidth:0,/** Stroke line join
     * @type {DatumString=} */strokeLinejoin:'miter',/** Opacity of shape
     * @type {DatumNumber=} */opacity:1,/** Normalized x coordinate
     * @type {DatumNumber=} */x:0.5,/** Normalized y coordinate
     * @type {DatumNumber=} */y:0.5,/** Normalized size of shape
     * @type {DatumNumber=} */size:1,/** Whether or not to show the point
     * @type {DatumBoolean=} */show:true};/**
   * @typedef {object=}
   * @alias ComponentPoint.settings.sizeLimits
   */const SIZE_LIMITS={/** Maximum size of shape, in pixels
     * @type {number=} */maxPx:10000,/** Minimum size of shape, in pixels
     * @type {number=} */minPx:1,/** Maximum size relative linear scale extent
     * @type {number=} */maxRelExtent:0.1,/** Minimum size relative linear scale extent
     * @type {number=} */minRelExtent:0.01,/** Maximum size relative discrete scale banwidth
     * @type {number=} */maxRelDiscrete:1,/** Minimum size relative discrete scale banwidth
     * @type {number=} */minRelDiscrete:0.1};function getPxSpaceFromScale(s,space){if(s&&typeof s.bandwidth==='function'){// some kind of ordinal scale
  return {isBandwidth:true,value:Math.max(1,s.bandwidth()*space)};}return {isBandwidth:false,value:Math.max(1,space)};}function getPointSizeLimits(x,y,width,height,limits){const xSpacePx=getPxSpaceFromScale(x?x.scale:undefined,width);const ySpacePx=getPxSpaceFromScale(y?y.scale:undefined,height);let maxSizePx=Math.min(xSpacePx.value*limits[xSpacePx.isBandwidth?'maxRelDiscrete':'maxRelExtent'],ySpacePx.value*limits[ySpacePx.isBandwidth?'maxRelDiscrete':'maxRelExtent']);let minSizePx=Math.min(xSpacePx.value*limits[xSpacePx.isBandwidth?'minRelDiscrete':'minRelExtent'],ySpacePx.value*limits[ySpacePx.isBandwidth?'minRelDiscrete':'minRelExtent']);const min=Math.max(1,Math.floor(minSizePx));const max=Math.max(1,Math.floor(maxSizePx));return {min,max,maxGlobal:limits.maxPx,minGlobal:limits.minPx};}function getType(s){let type=DEFAULT_DATA_SETTINGS$1.shape;let props={};if(typeof s.shape==='object'&&typeof s.shape.type==='string'){type=s.shape.type;props=s.shape;}else if(typeof s.shape==='string'){type=s.shape;}return [type,props];}function createDisplayPoints(dataPoints,_ref,pointSize,shapeFn){let{width,height}=_ref;return dataPoints.filter(p=>p.show!==false&&!isNaN(p.x+p.y)).map(p=>{let s=p;let size=PX_RX.test(p.size)?parseInt(p.size,10):pointSize.min+s.size*(pointSize.max-pointSize.min);if(notNumber(size)){s=DEFAULT_ERROR_SETTINGS.errorShape;size=pointSize.min+s.size*(pointSize.max-pointSize.min);}const[type,typeProps]=getType(s);const shapeSpec=_objectSpread2$1(_objectSpread2$1({},typeProps),{},{type,label:p.label,x:p.x*width,y:p.y*height,fill:s.fill,size:Math.min(pointSize.maxGlobal,Math.max(pointSize.minGlobal,size)),stroke:s.stroke,strokeWidth:s.strokeWidth,strokeDasharray:s.strokeDasharray,opacity:s.opacity});if(s===p.errorShape){shapeSpec.width=s.width;}const shape=shapeFn(shapeSpec);shape.data=p.data;return shape;});}const component$2={require:['chart','resolver','symbol'],defaultSettings:{settings:{},data:{},animations:{enabled:false,trackBy:node=>node.data.value},style:{item:'$shape'}},render(_ref2){let{data}=_ref2;const resolved=this.resolver.resolve({data,defaults:extend$1({},DEFAULT_DATA_SETTINGS$1,this.style.item),settings:this.settings.settings,scaled:{x:this.rect.width,y:this.rect.height}});const{width,height}=this.rect;const limits=extend$1({},SIZE_LIMITS,this.settings.settings.sizeLimits);const points=resolved.items;const pointSize=getPointSizeLimits(resolved.settings.x,resolved.settings.y,width,height,limits);return createDisplayPoints(points,this.rect,pointSize,this.settings.shapeFn||this.symbol);}};/**
   * @typedef {object} ComponentPoint
   * @property {'point'} type component type
   * @extends ComponentSettings
   * @example
  {
    type: 'point',
    data: {
      extract: {
        field: 'Month',
        props: {
          x: { field: 'Margin' },
          y: { field: 'Year' }
        }
      }
    },
    settings: {
      x: { scale: 'm' },
      y: { scale: 'y' },
    }
  }
   */const type$3='point';function pointMarker(picasso){picasso.component(type$3,component$2);picasso.component('point-marker',component$2);// temporary backwards compatibility - DEPRECATED
  }/**
   * Component settings
   * @typedef {object}
   * @alias ComponentPie.settings
   */const DEFAULT_DATA_SETTINGS={/** Start angle of the pie, in radians
     * @type {number=} */startAngle:0,/** End angle of the pie, in radians
     * @type {number=} */endAngle:2*Math.PI,/**
     * @typedef {object}
     */slice:{label:'',/** Absolute value of the slice's arc length
       * @type {number=} */arc:1,/** Visibility of the slice
       * @type {boolean=} */show:true,/** Fill color of the slice
       * @type {string=} */fill:'#333',/** Stroke color of the slice
       * @type {string=} */stroke:'#ccc',/** Stroke width of the slice
       * @type {number=} */strokeWidth:1,/** Stroke line join
       * @type {string=} */strokeLinejoin:'round',/** Opacity of the slice
       * @type {number=} */opacity:1,/** Inner radius of the slice
       * @type {number=} */innerRadius:0,/** Outer radius of the slice
       * @type {number=} */outerRadius:0.8,/** Corner radius of the slice, in pixels
       * @type {number=} */cornerRadius:0,/** Radial offset of the slice
       * @type {number=} */offset:0}};/**
   * @typedef {object} ComponentPie
   * @extends ComponentSettings
   * @property {'pie'} type component type
   * @example
   * {
   *   type: 'pie',
   *   data: {
   *     extract: {
   *       field: 'Region',
   *       props: {
   *         num: { field: 'Population' }
   *       }
   *     }
   *   },
   *   settings: {
   *     startAngle: Math.PI / 2,
   *     endAngle: -Math.PI / 2,
   *     slice: {
   *       arc: { ref: 'num' },
   *       fill: 'green',
   *       stroke: 'red',
   *       strokeWidth: 2,
   *       strokeLinejoin: 'round',
   *       innerRadius: 0.6,
   *       outerRadius 0.8,
   *       opacity: 0.8,
   *       offset: 0.2
   *     }
   *   }
   * }
   */function offsetSlice(centroid,offset,outerRadius,innerRadius){let[vx,vy]=centroid;const vlen=Math.sqrt(vx*vx+vy*vy);vx/=vlen;vy/=vlen;const diff=outerRadius-innerRadius;return {x:vx*offset*diff,y:vy*offset*diff};}function createDisplayPies(arcData,_ref,slices,sum){let{x,y,width,height}=_ref;const arcGen=arc();const center={x:x+width/2,y:y+height/2};const innerRadius=Math.min(width,height)/2;const outerRadius=Math.min(width,height)/2;const cornerRadius=outerRadius/100;return arcData.map((a,i)=>{const slice=slices[i];slice.type='path';const or=outerRadius*slice.outerRadius;const ir=innerRadius*slice.innerRadius;const cr=cornerRadius*slice.cornerRadius;arcGen.innerRadius(ir);arcGen.outerRadius(or);arcGen.cornerRadius(cr);slice.arcDatum=a;const centroid=arcGen.centroid(a);const offset=slice.offset?offsetSlice(centroid,slice.offset,or,ir):{x:0,y:0};slice.transform="translate(".concat(offset.x,", ").concat(offset.y,") translate(").concat(center.x,", ").concat(center.y,")");slice.desc={share:a.value/sum,slice:{start:a.startAngle,end:a.endAngle,innerRadius:ir,outerRadius:or,cornerRadius:cr,offset:{x:center.x+offset.x,y:center.y+offset.y}}};return slice;});}function arcValue(stngs,item){if(stngs.slice&&'arc'in stngs.slice){return item.arc;}return item.data.value;}const pieComponent={require:['chart','resolver'],defaultSettings:{settings:{startAngle:0,endAngle:2*Math.PI,padAngle:0,slice:{}},style:{slice:'$shape'},data:{}},render(_ref2){let{data}=_ref2;const arcValues=[];const slices=[];const stngs=this.settings.settings;const{items}=this.resolver.resolve({data,defaults:extend$1({},DEFAULT_DATA_SETTINGS.slice,this.style.slice),settings:stngs.slice});let sum=0;for(let i=0,len=items.length;i<len;i++){const val=arcValue(stngs,items[i]);if(val>0&&items[i].outerRadius>=items[i].innerRadius){arcValues.push(val);slices.push(items[i]);sum+=val;}}const pieGen=pie$1().sortValues(null);pieGen.startAngle(stngs.startAngle);pieGen.endAngle(stngs.endAngle);pieGen.padAngle(stngs.padAngle);const arcData=pieGen(arcValues);return createDisplayPies(arcData,extend$1({},this.rect,{x:0,y:0}),slices,sum);}};function pie(picasso){picasso.component('pie',pieComponent);}/**
   * Create a crispifier
   * @ignore
   *
   * @param  {Object} [crispMap] Optional crispmap if you need custom crisping.
   * @return {Function}          crispItem function
   *
   * @example
   * import { crispifierFactory } from "core/crispifier";
   *
   * let crispify = crispifierFactory(customCrispMap);
   *
   * // For a single item
   * crispify(myItem);
   *
   * // For multiple items
   * crispify.multiple(myArrayOfItems);
   */function crispifierFactory(crispMap){// Define the crispMap
  if(crispMap===undefined){crispMap={};crispMap.line={append:['x1','x2','y1','y2'],round:[],condition:item=>item.x1===item.x2||item.y1===item.y2,conditionAppend:item=>item.strokeWidth%2!==0};crispMap.rect={append:['x','y'],round:['width','height'],condition:()=>true,conditionAppend:item=>item.strokeWidth%2!==0};}// Re-map the crispmap
  Object.keys(crispMap).forEach(type=>{const self=crispMap[type];self.items=[];self.append.forEach(toAppend=>{self.items.push({key:toAppend,type:'append'});});self.round.forEach(toAppend=>{self.items.push({key:toAppend,type:'round'});});});/**
     * Crispify a single item
     * @ignore
     * @param  {Object} item  Item with renderer variables such as X, Y, and type.
     * @return {Undefined}    Returns nothing, modifies the original item instead
     */function crispItem(item){if(crispMap[item.type]&&crispMap[item.type].condition(item)){const self=crispMap[item.type];const doAppend=self.conditionAppend===undefined||self.conditionAppend(item);self.items.forEach(i=>{const rounded=Math.round(item[i.key]);const diff=item[i.key]-rounded;item[i.key]=rounded;if(doAppend&&i.type==='append'){if(diff>0){item[i.key]+=0.5;}else {item[i.key]-=0.5;}}});}}/**
     * Crispify multiple items
     * @ignore
     *
     * @param  {Array} items  Array of objects to crispify
     * @return {Undefined}    Returns nothing, modifies the original item instead
     */crispItem.multiple=items=>items.forEach(item=>crispItem(item));return crispItem;}const crispifier=crispifierFactory();class Transposer{/**
     * @private
     */constructor(){this.reset();this.push(...arguments);}/**
     * Evaluate a key for a transposed coordinate
     *
     * @param  {String} key   Key
     * @return {String}         Actual key
     */static evaluateKey(key,flipXY){if(flipXY){const firstChar=key.substring(0,1);const rest=key.substring(1);if(firstChar==='x'){return "y".concat(rest);}if(firstChar==='y'){return "x".concat(rest);}if(key==='cx'){return 'cy';}if(key==='cy'){return 'cx';}if(key==='width'){return 'height';}if(key==='height'){return 'width';}}return key;}/**
     * Transpose a coordinate according to this.flipXY and
     * the available rendering area
     *
     * @param  {String} key        The key of the coordinate to transpose
     * @param  {Number} coordinate The coordinate
     * @return {Number}            The actual location of the coordinate
     */transposeCoordinate(key,coordinate,flipXY){if(typeof coordinate==='number'&&isFinite(coordinate)){const firstChar=key.substring(0,1);if(firstChar==='x'||key==='cx'){return coordinate*this.width;}if(key==='width'){return coordinate*this.width;}if(key==='r'){return coordinate*(!flipXY?this.width:this.height);}if(firstChar==='y'||key==='cy'){return coordinate*this.height;}if(key==='height'){return coordinate*this.height;}}return coordinate;}/**
     * Push an item into the storage of the transposer
     *
     * @param  {Object} items An item to be drawed
     * @return {Object}       Can be chained
     */push(){this.storage.push(...arguments);return this;}processItem(item){let newItem={};const flipXY=typeof item.flipXY!=='undefined'?item.flipXY:this.flipXY;const crisp=typeof item.crisp!=='undefined'?item.crisp:this.crisp;if(item.fn&&typeof item.fn==='function'){let width=flipXY?this.height:this.width;let height=flipXY?this.width:this.height;item=item.fn({width,height,flipXY});const objectKeys=Object.keys(item);for(let ki=0,kl=objectKeys.length;ki<kl;ki++){let key=objectKeys[ki];const nkey=Transposer.evaluateKey(key,flipXY);newItem[nkey]=item[key];}}else {const objectKeys=Object.keys(item);for(let ki=0,kl=objectKeys.length;ki<kl;ki++){let key=objectKeys[ki];const nkey=Transposer.evaluateKey(key,flipXY);const nval=this.transposeCoordinate(nkey,item[key],flipXY);newItem[nkey]=nval;}}if(crisp){crispifier(newItem);}return newItem;}/**
     * Get the output of the transposer
     *
     * @return {Array}   Array of objects
     */output(){let items=[];for(let i=0,l=this.storage.length;i<l;i++){let newItem=this.processItem(this.storage[i]);items.push(newItem);}return items;}/**
     * Reset the transposer
     *
     * @return {Undefined}  Does not return anything
     */reset(){this.storage=[];this.flipXY=false;this.crisp=false;this.width=0;this.height=0;}}function transposer(){for(var _len=arguments.length,items=new Array(_len),_key=0;_key<_len;_key++){items[_key]=arguments[_key];}return new Transposer(...items);}/**
   * Generate array of lines (ticks) from scale
   *
   * @param {object} scale - A scale supplied by the chart
   * @param {object} settings - The settings object from the grid line component
   * @param {object} rect - The rect containing width and height to renderer in
   * @returns {array} - Returns an array of ticks
   * @ignore
   */function lineGen(scale,distance){if(!scale||!distance){return [];}return scale.cachedTicks&&scale.cachedTicks()||scale.ticks({distance});}const gridLineComponent={created(){},require:['chart','renderer','resolver'],defaultSettings:{layout:{displayOrder:0},style:{// Theming style
  ticks:'$guide-line',minorTicks:'$guide-line--minor'}},beforeRender(){this.blueprint=transposer();this.blueprint.width=this.rect.width;this.blueprint.height=this.rect.height;this.blueprint.x=this.rect.x;this.blueprint.y=this.rect.y;this.blueprint.crisp=true;},render(){// Setup scales
  this.x=this.settings.x?this.chart.scale(this.settings.x):null;this.y=this.settings.y?this.chart.scale(this.settings.y):null;updateScaleSize(this,'x',this.rect.width);updateScaleSize(this,'y',this.rect.height);// Return an empty array to abort rendering when no scales are available to renderer
  if(!this.x&&!this.y){return [];}this.settings.ticks=extend$1({show:true},this.style.ticks,this.settings.ticks||{});this.settings.minorTicks=extend$1({show:false},this.style.minorTicks,this.settings.minorTicks||{});// Setup lines for X and Y
  this.lines={x:[],y:[]};// Use the lineGen function to generate appropriate ticks
  this.lines.x=lineGen(this.x,this.rect.width);this.lines.y=lineGen(this.y,this.rect.height);// Set all Y lines to flipXY by default
  // This makes the transposer flip them individually
  this.lines.y=this.lines.y.map(i=>extend$1(i,{flipXY:true}));let addTicks=_ref=>{let{dir,isMinor}=_ref;let items=this.lines[dir].filter(tick=>!!tick.isMinor===isMinor);let settings=isMinor?this.settings.minorTicks:this.settings.ticks;let ticks=this.resolver.resolve({settings,data:{items,dir}}).items;ticks.forEach(style=>{let p=style.data;// If the style's show is falsy, don't renderer this item (to respect axis settings).
  if(style.show){var _p$value,_p$data;// Use the transposer to handle actual positioning
  this.blueprint.push({type:'line',x1:p.position,y1:0,x2:p.position,y2:1,stroke:style.stroke||'black',strokeWidth:typeof style.strokeWidth!=='undefined'?style.strokeWidth:1,strokeDasharray:typeof style.strokeDasharray!=='undefined'?style.strokeDasharray:undefined,flipXY:p.flipXY||false,// This flips individual points (Y-lines)
  value:(_p$value=p.value)!==null&&_p$value!==void 0?_p$value:(_p$data=p.data)===null||_p$data===void 0?void 0:_p$data.value,dir});}});};addTicks({dir:'x',isMinor:false});addTicks({dir:'x',isMinor:true});addTicks({dir:'y',isMinor:false});addTicks({dir:'y',isMinor:true});return this.blueprint.output();}};/**
   * @typedef {object} ComponentGridLine
   * @extends ComponentSettings
   * @property {'grid-line'} type component type
   * @example
   * {
   *  type: 'grid-line',
   *  settings: {
   *    x: {
   *      scale: '<name-of-scale>',
   *    },
   *    y: {
   *      scale: '<name-of-scale>',
   *    },
   *  },
   * }
   */ /**
   * Component settings
   * @typedef {object} ComponentGridLine.settings
   * @property {object} x
   * @property {string} x.scale - The scale to use along x
   * @property {object} y
   * @property {string} y.scale - The scale to use along y
   * @property {object} [ticks]
   * @property {boolean} [ticks.show=true]
   * @property {string} [ticks.stroke='black']
   * @property {number} [ticks.strokeWidth='1']
   * @property {string} [ticks.strokeDasharray]
   * @property {object} [minorTicks]
   * @property {boolean} [minorTicks.show=true]
   * @property {string} [minorTicks.stroke='black']
   * @property {number} [minorTicks.strokeWidth='1']
   * @property {string} [minorTicks.strokeDasharray]
   */function gridLine(picasso){picasso.component('grid-line',gridLineComponent);}/**
   * Return a D property for a SVG path to get a direction marker
   *
   * @param {number} x - X coordinate
   * @param {number} y - Y coordinate
   * @param {number} r - Radius
   * @param {string} [d='bottom'] - Direction
   * @returns {string} - Finished D property
   * @ignore
   */function directionMarker(x,y,r){let d=arguments.length>3&&arguments[3]!==undefined?arguments[3]:'bottom';r*=0.8;if(d==='left'||d==='right'){let right=d==='right';return "\n      M ".concat(x," ").concat(y-r,"\n      A ").concat(r*1.25," ").concat(r*1.25,", 0, 1, ").concat(right?0:1,", ").concat(x," ").concat(y+r,"\n      L ").concat(right?x+r:x-r," ").concat(y," Z\n    ");}let bottom=d==='bottom';return "\n    M ".concat(x-r," ").concat(y,"\n    A ").concat(r*1.25," ").concat(r*1.25,", 0, 1, ").concat(bottom?1:0,", ").concat(x+r," ").concat(y,"\n    L ").concat(x," ").concat(bottom?y+r:y-r," Z\n  ");}function directionTriangle(x,y,r){let d=arguments.length>3&&arguments[3]!==undefined?arguments[3]:'bottom';r*=0.75;if(d==='left'||d==='right'){let right=d==='right';x+=right?r*1.5:-(r*1.5);return "\n      M ".concat(x," ").concat(y-r,"\n      L ").concat(x," ").concat(y+r,"\n      L ").concat(right?x+r:x-r," ").concat(y," Z\n    ");}let bottom=d==='bottom';y+=bottom?r*1.5:-(r*1.5);return "\n    M ".concat(x-r," ").concat(y,"\n    L ").concat(x+r," ").concat(y,"\n    L ").concat(x," ").concat(bottom?y+r:y-r," Z\n  ");}/**
   * Handle out of bound shapes
   * Does not return anything, modifies "items" property instead (should be re-considered)
   *
   * @param {object} oob - Out of bounds object from parent
   * @param {object} settings - Settings object from parent
   * @param {object[]} items - Array of all items (for collision detection)
   * @ignore
   */function oobManager(_ref){let{blueprint,oob,settings,items}=_ref;const oobKeys=Object.keys(oob);let style=settings.style.oob||{};for(let i=0,len=oobKeys.length;i<len;i++){const key=oobKeys[i];const value=oob[key];if(value.length>0){let position=key.charAt(1);let flipXY=key.charAt(0)==='y';let xPadding=style.padding.x+style.width;let yPadding=style.padding.y+style.width;let direction='bottom';if(flipXY){direction=position==='1'?'bottom':'top';}else {direction=position==='1'?'right':'left';}let indicator=blueprint.processItem({fn:_ref2=>{let{width,height}=_ref2;/* eslint no-loop-func: 0 */let x=position*width+(position==='1'?-xPadding:xPadding);let y=flipXY?yPadding:height-yPadding;if(style.type==='arc'){return {type:'path',d:directionMarker(flipXY?y:x,flipXY?x:y,style.width,direction),x,y,stroke:style.stroke,fill:style.fill,strokeWidth:style.strokeWidth||0};}return {type:'circle',cx:x,cy:y,r:style.width,stroke:style.stroke,fill:style.fill,strokeWidth:style.strokeWidth||0,opacity:style.opacity,data:value};},flipXY});let x=indicator.cx||indicator.x;let y=indicator.cy||indicator.y;let text={type:'text',text:value.length||'',x:x-style.width*0.4,y:y+style.width*0.4,fontFamily:style.text.fontFamily,fontSize:"".concat(style.width*1.3,"px"),stroke:style.text.stroke,fill:style.text.fill,strokeWidth:style.text.strokeWidth||0,opacity:style.text.opacity};let triangle={type:'path',d:directionTriangle(x,y,style.width,direction),x,y,stroke:style.triangle.stroke,fill:style.triangle.fill,strokeWidth:style.triangle.strokeWidth||0,opacity:style.triangle.opacity};items.push(indicator,text,triangle);}}}function refLabelDefaultSettings(){return {fill:'#000',fontFamily:'Arial',fontSize:'12px',opacity:1,maxWidth:1,maxWidthPx:9999,padding:5,background:{fill:'#fff',stroke:'transparent',strokeWidth:0,opacity:0.5}};}/**
   * Converts a numerical OR string value to a normalized value
   *
   * @param {string|number} align -Description how to align (Numerical from 0-1 or 'top', 'left', 'center', 'middle', 'bottom' or 'right')
   * @returns {number} - Normalized value 0...1
   * @ignore
   */function alignmentToNumber(align){if(typeof align==='undefined'){return 0;}if(typeof align==='number'&&isFinite(align)){return align;}if(typeof align==='string'){switch(align){case'center':case'middle':return 0.5;case'bottom':case'right':return 1;case'top':case'left':default:return 0;}}return 0;}/**
   * Create line and label (if applicable)
   * Does not return anything, modifies "items" property instead (should be re-considered)
   *
   * @param {object} p - Current point
   * @param {object} style - Applicable line styling
   * @param {object} settings - Settings object derived from parent
   * @param {object[]} items - Array of all items (for collision detection)
   * @ignore
   */function createLineWithLabel(_ref){let{chart,blueprint,renderer,p,settings,items}=_ref;let doesNotCollide=true;let line=false;let rect=false;let label=false;let value=false;let style=extend$1(true,{},settings.style.line,p.line||{});// Use the transposer to handle actual positioning
  line=blueprint.processItem({type:'line',x1:p.position,y1:0,x2:p.position,y2:1,stroke:style.stroke||'black',strokeWidth:style.strokeWidth||1,strokeDasharray:style.strokeDasharray,flipXY:p.flipXY||false,// This flips individual points (Y-lines)
  value:p.valueInfo?p.valueInfo.id:p.value});if(p.label){const item=extend$1(true,refLabelDefaultSettings(),settings.style.label||{},{fill:style.stroke},p.label);let formatter;let measuredValue={width:0,height:0};let valueString='';if(typeof p.formatter==='string'){formatter=chart.formatter(p.formatter);}else if(typeof p.formatter==='object'){formatter=chart.formatter(p.formatter);}else if(typeof p.scale!=='undefined'&&p.scale.data){// TODO - Add support for array as source into formatter
  const scaleData=p.scale.data()&&p.scale.data().fields;formatter=scaleData&&scaleData[0]?scaleData[0].formatter():null;}if(p.label.showValue!==false){if(formatter){valueString=" (".concat(formatter(p.value),")");}else if(p.scale){valueString=" (".concat(p.value,")");}}if(valueString){measuredValue=renderer.measureText({text:valueString,fontFamily:item.fontFamily,fontSize:item.fontSize});}// Measure the label text
  let measuredLabel=renderer.measureText({text:item.text||'',fontFamily:item.fontFamily,fontSize:item.fontSize});let measured={width:measuredLabel.width+measuredValue.width,height:Math.max(measuredLabel.height,measuredValue.height)};let labelPadding=item.padding;// let anchor = item.anchor === 'end' ? 'end' : 'start';
  let align=alignmentToNumber(p.flipXY?item.vAlign:item.align);let vAlign=alignmentToNumber(p.flipXY?item.align:item.vAlign);let calcWidth=Math.min(1+measured.width+labelPadding*2,item.maxWidth*blueprint.width,item.maxWidthPx);let calcHeight=measured.height+labelPadding*2;let rectWidth=p.flipXY?calcHeight:calcWidth;let rectHeight=p.flipXY?calcWidth:calcHeight;rect=blueprint.processItem({fn:_ref2=>{let{width,height}=_ref2;let x=p.position*width-(p.flipXY?calcHeight:calcWidth)*(1-align);x=p.flipXY?x:Math.max(x,0);const y=Math.max(Math.abs(vAlign*height-rectHeight*vAlign),0);return {type:'rect',x,y,width:p.flipXY?rectWidth:Math.min(rectWidth,blueprint.width-x),height:rectHeight,stroke:item.background.stroke,strokeWidth:item.background.strokeWidth,fill:item.background.fill,opacity:item.background.opacity};},flipXY:p.flipXY||false// This flips individual points (Y-lines)
  });if(rect.x<-1||rect.x+rect.width>blueprint.width+1||rect.y<-1||rect.y+rect.height>blueprint.height+1){// do not create labels if out of bounds
  rect=undefined;}else {// Labels are just basic objects attached to a corner of a rect,
  // and this rect needs to already be processed
  // so there is no blueprint.processItem required here
  label={type:'text',text:item.text||'',fill:item.fill,opacity:item.opacity,fontFamily:item.fontFamily,fontSize:item.fontSize,x:rect.x+labelPadding,y:rect.y+rect.height/2+measured.height/3,maxWidth:rect.width-labelPadding*2-measuredValue.width,anchor:'start'};if(valueString){value={type:'text',text:valueString||'',fill:item.fill,opacity:item.opacity,fontFamily:item.fontFamily,fontSize:item.fontSize,x:label.x+3+(rect.width-(measuredValue.width+labelPadding*2)),y:label.y};}// Detect collisions with other labels/rects or lines
  for(let i=0,len=items.length;i<len;i++){let curItem=items[i];if(curItem.type==='rect'){// We only detect rects here, since rects are always behind labels,
  // and we wouldn't want to measure text one more time
  if(testRectRect(rect,curItem)){doesNotCollide=false;}}else if(curItem.type==='line'){// This will only collide when flipXY are the same for both objects,
  // So it only collides on objects on the same "axis"
  if(p.flipXY===curItem.flipXY&&testRectLine(rect,curItem)){doesNotCollide=false;}}}}}// Always push the line,
  // but this is done after collision detection,
  // because otherwise it would collide with it's own line
  items.push(line);// Only push rect & label if we haven't collided and both are defined
  if(doesNotCollide&&rect&&label){items.push(rect,label);if(value){items.push(value);}}}function createOobData(line){const data={value:line.value};if(line.label){data.label=line.label.text;}return data;}function filterUndefinedValue(line){const value=typeof line.value==='function'?line.value():line.value;return typeof value!=='undefined';}function isInvert(scale){const range=scale.range();return (range===null||range===void 0?void 0:range.length)===2&&range[0]>range[1];}function getPosition(scale,value){const min=scale.min();const max=scale.max();if(min===max){const invert=isInvert(scale);if(value<min){return invert?2:-1;}if(value>min){return invert?-1:2;}}return scale(value);}/**
   * Component settings
   * @typedef {object} ComponentRefLine.settings
   * @property {object} lines - X & Y Lines
   * @property {ComponentRefLine~Line[]} [lines.x=[]] - Reference lines along X axis
   * @property {ComponentRefLine~Line[]} [lines.y=[]] - Reference lines along Y axis
   */ /**
   * @private
   * @typedef {object} ComponentRefLine.style
   * @property {refline-oob-style} [oob=ComponentRefLine.style.oob] - Style for out of bounds object (oob)
   * @property {ComponentRefLine~Line} [line=ComponentRefLine~Line] - Generic style for lines
   * @property {ComponentRefLine~LineLabel} [label=ComponentRefLine~LineLabel] - Generic style for labels
   */ /**
   * @typedef {object} ComponentRefLine.style.oob
   * @property {boolean} [show=true] - Show out of bounds items
   * @property {string} [type=undefined] - EXPERIMENTAL:  Set this to 'arc' for an experimental out of bounds shape (only works with SVG)
   * @property {number} [width=10] - Width of the out of bounds object
   * @property {string} [fill='#1A1A1A'] - Fill color of the OOB object
   * @property {string} [stroke='transparent'] - Stroke of the OOB object
   * @property {number} [strokeWidth=0] - Stroke width of the OOB object
   * @property {number} [opacity=1] - Opacity of the OOB object
   * @property {ComponentRefLine~GenericText} [text=ComponentRefLine~GenericText] - Text configuration for out of bounds
   * @property {ComponentRefLine~GenericObject} [triangle=ComponentRefLine~GenericObject] - The triangle in OOB
   * @property {object} [padding] - Padding on X
   * @property {number} [padding.x=28] - Padding on X
   * @property {number} [padding.y=5] - Padding on X
   */ /**
   * @typedef {object} ComponentRefLine~GenericText
   * @property {string} [text=''] - Text (if applicable)
   * @property {string} [fontSize='12px'] - Font size (if applicable)
   * @property {string} [fontFamily='Arial'] - Font family
   * @property {string} [fill='#fff'] - Fill color
   * @property {string} [stroke='transparent'] - Stroke
   * @property {number} [strokeWidth=0] - Stroke width
   * @property {string} [strokeDasharray] - Stroke dash array
   * @property {number} [opacity=1] - Opacity
   */ /**
   * @typedef {object} ComponentRefLine~Line
   * @property {number|function} value - The value of the reference line. If a scale is specified, it is applied.
   * @property {string} [scale] - Scale to use (if undefined will use normalized value 0-1)
   * @property {ComponentRefLine~GenericObject} [line=ComponentRefLine~GenericObject] - The style of the line
   * @property {ComponentRefLine~LineLabel} [label=ComponentRefLine~LineLabel] - The label style of the line
   */ /**
   * @typedef {object} ComponentRefLine~LineLabel
   * @property {number} padding=5 - Padding inside the label
   * @property {string} [text=''] - Text
   * @property {string} [fontSize='12px'] - Font size
   * @property {string} [fontFamily='Arial'] - Font family
   * @property {string} [stroke='transparent'] - Stroke
   * @property {number} [strokeWidth=0] - Stroke width
   * @property {number} [opacity=1] - Opacity
   * @property {number|string} [align=0] - Alignment property left to right (0 = left, 1 = right). Also supports string ('left', 'center', 'middle', 'right')
   * @property {number|string} [vAlign=0] - Alignment property top to bottom (0 = top, 1 = bottom). Also supports string ('top', 'center', 'middle', 'bottom')
   * @property {number} [maxWidth=1] - The maximum relative width to the width of the rendering area (see maxWidthPx as well)
   * @property {number} [maxWidthPx=9999] - The maximum width in pixels. Labels will be rendered with the maximum size of the smallest value of maxWidth and maxWidthPx size, so you may specify maxWidth 0.8 but maxWidthPx 100 and will never be over 100px and never over 80% of the renderable area
   * @property {ComponentRefLine~LineLabelBackground} [background=ComponentRefLine~LineLabelBackground] - The background style (rect behind text)
   * @property {boolean} [showValue=true] - Show value label
   */ /**
   * @typedef {object} ComponentRefLine~LineLabelBackground
   * @property {string} [fill='#fff'] - Fill color
   * @property {string} [stroke='transparent'] - Stroke
   * @property {number} [strokeWidth=0] - Stroke width
   * @property {number} [opacity=0.5] - Opacity
   */ /**
   * @typedef {object} ComponentRefLine~GenericObject
   * @property {string} [fill='#fff'] - Fill color
   * @property {string} [stroke='transparent'] - Stroke
   * @property {number} [strokeWidth=0] - Stroke width
   * @property {number} [opacity=1] - Opacity
   */const refLineComponent={require:['chart','renderer'],defaultSettings:{layout:{displayOrder:0},style:{oob:{show:true,width:10,fill:'#1A1A1A',stroke:'transparent',strokeWidth:0,opacity:1,text:{fontFamily:'Arial',stroke:'transparent',fill:'#fff',strokeWidth:0,opacity:1},triangle:{fill:'#4D4D4D',stroke:'transparent',strokeWidth:0,opacity:1},padding:{x:28,y:5}},line:{stroke:'#000'},label:{strokeWidth:0}}},preferredSize(){return 30;},beforeRender(){this.blueprint=transposer();this.blueprint.width=this.rect.width;this.blueprint.height=this.rect.height;this.blueprint.x=this.rect.x;this.blueprint.y=this.rect.y;this.blueprint.crisp=true;},render(){let settings=this.settings;// Setup lines for X and Y
  this.lines={x:[],y:[]};this.lines.x=settings.lines&&settings.lines.x||[];this.lines.y=settings.lines&&settings.lines.y||[];if(this.lines.x.length===0&&this.lines.y.length===0){return [];}const oob={x0:[],x1:[],y0:[],y1:[]};// Convert a value to an actual position using the scale
  this.lines.x=this.lines.x.filter(filterUndefinedValue).map(line=>{if(typeof line.value==='function'){line.value=line.value();}if(line.scale){let scale=this.chart.scale(line.scale);const position=getPosition(scale,line.value);return extend$1(line,{scale,position});}return extend$1(line,{position:line.value});});// Set all Y lines to flipXY by default
  // This makes the transposer flip them individually
  this.lines.y=this.lines.y.filter(filterUndefinedValue).map(line=>{if(typeof line.value==='function'){line.value=line.value();}if(line.scale){let scale=this.chart.scale(line.scale);const position=getPosition(scale,line.value);return extend$1(line,{scale,position,flipXY:true});}return extend$1(line,{position:line.value,flipXY:true});});// Move out of bounds lines (OOB) to separate rendering
  this.lines.x=this.lines.x.filter(line=>{if(line.position<0||line.position>1){oob["x".concat(line.position>1?1:0)].push(createOobData(line));return false;}return true;});this.lines.y=this.lines.y.filter(line=>{if(line.position<0||line.position>1){oob["y".concat(line.position>1?1:0)].push(createOobData(line));return false;}return true;});let items=[];// Loop through all X and Y lines
  [...this.lines.x,...this.lines.y].forEach(p=>{let show=p.show===true||typeof p.show==='undefined';if(show){// Create line with labels
  createLineWithLabel({chart:this.chart,blueprint:this.blueprint,renderer:this.renderer,p,settings,items});}});// Handle out of bounds
  if(settings.style.oob.show){oobManager({blueprint:this.blueprint,oob,settings,items});}return items;}};/**
   * @typedef {object} ComponentRefLine
   * @extends ComponentSettings
   * @property {'ref-line'} type component type
   * @example
   * {
   *  type: 'ref-line',
   *  lines: {
   *    y: [{
   *      scale: 'y',
   *      value: 5000,
   *      label: {
   *        text: 'value label'
   *      }
   *    }]
   *  }
   * }
   */function refLine(picasso){picasso.component('ref-line',refLineComponent);}function appendStyle$2(struct,buildOpts){extend$1(struct,buildOpts.style);}function buildLine$1(buildOpts){const struct={type:'line',x1:0,x2:0,y1:0,y2:0,collider:{type:null}};if(buildOpts.align==='top'||buildOpts.align==='bottom'){struct.x1=buildOpts.innerRect.x-buildOpts.outerRect.x;struct.x2=struct.x1+buildOpts.innerRect.width;struct.y1=struct.y2=buildOpts.align==='top'?buildOpts.innerRect.height-buildOpts.padding:buildOpts.padding;}else {struct.x1=struct.x2=buildOpts.align==='left'?buildOpts.innerRect.width-buildOpts.padding:buildOpts.padding;struct.y1=buildOpts.innerRect.y-buildOpts.outerRect.y;struct.y2=struct.y1+buildOpts.innerRect.height;}appendStyle$2(struct,buildOpts);return struct;}function checkText(text){return typeof text==='string'||typeof text==='number'?text:'-';}function appendStyle$1(struct,buildOpts){['fill','fontSize','fontFamily'].forEach(style=>{struct[style]=buildOpts.style[style];});}function clampEnds(struct,buildOpts){if(buildOpts.tilted||buildOpts.stepSize){return;}if(buildOpts.align==='top'||buildOpts.align==='bottom'){const leftBoundary=0;const rightBoundary=buildOpts.outerRect.width;const textWidth=Math.min(buildOpts.maxWidth/2,buildOpts.textRect.width/2);const leftTextBoundary=struct.x-textWidth;const rightTextBoundary=struct.x+textWidth;if(leftTextBoundary<leftBoundary){struct.anchor='start';struct.x=buildOpts.innerRect.x-buildOpts.outerRect.x;}else if(rightTextBoundary>rightBoundary){struct.anchor='end';struct.x=buildOpts.innerRect.width+buildOpts.innerRect.x;}}else {const topBoundary=0;const bottomBoundary=buildOpts.outerRect.height;const textHeight=buildOpts.maxHeight/2;const topTextBoundary=struct.y-textHeight;const bottomTextBoundary=struct.y+textHeight;if(topTextBoundary<topBoundary){struct.y=buildOpts.innerRect.y-buildOpts.outerRect.y;struct.baseline='text-before-edge';}else if(bottomTextBoundary>bottomBoundary){struct.y=buildOpts.innerRect.height+(buildOpts.innerRect.y-buildOpts.outerRect.y);struct.baseline='text-after-edge';}}}function appendPadding$1(struct,buildOpts){if(buildOpts.align==='top'){struct.y-=buildOpts.padding;}else if(buildOpts.align==='bottom'){struct.y+=buildOpts.padding+buildOpts.maxHeight;}else if(buildOpts.align==='left'){struct.x-=buildOpts.padding;}else if(buildOpts.align==='right'){struct.x+=buildOpts.padding;}}function appendTilting(struct,buildOpts){if(buildOpts.tilted){const r=-buildOpts.angle;const radians=r*(Math.PI/180);if(buildOpts.align==='bottom'){struct.x-=buildOpts.maxHeight*Math.sin(radians)/2;struct.y-=buildOpts.maxHeight;struct.y+=buildOpts.maxHeight*Math.cos(radians)/2;}else {struct.x-=buildOpts.maxHeight*Math.sin(radians)/3;}struct.transform="rotate(".concat(r,", ").concat(struct.x,", ").concat(struct.y,")");struct.anchor=buildOpts.align==='bottom'===buildOpts.angle<0?'start':'end';// adjustForEnds
  const textWidth=Math.cos(radians)*buildOpts.maxWidth;if(buildOpts.align==='bottom'===buildOpts.angle<0){// right
  const rightBoundary=buildOpts.outerRect.width-buildOpts.paddingEnd;const rightTextBoundary=struct.x+textWidth;if(rightTextBoundary>rightBoundary){struct.maxWidth=(rightBoundary-struct.x-10)/Math.cos(radians);}}else {// left
  const leftBoundary=buildOpts.paddingEnd;const leftTextBoundary=struct.x-textWidth;if(leftTextBoundary<leftBoundary){struct.maxWidth=(struct.x-leftBoundary-10)/Math.cos(radians);}}}}function bandwidthCollider(tick,struct,buildOpts){if(buildOpts.align==='bottom'||buildOpts.align==='top'){const tickCenter=tick.position*buildOpts.innerRect.width;const leftBoundary=tickCenter+(buildOpts.innerRect.x-buildOpts.outerRect.x-buildOpts.stepSize/2);struct.collider={type:'rect',x:leftBoundary,y:0,width:leftBoundary<0?buildOpts.stepSize+leftBoundary:buildOpts.stepSize,// Adjust collider so that it doesnt extend onto neighbor collider
  height:buildOpts.innerRect.height};}else {const tickCenter=tick.position*buildOpts.innerRect.height;const topBoundary=tickCenter+(buildOpts.innerRect.y-buildOpts.outerRect.y-buildOpts.stepSize/2);struct.collider={type:'rect',x:0,y:topBoundary,width:buildOpts.innerRect.width,height:topBoundary<0?buildOpts.stepSize+topBoundary:buildOpts.stepSize// Adjust collider so that it doesnt extend onto neighbor collider
  };}// Clip edges of the collider, should not extend beyoned the outerRect
  const collider=struct.collider;collider.x=Math.max(collider.x,0);collider.y=Math.max(collider.y,0);const widthClip=collider.x+collider.width-(buildOpts.outerRect.x+buildOpts.outerRect.width);collider.width=widthClip>0?collider.width-widthClip:collider.width;const heightClip=collider.y+collider.height-(buildOpts.outerRect.y+buildOpts.outerRect.height);collider.height=heightClip>0?collider.height-heightClip:collider.height;}function boundsCollider(tick,struct){struct.collider={type:'polygon',vertices:[{x:struct.boundingRect.x,y:struct.boundingRect.y},{x:struct.boundingRect.x+struct.boundingRect.width,y:struct.boundingRect.y},{x:struct.boundingRect.x+struct.boundingRect.width,y:struct.boundingRect.y+struct.boundingRect.height},{x:struct.boundingRect.x,y:struct.boundingRect.y+struct.boundingRect.height}]};}function tiltedCollider(tick,struct,buildOpts){const radians=buildOpts.angle*(Math.PI/180);const halfWidth=Math.max(buildOpts.stepSize/2,struct.boundingRect.height/2);// Handle if bandwidth is zero
  const startAnchor=struct.anchor==='start';const em=struct.anchor==='end'&&radians<0;const sp=struct.anchor==='start'&&radians>=0;const y=struct.boundingRect.y+(sp||em?struct.boundingRect.height:0);// Generate starting points at bandwidth boundaries
  const points=[{x:struct.x-halfWidth,y},{x:struct.x+halfWidth,y}].map(p=>rotate(p,radians,{x:struct.x,y:struct.y}));// Rotate around center point to counteract labels rotation
  // Append points to wrap polygon around label
  const margin=10;// extend slightly to handle single char labels better
  const leftPoint={x:startAnchor?struct.boundingRect.x+struct.boundingRect.width+margin:struct.boundingRect.x-margin,y:struct.boundingRect.y+struct.boundingRect.height};const rightPoint={x:startAnchor?struct.boundingRect.x+struct.boundingRect.width+margin:struct.boundingRect.x-margin,y:struct.boundingRect.y};const orderedPoints=radians>=0?[leftPoint,rightPoint]:[rightPoint,leftPoint];points.push(...orderedPoints);struct.collider={type:'polygon',vertices:points};}function appendCollider(tick,struct,buildOpts){if(buildOpts.layered||!buildOpts.stepSize){boundsCollider(tick,struct);}else if(buildOpts.tilted){tiltedCollider(tick,struct,buildOpts);}else {bandwidthCollider(tick,struct,buildOpts);}}function appendBounds(struct,buildOpts){struct.boundingRect=buildOpts.textBounds(struct);}function wiggle(buildOpts,isVertical){const a=isNaN(buildOpts.style.align)?0.5:Math.min(Math.max(buildOpts.style.align,0),1);let w=0;if(buildOpts.tilted){w=buildOpts.stepSize*a;}else {const size=isVertical?buildOpts.textRect.height:buildOpts.textRect.width;w=Math.max(0,buildOpts.stepSize-size)*a;}return w;}function buildNode$1(tick,buildOpts){var _tick$value,_tick$data;const struct={type:'text',text:checkText(tick.label),x:0,y:0,maxWidth:buildOpts.maxWidth,maxHeight:buildOpts.maxHeight,tickValue:(_tick$value=tick.value)!==null&&_tick$value!==void 0?_tick$value:(_tick$data=tick.data)===null||_tick$data===void 0?void 0:_tick$data.value};if(buildOpts.align==='top'||buildOpts.align==='bottom'){struct.x=tick.start*buildOpts.innerRect.width+(buildOpts.innerRect.x-buildOpts.outerRect.x)+wiggle(buildOpts,false);struct.y=buildOpts.align==='top'?buildOpts.innerRect.height:0;struct.anchor=buildOpts.stepSize?'start':'middle';struct.x+=isNaN(buildOpts.style.offset)?0:+buildOpts.style.offset;}else {struct.y=tick.start*buildOpts.innerRect.height+(buildOpts.innerRect.y-buildOpts.outerRect.y)+wiggle(buildOpts,true);struct.x=buildOpts.align==='left'?buildOpts.innerRect.width:0;struct.anchor=buildOpts.align==='left'?'end':'start';struct.baseline=buildOpts.stepSize?'text-before-edge':'central';struct.y+=isNaN(buildOpts.style.offset)?0:+buildOpts.style.offset;}appendStyle$1(struct,buildOpts);clampEnds(struct,buildOpts);appendPadding$1(struct,buildOpts);appendTilting(struct,buildOpts);appendBounds(struct,buildOpts);appendCollider(tick,struct,buildOpts);return struct;}function appendStyle(struct,buildOpts){extend$1(struct,buildOpts.style);}function appendPadding(struct,buildOpts){if(buildOpts.align==='top'){struct.y1-=buildOpts.padding;struct.y2-=buildOpts.padding;}else if(buildOpts.align==='bottom'){struct.y1+=buildOpts.padding;struct.y2+=buildOpts.padding;}else if(buildOpts.align==='left'){struct.x1-=buildOpts.padding;struct.x2-=buildOpts.padding;}else if(buildOpts.align==='right'){struct.x1+=buildOpts.padding;struct.x2+=buildOpts.padding;}}function adjustForEnds(struct,buildOpts){const halfWidth=struct.strokeWidth/2;if(struct.x1===buildOpts.innerRect.width){// outer end tick
  struct.x1-=halfWidth;struct.x2-=halfWidth;}else if(struct.x1===0){// outer start tick
  struct.x1+=halfWidth;struct.x2+=halfWidth;}else if(struct.y1===buildOpts.innerRect.height){struct.y1-=halfWidth;struct.y2-=halfWidth;}else if(struct.y1===0){struct.y1+=halfWidth;struct.y2+=halfWidth;}}function buildNode(tick,buildOpts){const struct={type:'line',x1:0,x2:0,y1:0,y2:0,collider:{type:null},tickValue:tick.value};if(buildOpts.align==='top'||buildOpts.align==='bottom'){struct.x1=struct.x2=tick.position*buildOpts.innerRect.width+(buildOpts.innerRect.x-buildOpts.outerRect.x);struct.y1=buildOpts.align==='top'?buildOpts.innerRect.height:0;struct.y2=buildOpts.align==='top'?struct.y1-buildOpts.tickSize:struct.y1+buildOpts.tickSize;}else {struct.y1=struct.y2=tick.position*buildOpts.innerRect.height+(buildOpts.innerRect.y-buildOpts.outerRect.y);struct.x1=buildOpts.align==='left'?buildOpts.innerRect.width:0;struct.x2=buildOpts.align==='left'?struct.x1-buildOpts.tickSize:struct.x1+buildOpts.tickSize;}appendStyle(struct,buildOpts);appendPadding(struct,buildOpts);adjustForEnds(struct,buildOpts);return struct;}function isMajorTick(tick){return !tick.isMinor&&tick.position>=0&&tick.position<=1;}function isVerticalLabelOverlapping(_ref){let{majorTicks,measureText,rect}=_ref;const size=rect.height;const textHeight=measureText('M').height;if(majorTicks.length<2){return false;}const d=size*Math.abs(majorTicks[0].position-majorTicks[1].position);if(d<textHeight){return true;}return false;}function isHorizontalLabelOverlapping(_ref2){let{majorTicks,measureText,rect,state}=_ref2;/*
     * Currently isn't any good way of doing a accurate measurement on size available (bandWidth * width) for labels.
     * It's a lifecycle limitation as components docked either left or right can affect the width available after the calculation is done.
     * <number of components docked left/right> * <width of components> => Less accurate ===> Can result in only ellips char rendered as labels.
     */const m=state.labels.activeMode==='layered'?2:1;const size=rect.width;const tickSize=majorTicks.map(tick=>tick.label).map(l=>"".concat(l.slice(0,1)).concat(l.length>1?'…':''))// Measure the size of 1 chars + the ellips char.
  .map(measureText).map(r=>r.width);for(let i=0;i<majorTicks.length;++i){const tick=majorTicks[i];const d1=m*size*Math.abs(tick.start-tick.end);const d2=tickSize[i];if(d1<d2){return true;}}return false;}function shouldAutoTilt(_ref3){let{majorTicks,measure,rect,state,settings}=_ref3;const glyphCount=settings.labels.maxGlyphCount;const m=state.labels.activeMode==='layered'?2:1;const magicSizeRatioMultipler=settings.labels.tiltThreshold?settings.labels.tiltThreshold:0.7;// So that if less the 70% of labels are visible, toggle on tilt or use variable tiltThreshold
  const ellipsCharSize=measure('…').width;// include ellipsed char in calc as it's generally large then the char it replaces
  const size=rect.width;let maxLabelWidth=0;let d1=0;if(!isNaN(glyphCount)){const minBandwidth=majorTicks.reduce((prev,curr)=>Math.min(Math.abs(curr.start-curr.end),prev),Infinity);d1=m*size*minBandwidth;maxLabelWidth=measure('M').width*magicSizeRatioMultipler*glyphCount;if(maxLabelWidth+ellipsCharSize>d1){return true;}}else {for(let i=0;i<majorTicks.length;i++){const tick=majorTicks[i];const label=tick.label;const width=measure(label).width*(label.length>1?magicSizeRatioMultipler:1);d1=m*size*Math.abs(tick.start-tick.end);if(width+ellipsCharSize>d1){return true;}}}return false;}function isTiltedLabelOverlapping(_ref4){let{majorTicks,measureText,rect,bleedSize,angle}=_ref4;if(majorTicks.length<2){return false;}if(angle===0){return true;// TODO 0 angle should be considered non-tilted
  }const absAngle=Math.abs(angle);const size=Math.min(rect.outer.width-bleedSize,rect.inner.width);const stepSize=size*Math.abs(majorTicks[0].position-majorTicks[1].position);const textHeight=measureText('M').height;const reciprocal=1/stepSize;// 1 === Math.sin(90 * (Math.PI / 180))
  const distanceBetweenLabels=Math.sin(absAngle*(Math.PI/180))/reciprocal;return textHeight>distanceBetweenLabels;}function isToLarge(_ref5){let{rect,state,majorTicks,measure,horizontal}=_ref5;if(horizontal){return isHorizontalLabelOverlapping({majorTicks,measureText:measure,rect,state});}return isVerticalLabelOverlapping({majorTicks,measureText:measure,rect,state});}function getClampedValue(_ref6){let{value,maxValue,minValue,range,modifier}=_ref6;if(!isNaN(range)&&!isNaN(modifier)){value=range*modifier;}if(value>maxValue){value=maxValue;}if(value<minValue){value=minValue;}return value;}function getSize$1(_ref7){let{isDiscrete,rect,formatter,measureText,scale,settings,state}=_ref7;let size=0;const edgeBleed={left:0,top:0,right:0,bottom:0};const{maxLengthPx:maxValue,minLengthPx:minValue}=settings.labels;if(settings.labels.show){const align=settings.align;const horizontal=align==='top'||align==='bottom';const distance=horizontal?rect.inner.width:rect.inner.height;const majorTicks=scale.ticks({settings,distance,formatter}).filter(isMajorTick);const measure=text=>{const m=measureText({text,fontSize:settings.labels.fontSize,fontFamily:settings.labels.fontFamily});m.width=getClampedValue({value:m.width,maxValue,minValue});return m;};if(isDiscrete&&horizontal&&settings.labels.mode==='auto'){if(shouldAutoTilt({majorTicks,measure,rect:rect.inner,state,settings})){state.labels.activeMode='tilted';}else {state.labels.activeMode='horizontal';}}if(!settings.labels.filterOverlapping&&state.labels.activeMode!=='tilted'&&isToLarge({rect:rect.inner,state,majorTicks,measure,horizontal})){const toLargeSize=Math.max(rect.outer.width,rect.outer.height);// used to hide the axis
  return {size:toLargeSize,isToLarge:true};}let sizeFromTextRect;if(state.labels.activeMode==='tilted'){const radians=Math.abs(settings.labels.tiltAngle)*(Math.PI/180);// angle in radians
  sizeFromTextRect=r=>getClampedValue({value:r.width,maxValue,minValue})*Math.sin(radians)+r.height*Math.cos(radians);}else if(horizontal){sizeFromTextRect=r=>r.height;}else {sizeFromTextRect=r=>getClampedValue({value:r.width,maxValue,minValue});}let labels;if(horizontal&&state.labels.activeMode!=='tilted'){labels=['M'];}else if(!isNaN(settings.labels.maxGlyphCount)){let label='';for(let i=0;i<settings.labels.maxGlyphCount;i++){label+='M';}labels=[label];}else {labels=majorTicks.map(tick=>tick.label);}const tickMeasures=labels.map(measure);const labelSizes=tickMeasures.map(sizeFromTextRect);const textSize=Math.max(...labelSizes,0);size+=textSize;size+=settings.labels.margin;if(state.labels.activeMode==='layered'){size*=2;}if(state.labels.activeMode==='tilted'){const extendLeft=settings.align==='bottom'===settings.labels.tiltAngle>=0;const radians=Math.abs(settings.labels.tiltAngle)*(Math.PI/180);// angle in radians
  const h=measure('M').height;const maxWidth=(textSize-h*Math.cos(radians))/Math.sin(radians);const labelWidth=r=>Math.min(maxWidth,r.width)*Math.cos(radians)+r.height;const adjustByPosition=(s,i)=>{const pos=majorTicks[i]?majorTicks[i].position:0;if(extendLeft){return s-pos*rect.inner.width;}return s-(1-pos)*rect.inner.width;};const bleedSize=Math.min(settings.labels.maxEdgeBleed,Math.max(...tickMeasures.map(labelWidth).map(adjustByPosition),0))+settings.paddingEnd;const bleedDir=extendLeft?'left':'right';edgeBleed[bleedDir]=bleedSize;if(!settings.labels.filterOverlapping&&isTiltedLabelOverlapping({majorTicks,measureText:measure,rect,bleedSize,angle:settings.labels.tiltAngle})){const toLargeSize=Math.max(rect.outer.width,rect.outer.height);// used to hide the axis
  return {size:toLargeSize,isToLarge:true};}}}return {size,edgeBleed};}const PADDING$1=2;const tickDistance=(rect,start,end)=>rect.width*Math.abs(start.position-end.position);const getLeftEdgeWidth=_ref=>{let{innerRect,outerRect,tick,nextWidth}=_ref;const leftEdgeBleed=innerRect.x-outerRect.x;const left=innerRect.width*tick.position+leftEdgeBleed;const minDubble=Math.min(nextWidth,left)*2;const minWidth=tick.position===0?innerRect.width/2-PADDING$1:0;return Math.max(nextWidth,minDubble,minWidth);};const getRightEdgeWidth=_ref2=>{let{innerRect,outerRect,tick,prevWidth}=_ref2;const leftEdgeBleed=innerRect.x-outerRect.x;const rightEdgeBleed=outerRect.width-innerRect.width-leftEdgeBleed;const right=innerRect.width-innerRect.width*tick.position+rightEdgeBleed;const minDubble=Math.min(prevWidth,right)*2;const minWidth=tick.position===1?innerRect.width/2-PADDING$1:0;return Math.max(prevWidth,minDubble,minWidth);};function getHorizontalWidth(_ref3){let{layered,major,innerRect,outerRect,tick,index}=_ref3;const step=layered?2:1;const prev=major[index-step];const next=major[index+step];const prevWidth=prev?tickDistance(innerRect,tick,prev)/2-PADDING$1:Infinity;const nextWidth=next?tickDistance(innerRect,tick,next)/2-PADDING$1:Infinity;if(major.length<2){return innerRect.width;}if(!prev){return getLeftEdgeWidth({innerRect,outerRect,tick,nextWidth});}if(!next){return getRightEdgeWidth({innerRect,outerRect,tick,prevWidth});}return Math.min(prevWidth,nextWidth)*2;}function tickSpacing(settings){let spacing=0;spacing+=settings.paddingStart;spacing+=settings.line.show?settings.line.strokeWidth/2:0;spacing+=settings.ticks.show?settings.ticks.margin:0;return spacing;}function tickMinorSpacing(settings){return settings.line.strokeWidth+settings.minorTicks.margin;}function labelsSpacing(settings){let spacing=0;spacing+=settings.ticks.show?settings.ticks.tickSize:0;spacing+=tickSpacing(settings)+settings.labels.margin;return spacing;}function calcActualTextRect(_ref){let{style,measureText,tick}=_ref;return measureText({text:tick.label,fontSize:style.fontSize,fontFamily:style.fontFamily});}function majorTicks(ticks){return ticks.filter(t=>!t.isMinor);}function minorTicks(ticks){return ticks.filter(t=>t.isMinor);}function tickBuilder(ticks,buildOpts){return ticks.map(tick=>buildNode(tick,buildOpts));}function tickBandwidth(scale,tick){return tick?Math.abs(tick.end-tick.start):scale.bandwidth();}function labelBuilder(ticks,buildOpts,resolveTickOpts){return ticks.map((tick,idx)=>{resolveTickOpts(tick,idx);const label=buildNode$1(tick,buildOpts);label.data=tick.data;return label;});}function layeredLabelBuilder(ticks,buildOpts,settings,resolveTickOpts){const padding=buildOpts.padding;const spacing=labelsSpacing(settings);return ticks.map((tick,idx)=>{resolveTickOpts(tick,idx);const padding2=spacing+buildOpts.maxHeight+settings.labels.margin;buildOpts.layer=idx%2;buildOpts.padding=idx%2===0?padding:padding2;const label=buildNode$1(tick,buildOpts);label.data=tick.data;return label;});}function filterOverlappingLabels$1(labels,ticks,buildOpts){let isOverlapping=(i,k)=>{const rect1=expandRect(1,labels[i].boundingRect);const rect2=expandRect(1,labels[k].boundingRect);return testRectRect(rect1,rect2);};if(buildOpts&&buildOpts.tilted){const absAngle=Math.abs(buildOpts.angle);isOverlapping=(i,k)=>{const stepSize=Math.abs(labels[i].x-labels[k].x);const reciprocal=1/stepSize;const distanceBetweenLabels=Math.sin(absAngle*(Math.PI/180))/reciprocal;return labels[i].boundingRect.height>distanceBetweenLabels;};}for(let i=0;i<=labels.length-1;i++){for(let k=i+1;k<=Math.min(i+5,i+(labels.length-1));k++){// TODO Find a better way to handle exteme/layered labels then to iterare over ~5 next labels
  if(labels[i]&&labels[k]&&isOverlapping(i,k)){if(k===labels.length-1){// On collition with last label, remove current label instead
  labels.splice(i,1);if(ticks){ticks.splice(i,1);}}else {labels.splice(k,1);if(ticks){ticks.splice(k,1);}}k--;i--;}}}}function discreteCalcMaxTextRect(_ref2){let{textMetrics,settings,innerRect,scale,tilted,layered,tick}=_ref2;const h=textMetrics.height;const bandwidth=tickBandwidth(scale,tick);const textRect={width:0,height:h};if(settings.align==='left'||settings.align==='right'){textRect.width=innerRect.width-labelsSpacing(settings)-settings.paddingEnd;}else if(layered){textRect.width=bandwidth*innerRect.width*2;}else if(tilted){const radians=Math.abs(settings.labels.tiltAngle)*(Math.PI/180);textRect.width=(innerRect.height-labelsSpacing(settings)-settings.paddingEnd-h*Math.cos(radians))/Math.sin(radians);}else {textRect.width=bandwidth*innerRect.width;}textRect.width=getClampedValue({value:textRect.width,maxValue:settings.labels.maxLengthPx,minValue:settings.labels.minLengthPx});return textRect;}function continuousCalcMaxTextRect(_ref3){let{textMetrics,settings,innerRect,outerRect,tilted,layered,tick,index,major}=_ref3;const h=textMetrics.height;const textRect={width:0,height:h};if(settings.align==='left'||settings.align==='right'){textRect.width=innerRect.width-labelsSpacing(settings)-settings.paddingEnd;}else if(tilted){const radians=Math.abs(settings.labels.tiltAngle)*(Math.PI/180);textRect.width=(innerRect.height-labelsSpacing(settings)-settings.paddingEnd-h*Math.cos(radians))/Math.sin(radians);}else {textRect.width=getHorizontalWidth({layered,major,innerRect,outerRect,tick,index});}textRect.width=getClampedValue({value:textRect.width,maxValue:settings.labels.maxLengthPx,minValue:settings.labels.minLengthPx});return textRect;}function getStepSizeFn(_ref4){let{innerRect,scale,settings,tick}=_ref4;const size=settings.align==='top'||settings.align==='bottom'?innerRect.width:innerRect.height;const bandwidth=tickBandwidth(scale,tick);return size*bandwidth;}function nodeBuilder(isDiscrete){let resolveLabelRect;function continuous(){resolveLabelRect=continuousCalcMaxTextRect;return continuous;}function discrete(){resolveLabelRect=discreteCalcMaxTextRect;return discrete;}function build(_ref5){let{settings,scale,innerRect,outerRect,measureText,ticks,state,textBounds}=_ref5;const nodes=[];const major=majorTicks(ticks);const minor=minorTicks(ticks);const buildOpts={innerRect,align:settings.align,outerRect};const tilted=state.labels.activeMode==='tilted';const layered=state.labels.activeMode==='layered';let majorTickNodes;if(settings.line.show){buildOpts.style=settings.line;buildOpts.padding=settings.paddingStart;nodes.push(buildLine$1(buildOpts));}if(settings.ticks.show){buildOpts.style=settings.ticks;buildOpts.tickSize=settings.ticks.tickSize;buildOpts.padding=tickSpacing(settings);majorTickNodes=tickBuilder(major,buildOpts);}if(settings.labels.show){const padding=labelsSpacing(settings);buildOpts.style=settings.labels;buildOpts.padding=padding;buildOpts.tilted=tilted;buildOpts.layered=layered;buildOpts.angle=settings.labels.tiltAngle;buildOpts.paddingEnd=settings.paddingEnd;buildOpts.textBounds=textBounds;const resolveTickOpts=(tick,index)=>{buildOpts.textRect=calcActualTextRect({tick,measureText,style:buildOpts.style});const maxSize=resolveLabelRect({textMetrics:buildOpts.textRect,settings,innerRect,outerRect,scale,tilted,layered,tick,major,index});buildOpts.maxWidth=maxSize.width;buildOpts.maxHeight=maxSize.height;buildOpts.stepSize=getStepSizeFn({innerRect,scale,ticks,settings,tick});};let labelNodes=[];if(layered&&(settings.align==='top'||settings.align==='bottom')){labelNodes=layeredLabelBuilder(major,buildOpts,settings,resolveTickOpts);}else {labelNodes=labelBuilder(major,buildOpts,resolveTickOpts);}// Remove labels (and paired tick) that are overlapping
  if(settings.labels.filterOverlapping){filterOverlappingLabels$1(labelNodes,majorTickNodes,buildOpts);}nodes.push(...labelNodes);}if(settings.minorTicks&&settings.minorTicks.show&&minor.length>0){buildOpts.style=settings.minorTicks;buildOpts.tickSize=settings.minorTicks.tickSize;buildOpts.padding=tickMinorSpacing(settings);nodes.push(...tickBuilder(minor,buildOpts));}if(majorTickNodes){nodes.push(...majorTickNodes);}return nodes;}continuous.build=build;discrete.build=build;return isDiscrete?discrete():continuous();}// const DEFAULT_LAYOUT_SETTINGS = { // TODO create dis and con specific settings
  //   anchor: 'auto', // TODO re-name from align..
  //   // orientation: 'auto', // TODO impl. v/h/auto
  //   // direction: 'auto', // TODO impl. left/right/top/bottom/auto
  //   padding: { // TODO use dock layout margin instead..
  //     start: 0,
  //     end: 10
  //   },
  //   maxGlyphCount: NaN,
  //   maxEdgeBleed: Infinity
  //   // labelMode: 'auto' // TODO move here? auto, horizontal, layered
  // };
  /**
   * @typedef {object} ComponentAxis
   * @extends ComponentSettings
   * @property {'axis'} type component type
   * @property {string} scale reference to band or linear scale
   * @property {ComponentAxis~DiscreteSettings|ComponentAxis~ContinuousSettings} [settings] discrete or continuous axis settings
   * @example
   * {
   *  type: 'axis',
   *  scale: '<name-of-scale>'
   * }
   */ /**
   * Discrete axis settings
   * @typedef {object}
   * @alias ComponentAxis~DiscreteSettings
   * @example
   * {
   *  type: 'axis',
   *  scale: '<name-of-band-scale>',
   *  settings: {
   *    labels: {
   *      mode: 'tilted',
   *      tiltAngle: 40,
   *    },
   *  },
   * }
   */const DEFAULT_DISCRETE_SETTINGS={/**
     * @typedef {object}
     */labels:{/** Toggle labels on/off
       * @type {boolean=} */show:true,/** Tilting angle in degrees. Capped between -90 and 90. Only applicable when labels are in `tilted` mode.
       * @type {number=} */tiltAngle:40,/** Threshold for toggle of tilted labels. Capped between 0 and 1. For example, if it is set to 0.7, then tilted labels will be toggled if less than 70% of the labels are visible.
       * @type {number=} */tiltThreshold:0.7,/** Control the amount of space (in pixels) that labes can occupy outside their docking area. Only applicable when labels are in `tilted` mode.
       * @type {number=} */maxEdgeBleed:Infinity,/** Space in pixels between the tick and label.
       * @type {number=} */margin:4,/** Max length of labels in pixels
       * @type {number=} */maxLengthPx:150,/** Min length of labels in pixels. Labels will always at least require this much space
       * @type {number=} */minLengthPx:0,/** Control how labels arrange themself. Availabe modes are `auto`, `horizontal`, `layered` and `tilted`. When set to `auto` the axis determines the best possible layout in the current context.
       * @type {string=} */mode:'auto',/** When only a sub-set of data is available, ex. when paging. This property can be used to let the axis estimate how much space the labels will consume, allowing it to give a consistent space estimate over the entire dataset when paging.
       * @type {number=} */maxGlyphCount:NaN,/** Align act as a slider for the text bounding rect over the item bandwidth, given that the item have a bandwidth. Except when labels are tilted, then the align is a pure align that shifts the position of the label anchoring point.
       * @type {number=} */align:0.5,/** Offset in pixels along the axis direction.
       * @type {number=} */offset:0,/**
       * Toggle whether labels should be filtered if they are overlapping. Filtering may be applied in a non-sequential order.
       * If labels are overlapping and this setting is toggled off, the axis will automatically hide.
       * @type {boolean=}
       */filterOverlapping:false},/**
     * @typedef {object}
     */ticks:{/** Toggle ticks on/off
       * @type {boolean=} */show:false,/** Space in pixels between the ticks and the line.
       * @type {number=} */margin:0,/** Size of the ticks in pixels.
       * @type {number=} */tickSize:4},/**
     * @typedef {object}
     */line:{/** Toggle line on/off
       * @type {boolean=} */show:false},/** Padding in direction perpendicular to the axis
     * @type {number=} */paddingStart:0,/** Padding in direction perpendicular to the axis
     * @type {number=} */paddingEnd:10,/** Set the anchoring point of the axis. Available options are `auto/left/right/bottom/top`. In `auto` the axis determines the best option. The options are restricted based on the axis orientation, a vertical axis may only anchor on `left` or `right`
     * @type {string=} */align:'auto'};/**
   * Continuous axis settings
   * @typedef {object}
   * @alias ComponentAxis~ContinuousSettings
   * @example
   * {
   *  type: 'axis',
   *  scale: '<name-of-linear-scale>',
   *  settings: {
   *    minorTicks: {
   *      show: false,
   *    },
   *  },
   * }
   */const DEFAULT_CONTINUOUS_SETTINGS={/**
     * @typedef {object}
     */labels:{/** Toggle labels on/off
       * @type {boolean=} */show:true,/** Space in pixels between the tick and label.
       * @type {number=} */margin:4,/** Max length of labels in pixels
       * @type {number=} */maxLengthPx:150,/** Min length of labels in pixels. Labels will always at least require this much space
       * @type {number=} */minLengthPx:0,/** Align act as a slider for the text bounding rect over the item bandwidth, given that the item have a bandwidth.
       * @type {number=} */align:0.5,/** Offset in pixels along the axis direction.
       * @type {number=} */offset:0,/**
       * Toggle whether labels should be filtered if they are overlapping. Filtering may be applied in a non-sequential order.
       * If labels are overlapping and this setting is toggled off, the axis will automatically hide.
       * @type {boolean=}
       */filterOverlapping:true},/**
     * @typedef {object}
     */ticks:{/** Toggle ticks on/off
       * @type {boolean=} */show:true,/** Space in pixels between the ticks and the line.
       * @type {number=} */margin:0,/** Size of the ticks in pixels.
       * @type {number=} */tickSize:8},/**
     * @typedef {object}
     */minorTicks:{/** Toggle minor-ticks on/off
       * @type {boolean=} */show:false,/** Size of the ticks in pixels.
       * @type {number=} */tickSize:3,/** Space in pixels between the ticks and the line.
       * @type {number=} */margin:0},/**
     * @typedef {object}
     */line:{/** Toggle line on/off
       * @type {boolean=} */show:true},/** Padding in direction perpendicular to the axis
     * @type {number=} */paddingStart:0,/** Padding in direction perpendicular to the axis
     * @type {number=} */paddingEnd:10,/** Set the anchoring point of the axis. Available options are `auto/left/right/bottom/top`. In `auto` the axis determines the best option. The options are restricted based on the axis orientation, a vertical axis may only anchor on `left` or `right`
     * @type {string=} */align:'auto'};function oppositeAlign(align){switch(align){case'top':return 'bottom';case'bottom':return 'top';case'left':return 'right';case'right':return 'left';default:return align;}}function calcRequiredSize(_ref){let{isDiscrete,rect,formatter,measureText,scale,settings,state}=_ref;let size=0;const{size:labelSize,edgeBleed,isToLarge}=getSize$1({isDiscrete,rect,formatter,measureText,scale,settings,state});size+=labelSize;if(isToLarge){return {size};}if(settings.ticks.show){size+=settings.ticks.margin;size+=settings.ticks.tickSize;}if(settings.minorTicks&&settings.minorTicks.show){const minorTicksSize=settings.minorTicks.margin+settings.minorTicks.tickSize;if(minorTicksSize>size){size=minorTicksSize;}}if(settings.line.show){const halfWidth=settings.line.strokeWidth/2;size+=halfWidth;edgeBleed[oppositeAlign(settings.align)]=Math.ceil(halfWidth);}size+=settings.paddingStart;size+=settings.paddingEnd;return {size,edgeBleed};}function alignTransform(_ref){let{align,inner}=_ref;if(align==='left'){return {x:inner.width+inner.x};}if(align==='right'||align==='bottom'){return inner;}return {y:inner.y+inner.height};}function resolveAlign(align,dock){const horizontal=['top','bottom'];const vertical=['left','right'];if(horizontal.indexOf(align)!==-1&&vertical.indexOf(dock)===-1){return align;}if(vertical.indexOf(align)!==-1&&horizontal.indexOf(dock)===-1){return align;}return dock;// Invalid align, return current dock as default
  }/**
   * @ignore
   * @param {object} context - The component context
   */function resolveLocalSettings(_ref2){let{state,style,settings}=_ref2;const defaultStgns=extend$1(true,{},state.isDiscrete?DEFAULT_DISCRETE_SETTINGS:DEFAULT_CONTINUOUS_SETTINGS,style);const localStgns=extend$1(true,{},defaultStgns,settings.settings);const dock=settings.layout.dock||state.defaultDock;localStgns.dock=dock;localStgns.align=resolveAlign(settings.settings.align,dock);localStgns.labels.tiltAngle=Math.max(-90,Math.min(localStgns.labels.tiltAngle,90));const{paddingStart,paddingEnd}=localStgns;localStgns.paddingStart=typeof paddingStart==='function'?paddingStart.call(null):paddingStart;localStgns.paddingEnd=typeof paddingEnd==='function'?paddingEnd.call(null):paddingEnd;return localStgns;}function updateActiveMode(state,settings,isDiscrete){const mode=settings.labels.mode;if(!isDiscrete||!state.isHorizontal){return 'horizontal';}if(mode==='auto'){return state.labels.activeMode;}if(['layered','tilted'].indexOf(settings.labels.mode)!==-1&&['top','bottom'].indexOf(settings.dock)!==-1){return mode;}return 'horizontal';}const axisComponent={require:['chart','renderer','dockConfig'],defaultSettings:{layout:{displayOrder:0,prioOrder:0},settings:{},style:{labels:'$label',ticks:'$guide-line',minorTicks:'$guide-line--minor',line:'$guide-line'}},created(){// State is a representation of properties that are private to this component defintion and may be modified by only in this context.
  this.state={isDiscrete:!!this.scale.bandwidth,isHorizontal:false,labels:{activeMode:'horizontal'},ticks:[],innerRect:{width:0,height:0,x:0,y:0},outerRect:{width:0,height:0,x:0,y:0},defaultDock:undefined,concreteNodeBuilder:undefined,settings:undefined};if(this.state.isDiscrete){this.state.defaultDock='bottom';}else {this.state.defaultDock='left';}this.setState(this.settings);},setState(){this.state.isDiscrete=!!this.scale.bandwidth;this.state.settings=resolveLocalSettings(this);this.state.concreteNodeBuilder=nodeBuilder(this.state.isDiscrete);this.dockConfig.dock(this.state.settings.dock);// Override the dock setting (TODO should be removed)
  this.state.isHorizontal=this.state.settings.align==='top'||this.state.settings.align==='bottom';this.state.labels.activeMode=updateActiveMode(this.state,this.state.settings,this.state.isDiscrete);},preferredSize(opts){const{formatter,state,scale}=this;const distance=this.state.isHorizontal?opts.inner.width:opts.inner.height;this.state.pxScale=scaleWithSize(scale,distance);const reqSize=calcRequiredSize({isDiscrete:this.state.isDiscrete,rect:{inner:opts.inner,outer:opts.outer},formatter,measureText:this.renderer.measureText,scale:this.state.pxScale,settings:this.state.settings,state});return reqSize;},beforeUpdate(){let opts=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{settings}=opts;this.setState(settings);},resize(opts){const{inner,outer}=opts;const extendedInner=extend$1({},inner,alignTransform({align:this.state.settings.align,inner}));const finalOuter=outer||extendedInner;extend$1(this.state.innerRect,extendedInner);extend$1(this.state.outerRect,finalOuter);return outer;},beforeRender(){const{scale,formatter}=this;const distance=this.state.isHorizontal?this.state.innerRect.width:this.state.innerRect.height;this.state.pxScale=scaleWithSize(scale,distance);this.state.ticks=this.state.pxScale.ticks({distance,formatter}).filter(t=>t.position>=0&&t.position<=1);},render(){const{state}=this;const nodes=[];nodes.push(...this.state.concreteNodeBuilder.build({settings:this.state.settings,scale:this.state.pxScale,innerRect:this.state.innerRect,outerRect:this.state.outerRect,measureText:this.renderer.measureText,textBounds:this.renderer.textBounds,ticks:this.state.ticks,state}));crispifier.multiple(nodes);return nodes;}};const type$2='axis';function axis(picasso){picasso.component(type$2,axisComponent);}/**
   * @typedef {object} ComponentContainer
   * @experimental
   * @extends ComponentSettings
   * @property {'container'} type component type
   * @example
   * {
   *  type: 'container',
   *  preferredSize: ({ inner, outer, dock, children }) => {
   *    const sizes = children.map(c => c.preferredSize({ inner, outer }));
   *    return Math.max(...sizes);
   *  },
   *  strategy: (rect, components) => {
   *    const height = rect.height / components.length;
   *    components.forEach((c, i) => {
   *      c.resize({ ...rect, height, y: rect.y + i * height })
   *    });
   *    return { visible: components, hidden: [], order: components };
   *  },
   *  components: [
   *     ...
   *  ],
   * }
   */const containerComponent={render(){return [];}};function container(picasso){picasso.component('container',containerComponent);}function parseTitle(text,join,scale){let title='';if(typeof text==='function'){title=text();}else if(typeof text==='string'){title=text;}else if(scale){let data=scale.data();const titles=(data.fields||[]).map(field=>field.title());title=titles.join(join);}return title;}function getTextAnchor(dock,anchor){let val='middle';if(dock==='left'){if(anchor==='top'){val='end';}else if(anchor==='bottom'){val='start';}}else if(dock==='right'){if(anchor==='top'){val='start';}else if(anchor==='bottom'){val='end';}}else if(anchor==='left'){val='start';}else if(anchor==='right'){val='end';}return val;}function generateTitle(_ref){let{title,definitionSettings,dock,rect,measureText,style}=_ref;const struct={type:'text',text:title,x:0,y:0,dx:0,dy:0,anchor:getTextAnchor(dock,definitionSettings.anchor),baseline:'alphabetical',stroke:'transparent',strokeWidth:0,fontWeight:'normal'};extend$1(struct,style.text);const textRect=measureText(struct);if(dock==='top'||dock==='bottom'){let x=rect.width/2;if(definitionSettings.anchor==='left'){x=definitionSettings.paddingLeft||0;}else if(definitionSettings.anchor==='right'){x=rect.width-(definitionSettings.paddingRight||0);}struct.x=x;struct.y=dock==='top'?rect.height-definitionSettings.paddingStart:definitionSettings.paddingStart+textRect.height;struct.dy=dock==='top'?-(textRect.height/6):-(textRect.height/3);struct.maxWidth=rect.width*0.8;}else {let y=rect.height/2;if(definitionSettings.anchor==='top'){y=definitionSettings.paddingStart;}else if(definitionSettings.anchor==='bottom'){y=rect.height-definitionSettings.paddingStart;}struct.y=y;struct.x=dock==='left'?rect.width-definitionSettings.paddingStart:definitionSettings.paddingStart;struct.dx=dock==='left'?-(textRect.height/3):textRect.height/3;const rotation=dock==='left'?270:90;struct.transform="rotate(".concat(rotation,", ").concat(struct.x+struct.dx,", ").concat(struct.y+struct.dy,")");struct.maxWidth=rect.height*0.8;}if(!isNaN(definitionSettings.maxLengthPx)){struct.maxWidth=Math.min(struct.maxWidth,definitionSettings.maxLengthPx);}return struct;}/**
   * @typedef {object} ComponentText
   * @extends ComponentSettings
   * @property {'text'} type component type
   * @property {string|function} text Text to display
   * @example
   * {
   *  type: 'text',
   *  text: 'my title',
   *  dock: 'left',
   *  settings: {
   *    anchor: 'left',
   *  }
   * }
   */ /**
   * @typedef {object} ComponentText.settings
   * @property {number} [paddingStart=5] - Start padding in pixels
   * @property {number} [paddingEnd=5] - End padding in pixels
   * @property {number} [paddingLeft=0] - Left padding in pixels
   * @property {number} [paddingRight=0] - Right padding in pixels
   * @property {string} [anchor='center'] - Where to v- or h-align the text. Supports `left`, `right`, `top`, `bottom` and `center`
   * @property {string} [join=', '] - String to add when joining titles from multiple sources
   * @property {number} [maxLengthPx] - Limit the text length
   */ /**
   * @typedef {object} ComponentText.style
   * @property {object} [text]
   */ /**
   * @typedef {object} ComponentText.style.text
   * @property {string} [fontSize='12px'] - Font size of text
   * @property {string} [fontFamily='Source Sans Pro'] - Font family of text
   * @property {string} [fontWeight='normal'] - Font weight of text
   * @property {string} [fill='#ffffff'] - Fill color of text
   * @property {string} [stroke='transparent'] - Stroke of text
   * @property {number} [strokeWidth=0] - Stroke width of text
   * @property {number} [opacity=1] - Opacity of text
   */const textComponent={require:['renderer','chart'],defaultSettings:{layout:{dock:'bottom',displayOrder:0,prioOrder:0},settings:{paddingStart:5,paddingEnd:5,paddingLeft:0,paddingRight:0,anchor:'center',join:', ',maxLengthPx:NaN},style:{text:'$title'}},created(){this.definitionSettings=this.settings.settings;const text=this.settings.text;const join=this.definitionSettings.join;this.title=parseTitle(text,join,this.scale);},preferredSize(){const height=this.renderer.measureText({text:this.title,fontSize:this.style.text.fontSize,fontFamily:this.style.text.fontFamily}).height;return height+this.definitionSettings.paddingStart+this.definitionSettings.paddingEnd;},render(){const{title,definitionSettings,rect}=this;const nodes=[];nodes.push(generateTitle({title,dock:this.settings.layout.dock,definitionSettings,rect,measureText:this.renderer.measureText,style:this.style}));return nodes;},beforeUpdate(opts){if(opts.settings){extend$1(this.settings,opts.settings);this.definitionSettings=opts.settings.settings;}const text=this.settings.text;const join=this.definitionSettings.join;this.title=parseTitle(text,join,this.scale);}};function text(picasso){picasso.component('text',textComponent);}/**
   * @typedef {object} ComponentScrollbar
   * @extends ComponentSettings
   * @private
   */ /**
   * @typedef {object} ComponentScrollbar.settings
   * @property {boolean} [backgroundColor = '#eee']
   * @property {boolean} [thumbColor = '#ccc']
   * @property {boolean} [width = 16]
   */function start$1(_scrollbar,pos){const dock=_scrollbar.settings.layout.dock;const invert=_scrollbar.settings.settings.invert;const horizontal=dock==='top'||dock==='bottom';const lengthAttr=horizontal?'width':'height';const length=_scrollbar.rect[lengthAttr];const scroll=_scrollbar.chart.scroll(_scrollbar.settings.scroll);let currentMove;{// local scope to allow reuse of variable names later
  let offset=pos[horizontal?'x':'y'];if(invert){offset=length-offset;}const scrollState=scroll.getState();currentMove={startOffset:offset,startScroll:scrollState.start,swipe:false};// Detect swipe start outsize the thumb & change startScroll to jump the scroll there.
  const scrollPoint=offset/length*(scrollState.max-scrollState.min)+scrollState.min;if(scrollPoint<scrollState.start){currentMove.startScroll=scrollPoint;}else if(scrollPoint>scrollState.start+scrollState.viewSize){currentMove.startScroll=scrollPoint-scrollState.viewSize;}}const update=p=>{let offset=p[horizontal?'x':'y'];if(invert){offset=length-offset;}if(!currentMove.swipe){if(Math.abs(currentMove.startOffset-offset)<=1){return;}currentMove.swipe=true;}const scrollState=scroll.getState();const scrollMove=(offset-currentMove.startOffset)/length*(scrollState.max-scrollState.min);const scrollStart=currentMove.startScroll+scrollMove;scroll.moveTo(scrollStart);};const end=p=>{let offset=p[horizontal?'x':'y'];if(invert){offset=length-offset;}const scrollState=scroll.getState();if(currentMove.swipe){const scrollMove=(offset-currentMove.startOffset)/length*(scrollState.max-scrollState.min);const scrollStart=currentMove.startScroll+scrollMove;scroll.moveTo(scrollStart);}else {const scrollCenter=offset/length*(scrollState.max-scrollState.min)+scrollState.min;const scrollStart=scrollCenter-scrollState.viewSize/2;scroll.moveTo(scrollStart);}};return {update,end};}function getLocalPos(event,renderer){const containerRect=renderer.element().getBoundingClientRect();return {x:event.center.x-containerRect.left,y:event.center.y-containerRect.top};}const scrollbarComponent={require:['chart','renderer'],on:{panStart(event){const pos=getLocalPos(event,this.renderer);const startPos={x:pos.x-event.deltaX,y:pos.y-event.deltaY};this.currentMove=start$1(this,startPos);this.currentMove.update(pos);},panMove(event){if(!this.currentMove){return;}const pos=getLocalPos(event,this.renderer);this.currentMove.update(pos);},panEnd(event){if(!this.currentMove){return;}const pos=getLocalPos(event,this.renderer);this.currentMove.end(pos);this.currentMove=null;},panCancel(){this.currentMove=null;},tap(event){const pos=getLocalPos(event,this.renderer);const move=start$1(this,pos);move.end(pos);}},defaultSettings:{settings:{backgroundColor:'#eee',thumbColor:'#ccc',width:16// 32 for touch
  }},preferredSize:function preferredSize(rect){const scrollState=this.chart.scroll(this.settings.scroll).getState();// hide the scrollbar if it is not possible to scroll
  if(scrollState.viewSize>=scrollState.max-scrollState.min){const toLargeSize=Math.max(rect.width,rect.height);return toLargeSize;}return this.settings.settings.width;},render:function render(h){const dock=this.settings.layout.dock;const invert=this.settings.settings.invert;const horizontal=dock==='top'||dock==='bottom';const lengthAttr=horizontal?'width':'height';const _rect=this.rect;const length=_rect[lengthAttr];const scrollState=this.chart.scroll(this.settings.scroll).getState();let thumbStart=length*(scrollState.start-scrollState.min)/(scrollState.max-scrollState.min);const thumbRange=length*scrollState.viewSize/(scrollState.max-scrollState.min);if(invert){thumbStart=length-thumbStart-thumbRange;}return h('div',{style:{position:'relative',width:'100%',height:'100%',background:this.settings.settings.backgroundColor,pointerEvents:'auto'}},[].concat(h('div',{class:'scroller',style:{position:'absolute',[horizontal?'left':'top']:"".concat(thumbStart,"px"),[horizontal?'top':'left']:'25%',[horizontal?'height':'width']:'50%',// ${width}px
  [lengthAttr]:"".concat(Math.max(1,thumbRange),"px"),background:this.settings.settings.thumbColor}})));},renderer:'dom'};function scrollbar(picasso){picasso.component('scrollbar',scrollbarComponent);}const TARGET_SIZE=5;const VERTICAL=0;const HORIZONTAL=1;function buildLine(_ref){let{h,isVertical,value,pos,align,borderHit,state,idx}=_ref;const isAlignStart=align!=='end';const alignStart={left:'0',top:'0'};const alignEnd={right:'0',bottom:'0'};const alignStyle=isAlignStart?alignStart:alignEnd;let start=0;let width='100%';let height='100%';if(state.targetRect&&state.settings.bubbles.align==='start'){width="".concat(state.targetRect.x+state.targetRect.width,"px");height="".concat(state.targetRect.y+state.targetRect.height,"px");}else if(state.targetRect&&state.settings.bubbles.align==='end'){start=isVertical?state.targetRect.x:state.targetRect.y;width="".concat(state.rect.width-start,"px");height="".concat(state.rect.height-start,"px");}if(!isAlignStart){pos-=borderHit;}// edge
  return h('div',{onmouseover(e){e.srcElement.children[0].style.backgroundColor='#000';e.srcElement.children[0].style[isVertical?'height':'width']='2px';},onmouseout(e){e.srcElement.children[0].style.backgroundColor=state.style.line.stroke;e.srcElement.children[0].style[isVertical?'height':'width']='1px';},'data-value':value,'data-key':[state.key,'edge',idx].join('-'),style:{cursor:isVertical?'ns-resize':'ew-resize',position:'absolute',left:isVertical?"".concat(start,"px"):"".concat(pos,"px"),top:isVertical?"".concat(pos,"px"):"".concat(start,"px"),height:isVertical?"".concat(borderHit,"px"):height,width:isVertical?width:"".concat(borderHit,"px"),pointerEvents:'auto'}},[// line
  h('div',{style:extend$1({backgroundColor:state.style.line.stroke,position:'absolute',height:isVertical?"".concat(1,"px"):'100%',width:isVertical?'100%':"".concat(1,"px"),pointerEvents:'none'},alignStyle)})]);}function buildBubble(_ref2){let{h,isVertical,label,otherValue,rangeIdx,idx,pos,align,state,value}=_ref2;const isAlignStart=align!=='end';const isOutside=state.settings.bubbles.placement==='outside';let outside='none';let bubbleDock;if(isVertical){bubbleDock=isAlignStart?'left':'right';if(isOutside){outside=isAlignStart?'translate(-100%,  0px)':'translate(100%,  0px)';}}else {bubbleDock=isAlignStart?'top':'bottom';if(isOutside){outside=isAlignStart?'translate(0px, -100%)':'translate(0px,  100%)';}}let inEdit=state.edit&&state.edit.rangeIdx===rangeIdx&&state.edit.bubbleIdx===idx;const bubbleStyle={position:'relative',borderRadius:"".concat(state.style.bubble.borderRadius,"px"),border:"".concat(state.style.bubble.strokeWidth,"px solid ").concat(state.style.bubble.stroke),backgroundColor:state.style.bubble.fill,color:state.style.bubble.color,fontFamily:state.style.bubble.fontFamily,fontSize:state.style.bubble.fontSize,padding:'4px 8px',textAlign:'center',overflow:'hidden',textOverflow:'ellipsis',whiteSpace:'nowrap',maxWidth:'150px',minWidth:'50px',minHeight:'1em',pointerEvents:'auto',transform:isVertical?'translate(0,-50%)':'translate(-50%,0)',cursor:isVertical?'ns-resize':'ew-resize'};let currentBorderColor=state.style.bubble.stroke;const bubble=inEdit?h('input',{type:'text',value,style:_objectSpread2$1(_objectSpread2$1({},bubbleStyle),{},{textAlign:'start',textOverflow:'',fontSize:'13px'// TODO - make it styleable
  }),onkeyup(e){if(e.key==='Enter'){e.preventDefault();e.stopPropagation();const newValue=parseFloat(e.target.value);if(isNaN(newValue)){currentBorderColor='rgba(230, 78, 78, 0.6)';e.target.style.border="".concat(state.style.bubble.strokeWidth,"px solid ").concat(currentBorderColor);}else {state.onEditConfirmed(rangeIdx,newValue,otherValue);}}else if(e.key==='Escape'){e.preventDefault();e.stopPropagation();state.onEditCanceled();}}}):h('div',{'data-key':[state.key,'bubble',rangeIdx,idx].join('-'),'data-other-value':otherValue,'data-idx':rangeIdx,'data-bidx':idx,style:bubbleStyle},[label]);// bubble wrapper
  return h('div',{style:{position:'absolute',[bubbleDock]:'0',[isVertical?'top':'left']:"".concat(pos,"px"),transform:outside}},[// bubble
  bubble]);}function buildArea(_ref3){let{h,isVertical,top,height,color,on,opacity}=_ref3;return h('div',extend$1({style:{backgroundColor:color,opacity,position:'absolute',left:isVertical?0:"".concat(top,"px"),top:isVertical?"".concat(top,"px"):0,height:isVertical?"".concat(height,"px"):'100%',width:isVertical?'100%':"".concat(height,"px"),pointerEvents:'auto'}},on),[]);}function buildRange(_ref4){let{borderHit,els,isVertical,state,vStart,vEnd,idx}=_ref4;let targetOffset=0;if(state.targetRect){targetOffset=isVertical?state.targetRect.y:state.targetRect.x;}const hasScale=!!state.scale;const start=hasScale?state.scale.norm(vStart)*state.size:vStart;const end=hasScale?state.scale.norm(vEnd)*state.size:vEnd;const height=Math.abs(start-end);const top=Math.min(start,end)+targetOffset;const bottom=top+height;if(state.targetRect){const target=state.targetFillRect||state.targetRect;const targetSize=isVertical?target.height:target.width;const targetStart=hasScale?state.scale.norm(vStart)*targetSize:vStart;const targetEnd=hasScale?state.scale.norm(vEnd)*targetSize:vEnd;const targetHeight=Math.abs(targetStart-targetEnd);const targetTop=Math.min(targetStart,targetEnd);const targetArea={h:state.h,isVertical,top:targetTop,height:targetHeight,color:state.style.target.fill,opacity:state.style.target.opacity};if(state.style.target.opacity<0.8){targetArea.on={onmouseover(e){e.srcElement.style.opacity=state.style.target.opacity+0.1;},onmouseout(e){e.srcElement.style.opacity=state.style.target.opacity;}};}els.push(state.h('div',{style:{position:'absolute',left:"".concat(target.x,"px"),top:"".concat(target.y,"px"),height:"".concat(target.height,"px"),width:"".concat(target.width,"px")}},[buildArea(targetArea)]));}// active range area
  // els.push(buildArea({
  //   h: state.h,
  //   isVertical,
  //   top,
  //   height,
  //   color: state.settings.fill
  // }));
  const valStart=start<end?vStart:vEnd;const valEnd=start<end?vEnd:vStart;const[min,max]=hasScale?state.scale.domain():[Math.min(vStart,vEnd),Math.max(vStart,vEnd)];const isStartVisible=valStart+1e-5>=min&&valStart-1e-5<=max;// accept minor floating point difference
  const isEndVisible=valEnd-1e-5<=max&&valEnd+1e-5>=min;if(isStartVisible){els.push(buildLine({h:state.h,isVertical,borderHit,value:valStart,pos:top,align:'start',state,idx}));}if(isEndVisible){els.push(buildLine({h:state.h,isVertical,borderHit,value:valEnd,pos:bottom,align:'end',state,idx}));}const bubbles=state.settings.bubbles;if(bubbles&&bubbles.show){const fontSize=bubbles.fontSize;const fontFamily=bubbles.fontFamily;const fill=bubbles.fill;const style={fontSize,fontFamily,color:fill};const range=[vStart,vEnd];if(isStartVisible){els.push(buildBubble({h:state.h,isVertical,align:bubbles.align,style,rangeIdx:idx,idx:0,otherValue:valEnd,value:valStart,label:"".concat(state.format(valStart,range)),pos:top,state}));}if(isEndVisible){els.push(buildBubble({h:state.h,isVertical,align:bubbles.align,style,rangeIdx:idx,idx:1,otherValue:valStart,value:valEnd,label:"".concat(state.format(valEnd,range)),pos:bottom,state}));}}}function getMoveDelta(state){const posDelta=state.active.limitHigh-state.active.end;const negDelta=state.active.limitLow-state.active.start;let delta=state.current-state.start;if(delta<0){delta=Math.max(delta,negDelta);}else {delta=Math.min(delta,posDelta);}return delta;}function nodes(state){let els=[];const isVertical=state.direction===VERTICAL;if(Array.isArray(state.ranges)){// add all other ranges
  state.ranges.forEach((r,i)=>{if(!state.active||i!==state.active.idx){buildRange({borderHit:TARGET_SIZE,els,isVertical,state,vStart:Math.min(r.min,r.max),vEnd:Math.max(r.min,r.max),idx:i});}});}if(state.active){// add active range
  let vStart=state.start;let vEnd=state.current;if(state.active.idx!==-1){if(state.active.mode==='foo'){vStart=Math.min(state.active.start,state.active.end);vEnd=Math.max(state.active.start,state.active.end);}else if(state.active.mode==='modify'){vStart=Math.min(state.start,state.current);vEnd=Math.max(state.start,state.current);}else {const delta=getMoveDelta(state);vStart=state.active.start+delta;vEnd=state.active.end+delta;}}buildRange({borderHit:TARGET_SIZE,els,isVertical,state,vStart,vEnd,idx:state.active.idx});}return els;}function rangelimits(state){return {min:state.scale.min(),max:state.scale.max()};}function areaLimits(state){return {min:0,max:state.direction?state.rect.width:state.rect.height};}function findActive(state,value,limits){let rs=state.ranges;let i;let activeIdx=-1;for(i=0;i<rs.length;i++){if(rs[i].min<=value&&value<=rs[i].max){activeIdx=i;limits.min=i?rs[i-1].max:limits.min;limits.max=i+1<rs.length?rs[i+1].min:limits.max;break;}else if(value<rs[i].min){limits.max=rs[i].min;limits.min=i?rs[i-1].max:limits.min;break;}}if(activeIdx===-1&&rs.length&&i>=rs.length){limits.min=rs[rs.length-1].max;}let activeRange;if(activeIdx!==-1){activeRange={idx:activeIdx,start:rs[activeIdx].min,end:rs[activeIdx].max,limitLow:limits.min,limitHigh:limits.max,mode:'foo'};}state.active=activeRange;}function startArea(_ref){let{state,e,renderer,ranges,targetSize}=_ref;if(state.started){return;}const x=e.center.x-e.deltaX;const y=e.center.y-e.deltaY;let target=document.elementFromPoint(x,y);if(!renderer.element().contains(target)){target=null;}const tempState={started:true};state.offset=renderer.element().getBoundingClientRect();state.ranges=ranges(state);const relX=x-state.offset.left;// coordinate relative renderer
  const relY=y-state.offset.top;const startPoint=e.center[state.cssCoord.coord]-e[state.cssCoord.pos]-state.offset[state.cssCoord.offset];const relStart=e.center[state.cssCoord.coord]-state.offset[state.cssCoord.offset];let v=relStart;let vStart=startPoint;tempState.start=startPoint;tempState.current=relStart;let rs=state.ranges;const limits=areaLimits(state);let i;let activeIdx=-1;if(target&&target.hasAttribute('data-idx')){activeIdx=parseInt(target.getAttribute('data-idx'),10);limits.min=activeIdx>0?rs[activeIdx-1].max:limits.min;limits.max=activeIdx+1<rs.length?rs[activeIdx+1].min:limits.max;}else {for(i=0;i<rs.length;i++){if(rs[i].min<=vStart&&vStart<=rs[i].max){activeIdx=i;limits.min=i?rs[i-1].max:limits.min;limits.max=i+1<rs.length?rs[i+1].min:limits.max;break;}else if(vStart<rs[i].min){limits.max=rs[i].min;limits.min=i?rs[i-1].max:limits.min;break;}}if(activeIdx===-1&&rs.length&&i>=rs.length){limits.min=rs[rs.length-1].max;}}if(activeIdx===-1&&!state.multi){tempState.ranges=[];limits.min=0;limits.max=state.direction?state.rect.width:state.rect.height;}let activeRange;if(activeIdx!==-1){activeRange={idx:activeIdx,start:rs[activeIdx].min,end:rs[activeIdx].max,limitLow:limits.min,limitHigh:limits.max,mode:'move'};if(target&&target.hasAttribute('data-other-value')){tempState.start=parseFloat(target.getAttribute('data-other-value'));activeRange.mode='modify';}else {let pxStart=activeRange.start;let pxEnd=activeRange.end;if(Math.abs(startPoint-pxStart)<=targetSize){tempState.start=activeRange.end;activeRange.mode='modify';}else if(Math.abs(startPoint-pxEnd)<=targetSize){tempState.start=activeRange.start;activeRange.mode='modify';}}}else {activeRange={idx:-1,start:vStart,end:v,limitLow:limits.min,limitHigh:limits.max,mode:'current'};}tempState.active=activeRange;if(activeRange.mode!=='modify'&&state.targetRect&&!testRectPoint(state.targetRect,{x:relX,y:relY}));else {Object.keys(tempState).forEach(key=>state[key]=tempState[key]);}}function start$2(_ref2){let{state,e,renderer,ranges,targetSize}=_ref2;if(state.started){return;}state.edit=null;const x=e.center.x-e.deltaX;const y=e.center.y-e.deltaY;let target=document.elementFromPoint(x,y);if(!renderer.element().contains(target)){target=null;}const tempState={started:true};state.offset=extend$1({},renderer.element().getBoundingClientRect());const relX=x-state.offset.left;// coordinate relative renderer
  const relY=y-state.offset.top;state.offset.left+=state.targetRect?state.targetRect.x:0;// make offset relative to targetRect
  state.offset.top+=state.targetRect?state.targetRect.y:0;state.ranges=ranges(state,state.fauxBrushInstance||state.brushInstance);const startPoint=e.center[state.cssCoord.coord]-e[state.cssCoord.pos]-state.offset[state.cssCoord.offset];const relStart=e.center[state.cssCoord.coord]-state.offset[state.cssCoord.offset];tempState.current=state.scale.normInvert(relStart/state.size);tempState.start=state.scale.normInvert(startPoint/state.size);let rs=state.ranges;const limits=rangelimits(state);let i;let activeIdx=-1;if(target&&target.hasAttribute('data-idx')){activeIdx=parseInt(target.getAttribute('data-idx'),10);limits.min=activeIdx>0?rs[activeIdx-1].max:limits.min;limits.max=activeIdx+1<rs.length?rs[activeIdx+1].min:limits.max;}else {for(i=0;i<rs.length;i++){if(rs[i].min<=tempState.start&&tempState.start<=rs[i].max){activeIdx=i;limits.min=i?rs[i-1].max:limits.min;limits.max=i+1<rs.length?rs[i+1].min:limits.max;break;}else if(tempState.start<rs[i].min){limits.max=rs[i].min;limits.min=i?rs[i-1].max:limits.min;break;}}if(activeIdx===-1&&rs.length&&i>=rs.length){limits.min=rs[rs.length-1].max;}}if(activeIdx===-1&&!state.multi){tempState.ranges=[];limits.min=state.scale.min();limits.max=state.scale.max();}let activeRange;if(activeIdx!==-1){activeRange={idx:activeIdx,start:rs[activeIdx].min,end:rs[activeIdx].max,limitLow:limits.min,limitHigh:limits.max,mode:'move'};if(target&&target.hasAttribute('data-other-value')){tempState.start=parseFloat(target.getAttribute('data-other-value'));activeRange.mode='modify';}else {let pxStart=state.scale.norm(activeRange.start)*state.size;let pxEnd=state.scale.norm(activeRange.end)*state.size;if(Math.abs(startPoint-pxStart)<=targetSize){tempState.start=activeRange.end;activeRange.mode='modify';}else if(Math.abs(startPoint-pxEnd)<=targetSize){tempState.start=activeRange.start;activeRange.mode='modify';}}}else {activeRange={idx:-1,start:tempState.start,end:tempState.current,limitLow:limits.min,limitHigh:limits.max,mode:'current'};}tempState.active=activeRange;if(activeRange.mode!=='modify'&&state.targetRect&&!testRectPoint(state.targetRect,{x:relX,y:relY}));else {Object.keys(tempState).forEach(key=>state[key]=tempState[key]);}}function end(state,ranges){state.started=false;state.ranges=ranges(state,state.fauxBrushInstance||state.brushInstance);const limits=rangelimits(state);findActive(state,state.current,limits);}function endArea(state,ranges){state.started=false;state.ranges=ranges(state);const limits=areaLimits(state);findActive(state,state.current,limits);}function move(state,e){const relY=e.center[state.cssCoord.coord]-state.offset[state.cssCoord.offset];const rel=relY/state.size;const v=state.scale.normInvert(rel);state.current=Math.max(Math.min(v,state.active.limitHigh),state.active.limitLow);}function moveArea(state,e){const rel=e.center[state.cssCoord.coord]-state.offset[state.cssCoord.offset];state.current=Math.max(Math.min(rel,state.active.limitHigh),state.active.limitLow);}function render$c(state){state.renderer.render(nodes(state));}function ranges$2(state,brush){if(!brush||!brush.isActive()){return [];}const sourceData=state.scale.data();const sourceFields=sourceData?sourceData.fields||[]:[];const sources=sourceFields.map(field=>field.id());const rangeBrush=brush.brushes().filter(f=>f.type==='range'&&sources.indexOf(f.id)!==-1)[0];if(!rangeBrush){return [];}return rangeBrush.brush.ranges();}function setRanges$1(state){let rs=state.ranges.map(r=>({min:r.min,max:r.max}));if(state.active.idx!==-1){if(state.active.mode==='modify'){rs[state.active.idx].min=Math.min(state.start,state.current);rs[state.active.idx].max=Math.max(state.start,state.current);}else {const delta=getMoveDelta(state);rs[state.active.idx].min+=delta;rs[state.active.idx].max+=delta;}}else {rs.push({min:Math.min(state.start,state.current),max:Math.max(state.start,state.current)});}const scaleData=state.scale.data();if(scaleData&&scaleData.fields){scaleData.fields.forEach(field=>{if(state.fauxBrushInstance){let ordRS=ranges$2(state,state.fauxBrushInstance);let oldValues=state.findValues(ordRS);let values=state.findValues(rs);let addedValues=values.filter(v=>oldValues.indexOf(v)===-1);let removedValues=oldValues.filter(v=>values.indexOf(v)===-1);let addItems=addedValues.map(v=>({key:field.id(),value:v}));let removeItems=removedValues.map(v=>({key:field.id(),value:v}));state.brushInstance.addAndRemoveValues(addItems,removeItems);state.fauxBrushInstance.setRange(field.id(),rs);}else {state.brushInstance.setRange(field.id(),rs);}});}}function setEditedRanges(state,idx,startValue,endValue){let rs=state.ranges.map(r=>({min:r.min,max:r.max}));const limitMin=state.scale.min();const limitMax=state.scale.max();rs[idx]={min:Math.max(limitMin,Math.min(startValue,endValue)),max:Math.min(limitMax,Math.max(startValue,endValue))};state.ranges[idx]=_objectSpread2$1({},rs[idx]);const scaleData=state.scale.data();if(scaleData&&scaleData.fields){scaleData.fields.forEach(field=>{if(!state.fauxBrushInstance){state.brushInstance.setRange(field.id(),rs);}});}}function findClosest(value,scale){let name;let minDist=Infinity;const domain=scale.domain();const halfBandwidth=scale.bandwidth()/2;for(let i=0;i<domain.length;++i){const d=Math.abs(value-halfBandwidth-scale(domain[i]));if(d<minDist){minDist=d;name=domain[i];}}return name;}function findClosestLabel(value,scale){const ticks=scale.ticks();const idx=scale.domain().indexOf(findClosest(value,scale));return idx!==-1?ticks[idx].label:'-';}function rangesOverlap(r1,r2){return Math.min(...r1)<=Math.max(...r2)&&Math.max(...r1)>=Math.min(...r2);}function findValues(rangesValues,scale){const domain=scale.domain();const scaleRange=scale.range();const values=[];rangesValues.forEach(range=>{if(!rangesOverlap(scaleRange,[range.min,range.max])){return;}const startIdx=domain.indexOf(findClosest(range.min,scale));const endIdx=domain.indexOf(findClosest(range.max,scale));values.push.apply(values,domain.slice(Math.min(startIdx,endIdx),Math.max(startIdx,endIdx)+1));/* eslint prefer-spread:0 */});return values;}function resolveNodeBounds(targetNodes){const points=targetNodes.reduce((ary,node)=>{ary.push(...rectToPoints(node.bounds));return ary;},[]);return pointsToRect(points);}function resolveTarget(ctx){const resolved={targetRect:null,targetFillRect:null,scale:null,size:null};const stngs=ctx.settings.settings;const targets=stngs.target&&(stngs.target.components||(stngs.target.component?[stngs.target.component]:[])).map(c=>ctx.chart.component(c)).filter(c=>!!c&&!!c.rect);const targetNodes=stngs.target&&stngs.target.selector?ctx.chart.findShapes(stngs.target.selector):[];const targetFillNodes=stngs.target&&stngs.target.fillSelector?ctx.chart.findShapes(stngs.target.fillSelector):[];if(targetNodes.length>0){const bounds=resolveNodeBounds(targetNodes);resolved.size=bounds[ctx.state.direction===VERTICAL?'height':'width'];resolved.scale=scaleWithSize(ctx.chart.scale(stngs.scale),resolved.size);resolved.targetRect=bounds;if(targetFillNodes.length>0){const fillBounds=resolveNodeBounds(targetFillNodes);resolved.targetFillRect=fillBounds;}}else if(targets&&targets.length>0){const targetRect=targets.slice(1).reduce((prev,curr)=>({x0:Math.min(prev.x0,curr.rect.computedInner.x),y0:Math.min(prev.y0,curr.rect.computedInner.y),x1:Math.max(prev.x1,curr.rect.computedInner.x+curr.rect.computedInner.width),y1:Math.max(prev.y1,curr.rect.computedInner.y+curr.rect.computedInner.height)}),{x0:targets[0].rect.computedInner.x,y0:targets[0].rect.computedInner.y,x1:targets[0].rect.computedInner.x+targets[0].rect.computedInner.width,y1:targets[0].rect.computedInner.y+targets[0].rect.computedInner.height});resolved.targetRect={x:targetRect.x0-ctx.state.rect.x,y:targetRect.y0-ctx.state.rect.y,width:targetRect.x1-targetRect.x0,height:targetRect.y1-targetRect.y0};}return resolved;}/**
   * @typedef {object} ComponentBrushRange.settings
   * @property {string|object} brush - Brush context to apply changes to
   * @property {string} scale - Scale to extract data from
   * @property {string} [direction=vertical] - Rendering direction [horizontal|vertical]
   * @property {object} [bubbles]
   * @property {boolean} [bubbles.show=true] - True to show label bubble, false otherwise
   * @property {string} [bubbles.align=start] - Where to anchor bubble [start|end]
   * @property {function} [bubbles.label] - Callback function for the labels
   * @property {object} [target]
   * @property {string[]} [target.components] - Render matching overlay on target components
   * @property {string} [target.selector] - Instead of targeting a component, target one or more shapes
   * @property {string} [target.fillSelector] - Target a subset of the selector as fill area. Only applicable if `selector` property is set
   */ /**
   * @private
   * @typedef {object} ComponentBrushRangeStyle
   * @property {object} [bubble]
   * @property {string} [bubble.fontSize]
   * @property {string} [bubble.fontFamily]
   * @property {string} [bubble.fill]
   * @property {string} [bubble.color]
   * @property {string} [bubble.stroke]
   * @property {number} [bubble.strokeWidth]
   * @property {number} [bubble.borderRadius]
   * @property {object} [line]
   * @property {string} [line.stroke]
   * @property {number} [line.strokeWidth]
   * @property {object} [target]
   * @property {string} [target.fill]
   * @property {number} [target.strokeWidth]
   * @property {number} [target.opacity]
   */const brushRangeComponent={require:['chart','settings','renderer'],defaultSettings:{settings:{bubbles:{show:true,align:'start'}},style:{bubble:'$label-overlay',line:'$shape-guide--inverted',target:'$selection-area-target'}},renderer:'dom',on:{rangeStart(e){this.start(e);},rangeMove(e){this.move(e);},rangeEnd(e){this.end(e);},rangeClear(e){this.clear(e);},bubbleStart(e){this.bubbleStart(e);}},created(){this.state={key:this.settings.key||'brush-range'};},beforeRender(opts){this.state.rect=opts.size.computedInner;},renderRanges(){if(!this.state.started){this.state.ranges=ranges$2(this.state,this.state.brushInstance);this.state.active=null;render$c(this.state);}},render(h){const stngs=this.settings.settings;this.state.direction=stngs.direction==='vertical'?VERTICAL:HORIZONTAL;const offset=this.renderer.element().getBoundingClientRect();const size=this.state.rect[this.state.direction===VERTICAL?'height':'width'];let scale=scaleWithSize(this.chart.scale(stngs.scale),size);const target=resolveTarget(this);scale=target.scale?target.scale:scale;this.state.targetRect=target.targetRect;this.state.targetFillRect=target.targetFillRect;this.state.size=target.size===null?size:target.size;this.state.settings=stngs;this.state.style=this.style;this.state.offset=offset;this.state.brush=typeof stngs.brush==='object'?stngs.brush.context:stngs.brush;this.state.brushInstance=this.chart.brush(this.state.brush);this.state.renderer=this.renderer;this.state.multi=!!stngs.multiple;this.state.h=h;this.state.onEditConfirmed=(rangeIdx,value,otherValue)=>{this.state.edit=null;setEditedRanges(this.state,rangeIdx,value,otherValue);this.emit('bubbleEnd');render$c(this.state);};this.state.onEditCanceled=()=>{this.state.edit=null;render$c(this.state);};this.state.cssCoord={offset:this.state.direction===VERTICAL?'top':'left',coord:this.state.direction===VERTICAL?'y':'x',pos:this.state.direction===VERTICAL?'deltaY':'deltaX'};this.state.format=typeof stngs.bubbles.label==='function'?(v,r)=>stngs.bubbles.label.call(undefined,{datum:v,data:r,scale,resources:{scale:this.chart.scale,formatter:this.chart.formatter}}):false;if(!{}.hasOwnProperty.call(scale,'norm')){// Non-linear scale if norm method is unavailable
  this.state.editable=false;this.state.scale=scaleLinear();this.state.scale.data=scale.data;if(!this.state.format){this.state.format=(v,r)=>{if(!rangesOverlap(scale.range(),r)){return '-';}return findClosestLabel(v,scale);};}this.state.fauxBrushInstance=brush();this.state.findValues=valueRanges=>findValues(valueRanges,scale);}else {this.state.editable=true;this.state.observeBrush=typeof stngs.brush==='object'?stngs.brush.observe:false;this.state.fauxBrushInstance=null;this.state.findValues=null;this.state.scale=scale;const scaleData=this.state.scale.data();if(!this.state.format&&scaleData&&scaleData.fields&&scaleData.fields[0]){this.state.format=scaleData.fields[0].formatter();}}this.state.ranges=ranges$2(this.state,this.state.brushInstance);return this.state.observeBrush||this.state.sourcedFromThisComponent?[nodes(this.state)]:[];},mounted(){if(this.state.observeBrush&&this.state.brushInstance){this.state.brushInstance.on('update',this.renderRanges);}},beforeDestroy(){if(this.state.observeBrush&&this.state.brushInstance){this.state.brushInstance.removeListener('update',this.renderRanges);}},start(e){start$2({e,state:this.state,renderer:this.renderer,ranges:ranges$2,targetSize:TARGET_SIZE});},end(){if(!this.state.started){return;}end(this.state,ranges$2);render$c(this.state);this.state.sourcedFromThisComponent=true;this.state.active=null;},move(e){if(!this.state.started){return;}move(this.state,e);setRanges$1(this.state);render$c(this.state);},clear(){if(this.state.fauxBrushInstance){this.state.fauxBrushInstance.clear();}this.state.renderer.render([]);this.state.started=false;this.state.active=null;this.state.sourcedFromThisComponent=false;},bubbleStart(e){if(!this.state.editable){return;}const ee=e.srcEvent||e;const target=ee.target;const ed={rangeIdx:parseInt(target.getAttribute('data-idx'),10),bubbleIdx:parseInt(target.getAttribute('data-bidx'),10)};if(isNaN(ed.rangeIdx)||JSON.stringify(ed)===JSON.stringify(this.state.edit)){return;}this.state.edit=ed;ee.stopPropagation();ee.stopImmediatePropagation();ee.preventDefault();const wrapper=target.parentNode;render$c(this.state);const inputEl=wrapper.querySelector('input');inputEl.focus();inputEl.select();}};function render$b(state){state.renderer.render(nodes(state));}function ranges$1(state){return state.rc.ranges();}function shapesFromRange(state,brushRange){const shapeAt={x:state.direction?brushRange.min+state.rect.x:state.rect.x,y:state.direction?state.rect.y:brushRange.min+state.rect.y,width:state.direction?brushRange.max-brushRange.min:state.rect.width+state.rect.x,height:state.direction?state.rect.height+state.rect.y:brushRange.max-brushRange.min};return state.chart.shapesAt(shapeAt,state.settings.brush);}function brushFromShape(state,newShapes){state.chart.brushFromShapes(newShapes,state.settings.brush);}function setRanges(state){const rs=state.ranges.map(r=>({min:r.min,max:r.max}));if(state.active.idx!==-1){if(state.active.mode==='modify'){rs[state.active.idx].min=Math.min(state.start,state.current);rs[state.active.idx].max=Math.max(state.start,state.current);}else {const delta=getMoveDelta(state);rs[state.active.idx].min=state.active.start+delta;rs[state.active.idx].max=state.active.end+delta;}}else {rs.push({min:Math.min(state.start,state.current),max:Math.max(state.start,state.current)});}state.rc.set(rs);let shapes=[];rs.forEach(range=>{shapes=[...shapes,...shapesFromRange(state,range)];});brushFromShape(state,shapes);}function getBubbleLabel(state,value,range){const min=Math.min(...range);const max=Math.max(...range);const shapeAt={x:state.direction?min+state.rect.x:state.rect.x,y:state.direction?state.rect.y:min+state.rect.y,width:state.direction?max-min:state.rect.width+state.rect.x,height:state.direction?state.rect.height+state.rect.y:max-min};const shapes=state.chart.shapesAt(shapeAt,state.settings.brush);if(shapes.length===0){return '-';}const labelShape=shapes.reduce((s0,s1)=>{// Min value
  const bounds0=s0.bounds;const bounds1=s1.bounds;if(value===min){if(bounds0[state.cssCoord.coord]<=bounds1[state.cssCoord.coord]){return s0;}return s1;}// Max value
  if(bounds0[state.cssCoord.coord]+bounds0[state.cssCoord.area]>=bounds1[state.cssCoord.coord]+bounds1[state.cssCoord.area]){return s0;}return s1;});const compConfig=state.settings.brush.components.reduce((c0,c1)=>c0.key===labelShape.key?c0:c1);if(typeof state.settings.bubbles.label==='function'){return state.settings.bubbles.label(labelShape.data);}if(Array.isArray(compConfig.data)&&compConfig.data.length){return labelShape.data[compConfig.data[0]].label;}return labelShape.data&&labelShape.data.label?labelShape.data.label:'-';}/**
   * @typedef {object} ComponentBrushAreaDir.settings
   * @property {object} brush
   * @property {BrushTargetConfig[]} brush.components
   * @property {string} [direction=vertical] - Rendering direction [horizontal|vertical]
   * @property {object} [bubbles]
   * @property {boolean} [bubbles.show=true] - True to show label bubble, false otherwise
   * @property {string} [bubbles.align=start] - Where to anchor bubble [start|end]
   * @property {function} [bubbles.label] - Callback function for the labels
   * @property {object} [target]
   * @property {string[]} [target.components] - Render matching overlay on target components
   */ /**
   * @private
   * @typedef {object} ComponentBrushAreaDirStyle
   * @property {object} [bubble]
   * @property {string} [bubble.fontSize]
   * @property {string} [bubble.fontFamily]
   * @property {string} [bubble.fill]
   * @property {string} [bubble.color]
   * @property {string} [bubble.stroke]
   * @property {number} [bubble.strokeWidth]
   * @property {number} [bubble.borderRadius]
   * @property {object} [line]
   * @property {string} [line.stroke]
   * @property {number} [line.strokeWidth]
   * @property {object} [target]
   * @property {string} [target.fill]
   * @property {number} [target.strokeWidth]
   * @property {number} [target.opacity]
   */const brushAreaDirectionalComponent={require:['chart','settings','renderer'],defaultSettings:{settings:{bubbles:{show:true,align:'start'}},style:{bubble:'$label-overlay',line:'$shape-guide--inverted',target:'$selection-area-target'}},renderer:'dom',on:{areaStart(e){this.start(e);},areaMove(e){this.move(e);},areaEnd(e){this.end(e);},areaClear(e){this.clear(e);}},created(){this.state={key:this.settings.key||'brush-area-dir'};},render(h){this.state.rect=this.rect;const stngs=this.settings.settings;const direction=stngs.direction==='vertical'?VERTICAL:HORIZONTAL;const size=this.state.rect[direction===VERTICAL?'height':'width'];const offset=this.renderer.element().getBoundingClientRect();const targets=(stngs.target?stngs.target.components||[stngs.target.component]:[]).map(c=>this.chart.component(c)).filter(c=>!!c&&!!c.rect);const targetRect=targets[0]?targets.slice(1).reduce((prev,curr)=>({x0:Math.min(prev.x0,curr.rect.x),y0:Math.min(prev.y0,curr.rect.y),x1:Math.max(prev.x1,curr.rect.x+curr.rect.width),y1:Math.max(prev.y1,curr.rect.y+curr.rect.height)}),{x0:targets[0].rect.x,y0:targets[0].rect.y,x1:targets[0].rect.x+targets[0].rect.width,y1:targets[0].rect.y+targets[0].rect.height}):null;this.state.targetRect=targetRect?{x:targetRect.x0-this.rect.x,y:targetRect.y0-this.rect.y,width:targetRect.x1-targetRect.x0,height:targetRect.y1-targetRect.y0}:null;this.state.style=this.style;this.state.chart=this.chart;this.state.direction=direction;this.state.settings=stngs;this.state.offset=offset;this.state.rc=rangeCollection();this.state.renderer=this.renderer;this.state.multi=!!stngs.multiple;this.state.h=h;this.state.size=size;this.state.cssCoord={offset:this.state.direction===VERTICAL?'top':'left',coord:this.state.direction===VERTICAL?'y':'x',pos:this.state.direction===VERTICAL?'deltaY':'deltaX',area:this.state.direction===VERTICAL?'height':'width'};this.state.format=function getFormat(v,r){return getBubbleLabel(this,v,r);};return [];},start(e){startArea({e,state:this.state,renderer:this.renderer,ranges:ranges$1,targetSize:TARGET_SIZE});},end(){if(!this.state.started){return;}endArea(this.state,ranges$1);render$b(this.state);},move(e){if(!this.state.started){return;}moveArea(this.state,e);setRanges(this.state);render$b(this.state);},clear(){if(this.state.rc){this.state.rc.clear();}this.state.renderer.render([]);}};/**
   * @typedef {object} ComponentBrushAreaDir
   * @extends ComponentSettings
   * @property {'brush-area-dir'} type component type
   */ /**
   * @typedef {object} ComponentBrushRange
   * @extends ComponentSettings
   * @property {'brush-range'} type component type
   */function rangeBrush$1(picasso){picasso.component('brush-range',brushRangeComponent);picasso.component('brush-area-dir',brushAreaDirectionalComponent);}const FILL='#ccc';const OPACITY=1;function ranges(state){const brush=state.brush;if(!brush||!brush.isActive()){return [];}const sourceData=state.scale.data();const sourceFields=sourceData?sourceData.fields||[]:[];const sources=sourceFields.map(field=>field.id());const rangeBrush=brush.brushes().filter(f=>f.type==='range'&&sources.indexOf(f.id)!==-1)[0];if(!rangeBrush){return [];}return rangeBrush.brush.ranges();}function shapes(state){const isVertical=state.direction==='vertical';const size=state.rect[isVertical?'height':'width'];const otherSize=state.rect[isVertical?'width':'height'];return ranges(state).map(range=>{const start=state.scale(range.min)*size;const end=state.scale(range.max)*size;const low=Math.min(start,end);const s=Math.abs(start-end);return {type:'rect',fill:state.fill,opacity:state.opacity,x:isVertical?0:low,width:isVertical?otherSize:s,y:isVertical?low:0,height:isVertical?s:otherSize};});}function onStart(state){state.renderer.render(shapes(state));}function onUpdate(state){state.renderer.render(shapes(state));}function onEnd(state){state.renderer.render(shapes(state));}function setup(state,brush,scale,renderer){state.brush=brush;if(!brush){return;}function start(){onStart(state);}function update(){onUpdate(state);}function end(){onEnd(state);}brush.on('start',start);brush.on('update',update);brush.on('end',end);state.start=start;state.update=update;state.end=end;state.brush=brush;state.scale=scale;state.renderer=renderer;}function teardown(state){if(state.brush){state.brush.removeListener('start',state.start);state.brush.removeListener('update',state.update);state.brush.removeListener('end',state.end);}state.start=undefined;state.update=undefined;state.end=undefined;state.brush=undefined;state.scale=undefined;state.renderer=undefined;}/**
   * @private
   * @typedef {object} ComponentRange
   * @extends ComponentSettings
   */ /**
   * @typedef {object} ComponentRange.settings
   * @property {string} brush - Name of brush instance
   * @property {string} scale - Name of a scale
   * @property {string} [direction='horizontal'] - Direction of the brush
   * @property {string} [fill='#ccc'] - Fill color
   * @property {number} [opacity=1] - Layer opacity
   */const rangeComponent={require:['chart','settings','renderer'],defaultSettings:{settings:{}},preferredSize:()=>50,created(){this.state={};},render(){const stngs=this.settings.settings;const brush=this.chart.brush(stngs.brush);const direction=stngs.direction||'horizontal';const distance=direction==='horizontal'?this.rect.width:this.rect.height;const scale=scaleWithSize(this.chart.scale(stngs.scale),distance);teardown(this.state);setup(this.state,brush,scale,this.renderer);this.state.rect=this.rect;this.state.fill=stngs.fill||FILL;this.state.opacity=typeof stngs.opacity!=='undefined'?stngs.opacity:OPACITY;this.state.direction=direction;return shapes(this.state);},beforeDestroy(){teardown(this.state);}};function rangeBrush$2(picasso){picasso.component('range',rangeComponent);}function getPoint(rendererBounds,event){const eventOffsetX=event.center.x;const eventOffsetY=event.center.y;return {x:eventOffsetX-rendererBounds.left,y:eventOffsetY-rendererBounds.top};// return {
  //   x: Math.min(Math.max(eventOffsetX - rendererBounds.left, 0), rendererBounds.width),
  //   y: Math.min(Math.max(eventOffsetY - rendererBounds.top, 0), rendererBounds.height)
  // };
  }function withinThreshold(p,state,settings){const startPoint=state.points[0];const sqrDist=sqrDistance(p,startPoint);return sqrDist<settings.settings.snapIndicator.threshold**2;}function appendToPath(state,p){if(state.path.d==null){state.path.d="M".concat(p.x," ").concat(p.y," ");}else {state.path.d+="L".concat(p.x," ").concat(p.y," ");}state.points.push(p);}function render$a(state,renderer){const nodes=[state.startPoint,state.path,state.snapIndicator].filter(node=>node.visible);renderer.render(nodes);}function setSnapIndictor(_ref){let{state,start=null,end=null}=_ref;if(start!==null){state.snapIndicator.x1=start.x;state.snapIndicator.y1=start.y;}if(end!==null){state.snapIndicator.x2=end.x;state.snapIndicator.y2=end.y;}}function showSnapIndicator(state,show){state.snapIndicator.visible=show;}function setStartPoint(state,p){state.startPoint.cx=p.x;state.startPoint.cy=p.y;}function getComponentDelta(chart,rendererBounds){const chartBounds=chart.element.getBoundingClientRect();return {x:rendererBounds.left-chartBounds.left,y:rendererBounds.top-chartBounds.top};}function doLineBrush(state,chart){if(state.active){const p1=state.points[state.points.length-2];const p2=state.points[state.points.length-1];state.lineBrushShape.x1=p1.x+state.componentDelta.x;state.lineBrushShape.y1=p1.y+state.componentDelta.y;state.lineBrushShape.x2=p2.x+state.componentDelta.x;state.lineBrushShape.y2=p2.y+state.componentDelta.y;const shapes=chart.shapesAt(state.lineBrushShape,{components:state.brushConfig});chart.brushFromShapes(shapes,{components:state.brushConfig});}}function doPolygonBrush(state,chart){if(state.active){const dx=state.componentDelta.x;const dy=state.componentDelta.y;const vertices=state.points.map(p=>({x:p.x+dx,y:p.y+dy}));const shapes=chart.shapesAt({vertices},{components:state.brushConfig});chart.brushFromShapes(shapes,{components:state.brushConfig});}}function initPath(stgns){return {visible:true,type:'path',d:null,fill:stgns.fill,stroke:stgns.stroke,strokeWidth:stgns.strokeWidth,opacity:stgns.opacity,strokeDasharray:stgns.strokeDasharray,collider:{type:null}};}function initSnapIndicator(stgns){return {visible:false,type:'line',x1:0,y1:0,x2:0,y2:0,strokeDasharray:stgns.strokeDasharray,stroke:stgns.stroke,strokeWidth:stgns.strokeWidth,opacity:stgns.opacity,collider:{type:null}};}function initStartPoint(stgns){return {visible:true,type:'circle',cx:0,cy:0,r:stgns.r,fill:stgns.fill,opacity:stgns.opacity,stroke:stgns.stroke,strokeWidth:stgns.strokeWidth,collider:{type:null}};}function getBrushConfig$1(settings){return settings.settings.brush.components.map(b=>({key:b.key,contexts:b.contexts||['lassoBrush'],data:b.data||[''],action:b.action||'add'}));}function endBrush(state,chart){state.brushConfig.forEach(config=>{config.contexts.forEach(context=>{chart.brush(context).end();});});}function resetState$1(){return {points:[],active:false,path:null,snapIndicator:null,startPoint:null,rendererBounds:null,componentDelta:null,brushConfig:null,lineBrushShape:{x1:0,y1:0,x2:0,y2:0}// Keep a single shape instance to avoid instantiating a new object on each lookup
  };}/**
   * @typedef {object} ComponentBrushLasso
   * @extends ComponentSettings
   * @property {'brush-lasso'} type component type
   * @example
   * {
   *  type: 'brush-lasso',
   *  settings: {
   *    brush: {
   *      components: [{ key: '<target-component>', contexts: ['<brush-context>'] }]
   *    }
   *  },
   * }
   */ /**
   * Component settings
   * @typedef {object} ComponentBrushLasso.settings
   * @property {object} [lasso] - Lasso style settings
   * @property {string} [lasso.fill='transparent']
   * @property {string} [lasso.stroke='black']
   * @property {number} [lasso.strokeWidth=2]
   * @property {number} [lasso.opacity=0.7]
   * @property {number} [lasso.strokeDasharray]
   * @property {object} [snapIndicator] - Snap indicator settings
   * @property {number} [snapIndicator.threshold=75] - The distance in pixel to show the snap indicator, if less then threshold the indicator is dispalyed
   * @property {string} [snapIndicator.strokeDasharray='5, 5']
   * @property {string} [snapIndicator.stroke='black']
   * @property {number} [snapIndicator.strokeWidth=2]
   * @property {number} [snapIndicator.opacity=0.5]
   * @property {object} [startPoint] - Start point style settings
   * @property {number} [startPoint.r=10] - Circle radius
   * @property {string} [startPoint.stroke='green']
   * @property {number} [startPoint.strokeWidth=1]
   * @property {number} [startPoint.opacity=1]
   * @property {object} [brush]
   * @property {object[]} brush.components - Array of components to brush on.
   * @property {string} [brush.components[].component.key] - Component key
   * @property {string[]} [brush.components[].component.contexts=['brushLasso']] - Name of the brushing contexts to affect
   * @property {string[]} [brush.components[].component.data=['']] - The mapped data properties to add to the brush
   * @property {string} [brush.components[].component.action='add'] - Type of action to respond with
   */const brushLassoComponent={require:['chart','renderer','settings'],defaultSettings:{layout:{displayOrder:0},settings:{brush:{components:[]},snapIndicator:{threshold:75,strokeDasharray:'5, 5',stroke:'black',strokeWidth:2,opacity:0.5},lasso:{fill:'transparent',stroke:'black',strokeWidth:2,opacity:0.7,strokeDasharray:'20, 10'},startPoint:{r:10,fill:'green',stroke:'black',strokeWidth:1,opacity:1}}},on:{lassoStart(e){this.start(e);},lassoEnd(e){this.end(e);},lassoMove(e){this.move(e);},lassoCancel(){this.cancel();}},created(){this.state=resetState$1();},start(e){this.state.active=true;this.state.path=initPath(this.settings.settings.lasso);this.state.snapIndicator=initSnapIndicator(this.settings.settings.snapIndicator);this.state.startPoint=initStartPoint(this.settings.settings.startPoint);this.state.rendererBounds=this.renderer.element().getBoundingClientRect();this.state.componentDelta=getComponentDelta(this.chart,this.state.rendererBounds);this.state.brushConfig=getBrushConfig$1(this.settings);const p=getPoint(this.state.rendererBounds,e);appendToPath(this.state,p);setSnapIndictor({state:this.state,start:p});setStartPoint(this.state,p);},move(e){if(!this.state.active){return;}const p=getPoint(this.state.rendererBounds,e);if(withinThreshold(p,this.state,this.settings)){showSnapIndicator(this.state,true);}else {showSnapIndicator(this.state,false);}appendToPath(this.state,p);setSnapIndictor({state:this.state,end:p});render$a(this.state,this.renderer);doLineBrush(this.state,this.chart);},end(e){if(!this.state.active){return;}showSnapIndicator(this.state,false);const p=getPoint(this.state.rendererBounds,e);const shouldSnap=withinThreshold(p,this.state,this.settings);if(shouldSnap){doPolygonBrush(this.state,this.chart);}this.state=resetState$1();this.renderer.render([]);},cancel(){if(!this.state.active){return;}endBrush(this.state,this.chart);this.state=resetState$1();this.renderer.render([]);},render(){// Do nothing
  }};function lassoBrush(picasso){picasso.component('brush-lasso',brushLassoComponent);}/**
   * Using the basic example found here: https://en.wikipedia.org/wiki/Binary_search_algorithm
   *
   * Finds the first node that may intersect the label.
   * @private
   */function binaryLeftSearch(labelBounds,ary,coord,side,extractBounds){let left=0;let right=ary.length-1;let bounds;while(left<right){let m=Math.floor((left+right)/2);bounds=extractBounds(ary[m]);if(bounds[coord]+bounds[side]<labelBounds[coord]){// label is on right side
  left=m+1;}else {// label is on the left side
  right=m;}}return left;}/**
   * The purpose of this module is to act as a filtering function to remove any labels
   * that meets one of the following criterias:
   * -- The label is not fully inside the container, such that it would be fully or partially clipped if rendered
   * -- The label overlaps another label
   * -- The label overlaps another bar which is not the bar the label is originating from
   *
   * Assumes that the nodes are sorted from left/top to right/down, as that allows
   * some optimizations to be performed.
   * @private
   * @returns {function} Filter function, returns false if label be removed and true otherwise
   */function filterOverlappingLabels(_ref){let{orientation,targetNodes,labels,container}=_ref;let findLeft=arguments.length>1&&arguments[1]!==undefined?arguments[1]:binaryLeftSearch;const renderLabels=[];const coord=orientation==='v'?'x':'y';const side=orientation==='v'?'width':'height';const getTextBounds=item=>item.textBounds;const getNodeBounds=item=>item.node.localBounds;return (doNotUse,labelIndex)=>{const{textBounds:labelBounds,node:labelNode}=labels[labelIndex];// ### Test if label is not fully inside container based on the orientation ###
  if(labelBounds[coord]<container[coord]||labelBounds[coord]+labelBounds[side]>container[coord]+container[side]){return false;}// ### Test label to label collision ###
  const leftStartLabel=findLeft(labelBounds,renderLabels,coord,side,getTextBounds);for(let i=leftStartLabel;i<renderLabels.length;i++){if(testRectRect(labelBounds,renderLabels[i].textBounds)){return false;}}// ### Test label to node collision ###
  const leftStartNode=findLeft(labelBounds,targetNodes,coord,side,getNodeBounds);const labelRightBoundary=labelBounds[coord]+labelBounds[side];for(let i=leftStartNode;i<targetNodes.length;i++){const node=targetNodes[i].node;// Do not test beyond this node, as they are assumed to not collide with the label
  if(labelRightBoundary<node.localBounds[coord]){break;}if(testRectRect(labelBounds,node.localBounds)&&labelNode!==node){return false;}}// No collision occured, allow the label to be rendered
  renderLabels.push(labels[labelIndex]);return true;};}const PADDING=4;// const DOUBLE_PADDING = PADDING * 2;
  function cbContext$2(node,chart){return {node,data:node.data,scale:chart.scale,formatter:chart.formatter,dataset:chart.dataset};}function isValidText(text){const type=typeof text;return (type==='string'||type==='number')&&text!=='';}function toBackground(label){return _objectSpread2$1(_objectSpread2$1({type:'rect',rx:2,ry:2,fill:label.backgroundColor},label.backgroundBounds),{},{data:"".concat(label.data," ").concat(label.text),rotation:label.transform&&label.transform.match(/rotate/gi)?'rotated':'horizontal'});}function isTextWidthInRectWidth(rect,label,rotate){return rotate?rect.width>=label.height:rect.width>=label.width;}function isTextHeightInRectHeight(rect,label,rotate){return rotate?rect.height>=label.width:rect.height>=label.height;}function isGoodPlacement(orientation,rect,label,fitsHorizontally,overflow){let fitWidth;let fitHeight;if(orientation==='v'){fitWidth=fitsHorizontally||overflow||isTextWidthInRectWidth(rect,label,true);fitHeight=isTextHeightInRectHeight(rect,label,!fitsHorizontally);}else {fitWidth=isTextWidthInRectWidth(rect,label);fitHeight=overflow||isTextHeightInRectHeight(rect,label,false);}return fitWidth&&fitHeight;}function isTextInRect(rect,label,opts){return isTextWidthInRectWidth(rect,label,opts.rotate)&&isTextHeightInRectHeight(rect,label,opts.rotate);}function placeSegmentInSegment(majorSegmentPosition,majorSegmentSize,minorSegmentSize,align){const majorSegmentCenter=majorSegmentPosition+majorSegmentSize*0.5;const offset=(align-0.5)*(majorSegmentSize-minorSegmentSize);const minorSegmentCenter=majorSegmentCenter+offset;const minorSegmentPosition=minorSegmentCenter-minorSegmentSize*0.5;return minorSegmentPosition;}function placeTextInRect$2(rect,text,opts){const label={type:'text',text,maxWidth:opts.rotate?rect.height:rect.width,x:0,y:rect.y,dx:0,dy:0,fill:opts.fill,anchor:opts.rotate?'end':'start',baseline:'central',fontSize:"".concat(opts.fontSize,"px"),fontFamily:opts.fontFamily};const textMetrics=opts.textMetrics;if(!opts.overflow&&!isTextInRect(rect,textMetrics,opts)){return false;}const baseLineOffset=textMetrics.height*0.5;if(opts.rotate){label.x=placeSegmentInSegment(rect.x,rect.width,textMetrics.height,opts.align)+baseLineOffset;label.y=placeSegmentInSegment(rect.y,rect.height,textMetrics.width,opts.justify);label.transform="rotate(-90, ".concat(label.x+label.dx,", ").concat(label.y+label.dy,")");}else {label.x=placeSegmentInSegment(rect.x,rect.width,textMetrics.width,opts.align);label.y=placeSegmentInSegment(rect.y,rect.height,textMetrics.height,opts.justify)+baseLineOffset;}return label;}function limitBounds(bounds,view){const minY=Math.max(0,Math.min(bounds.y,view.height));const maxY=Math.max(0,Math.min(bounds.y+bounds.height,view.height));const minX=Math.max(0,Math.min(bounds.x,view.width));const maxX=Math.max(0,Math.min(bounds.x+bounds.width,view.width));bounds.x=minX;bounds.width=maxX-minX;bounds.y=minY;bounds.height=maxY-minY;}function pad$1(bounds){let padding=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{top=PADDING,bottom=PADDING,left=PADDING,right=PADDING}=padding;bounds.x+=left;bounds.width-=left+right;bounds.y+=top;bounds.height-=top+bottom;}function getBarRect(_ref){let{bar,view,direction,position,padding=PADDING}=_ref;const bounds={};extend$1(bounds,bar);if(!position||position==='inside');else if(direction==='up'||direction==='down'){const start=Math.max(0,Math.min(bar.y,view.height));const end=Math.max(0,Math.min(bar.y+bar.height,view.height));if(position==='outside'&&direction==='up'||position==='opposite'&&direction==='down'){bounds.y=0;bounds.height=start;}else if(position==='outside'&&direction==='down'||position==='opposite'&&direction==='up'){bounds.y=end;bounds.height=view.height-end;}}else {const start=Math.max(0,Math.min(bar.x,view.width));const end=Math.max(0,Math.min(bar.x+bar.width,view.width));if(position==='outside'&&direction==='left'||position==='opposite'&&direction==='right'){bounds.x=0;bounds.width=start;}else if(position==='outside'&&direction==='right'||position==='opposite'&&direction==='left'){bounds.x=end;bounds.width=view.width-end;}}limitBounds(bounds,view);pad$1(bounds,padding);return bounds;}function findBestPlacement$1(_ref2){let{direction,fitsHorizontally,// lblStngs,
  measured,node,orientation,// placements,
  placementSettings,rect}=_ref2;let barRect=arguments.length>1&&arguments[1]!==undefined?arguments[1]:getBarRect;let largest;let bounds;let placement;let testBounds;let p;const boundaries=[];const dimension=orientation==='h'?'width':'height';for(p=0;p<placementSettings.length;p++){placement=placementSettings[p];testBounds=barRect({bar:node.localBounds,view:rect,direction,position:placement.position,padding:placement.padding});boundaries.push(testBounds);largest=!p||testBounds[dimension]>largest[dimension]?testBounds:largest;if(isGoodPlacement(orientation,testBounds,measured,fitsHorizontally,placement.overflow)){bounds=testBounds;break;}}// fallback strategy - place the text in the largest rectangle
  if(!bounds){bounds=largest;p=boundaries.indexOf(bounds);}placement=placementSettings[p];return {bounds,placement};}function approxTextBounds(label,textMetrics,rotated,rect){let padding=arguments.length>4&&arguments[4]!==undefined?arguments[4]:{};const{top=PADDING,bottom=PADDING,left=PADDING,right=PADDING}=padding;const x0=label.x+label.dx;const y0=label.y+label.dy;const height=rotated?Math.min(textMetrics.width,rect.height):Math.min(textMetrics.height,rect.width);const width=rotated?Math.min(textMetrics.height,rect.height):Math.min(textMetrics.width,rect.width);const offset=textMetrics.height*0.5;const PADDING_OFFSET=1e-9;// Needed to support a case when multiple bars are on the same location
  const x=rotated?x0-offset:x0;const y=rotated?y0:y0-offset;const bounds={x:x-left-PADDING_OFFSET,y:y-top-PADDING_OFFSET,width:width+(left+right)-PADDING_OFFSET,height:height+(top+bottom)-PADDING_OFFSET};return bounds;}function placeInBars(_ref3){let{chart,targetNodes,rect,fitsHorizontally,collectiveOrientation}=_ref3;let findPlacement=arguments.length>1&&arguments[1]!==undefined?arguments[1]:findBestPlacement$1;let placer=arguments.length>2&&arguments[2]!==undefined?arguments[2]:placeTextInRect$2;let postFilter=arguments.length>3&&arguments[3]!==undefined?arguments[3]:filterOverlappingLabels;const labels=[];const postFilterContext={container:rect,targetNodes,labels:[],orientation:collectiveOrientation};let label;let target;let node;let text;let justify;let bounds;let fill;let measured;let direction;let lblStngs;let placement;let placements;let arg;let orientation;for(let i=0,len=targetNodes.length;i<len;i++){bounds=null;target=targetNodes[i];node=target.node;arg=cbContext$2(node,chart);direction=target.direction;orientation=direction==='left'||direction==='right'?'h':'v';for(let j=0;j<target.texts.length;j++){text=target.texts[j];if(!isValidText(text)){continue;}lblStngs=target.labelSettings[j];measured=target.measurements[j];placements=lblStngs.placements;const bestPlacement=findPlacement({direction,fitsHorizontally,lblStngs,measured,node,orientation,placements,placementSettings:target.placementSettings[j],rect});bounds=bestPlacement.bounds;placement=bestPlacement.placement;if(bounds&&placement){justify=placement.justify;const linkData=typeof lblStngs.linkData==='function'?lblStngs.linkData(arg,i):undefined;const overflow=typeof placement.overflow==='function'?placement.overflow(arg,i):placement.overflow;if(direction==='up'){justify=1-justify;}if(placement.position==='opposite'){justify=1-justify;}if(direction==='left'){justify=1-justify;}const isRotated=!(collectiveOrientation==='h'||fitsHorizontally);label=placer(bounds,text,{justify:orientation==='h'?placement.align:justify,align:orientation==='h'?justify:placement.align,fontSize:lblStngs.fontSize,fontFamily:lblStngs.fontFamily,textMetrics:measured,rotate:isRotated,overflow:!!overflow});if(label){const textBounds=approxTextBounds(label,measured,isRotated,bounds,placement.padding);fill=typeof placement.fill==='function'?placement.fill(_objectSpread2$1(_objectSpread2$1({},arg),{},{textBounds}),i):placement.fill;label.fill=fill;if(typeof linkData!=='undefined'){label.data=linkData;}if(typeof placement.background==='object'){label.backgroundColor=typeof placement.background.fill==='function'?placement.background.fill(_objectSpread2$1(_objectSpread2$1({},arg),{},{textBounds}),i):placement.background.fill;if(typeof label.backgroundColor!=='undefined'){label.backgroundBounds=approxTextBounds(label,measured,isRotated,bounds,placement.background.padding);}}labels.push(label);postFilterContext.labels.push({node,textBounds});}}}}const filteredLabels=labels.filter(postFilter(postFilterContext));const backgrounds=filteredLabels.filter(lb=>typeof lb.backgroundBounds!=='undefined').map(toBackground);return [...backgrounds,...filteredLabels];}function precalculate(_ref4){let{nodes,rect,chart,labelSettings,placementSettings,settings,renderer}=_ref4;const labelStruct={};const targetNodes=[];let target;let fitsHorizontally=true;let hasHorizontalDirection=false;let node;let text;let bounds;let measured;let lblStng;let direction;for(let i=0;i<nodes.length;i++){node=nodes[i];bounds=node.localBounds;if(!testRectRect(bounds,rect)){continue;}let arg=cbContext$2(node,chart);target={node,texts:[],measurements:[],labelSettings:[],placementSettings:[]// direction: 'up'
  };for(let j=0;j<labelSettings.length;j++){lblStng=labelSettings[j];text=typeof lblStng.label==='function'?lblStng.label(arg,i):undefined;if(!isValidText(text)){continue;// eslint-ignore-line
  }direction=typeof settings.direction==='function'?settings.direction(arg,i):settings.direction||'up';hasHorizontalDirection=hasHorizontalDirection||direction==='left'||direction==='right';labelStruct.fontFamily=lblStng.fontFamily;labelStruct.fontSize="".concat(lblStng.fontSize,"px");labelStruct.text=text;measured=renderer.measureText(labelStruct);target.measurements.push(measured);target.texts.push(text);target.labelSettings.push(lblStng);target.placementSettings.push(placementSettings[j]);target.direction=direction;fitsHorizontally=fitsHorizontally&&measured.width<=bounds.width-PADDING*2;}targetNodes.push(target);}return {targetNodes,fitsHorizontally,hasHorizontalDirection};}function getOrientation(_ref5){let{orientation='auto',defaultOrientation='h'}=_ref5;switch(orientation.toLocaleLowerCase()){case'vertical':return 'v';case'horizontal':return 'h';default:return defaultOrientation;}}/**
   * @typedef {object} ComponentLabels~BarsLabelStrategy
   * @property {'bar'} type Name of strategy
   */ /**
   * Bars strategy settings
   * @typedef {object} ComponentLabels~BarsLabelStrategy.settings
   * @property {string|function} [direction='up'] - The direction in which the bars are growing: 'up', 'down', 'right' or 'left'.
   * @property {string} [orientation='auto'] - Orientation of text: 'auto', 'horizontal' or 'vertical'
   * @property {string} [fontFamily='Arial']
   * @property {number} [fontSize=12]
   * @property {Array<object>} labels
   * @property {string|function} labels[].label - The text value
   * @property {function} labels[].linkData - Link data to the label
   * @property {Array<object>} labels[].placements
   * @property {string} labels[].placements[].position - 'inside' | 'outside' | 'opposite'
   * @property {number} [labels[].placements[].justify=0] - Placement of the label along the direction of the bar
   * @property {number} [labels[].placements[].align=0.5] - Placement of the label along the perpendicular direction of the bar
   * @property {string} [labels[].placements[].fill='#333'] - Color of the label
   * @property {boolean} [labels[].placements[].overflow=false] - True if the label is allowed to overflow the bar
   * @property {object} labels[].placements[].padding - Padding between the label and the bar
   * @property {number} [labels[].placements[].padding.top=4] - Padding-top between the label and the bar
   * @property {number} [labels[].placements[].padding.bottom=4] - Padding-bottom between the label and the bar
   * @property {number} [labels[].placements[].padding.left=4] - Padding-left between the label and the bar
   * @property {number} [labels[].placements[].padding.right=4] - Padding-right between the label and the bar
   * @property {object} labels[].placements[].background - Background of the label
   * @property {string|function} labels[].placements[].background.fill - Background color of the label
   * @property {object} labels[].placements[].background.padding - Padding between the label and the background
   * @property {number} [labels[].placements[].background.padding.top=4] - Padding-top between the label and the background
   * @property {number} [labels[].placements[].background.padding.bottom=4] - Padding-bottom between the label and the background
   * @property {number} [labels[].placements[].background.padding.left=4] - Padding-left between the label and the background
   * @property {number} [labels[].placements[].background.padding.right=4] - Padding-right between the label and the background
   */function bars(_ref6){let{settings,chart,nodes,rect,renderer,style}=_ref6;let placer=arguments.length>1&&arguments[1]!==undefined?arguments[1]:placeInBars;const defaults=extend$1({fontSize:12,fontFamily:'Arial',align:0.5,justify:0,fill:'#333'},style.label);defaults.fontSize=parseInt(defaults.fontSize,10);const labelSettings=settings.labels.map(labelSetting=>extend$1({},defaults,settings,labelSetting));const placementSettings=settings.labels.map(labelSetting=>labelSetting.placements.map(placement=>extend$1({},defaults,settings,labelSetting,placement)));const{fitsHorizontally,hasHorizontalDirection,targetNodes}=precalculate({nodes,chart,renderer,settings,rect,labelSettings,placementSettings});const orientation=getOrientation({orientation:settings.orientation,defaultOrientation:hasHorizontalDirection?'h':'v'});const coord=orientation==='h'?'y':'x';const side=orientation==='h'?'height':'width';targetNodes.sort((a,b)=>a.node.localBounds[coord]+a.node.localBounds[side]-(b.node.localBounds[coord]+b.node.localBounds[side]));return placer({chart,targetNodes,stngs:settings,rect,fitsHorizontally,collectiveOrientation:orientation});}const LABEL_OVERLAP_THRESHOLD_X=4;// When a label is animated, the label rect width should be bit larger than the measured text width,
  // otherwise the animated label will be ellipsed.
  const LABEL_RECT_WIDTH_PADDING=1;function normalize$2(angle){const PI2=Math.PI*2;return (angle%PI2+PI2)%PI2;// normalize
  }function pad$3(bounds,padding){bounds.x+=padding;bounds.width-=padding*2;bounds.y+=padding;bounds.height-=padding*2;}function getTopLeftBounds(bounds){const x=bounds.x;const y=bounds.y-bounds.height/2;return {x,y,width:bounds.width,height:bounds.height};}// assume 0 <= angle < (PI / 2)
  function getLineCircleIntersection(radius,offset,angle){let{x,y}=offset;if(x*x+y*y>radius*radius){return null;}let dx=Math.sin(angle);let dy=Math.cos(angle);let D=x*dy-y*dx;let d=radius*radius-D*D;if(d<0){return null;}let sqrtD=Math.sqrt(d);return {x:D*dy+dx*sqrtD,y:-(D*dx)+dy*sqrtD};}// assume 0 <= angle < (PI * 2)
  function getRectFromCircleIntersection(_ref){let{radius,size,angle}=_ref;let{width,height}=size;let lineOffset={x:width/2,y:height/2};let section=Math.floor(angle/(Math.PI/2));let intersection;let offset;switch(section){case 0:intersection=getLineCircleIntersection(radius,lineOffset,angle);if(!intersection){return null;}intersection.y*=-1;offset={x:-width,y:0};break;case 1:intersection=getLineCircleIntersection(radius,lineOffset,Math.PI-angle);if(!intersection){return null;}offset={x:-width,y:-height};break;case 2:intersection=getLineCircleIntersection(radius,lineOffset,angle-Math.PI);if(!intersection){return null;}intersection.x*=-1;offset={x:0,y:-height};break;case 3:intersection=getLineCircleIntersection(radius,lineOffset,2*Math.PI-angle);if(!intersection){return null;}intersection.x*=-1;intersection.y*=-1;offset={x:0,y:0};break;default:throw new Error('invalid angle');}let bounds={x:intersection.x+offset.x,y:intersection.y+offset.y,width,height};return bounds;}function getHorizontalInsideSliceRect(_ref2){let{slice,padding,measured,store}=_ref2;const{start,end,outerRadius}=slice;const middle=normalize$2((start+end)/2);const size={width:measured.width+padding*2+LABEL_RECT_WIDTH_PADDING,height:measured.height+padding*2};let bounds=getRectFromCircleIntersection({radius:outerRadius,size,angle:middle});if(!bounds){return null;}bounds.baseline='top';pad$3(bounds,padding);if(store.insideLabelBounds.some(rect=>testRectRect(rect,bounds))){return null;}store.insideLabelBounds.push({x:bounds.x-LABEL_OVERLAP_THRESHOLD_X,y:bounds.y,width:bounds.width+LABEL_OVERLAP_THRESHOLD_X*2,height:bounds.height});// Copy as bounds is mutated else where
  return bounds;}function getHorizontalIntoSliceRect(_ref3){let{slice,padding,measured}=_ref3;let{start,end,innerRadius,outerRadius}=slice;const middle=normalize$2((start+end)/2);let size={width:measured.width+padding*2+LABEL_RECT_WIDTH_PADDING,height:measured.height+padding*2};let bounds=getRectFromCircleIntersection({radius:outerRadius,size,angle:middle});if(!bounds){return null;}bounds.baseline='top';let startLine={x1:0,y1:0,x2:Math.sin(start)*outerRadius,y2:-Math.cos(start)*outerRadius};if(testRectLine(bounds,startLine)){return null;}let endLine={x1:0,y1:0,x2:Math.sin(end)*outerRadius,y2:-Math.cos(end)*outerRadius};if(testRectLine(bounds,endLine)){return null;}let circle={cx:0,cy:0,r:innerRadius};if(testCircleRect(circle,bounds)){return null;}pad$3(bounds,padding);return bounds;}// TODO: this case can support a justify setting
  function getRotatedInsideSliceRect(_ref4){let{slice,measured,padding}=_ref4;let{start,end,innerRadius,outerRadius}=slice;let maxWidth=outerRadius-innerRadius-padding*2;let size=end-start;if(size<Math.PI){let x=(measured.height/2+padding)/Math.tan(size/2);if(x>innerRadius){maxWidth=outerRadius-x-padding*2;}}if(maxWidth<0||maxWidth<measured.minReqWidth){return null;}const middle=normalize$2((start+end)/2);let r=outerRadius-padding;let bounds={x:Math.sin(middle)*r,y:-Math.cos(middle)*r,width:maxWidth,height:measured.height};if(middle<Math.PI){bounds.angle=middle-Math.PI/2;bounds.anchor='end';}else {bounds.angle=middle+Math.PI/2;bounds.anchor='start';}return bounds;}function getRotatedOusideSliceRect(_ref5){let{slice,measured,padding,view}=_ref5;let{start,end,outerRadius,offset}=slice;let r=outerRadius+padding;let size=end-start;if(size<Math.PI){let minR=(measured.height/2+padding)/Math.tan(size/2);if(minR>r){return null;}}const middle=normalize$2((start+end)/2);let x=Math.sin(middle)*r;let y=-Math.cos(middle)*r;let maxWidth=measured.width+LABEL_RECT_WIDTH_PADDING;let v=middle%Math.PI;if(v>Math.PI/2){v=Math.PI-v;}if(Math.cos(v)>0.001){let edge=y<0?view.y:view.y+view.height;let d=Math.abs(edge-offset.y);let w=d/Math.cos(v)-Math.tan(v)*(measured.height/2)-padding*2-outerRadius;if(w<maxWidth){maxWidth=w;}}if(Math.sin(v)>0.001){let edge=x<0?view.x:view.x+view.width;let d=Math.abs(edge-offset.x);let w=d/Math.sin(v)-measured.height/2/Math.tan(v)-padding*2-outerRadius;if(w<maxWidth){maxWidth=w;}}if(maxWidth<=0||maxWidth<measured.minReqWidth){return null;}let bounds={x,y,width:maxWidth,height:measured.height};if(middle<Math.PI){bounds.angle=middle-Math.PI/2;bounds.anchor='start';}else {bounds.angle=middle+Math.PI/2;bounds.anchor='end';}return bounds;}function outOfSpace(context,section,view){switch(section){case 0:return context.q1maxY<0;case 1:return context.q2minY>view.height;case 2:return context.q3minY>view.height;case 3:return context.q4maxY<0;default:return true;}}function adjustBounds(bounds,context,slice){const LINE_PADDING=2;const LIMIT=1;const{start,end,offset,outerRadius}=slice;const middle=normalize$2((start+end)/2);let section=Math.floor(middle/(Math.PI/2));switch(section){case 0:if(context.q1maxY!==undefined){let y=Math.min(bounds.y,context.q1maxY-bounds.height);let dy=bounds.y-y;bounds.y=y;if(dy>LIMIT){let r=outerRadius+LINE_PADDING;bounds.line={type:'line',x1:bounds.x-LINE_PADDING,y1:bounds.y+LINE_PADDING,x2:offset.x+Math.sin(middle)*r,y2:offset.y-Math.cos(middle)*r,strokeWidth:1};}}break;case 1:if(context.q2minY!==undefined){let y=Math.max(bounds.y,context.q2minY);let dy=y-bounds.y;bounds.y=y;if(dy>LIMIT){let r=outerRadius+LINE_PADDING;bounds.line={type:'line',x1:bounds.x-LINE_PADDING,y1:bounds.y-LINE_PADDING,x2:offset.x+Math.sin(middle)*r,y2:offset.y-Math.cos(middle)*r,strokeWidth:1};}}break;case 2:if(context.q3minY!==undefined){let y=Math.max(bounds.y,context.q3minY);let dy=y-bounds.y;bounds.y=y;if(dy>LIMIT){let r=outerRadius+LINE_PADDING;bounds.line={type:'line',x1:bounds.x+LINE_PADDING,y1:bounds.y-LINE_PADDING,x2:offset.x+Math.sin(middle)*r,y2:offset.y-Math.cos(middle)*r,strokeWidth:1};}}break;case 3:if(context.q4maxY!==undefined){let y=Math.min(bounds.y,context.q4maxY-bounds.height);let dy=bounds.y-y;bounds.y=y;if(dy>LIMIT){let r=outerRadius+LINE_PADDING;bounds.line={type:'line',x1:bounds.x+LINE_PADDING,y1:bounds.y+LINE_PADDING,x2:offset.x+Math.sin(middle)*r,y2:offset.y-Math.cos(middle)*r,strokeWidth:1};}}break;}}function updateContext(_ref6){let{context,node,bounds}=_ref6;const PADDING=2;let{start,end}=node.desc.slice;const middle=normalize$2((start+end)/2);let section=Math.floor(middle/(Math.PI/2));switch(section){case 0:context.q1maxY=bounds.y-PADDING;if(context.q2minY===undefined){context.q2minY=bounds.y+bounds.height+PADDING;}break;case 1:context.q2minY=bounds.y+bounds.height+PADDING;break;case 2:context.q3minY=bounds.y+bounds.height+PADDING;break;case 3:context.q4maxY=bounds.y-PADDING;if(context.q3minY===undefined){context.q3minY=bounds.y+bounds.height+PADDING;}break;}}function getHorizontalOusideSliceRect(_ref7){let{slice,measured,padding,view,context}=_ref7;let{start,end,outerRadius,offset}=slice;const middle=normalize$2((start+end)/2);let section=Math.floor(middle/(Math.PI/2));if(outOfSpace(context,section,view)){return null;}let r=outerRadius+padding+measured.height/2;let x=Math.sin(middle)*r;let y=-Math.cos(middle)*r;let maxWidth=measured.width+LABEL_RECT_WIDTH_PADDING;if(middle<Math.PI){let w=Math.abs(view.x+view.width-(x+offset.x));if(w<maxWidth){maxWidth=w;}}else {let w=Math.abs(view.x-(x+offset.x));if(w<maxWidth){maxWidth=w;}}if(maxWidth<measured.minReqWidth){return null;}let bounds={x,y,width:maxWidth,height:measured.height};if(middle<Math.PI){bounds.anchor='start';}else {bounds.anchor='end';}return bounds;}function cbContext$1(node,chart){return {node,data:node.data,scale:chart.scale,formatter:chart.formatter,dataset:chart.dataset};}function placeTextOnPoint(rect,text,opts){const label={type:'text',text,maxWidth:rect.width,x:rect.x,y:rect.y+(rect.baseline==='top'?rect.height/2:0),fill:opts.fill,anchor:rect.anchor||'start',baseline:'middle',fontSize:"".concat(opts.fontSize,"px"),fontFamily:opts.fontFamily};if(!isNaN(rect.angle)){let angle=rect.angle*(360/(Math.PI*2));label.transform="rotate(".concat(angle,", ").concat(label.x,", ").concat(label.y,")");}return label;}function getSliceRect(_ref8){let{slice,direction,position,padding,measured,view,context,store}=_ref8;let{start,end,innerRadius,offset}=slice;let bounds;let s;switch(position){case'into':if(direction==='rotate'){bounds=getRotatedInsideSliceRect({slice,measured,padding});}else {bounds=getHorizontalIntoSliceRect({slice,measured,padding});}break;case'inside':s={start,end,innerRadius:0,outerRadius:innerRadius};if(direction==='rotate'){bounds=getRotatedInsideSliceRect({slice:s,measured,padding});}else {bounds=getHorizontalInsideSliceRect({slice:s,measured,padding,store});}break;case'outside':if(direction==='rotate'){bounds=getRotatedOusideSliceRect({slice,measured,padding,view});}else {bounds=getHorizontalOusideSliceRect({slice,measured,padding,view,context});}break;default:throw new Error('not implemented');}if(bounds){bounds.x+=offset.x;bounds.y+=offset.y;if(position==='outside'&&direction!=='rotate'){adjustBounds(bounds,context,slice);}}return bounds;}function findBestPlacement(_ref9){let{context,direction,measured,node,placementSettings,rect,store}=_ref9;let sliceRect=arguments.length>1&&arguments[1]!==undefined?arguments[1]:getSliceRect;for(let p=0;p<placementSettings.length;p++){let placement=placementSettings[p];let bounds=sliceRect({context,slice:node.desc.slice,view:rect,direction,position:placement.position,measured,padding:placement.padding,store});if(!bounds){continue;}return {bounds,placement};}return {bounds:null,placement:null};}/*
   * Sorts the nodes so that
   *   in each quarter sort nodes from the center (in y) outwards
   *   first quarter before the second
   *   forth quarter before the third
   */function sortNodes(nodes){const q1=[];const q2=[];const q3=[];const q4=[];for(let i=0;i<nodes.length;++i){const{start,end}=nodes[i].desc.slice;const middle=normalize$2((start+end)/2);let section=Math.floor(middle/(Math.PI/2));switch(section){case 0:q1.push(nodes[i]);break;case 1:q2.push(nodes[i]);break;case 2:q3.push(nodes[i]);break;case 3:q4.push(nodes[i]);break;}}const sortFn=(a,b)=>{const middleA=normalize$2((a.desc.slice.start+a.desc.slice.end)/2);const middleB=normalize$2((b.desc.slice.start+b.desc.slice.end)/2);return middleA-middleB;};const reverseSortFn=(a,b)=>sortFn(b,a);q1.sort(reverseSortFn);q2.sort(sortFn);q3.sort(reverseSortFn);q4.sort(sortFn);return q1.concat(q2,q4,q3);}function measureText$1(text,stgns,renderer){const fontFamily=stgns.fontFamily;const fontSize="".concat(stgns.fontSize,"px");const metrics=renderer.measureText({text,fontFamily,fontSize});metrics.minReqWidth=Math.min(metrics.width,renderer.measureText({text:"".concat(text[0],"\u2026"),fontFamily,fontSize}).width);return metrics;}/**
   * @typedef {object} ComponentLabels~SlicesLabelStrategy
   * @property {'slice'} type Name of strategy
   */ /**
   * Slices strategy settings
   * @typedef {object} ComponentLabels~SlicesLabelStrategy.settings
   * @property {string|function} [direction='horizontal'] - The direction of the text: 'horizontal' or 'rotate'.
   * @property {string} [fontFamily='Arial']
   * @property {number} [fontSize=12]
   * @property {Array<object>} labels
   * @property {string|function} labels[].label - The text value
   * @property {function} labels[].linkData - Link data to the label
   * @property {Array<object>} labels[].placements
   * @property {string} [labels[].placements[].position='into'] - 'inside' | 'into' | 'outside' (outside is not implmented yet)
   * @property {string} [labels[].placements[].fill='#333'] - Color of the label
   */function slices(_ref10){let{settings,chart,nodes,rect,renderer,style}=_ref10;let findPlacement=arguments.length>1&&arguments[1]!==undefined?arguments[1]:findBestPlacement;let placer=arguments.length>2&&arguments[2]!==undefined?arguments[2]:placeTextOnPoint;const defaults=extend$1({fontSize:12,fontFamily:'Arial',fill:'#333',padding:4,position:'into'},style.label);defaults.fontSize=parseInt(defaults.fontSize,10);const labelSettings=settings.labels.map(labelSetting=>extend$1({},defaults,settings,labelSetting));const placementSettings=settings.labels.map(labelSetting=>labelSetting.placements.map(placement=>extend$1({},defaults,settings,labelSetting,placement)));const labels=[];const store={insideLabelBounds:[]};nodes=sortNodes(nodes);const context={};for(let i=0,len=nodes.length;i<len;i++){const node=nodes[i];const arg=cbContext$1(node,chart);for(let j=0;j<labelSettings.length;j++){const lblStngs=labelSettings[j];const text=typeof lblStngs.label==='function'?lblStngs.label(arg,i):'';if(!text){continue;}const direction=typeof lblStngs.direction==='function'?lblStngs.direction(arg,i):lblStngs.direction||'horizontal';const linkData=typeof lblStngs.linkData==='function'?lblStngs.linkData(arg,i):undefined;const measured=measureText$1(text,lblStngs,renderer);const bestPlacement=findPlacement({context,direction,lblStngs,measured,node,placementSettings:placementSettings[j],rect,store});const bounds=bestPlacement.bounds;const placement=bestPlacement.placement;if(bounds&&placement){if(placement.position==='outside'&&direction!=='rotate'){updateContext({context,node,bounds});const topLeftBounds=getTopLeftBounds(bounds);if(!rectContainsRect(topLeftBounds,rect)){continue;}}const fill=typeof placement.fill==='function'?placement.fill(arg,i):placement.fill;const label=placer(bounds,text,{fill,fontSize:lblStngs.fontSize,fontFamily:lblStngs.fontFamily,textMetrics:measured});if(label){if(typeof linkData!=='undefined'){label.data=linkData;}labels.push(label);if(bounds.line){bounds.line.stroke=fill;labels.push(bounds.line);}}}}}return labels;}const LINEBREAK_REGEX=/\n+|\r+|\r\n/;const WHITESPACE_REGEX=/\s/;const HYPHEN_REGEX=/[a-zA-Z\u00C0-\u00F6\u00F8-\u00FF\u00AD]/;const NO_BREAK=0;const MANDATORY=1;const BREAK_ALLOWED=2;function includesLineBreak(c){if(typeof c==='string'){return c.search(LINEBREAK_REGEX)!==-1;}return String(c).search(LINEBREAK_REGEX)!==-1;}function includesWhiteSpace(c){return c.search(WHITESPACE_REGEX)!==-1;}function hyphenationAllowed(c){/* Latin character set. Excluding numbers, sign and symbol characters, but including soft hyphen */return c.search(HYPHEN_REGEX)!==-1;}function resolveBreakOpportunity(chunk,i,chunks,mandatory,noBreakAllowed){if(mandatory.some(fn=>fn(chunk,i,chunks))){return MANDATORY;}if(noBreakAllowed.some(fn=>fn(chunk,i,chunks))){return NO_BREAK;}return BREAK_ALLOWED;}function cleanEmptyChunks(chunks){if(chunks[0]===''){chunks.shift();}if(chunks[chunks.length-1]===''){chunks.pop();}}function clamp$2(val,min,max){return Math.max(min,Math.min(max,val));}function stringTokenizer(){let{string,separator='',reverse=false,measureText=text=>({width:text.length,height:1}),mandatoryBreakIdentifiers=[includesLineBreak],noBreakAllowedIdentifiers=[],suppressIdentifier=[includesWhiteSpace,includesLineBreak,chunk=>chunk===''],hyphenationIdentifiers=[hyphenationAllowed]}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const chunks=String(string).split(separator);cleanEmptyChunks(chunks);const length=chunks.length;const isNotDone=reverse?p=>p>=0:p=>p<length;let position=reverse?length:-1;// Set init position 1 step before or after to make first next call go to first position
  function peek(peekAt){const i=clamp$2(peekAt,0,length-1);const chunk=chunks[i];const textMeasure=measureText(chunk);const opportunity=resolveBreakOpportunity(chunk,i,chunks,mandatoryBreakIdentifiers,noBreakAllowedIdentifiers);return {index:i,value:chunk,breakOpportunity:opportunity,suppress:suppressIdentifier.some(fn=>fn(chunk,i,chunks)),hyphenation:hyphenationIdentifiers.some(fn=>fn(chunk,i,chunks)),width:textMeasure.width,height:textMeasure.height,done:false};}function next(jumpToPosition){if(isNaN(jumpToPosition)){if(reverse){position--;}else {position++;}}else {position=clamp$2(jumpToPosition,0,length-1);}if(isNotDone(position)){return peek(position);}return {done:true};}return {next,peek,length};}const HYPHENS_CHAR='\u2010';const ELLIPSIS_CHAR='…';const BASE=24;const PAD=4;const BUMP=1e-12;const DEFAULT_FONT_HEIGHT=16;const DEFAULT_LINE_HEIGHT=1.2;const TEXT_REGEX=/^\s*\d+(\.\d+)?px\s*$/i;function isValidFontSize(val){const type=typeof val;if(type==='string'){return TEXT_REGEX.test(val);}return false;}function fontSizeToHeight(fontSize){if(isValidFontSize(fontSize)){const size=parseFloat(fontSize);const m=PAD*Math.ceil((size+BUMP)/BASE);return size+m;}return DEFAULT_FONT_HEIGHT;}function fontSizeToLineHeight(node){const fontSize=node['font-size']||node.fontSize;if(isValidFontSize(fontSize)){return parseFloat(fontSize)*Math.max(isNaN(node.lineHeight)?DEFAULT_LINE_HEIGHT:node.lineHeight,0);}return DEFAULT_FONT_HEIGHT*DEFAULT_LINE_HEIGHT;}function resolveMaxAllowedLines(node){const maxHeight=node.maxHeight;const maxLines=Math.max(node.maxLines,1)||Infinity;if(isNaN(maxHeight)){return maxLines;}const computedLineHeight=fontSizeToLineHeight(node);return Math.max(1,Math.min(Math.floor(maxHeight/computedLineHeight),maxLines));}function initState$1(node,measureText){return {lines:[],line:'',width:0,maxLines:resolveMaxAllowedLines(node),maxWidth:node.maxWidth,hyphens:{enabled:node.hyphens==='auto',char:HYPHENS_CHAR,metrics:measureText(HYPHENS_CHAR)}};}function newLine(state){state.lines.push(state.line);state.line='';state.width=0;}function appendToLine(state,token){state.line+=token.value;state.width+=token.width;}function insertHyphenAndJump(state,token,iterator){if(token.width>state.maxWidth){return token;}const startIndex=token.index;for(let i=1;i<5;i++){const pairToken=iterator.peek(token.index-1);if(!token.hyphenation||!pairToken.hyphenation||token.index===0){return token;}if(state.width+state.hyphens.metrics.width<=state.maxWidth){state.line+=state.hyphens.char;return token;}if(state.line.length===1){return token;}token=iterator.next(startIndex-i);state.line=state.line.slice(0,-1);state.width-=token.width;}return token;}function breakSequence(state,token,measureText){const charTokenIterator=stringTokenizer({string:token.value,measureText});while(state.lines.length<state.maxLines){let charToken=charTokenIterator.next();if(charToken.done){break;}else if(state.width+charToken.width>state.maxWidth&&charToken.breakOpportunity===BREAK_ALLOWED&&state.line.length>0){charToken=state.hyphens.enabled?insertHyphenAndJump(state,charToken,charTokenIterator):charToken;newLine(state);appendToLine(state,charToken);}else {appendToLine(state,charToken);}}}function breakAll(node,measureText){const text=node.text;const iterator=stringTokenizer({string:text,separator:'',measureText,noBreakAllowedIdentifiers:[(chunk,i)=>i===0]});const state=initState$1(node,measureText);let reduced=true;while(state.lines.length<state.maxLines){let token=iterator.next();if(token.done){newLine(state);reduced=false;break;}else if(token.breakOpportunity===MANDATORY){newLine(state);}else if(state.width+token.width>state.maxWidth&&token.breakOpportunity===BREAK_ALLOWED){if(token.suppress){// Token is suppressable and can be ignored
  state.width+=token.width;}else {token=state.hyphens.enabled?insertHyphenAndJump(state,token,iterator):token;newLine(state);appendToLine(state,token);}}else {appendToLine(state,token);}}return {lines:state.lines,reduced};}function breakWord(node,measureText){const text=node.text;const iterator=stringTokenizer({string:text,separator:/(\s|-|\u2010)/,measureText});const state=initState$1(node,measureText);let reduced=true;while(state.lines.length<state.maxLines){let token=iterator.next();if(token.done){newLine(state);reduced=false;break;}else if(token.breakOpportunity===MANDATORY){newLine(state);}else if(state.width+token.width>state.maxWidth&&token.breakOpportunity===BREAK_ALLOWED){if(token.suppress){// Token is suppressable and can be ignored
  newLine(state);}else if(token.width>state.maxWidth){// Single sequence is wider then maxWidth, break sequence into multiple lines
  breakSequence(state,token,measureText);}else {newLine(state);appendToLine(state,token);}}else {appendToLine(state,token);}}return {lines:state.lines,reduced};}function generateLineNodes(result,item,halfLead,height){const container={type:'container',children:[]};if(typeof item.id!=='undefined'){// TODO also inherit data attribute and more?
  container.id=item.id;}let currentY=0;result.lines.forEach((line,i)=>{const node=extend$1({},item);node.text=line;node._lineBreak=true;// Flag node as processed to avoid duplicate linebreak run
  currentY+=halfLead;// leading height above
  if(result.reduced&&i===result.lines.length-1){node.text+=ELLIPSIS_CHAR;}else {delete node.maxWidth;}node.dy=isNaN(node.dy)?currentY:node.dy+currentY;currentY+=height;currentY+=halfLead;// Leading height below
  container.children.push(node);});return container;}function shouldLineBreak(item){// If type text and not already broken into lines
  return item.type==='text'&&!item._lineBreak;}function wrappedMeasureText(node,measureText){return text=>measureText({text,fontSize:node.fontSize,fontFamily:node.fontFamily});}function resolveLineBreakAlgorithm(node){const WORDBREAK={'break-all':breakAll,'break-word':breakWord};return WORDBREAK[node.wordBreak];}/**
   * Apply wordBreak rules to text nodes.
   * @ignore
   * @param {function} measureText
   * @returns {function} Event function to convert a text node into multiple nodes
   */function onLineBreak(measureText){return state=>{const item=state.node;if(shouldLineBreak(item)){const wordBreakFn=resolveLineBreakAlgorithm(item);if(!wordBreakFn){return;}const tm=measureText(item);if(tm.width>item.maxWidth||includesLineBreak(item.text)){const diff=fontSizeToLineHeight(item)-tm.height;const halfLead=diff/2;const result=wordBreakFn(item,wrappedMeasureText(item,measureText));state.node=generateLineNodes(result,item,halfLead,tm.height);// Convert node to container
  }}};}function ellipsText(_ref,measureText){let{text,'font-size':fontSize,'font-family':fontFamily,maxWidth}=_ref;// eslint-disable-line import/prefer-default-export
  text=typeof text==='string'?text:"".concat(text);if(maxWidth===undefined){return text;}let textWidth=measureText({text,fontSize,fontFamily}).width;if(textWidth<=maxWidth){return text;}let min=0;let max=text.length-1;while(min<=max){let reduceIndex=Math.floor((min+max)/2);let reduceText=text.substr(0,reduceIndex)+ELLIPSIS_CHAR;textWidth=measureText({text:reduceText,fontSize,fontFamily}).width;if(textWidth<=maxWidth){min=reduceIndex+1;}else {// textWidth > maxWidth
  max=reduceIndex-1;}}return text.substr(0,max)+ELLIPSIS_CHAR;}/**
   * Currently some browsers, IE11 and Edge confirmed, doesn't support the dominant-baseline svg-attribute and
   * the browser that does, have different implementations. Thus giving an unpredictable result when rendering'
   * text and predicting it's position (ex. in collision detection).
   *
   * To supplement and the aid in aligning/positioning text with various items, this function can be used
   * to follow a common heuristic across supported renderers.
   * @ignore
   * @param {object} textNode
   * @param {string|number} [textNode['font-size']=0] - String in px format or number
   * @param {string} [textNode['dominant-baseline']] - If baseline is omitted dominant-baseline is used
   * @param {string} [textNode.baseline]
   * @returns {number} Delta-y required to adjust for baseline
   */function baselineHeuristic(textNode){const baseline=textNode.baseline||textNode['dominant-baseline'];let dy=0;const fontSize=parseInt(textNode.fontSize||textNode['font-size'],10)||0;switch(baseline){case'hanging':dy=fontSize*0.75;break;case'text-before-edge':dy=fontSize*0.85;break;case'middle':dy=fontSize*0.25;break;case'central':dy=fontSize*0.35;break;case'mathemetical':dy=fontSize/2;break;case'text-after-edge':case'ideographic':dy=-fontSize*0.2;break;default:dy=0;break;}return dy;}const heightCache={};const widthCache={};const contextCache={fontSize:undefined,fontFamily:undefined};let context;function setContext(){context=context||document.createElement('canvas').getContext('2d');}function setFont(fontSize,fontFamily){if(contextCache.fontSize===fontSize&&contextCache.fontFamily===fontFamily){return;}context.font=fontSize+' '+fontFamily;// eslint-disable-line
  contextCache.fontSize=fontSize;contextCache.fontFamily=fontFamily;}function measureTextWidth(text,fontSize,fontFamily){const key=text+fontSize+fontFamily;if(typeof widthCache[key]!=='number'){setContext();setFont(fontSize,fontFamily);widthCache[key]=context.measureText(text).width;}return widthCache[key];}function measureTextHeight(fontSize){if(typeof heightCache[fontSize]!=='number'){heightCache[fontSize]=fontSizeToHeight(fontSize);}return heightCache[fontSize];}/**
   * @private
   * @param {object} opts
   * @param {string} opts.text - Text to measure
   * @param {string} opts.fontSize - Font size with a unit definition, ex. 'px' or 'em'
   * @param {string} opts.fontFamily - Font family
   * @return {object} Width and height of text in pixels
   * @example
   * measureText({
   *  text: 'my text',
   *  fontSize: '12px',
   *  fontFamily: 'Arial'
   * }); // returns { width: 20, height: 12 }
   */function measureText(_ref){let{text,fontSize,fontFamily}=_ref;const w=measureTextWidth(text,fontSize,fontFamily);const h=measureTextHeight(fontSize);return {width:w,height:h};}/**
   * Calculates the bounding rectangle of a text node.
   * The bounding rectangle is a approximate of the "em square" seen here (http://www.w3resource.com/html5-canvas/html5-canvas-text.php)
   * @ignore
   * @param {object} attrs - Text node definition
   * @param {number} [attrs.x] - X-coordinate
   * @param {number} [attrs.y] - Y-coordinate
   * @param {number} [attrs.dx] - Delta x-coordinate
   * @param {number} [attrs.dy] - Delta y-coordinate
   * @param {string} [attrs.anchor] - Text anchor
   * @param {number} [attrs.maxWidth] - Maximum allowed text width
   * @return {object} The bounding rectangle
   */function calcTextBounds(attrs){let measureFn=arguments.length>1&&arguments[1]!==undefined?arguments[1]:measureText;const fontSize=attrs['font-size']||attrs.fontSize;const fontFamily=attrs['font-family']||attrs.fontFamily;const textMeasure=measureFn({text:attrs.text,fontFamily,fontSize});const calWidth=Math.min(attrs.maxWidth||textMeasure.width,textMeasure.width);// Use actual value if max is not set
  const x=attrs.x||0;const y=attrs.y||0;const dx=attrs.dx||0;const dy=(attrs.dy||0)+baselineHeuristic(attrs);const boundingRect={x:0,y:y+dy-textMeasure.height*0.75,// Magic number for alphabetical baseline
  width:calWidth,height:textMeasure.height};const anchor=attrs['text-anchor']||attrs.anchor;if(anchor==='middle'){boundingRect.x=x+dx-calWidth/2;}else if(anchor==='end'){boundingRect.x=x+dx-calWidth;}else {boundingRect.x=x+dx;}return boundingRect;}/**
   * Calculates the bounding rectangle of a text node. Including any line breaks.
   * @ignore
   * @param {object} node
   * @param {string} node.text - Text to measure
   * @param {number} [node.x=0] - X-coordinate
   * @param {number} [node.y=0] - Y-coordinate
   * @param {number} [node.dx=0] - Delta x-coordinate
   * @param {number} [node.dy=0] - Delta y-coordinate
   * @param {string} [node.anchor='start'] - Text anchor
   * @param {string} [node.fontSize] - Font size
   * @param {string} [node.fontFamily] - Font family
   * @param {string} [node['font-size']] - Font size
   * @param {string} [node['font-family']] - Font family
   * @param {string} [node.wordBreak] - Word-break option
   * @param {number} [node.maxWidth] - Maximum allowed text width
   * @param {number} [node.maxHeight] - Maximum allowed text height. If both maxLines and maxHeight are set, the property that results in the fewest number of lines is used
   * @param {number} [node.maxLines] - Maximum number of lines allowed.
   * @param {number} [node.lineHeight=1.2] - Line height
   * @param {function} [measureFn] - Optional text measure function
   * @return {object} The bounding rectangle
   */function textBounds(node){let measureFn=arguments.length>1&&arguments[1]!==undefined?arguments[1]:measureText;const lineBreakFn=resolveLineBreakAlgorithm(node);const fontSize=node['font-size']||node.fontSize;const fontFamily=node['font-family']||node.fontFamily;const tm=measureFn({text:node.text,fontFamily,fontSize});if(lineBreakFn&&(tm.width>node.maxWidth||includesLineBreak(node.text))){const resolvedLineBreaks=lineBreakFn(node,text=>measureFn({text,fontFamily,fontSize}));const nodeCopy=extend$1({},node);let maxWidth=0;let widestLine='';for(let i=0,len=resolvedLineBreaks.lines.length;i<len;i++){let line=resolvedLineBreaks.lines[i];line+=i===len-1&&resolvedLineBreaks.reduced?ELLIPSIS_CHAR:'';const width=measureFn({text:line,fontSize,fontFamily}).width;if(width>=maxWidth){maxWidth=width;widestLine=line;}}nodeCopy.text=widestLine;const bounds=calcTextBounds(nodeCopy,measureFn);bounds.height=fontSizeToLineHeight(node)*resolvedLineBreaks.lines.length;return bounds;}return calcTextBounds(node,measureFn);}const LINE_HEIGHT=1.2;const CIRCLE_FACTOR=0.9;function cbContext(node,chart){return {node,data:node.data,scale:chart.scale,formatter:chart.formatter,dataset:chart.dataset};}function placeTextInRect$1(rect,text,opts){const label={type:'text',text,maxWidth:rect.width,x:0,y:rect.y,dx:0,dy:0,fill:opts.fill,anchor:'start',baseline:'alphabetical',fontSize:"".concat(opts.fontSize,"px"),fontFamily:opts.fontFamily};const textMetrics=opts.textMetrics;if(rect.width<opts.fontSize){return false;}const wiggleWidth=Math.max(0,rect.width-textMetrics.width);label.x=rect.x+opts.align*wiggleWidth;label.y=rect.y+textMetrics.height/LINE_HEIGHT;return label;}function getRectFromCircle(_ref){let{cx,cy,r}=_ref;return {type:'circle',bounds:{cx,cy,r}};}function getSliceBounds(slice){const EPSILON=1e-12;let{start,end,innerRadius,outerRadius,offset}=slice;if(Math.abs(start+2*Math.PI-end)>EPSILON){return {type:null,bounds:null};}let r=innerRadius!==0?innerRadius:outerRadius;return getRectFromCircle({cx:offset.x,cy:offset.y,r});}function getBounds(node){if(node.desc&&node.desc.slice){return getSliceBounds(node.desc.slice);}if(node.type==='circle'){return getRectFromCircle(node.attrs);}if(node.type==='rect'){return {type:'rect',bounds:node.bounds};}// defualt to node.bounds ?
  return {type:null,bounds:null};}/**
   * @typedef {object} ComponentLabels~RowsLabelStrategy
   * @property {'rows'} type Name of strategy
   */ /**
   * Rows strategy settings
   * @typedef {object} ComponentLabels~RowsLabelStrategy.settings
   * @property {string} [fontFamily='Arial']
   * @property {number} [fontSize=12]
   * @property {number} [justify=0.5]
   * @property {number} [padding=4]
   * @property {Array<object>} labels
   * @property {string|function} labels[].label - The text value
   * @property {function} labels[].linkData - Link data to the label
   * @property {number} [labels[].align=0.5]
   * @property {string|function} [labels[].fill='#333']
   */function rows(_ref2){let{settings,chart,nodes,renderer,style}=_ref2;let placer=arguments.length>1&&arguments[1]!==undefined?arguments[1]:placeTextInRect$1;const defaults=extend$1({fontSize:12,fontFamily:'Arial',fill:'#333',padding:4,align:0.5,justify:0.5},style.label);defaults.fontSize=parseInt(defaults.fontSize,10);const rowSettings=extend$1({},defaults,settings);const labelSettings=settings.labels.map(labelSetting=>extend$1({},rowSettings,labelSetting));const labelStruct={};const labels=[];for(let i=0,len=nodes.length;i<len;i++){let node=nodes[i];let arg=cbContext(node,chart);let{type,bounds}=getBounds(node);if(!bounds){continue;}let totalHeight=0;let measurements=[];let texts=[];let maxHeight=type==='circle'?2*bounds.r*CIRCLE_FACTOR:bounds.height;totalHeight+=rowSettings.padding;let j;for(j=0;j<labelSettings.length;j++){let lblStngs=labelSettings[j];let text=typeof lblStngs.label==='function'?lblStngs.label(arg,i):'';labelStruct.fontFamily=lblStngs.fontFamily;labelStruct.fontSize="".concat(lblStngs.fontSize,"px");labelStruct.text=text;let measured=renderer.measureText(labelStruct);totalHeight+=measured.height+lblStngs.padding;if(totalHeight>maxHeight){break;}texts.push(text);measurements.push(measured);}const labelCount=j;const wiggleHeight=Math.max(0,maxHeight-totalHeight);let currentY;if(type==='circle'){currentY=bounds.cy-bounds.r*CIRCLE_FACTOR;}else {currentY=bounds.y;}currentY+=rowSettings.justify*wiggleHeight+rowSettings.padding;for(j=0;j<labelCount;j++){let lblStngs=labelSettings[j];let rect;if(type==='circle'){let maxYDistToCenter=Math.max(Math.abs(currentY-bounds.cy),Math.abs(currentY+measurements[j].height-bounds.cy));let halfWidth=Math.sqrt(bounds.r*bounds.r-maxYDistToCenter*maxYDistToCenter);rect={x:bounds.cx-halfWidth+rowSettings.padding,y:currentY,width:2*halfWidth-2*rowSettings.padding,height:measurements[j].height};}else {rect={x:bounds.x+rowSettings.padding,y:currentY,width:bounds.width-2*rowSettings.padding,height:measurements[j].height};}currentY+=measurements[j].height+rowSettings.padding;let fill=typeof lblStngs.fill==='function'?lblStngs.fill(arg,i):lblStngs.fill;const linkData=typeof lblStngs.linkData==='function'?lblStngs.linkData(arg,i):undefined;let label=placer(rect,texts[j],{fill,align:lblStngs.align,fontSize:lblStngs.fontSize,fontFamily:lblStngs.fontFamily,textMetrics:measurements[j]});if(label){if(label.text&&label.text!==ELLIPSIS_CHAR){const ellipsed=ellipsText(label,renderer.measureText);if(ELLIPSIS_CHAR===ellipsed){// don't include label if it's only an ellipsis
  continue;}label.ellipsed=ellipsed;}if(typeof linkData!=='undefined'){label.data=linkData;}labels.push(label);}}}return labels;}var strategies={bar:bars,slice:slices,rows};/**
   * @typedef {object} ComponentLabels
   * @extends ComponentSettings
   * @property {'labels'} type component type
   * @example
  {
    type: 'labels',
    settings: {
      sources: [
        {
          component: 'bars',
          selector: 'rect', // select all 'rect' shapes from the 'bars' component
          strategy: {
            type: 'bar', // the strategy type
            settings: {
              labels: [
                {
                  label({ data }) {
                    return data ? data.end.label : '';
                  },
                  placements: [
                    // label placements in prio order. Label will be placed in the first place it fits into
                    { position: 'inside', fill: '#fff' },
                    { position: 'outside', fill: '#666' },
                  ],
                },
              ],
            },
          },
        },
      ],
    },
  }
   */ /**
   * Component settings
   * @typedef {object} ComponentLabels.settings
   * @property {Array<ComponentLabels~Source>} sources Source settings
   */ /**
   * @typedef {object} ComponentLabels~Source
   * @property {string} component Key of target component
   * @property {string} selector Shape selector
   * @property {ComponentLabels~BarsLabelStrategy|ComponentLabels~RowsLabelStrategy|ComponentLabels~SlicesLabelStrategy} strategy Strategy settings
   */function strategy(_ref,fn){let{chart,source,rect,renderer,style}=_ref;const component=chart.component(source.component);if(!component){return [];}const nodes=chart.findShapes(source.selector).filter(n=>n.key===source.component);return fn({chart,settings:source.strategy.settings,nodes,rect:{x:0,y:0,width:rect.width,height:rect.height},renderer,style});}const labelsComponent={require:['chart','renderer','settings'],defaultSettings:{settings:{},style:{label:'$label'}},render(){const stngs=this.settings.settings;const labels=[];(stngs.sources||[]).forEach(source=>{if(source.strategy&&strategies[source.strategy.type]&&source.component){labels.push(...strategy({chart:this.chart,rect:this.rect,renderer:this.renderer,source,style:this.style},strategies[source.strategy.type]));}});return labels;}};function labels(picasso){picasso.component('labels',labelsComponent);}/**
   * Component settings
   * @typedef {object=}
   * @alias ComponentLegendCat.settings
   */const DEFAULT_SETTINGS$2={/**
     * @typedef {object=}
     */layout:{/**
       * Maximum number of columns (vertical) or rows (horizontal)
       * @type {number=}
       */size:1,/**
       * Layout direction. Either `'ltr'` or `'rtl'`
       * @type {string=}
       */direction:'ltr',/** Initial scroll offset
       * @type {number=} */scrollOffset:0},/**
     * Settings applied per item
     * @typedef {object=}
     */item:{/** Whether to show the current item
       * @type {boolean=} */show:true,/** Justify item
       * @type {number=} */justify:0.5,/** Align item
       * @type {number=} */align:0.5,/**
       * @typedef {object=} */label:{/** Font size in pixels
         * @type {string=} */fontSize:'12px',/** Font family
         * @type {string=} */fontFamily:'Arial',fill:'#595959',/** Word break rule, how to apply line break if label text overflows its maxWidth property. Either `'break-word'` or `'break-all'`
         * @type {string=} */wordBreak:'none',/** Max number of lines allowed if label is broken into multiple lines (only applicable with wordBreak)
         * @type {number=} */maxLines:2,/** Maximum width of label, in px
         * @type {number=} */maxWidth:136,/** Line height as a multiple of the font size
         * @type {number=} */lineHeight:1.2},/**
       * @typedef {object=} */shape:{/**
         * Type of shape
         * @type {string=} */type:'square',/**
         * Size of shape in pixels
         * @type {number=} */size:12}},/**
     * @typedef {object=} */title:{/** Whether to show the title
       * @type {boolean=} */show:true,/** Title text. Defaults to the title of the provided data field
       * @type {string=} */text:undefined,/** Horizontal alignment of the text. Allowed values are `'start'`, `'middle'` and `'end'`
       * @type {string}
       */anchor:'start',/** Font size in pixels
       * @type {string=} */fontSize:'16px',/** Font family
       * @type {string=} */fontFamily:'Arial',/** Title color
       * @type {string=} */fill:'#595959',/** Word break rule, how to apply line break if label text overflows its maxWidth property. Either `'break-word'` or `'break-all'`
       * @type {string=} */wordBreak:'none',/** Max number of lines allowed if label is broken into multiple lines, is only appled when `wordBreak` is not set to `'none'`
       * @type {number=} */maxLines:2,/** Maximum width of title, in px
       * @type {number=} */maxWidth:156,/** Line height as a multiple of the font size
       * @type {number=} */lineHeight:1.25},/**
     * @typedef {object=} */navigation:{/**
       * @typedef {object=} */button:{/**
         * @type {object<string, boolean>=} */class:undefined,/**
         * @type {function} */content:undefined,/**
         * @type {number=} */tabIndex:undefined},/** Whether the button should be disabled or not
       * @type {boolean=} */disabled:false}};/**
   * Resolve settings based on input, defaults, and data
   *
   * @ignore
   * @param {legendComponent} comp - The component instance
   */function resolveSettings$3(comp){const domain=comp.scale.domain();let data={items:[]};const dock=comp.settings.layout.dock;if(comp.scale.type==='threshold-color'){const fields=comp.scale.data().fields;const sourceField=fields[0];let formatter=v=>String(v);if(comp.settings.formatter){formatter=comp.chart.formatter(comp.settings.formatter);}else if(sourceField){formatter=sourceField.formatter();}for(let i=0;i<domain.length-1;i++){const it={value:domain[i],label:"".concat(formatter(domain[i])," - < ").concat(formatter(domain[i+1]))};if(sourceField){it.source={field:sourceField.id()};}data.items.push(it);}const orientation=dock==='top'||dock==='bottom'?'horizontal':'vertical';if(orientation==='vertical'){data.items.reverse();}}else {const labels=comp.scale.labels?comp.scale.labels():null;data.items=domain.map((d,idx)=>{const datum=comp.scale.datum?extend$1({},comp.scale.datum(d)):{value:d};datum.value=d;if(comp.scale.label){datum.label=comp.scale.label(d);}else if(labels){datum.label=labels[idx];}return datum;});}const title=comp.resolver.resolve({data:{fields:comp.scale.data().fields},defaults:extend$1(true,{},DEFAULT_SETTINGS$2.title,comp.style.title),settings:comp.settings.settings.title});const layout=comp.resolver.resolve({data:{fields:comp.scale.data().fields},defaults:DEFAULT_SETTINGS$2.layout,settings:comp.settings.settings.layout});const labels=comp.resolver.resolve({data,defaults:extend$1(true,{},DEFAULT_SETTINGS$2.item.label,comp.style.item.label),settings:(comp.settings.settings.item||{}).label});const shapeSettings=extend$1(true,{},(comp.settings.settings.item||{}).shape);if(typeof shapeSettings.fill==='undefined'&&comp.settings.scale){shapeSettings.fill={scale:comp.settings.scale};}const symbols=comp.resolver.resolve({data,defaults:extend$1(true,{},DEFAULT_SETTINGS$2.item.shape,comp.style.item.shape),settings:shapeSettings});const items=comp.resolver.resolve({data,defaults:extend$1(true,{},{show:DEFAULT_SETTINGS$2.item.show}),settings:{show:(comp.settings.settings.item||{}).show}});function range(item,i){let v=item.data.value;let next=domain[i+1];item.data.value=[v,next];}if(comp.scale.type==='threshold-color'){const orientation=dock==='top'||dock==='bottom'?'horizontal':'vertical';if(orientation==='vertical'){items.items.reverse().forEach(range);items.items.reverse();}else {items.items.forEach(range);}}return {title,labels,symbols,items,layout};}/* eslint no-mixed-operators:0 */function placeTextInRect(rect,label,opts){const textMetrics=opts.textMetrics;if(rect.height<textMetrics.height){return false;}const wiggleWidth=Math.max(0,rect.width-textMetrics.width);label.baseline='text-before-edge';const wiggleHeight=Math.max(0,rect.height-textMetrics.height);label.x=rect.x+opts.align*wiggleWidth;label.y=rect.y+opts.justify*wiggleHeight+parseInt(label.fontSize,10)*0.175;// 0.175 - basline offset
  return label;}function wiggleSymbol(container,size,opts){const wiggleWidth=Math.max(0,container.width-size);const wiggleHeight=Math.max(0,container.height-size);return {x:container.x+size/2+opts.align*wiggleWidth,y:container.y+size/2+opts.justify*wiggleHeight};}function createRenderItem(_ref){let{x=0,y,item,globalMetrics,createSymbol,direction='ltr'}=_ref;let label=item.label.displayObject;let labelBounds=item.label.bounds;let symbolItem=item.symbol.meta;const rtl=direction==='rtl';let labelRect={x:rtl?x+globalMetrics.maxLabelBounds.width:x+globalMetrics.maxSymbolSize+globalMetrics.spacing,y,width:globalMetrics.maxLabelBounds.width,height:Math.max(globalMetrics.maxSymbolSize,globalMetrics.maxLabelBounds.height)};let wiggled=wiggleSymbol({x:rtl?x+globalMetrics.maxLabelBounds.width+globalMetrics.spacing:x,y,width:globalMetrics.maxSymbolSize,height:labelRect.height},symbolItem.size,{align:typeof symbolItem.align==='undefined'?0.5:symbolItem.align,justify:typeof symbolItem.justify==='undefined'?0.5:symbolItem.justify});const symbol=createSymbol(extend$1({},symbolItem,wiggled));delete symbol.collider;label.anchor=rtl?'end':'start';placeTextInRect(labelRect,label,{textMetrics:labelBounds,fontSize:parseInt(label.fontSize,10),align:0.0,justify:0.5});let container={type:'container',data:item.label.displayObject.data,children:[symbol,label],collider:{type:'rect',x,y,width:globalMetrics.maxItemBounds.width,height:globalMetrics.maxItemBounds.height}};return {item:container,metrics:labelRect};}function getItemsToRender(_ref2,rect,_ref3){let{viewRect}=_ref2;let{itemized,create=createRenderItem,parallels,createSymbol}=_ref3;const direction=itemized.layout.direction;const globalMetrics=itemized.globalMetrics;const legendItems=itemized.items;const isHorizontal=itemized.layout.orientation==='horizontal';let s=0;const renderItems=[];const fixedHeight=globalMetrics.maxItemBounds.height;const fixedWidth=globalMetrics.maxItemBounds.width;const rowHeight=itemized.layout.margin.vertical+fixedHeight;const columnWidth=itemized.layout.margin.horizontal+fixedWidth;let x=rect.x;let y=rect.y;let shift=viewRect.x-rect.x;for(let i=0;i<legendItems.length;i++){let renderItem=create({y,x:direction==='rtl'?viewRect.x+shift+viewRect.width-fixedWidth-(x-rect.x):x,item:legendItems[i],globalMetrics,direction,createSymbol});if(isHorizontal&&x>=viewRect.x-fixedWidth||!isHorizontal&&y>=viewRect.y-fixedHeight){renderItems.push(renderItem.item);}s++;if(s>=parallels){s=0;if(isHorizontal){x+=columnWidth;// next column
  y=rect.y;// reset y to first row
  }else {y+=rowHeight;// next row
  x=rect.x;// reset x to first column
  }}else if(isHorizontal){y+=rowHeight;// next row
  }else {x+=columnWidth;// next column
  }if(!isHorizontal&&y>viewRect.y+viewRect.height){break;}else if(isHorizontal&&x>viewRect.x+viewRect.width){break;}}return renderItems;}function itemize$2(_ref4,renderer){let{resolved,dock}=_ref4;let label;let items=[];let item;let sourceItems=resolved.items.items;let sourceSymbols=resolved.symbols.items;let sourceLabels=resolved.labels.items;let maxSymbolSize=0;let maxLabelWidth=0;let maxLabelHeight=0;for(let i=0;i<sourceItems.length;i++){if(sourceItems[i].show===false){continue;}const text=typeof sourceLabels[i].text!=='undefined'?sourceLabels[i].text:sourceLabels[i].data.label||'';label=extend$1({},sourceLabels[i],{// create the displayObject here in order to measure it
  type:'text',fontSize:"".concat(parseInt(sourceLabels[i].fontSize,10),"px"),text,title:text});item={symbol:{// can't create a displayObject here due to need to wiggle the center position of the symbol later on,
  // just store the object needed later on
  meta:sourceSymbols[i]},label:{displayObject:label,bounds:renderer.textBounds(label)}};items.push(item);maxSymbolSize=Math.max(sourceSymbols[i].size,maxSymbolSize);maxLabelWidth=Math.max(item.label.bounds.width,maxLabelWidth);maxLabelHeight=Math.max(item.label.bounds.height,maxLabelHeight);}return {items,globalMetrics:{spacing:8,maxSymbolSize,maxItemBounds:{height:Math.max(maxSymbolSize,maxLabelHeight),width:maxSymbolSize+8+maxLabelWidth},maxLabelBounds:{width:maxLabelWidth,height:maxLabelHeight}},layout:{margin:{vertical:typeof resolved.layout.item.vertical!=='undefined'?resolved.layout.item.vertical:4,horizontal:typeof resolved.layout.item.horizontal!=='undefined'?resolved.layout.item.horizontal:4},mode:resolved.layout.item.mode,size:resolved.layout.item.size,orientation:dock==='top'||dock==='bottom'?'horizontal':'vertical',direction:resolved.layout.item.direction,scrollOffset:resolved.layout.item.scrollOffset}};}function extent(itemized,parallels){const count=itemized.items.length;const size=Math.ceil(count/parallels);const property=itemized.layout.orientation==='horizontal'?'width':'height';const margin=property==='width'?'horizontal':'vertical';return itemized.globalMetrics.maxItemBounds[property]*size+(size-1)*itemized.layout.margin[margin];}function spread(itemized,parallels){const size=parallels;const property=itemized.layout.orientation==='horizontal'?'height':'width';const margin=property==='width'?'horizontal':'vertical';return itemized.globalMetrics.maxItemBounds[property]*size+// expected vertical size of items
  (size-1)*itemized.layout.margin[margin];// expected spacing between items
  }function parallelize(availableExtent,availableSpread,itemized){const count=itemized.items.length;const extentProperty=itemized.layout.orientation==='horizontal'?'width':'height';const margin=extentProperty==='width'?'horizontal':'vertical';const extentInPx=itemized.globalMetrics.maxItemBounds[extentProperty]*count+(count-1)*itemized.layout.margin[margin];let numNeeded=Math.ceil(extentInPx/availableExtent);if(availableSpread!=null){const spreadProperty=itemized.layout.orientation==='horizontal'?'height':'width';const spreadMargin=spreadProperty==='width'?'horizontal':'vertical';const spreadMarginSize=itemized.layout.margin[spreadMargin]||4;const numAllowed=Math.floor((availableSpread+spreadMarginSize)/(spreadMarginSize+itemized.globalMetrics.maxItemBounds[spreadProperty]));numNeeded=Math.min(numNeeded,numAllowed);}const numInput=isNaN(itemized.layout.size)?1:itemized.layout.size;return Math.max(1,Math.min(numNeeded,numInput));}function itemRenderer(legend,_ref5){let{onScroll=()=>{}}=_ref5;let itemized;let parallels;let viewRect;let containerRect;let offset=null;let overflow=0;const api={itemize:obj=>{itemized=itemize$2(obj,legend.renderer);offset=!isNaN(itemized.layout.scrollOffset)?itemized.layout.scrollOffset:offset;// Set the initial offset
  },getItemsToRender:obj=>{viewRect=obj.viewRect;overflow=api.getContentOverflow(viewRect);const ext=api.extent();offset=Math.max(0,Math.min(offset,overflow));containerRect=extend$1({},viewRect);const offsetProperty=api.orientation()==='horizontal'?'x':'y';containerRect[offsetProperty]-=offset;containerRect[offsetProperty==='x'?'width':'height']=ext;return getItemsToRender(obj,containerRect,{itemized,parallels,createSymbol:legend.symbol});},parallelize:(availableExtent,availableSpread)=>{parallels=parallelize(availableExtent,availableSpread,itemized);return parallels;},hasContentOverflow:()=>{const property=itemized.layout.orientation==='horizontal'?'width':'height';return extent(itemized,parallels)>viewRect[property];},getContentOverflow:function(){let rect=arguments.length>0&&arguments[0]!==undefined?arguments[0]:viewRect;const property=itemized.layout.orientation==='horizontal'?'width':'height';return Math.max(0,extent(itemized,parallels)-rect[property]);},getNextSize:()=>{// TODO - calculate the actual size to next item to ensure alignment
  const property=itemized.layout.orientation==='horizontal'?'width':'height';const margin=property==='width'?'horizontal':'vertical';return itemized.globalMetrics.maxItemBounds[property]+itemized.layout.margin[margin];},getPrevSize:()=>{// TODO - calculate the actual size to next item to ensure alignment
  const property=itemized.layout.orientation==='horizontal'?'width':'height';const margin=property==='width'?'horizontal':'vertical';return itemized.globalMetrics.maxItemBounds[property]+itemized.layout.margin[margin];},hasNext:()=>{if(api.orientation()==='horizontal'){return viewRect.x+viewRect.width<containerRect.x+containerRect.width;}return viewRect.y+viewRect.height<containerRect.y+containerRect.height;},hasPrev:()=>{if(api.orientation()==='horizontal'){return containerRect.x<viewRect.x;}return containerRect.y<viewRect.y;},next:()=>{api.scroll(-api.getNextSize());},prev:()=>{api.scroll(api.getPrevSize());},scroll:delta=>{const current=Math.max(0,Math.min(overflow,offset-delta));if(current===offset){return;}offset=current;onScroll();},offset:()=>offset,orientation:()=>itemized.layout.orientation,direction:()=>itemized.layout.direction,extent:()=>extent(itemized,parallels),// total amount of space along orientation
  spread:()=>spread(itemized,parallels)// total amount of space perpendicular to orientation
  };return api;}/**
   * Concatenate object keys into a space separated string. Use for transforming a 'class name map' into a class string
   * @private
   * @param  {Object} classMap Object with class names as keys and true or false values depending on if they should be in the returned class string or not
   * @return {String} Space separated string with class names
   */function classString(classMap){return Object.keys(classMap).filter(className=>classMap[className]).join(' ');}const DIR={up:'\u25B2',right:'\u25B6',down:'\u25BC',left:'\u25C0'};function itemize$1(_ref){let{// resolved,
  dock,navigation}=_ref;return {layout:{orientation:dock==='top'||dock==='bottom'?'vertical':'horizontal'},navigation};}function btn(h,_ref2){let{size,isActive,direction,nav,attrs}=_ref2;let c={};let content='';const attrsMerged=attrs;if(nav&&nav.button){if(typeof nav.button.class==='function'){c=nav.button.class({direction});}else if(nav.button.class){c=nav.button.class;}if(typeof nav.button.content==='function'){content=nav.button.content(h,{direction});}if(nav.button.tabIndex!==undefined){attrsMerged.tabindex=nav.button.tabIndex;}}const style={width:"".concat(size,"px"),minWidth:"".concat(size,"px"),height:"".concat(size,"px")};if(!Object.keys(c).length){// if no classes are set, add some basic styling
  style.border='0';style.background='none';}if(!isActive||nav&&nav.disabled){attrsMerged.disabled='disabled';}return h('button',extend$1({class:classString(c),style},attrsMerged),[content||h('span',{style:{pointerEvents:'none'}},[DIR[direction]])]);}function render$9(renderer,_ref3,itemized,legend){let{rect,itemRenderer}=_ref3;if(!renderer||!renderer.renderArgs){return;}renderer.size(rect);const h=renderer.renderArgs[0];const isVertical=itemized.layout.orientation==='vertical';// orientation of the navigation (not the legend)
  const isRtl=itemRenderer.direction()==='rtl';const hasNext=itemRenderer.hasNext();const hasPrev=itemRenderer.hasPrev();if(!hasPrev&&!hasNext){renderer.render([]);return;}const buttonSize=32;const order=isVertical?['right','left']:['down','up'];if(isRtl&&isVertical){order.reverse();}const nodes=[h('div',{style:{position:'relative',display:'flex','flex-direction':isVertical?'column':'row','justify-content':'center',height:'100%',pointerEvents:'auto'},dir:isRtl&&!isVertical?'rtl':'ltr'},[btn(h,{size:buttonSize,isActive:hasNext,direction:order[0],attrs:{'data-action':'next','data-component-key':legend.settings.key},nav:itemized.navigation}),btn(h,{size:buttonSize,isActive:hasPrev,direction:order[1],attrs:{'data-action':'prev','data-component-key':legend.settings.key},nav:itemized.navigation})])];renderer.render(nodes);}function navRenderer(legend){let itemized;const nav={itemize:obj=>{itemized=itemize$1(obj);},render:obj=>render$9(nav.renderer,obj,itemized,legend),extent:()=>32,spread:()=>64};return nav;}function itemize(_ref,legend){let{resolved}=_ref;if(resolved.title.item.show===false){return null;}const t=extend$1({},resolved.title.item,{type:'text'});if(resolved.layout.item.direction==='rtl'){if(!t.anchor||t.anchor==='start'){t.anchor='end';}else if(t.anchor==='end'){t.anchor='start';}}if(typeof resolved.title.settings.text==='undefined'){const fields=legend.scale.data().fields;t.text=fields&&fields[0]?fields[0].title():'';}return {displayObject:t,bounds:legend.renderer.textBounds(t)};}function render$8(_ref2,renderer,itemized){let{rect}=_ref2;if(!renderer){return;}const nodes=[];renderer.size(rect);if(itemized){const align={start:0,end:rect.width,middle:rect.width/2};nodes.push(extend$1({},itemized.displayObject,{x:align[itemized.displayObject.anchor]||0,y:0,baseline:'text-before-edge',title:itemized.displayObject.text}));}renderer.render(nodes);}function titleRenderer(legend){let itemized;const api={itemize:obj=>{itemized=itemize(obj,legend);},render:obj=>{render$8(obj,api.renderer,itemized);},spread:()=>itemized?itemized.bounds.height:0,extent:()=>itemized?itemized.bounds.width:0};return api;}/* eslint no-mixed-operators:0 */function layout(rect,display,orientation,_ref){let{itemRenderer,navigationRenderer,titleRenderer,isPreliminary=false}=_ref;let title;let content;let navigation;let preferredSize=0;const paddedRect={x:display.spacing,y:display.spacing,width:rect.width-2*display.spacing,height:rect.height-2*display.spacing};title={x:paddedRect.x,y:paddedRect.y,width:paddedRect.width,height:titleRenderer.spread()};if(orientation==='horizontal'){// const titleAtTop = false;
  // if (titleAtTop) { // this might be a nicer layout sometimes
  //   // |------------------|
  //   // |title             |
  //   // |------------|-----|
  //   // |content     | nav |
  //   // |------------|-----|
  //   // available space for items without navigation UI
  //   const availableExtentForItems = paddedRect.width;
  //   const availableSpreadForItems = paddedRect.height - (title.y + title.height) + 8;
  //   const isRtl = itemRenderer.direction() === 'rtl';
  //   itemRenderer.parallelize(availableExtentForItems, isPreliminary ? undefined : availableSpreadForItems);
  //   const navigationSize = itemRenderer.extent() > availableExtentForItems ? navigationRenderer.extent() : 0;
  //   content = {
  //     x: paddedRect.x,
  //     y: title.y + title.height,
  //     width: paddedRect.width - navigationSize,
  //     height: availableSpreadForItems
  //   };
  //   navigation = {
  //     x: content.x + content.width,
  //     y: title.y + title.height,
  //     width: navigationSize,
  //     height: paddedRect.height - (title.y + title.height) + 8
  //   };
  //   if (isRtl) { // switch navigation and content
  //     navigation.x = content.x;
  //     content.x = navigation.x + navigation.width;
  //     // totalContent.x = navigation.x;
  //   }
  //   preferredSize = title.height + Math.max(navigationRenderer.spread(), itemRenderer.spread());
  // } else {
  // |-----|------------|-----|
  // |title|content     | nav |
  // |-----|------------|-----|
  title={x:paddedRect.x,y:paddedRect.y,width:titleRenderer.extent(),height:titleRenderer.spread()};// available space for items without navigation UI
  const availableExtentForItems=paddedRect.width-title.width-(title.width?display.spacing:0);const availableSpreadForItems=paddedRect.height;itemRenderer.parallelize(availableExtentForItems,isPreliminary?undefined:availableSpreadForItems);const navigationSize=itemRenderer.extent()>availableExtentForItems?navigationRenderer.extent():0;const spread=itemRenderer.spread();const navigationSpread=navigationSize?navigationRenderer.spread():0;content={x:title.x+title.width+(title.width?display.spacing:0),y:paddedRect.y+Math.max(0,(navigationSpread-spread)/2),width:paddedRect.width-navigationSize-title.width-(navigationSize?display.spacing:0)-(title.width?display.spacing:0),height:availableSpreadForItems};navigation={x:content.x+content.width+(navigationSize?display.spacing:0),y:paddedRect.y,width:navigationSize,height:paddedRect.height};title.y=content.y;const isRtl=itemRenderer.direction()==='rtl';if(isRtl){// switch title, content and navigation
  navigation.x=paddedRect.x;content.x=navigation.x+navigation.width+(navigation.width?display.spacing:0);title.x=content.x+content.width+(title.width?display.spacing:0);}preferredSize=Math.max(title.height,navigationSpread,itemRenderer.spread());// }
  }else {// |------------|
  // |title       |
  // |------------|
  // |content     |
  // |------------|
  // |navigation  |
  // |------------|
  const availableExtentForItems=paddedRect.height-title.height-(title.height?display.spacing:0);const availableSpreadForItems=paddedRect.width;itemRenderer.parallelize(availableExtentForItems,isPreliminary?undefined:availableSpreadForItems);const navigationSize=itemRenderer.extent()>availableExtentForItems?navigationRenderer.extent():0;navigation={x:paddedRect.x,y:paddedRect.y+paddedRect.height-navigationSize,width:paddedRect.width,height:navigationSize};content={x:paddedRect.x,y:title.y+title.height+(title.height?display.spacing:0),width:paddedRect.width,height:paddedRect.height-title.height-(title.height?display.spacing:0)-navigation.height-(navigation.height?display.spacing:0)};preferredSize=Math.max(titleRenderer.extent(),navigationSize?navigationRenderer.spread():0,itemRenderer.spread());}content=extend$1({},rect,{x:rect.x+content.x,y:rect.y+content.y,width:content.width,height:content.height});navigation.x+=rect.x;navigation.y+=rect.y;title.x+=rect.x;title.y+=rect.y;return {title:extend$1({},rect,title),content:extend$1({},rect,content),navigation:extend$1({},rect,navigation),orientation,preferredSize};}function update$1(comp){comp.state.resolved=resolveSettings$3(comp);comp.titleRenderer.itemize({resolved:comp.state.resolved,dock:comp.settings.layout.dock||'center'});comp.itemRenderer.itemize({resolved:comp.state.resolved,dock:comp.settings.layout.dock||'center'});comp.navigationRenderer.itemize({resolved:comp.state.resolved,dock:comp.settings.layout.dock||'center',navigation:comp.settings.settings.navigation});comp.state.display={spacing:8};}function preferredSize(comp,size){let s=0;const dock=comp.settings.layout.dock||'center';const orientation=dock==='top'||dock==='bottom'?'horizontal':'vertical';const d=comp.state.display;const tempLayout=layout(size.inner,d,orientation,{itemRenderer:comp.itemRenderer,navigationRenderer:comp.navigationRenderer,titleRenderer:comp.titleRenderer,isPreliminary:true});s+=d.spacing;// start padding in both vertical and horizontal mode
  s+=tempLayout.preferredSize;s+=d.spacing;// end padding in both vertical and horizontal mode
  return s;}function render$7(legend){const{rect,settings,state,itemRenderer,navigationRenderer,titleRenderer}=legend;const dock=settings.layout.dock;const orientation=dock==='top'||dock==='bottom'?'horizontal':'vertical';const l=layout(rect,state.display,orientation,{itemRenderer,navigationRenderer,titleRenderer});legend.renderer.size(l.content);// l.content.x = 0;
  // l.content.y = 0;
  // l.navigation.x += rect.x;
  // l.navigation.y += rect.y;
  // l.title.x += rect.x;
  // l.title.y += rect.y;
  let contentItems=itemRenderer.getItemsToRender({viewRect:extend$1({},l.content,{x:0,y:0})});navigationRenderer.render({rect:l.navigation,itemRenderer});titleRenderer.render({rect:l.title});legend.state.views={layout:l};return contentItems;}const component$1={require:['chart','settings','renderer','update','resolver','registries','symbol'],defaultSettings:{settings:{},style:{item:{label:'$label',shape:'$shape'},title:'$title'}},mounted(renderElement){if(renderElement&&renderElement.parentNode){this.navigationRenderer.renderer.appendTo(renderElement.parentNode);this.titleRenderer.renderer.appendTo(renderElement.parentNode);renderElement.parentNode.insertBefore(this.navigationRenderer.renderer.element(),renderElement);renderElement.parentNode.insertBefore(this.titleRenderer.renderer.element(),renderElement);}this.navigationRenderer.render({rect:this.state.views.layout.navigation,itemRenderer:this.itemRenderer});this.titleRenderer.render({rect:this.state.views.layout.title});},beforeUnmount(){this.navigationRenderer.renderer.clear();this.titleRenderer.renderer.clear();},on:{panstart(){if(this.state.interaction.started){return;}const contentOverflow=this.itemRenderer.getContentOverflow();if(!contentOverflow){return;}this.state.interaction.started=true;this.state.interaction.delta=0;},panmove(e){if(!this.state.interaction.started){return;}const delta=this.itemRenderer.orientation()==='horizontal'?(this.itemRenderer.direction()==='rtl'?-1:1)*e.deltaX:e.deltaY;this.itemRenderer.scroll(delta-this.state.interaction.delta);this.state.interaction.delta=delta;},panend(){this.state.interaction.started=false;},scroll(delta){this.itemRenderer.scroll(-delta);},next(){this.itemRenderer.next();},prev(){this.itemRenderer.prev();}},created(){this.state={interaction:{}};this.onScroll=()=>{const items=render$7(this);this.update(items);};this.itemRenderer=itemRenderer(this,{onScroll:this.onScroll});this.navigationRenderer=navRenderer(this);this.titleRenderer=titleRenderer(this);this.navigationRenderer.renderer=this.registries.renderer('dom')();this.titleRenderer.renderer=this.registries.renderer(this.settings.renderer)();update$1(this);},preferredSize(obj){return preferredSize(this,obj);},beforeUpdate(){update$1(this);},render(){return render$7(this);},beforeDestroy(){this.navigationRenderer.renderer.destroy();this.titleRenderer.renderer.destroy();},additionalElements(){return [this.titleRenderer.renderer.element(),this.navigationRenderer.renderer.element()];},_DO_NOT_USE_getInfo(){return {offset:this.itemRenderer.offset()};}};/**
   * @typedef {object} ComponentLegendCat
   * @extends ComponentSettings
   * @property {'legend-cat'} type component type
   * @property {string} scale Reference to categorical color scale
   * @example
  {
    type: 'legend-cat',
    scale: '<categorical-color-scale>',
  }
   */const type$1='legend-cat';function categoricalLegend(picasso){picasso.component(type$1,component$1);}function applyAlignJustify(ctx,node){let wiggle=0;const cmd={type:ctx.state.isVertical?'justify':'align',coord:ctx.state.isVertical?'y':'x',pos:ctx.state.isVertical?'height':'width',fn:ctx.state.isVertical?'requiredHeight':'requiredWidth'};wiggle=ctx.state.rect[cmd.pos]-ctx.state.legend.length()-ctx.state.title[cmd.fn]();wiggle*=Math.min(1,Math.max(ctx.stgns[cmd.type],0));node[cmd.coord]+=wiggle;}function generateStopNodes(ctx){const fillScale=ctx.state.legend.fillScale;const majorScale=ctx.state.legend.majorScale;const stops=fillScale.domain().map(d=>({type:'stop',color:fillScale(d),offset:Math.min(1,Math.max(0,majorScale.norm(d)))}));return stops.sort((a,b)=>a.offset-b.offset);}function createTitleNode(ctx){const state=ctx.state;const settings=ctx.stgns;const isTickLeft=state.ticks.anchor==='left';const isTickTop=state.ticks.anchor==='top';let x=state.rect.x;let y=state.rect.y;let textAnchor='start';if(state.title.anchor==='left'){x+=state.title.requiredWidth()-settings.title.padding;y+=state.title.textMetrics.height;y+=isTickTop?state.rect.height-state.title.textBounds.height:0;textAnchor='end';}else if(state.title.anchor==='right'){x+=state.legend.length();x+=settings.title.padding;y+=state.title.textMetrics.height;y+=isTickTop?state.rect.height-state.title.textBounds.height:0;}else if(state.title.anchor==='top'){x+=isTickLeft?state.rect.width:0;y+=state.title.textMetrics.height;textAnchor=isTickLeft?'end':'start';}const node={tag:'legend-title',type:'text',x,y:Math.min(y,state.rect.y+state.rect.height),text:settings.title.text,fill:settings.title.fill,fontSize:settings.title.fontSize,fontFamily:settings.title.fontFamily,maxWidth:settings.title.maxLengthPx,maxLines:settings.title.maxLines,wordBreak:settings.title.wordBreak,hyphens:settings.title.hyphens,lineHeight:settings.title.lineHeight,anchor:textAnchor,title:settings.title.text};applyAlignJustify(ctx,node);return node;}function createLegendRectNode(ctx,stops){const state=ctx.state;const settings=ctx.stgns;const container=state.rect;let x=container.x;let y=container.y;let width=state.isVertical?settings.size:state.legend.length();let height=state.isVertical?state.legend.length():settings.size;if(state.ticks.anchor==='left'){x+=state.rect.width-settings.size;}else if(state.ticks.anchor==='top'){y+=state.rect.height-settings.size;}if(state.title.anchor==='top'){y+=state.title.requiredHeight();}else if(state.title.anchor==='left'){x+=state.title.requiredWidth();}const node={type:'rect',x,y,width,height,fill:{type:'gradient',stops,degree:state.isVertical?90:180}};applyAlignJustify(ctx,node);return node;}function createTickNodes(ctx,legendNode){const state=ctx.state;const settings=ctx.stgns;let anchor='start';const rangeSelectorRect={type:'rect',x:legendNode.x,y:legendNode.y,width:state.isVertical?0:legendNode.width,height:state.isVertical?legendNode.height:0,fill:'transparent'};const nodes=state.ticks.values.map(tick=>{let x=0;let y=0;let dx=0;let dy=0;let baseline='alphabetical';if(state.isVertical){y=legendNode.y+legendNode.height*tick.pos;baseline=tick.pos===0?'text-before-edge':'text-after-edge';}else {x=legendNode.x+legendNode.width*tick.pos;}if(state.ticks.anchor==='right'){x=legendNode.x+settings.size+settings.tick.padding;rangeSelectorRect.x=legendNode.x+legendNode.width;}else if(state.ticks.anchor==='left'){x=legendNode.x-settings.tick.padding;anchor='end';}else if(state.ticks.anchor==='top'){y=legendNode.y-settings.tick.padding;dy-=tick.textMetrics.height*0.25;anchor=tick.pos===0?'start':'end';}else if(state.ticks.anchor==='bottom'){y=legendNode.y+legendNode.height+settings.tick.padding;dy=tick.textMetrics.height*0.8;anchor=tick.pos===0?'start':'end';rangeSelectorRect.y=legendNode.y+legendNode.height;}const node={type:'text',x,y,dx,dy,text:tick.label,fontSize:settings.tick.fontSize,fontFamily:settings.tick.fontFamily,fill:settings.tick.fill,maxWidth:state.isVertical?settings.tick.maxLengthPx:Math.min(settings.tick.maxLengthPx,state.legend.length()/2),anchor,textBoundsFn:ctx.renderer.textBounds,title:tick.label,baseline};return node;});return {type:'container',id:'legend-seq-ticks',children:[...nodes,rangeSelectorRect]};}function resolveAnchor(dock,anchor,map){const mapped=map[dock];if(typeof mapped==='object'){if(mapped.valid.indexOf(anchor)!==-1){return anchor;}return mapped.default;}return map.default;}function resolveTickAnchor(settings){const dock=settings.layout.dock;const anchor=settings.settings.tick.anchor;const dockAnchorMap={left:{valid:['left','right'],default:'left'},right:{valid:['left','right'],default:'right'},top:{valid:['top','bottom'],default:'top'},bottom:{valid:['top','bottom'],default:'bottom'},default:'right'};return resolveAnchor(dock,anchor,dockAnchorMap);}function resolveTitleAnchor(settings){const dockAnchorMap={left:{valid:['top'],default:'top'},right:{valid:['top'],default:'top'},top:{valid:['left','right'],default:'left'},bottom:{valid:['left','right'],default:'left'},default:'top'};const dock=settings.layout.dock;const anchor=settings.settings.title.anchor;return resolveAnchor(dock,anchor,dockAnchorMap);}function initRect(ctx,size){const rect={x:0,y:0,width:0,height:0};const padding=ctx.stgns.padding;rect.x=padding.left;rect.y=padding.top;rect.width=size.width-padding.left-padding.right;rect.height=size.height-padding.top-padding.bottom;return rect;}function getTicks$2(ctx,majorScale){const values=majorScale.domain();let labels=values;let labelFn=ctx.stgns.tick.label;if(!labelFn&&ctx.formatter){labelFn=ctx.formatter;}else if(!labelFn&&majorScale.data().fields){labelFn=majorScale.data().fields[0].formatter();}if(typeof labelFn==='function'){labels=values.map(labelFn).map(String);}const ticks=values.map((value,i)=>{const label=labels[i];return {value,label,pos:majorScale.norm(parseFloat(value,10)),textMetrics:ctx.renderer.measureText({text:label,fontSize:ctx.stgns.tick.fontSize,fontFamily:ctx.stgns.tick.fontFamily})};});return ticks;}function initState(ctx){const isVertical=ctx.settings.layout.dock!=='top'&&ctx.settings.layout.dock!=='bottom';const titleStgns=ctx.stgns.title;const fillScale=ctx.chart.scale(ctx.stgns.fill);const majorScale=ctx.chart.scale(ctx.stgns.major);const tickValues=getTicks$2(ctx,majorScale);const tickAnchor=resolveTickAnchor(ctx.settings);if(typeof titleStgns.text==='undefined'){const fields=majorScale.data().fields;titleStgns.text=fields&&fields[0]?fields[0].title():'';}const titleTextMetrics=ctx.renderer.measureText({text:titleStgns.text,fontSize:titleStgns.fontSize,fontFamily:titleStgns.fontFamily});const titleTextBounds=ctx.renderer.textBounds({text:titleStgns.text,fontSize:titleStgns.fontSize,fontFamily:titleStgns.fontFamily,maxLines:titleStgns.maxLines,maxWidth:titleStgns.maxLengthPx,wordBreak:titleStgns.wordBreak,hyphens:titleStgns.hyphens,lineHeight:titleStgns.lineHeight});const state={isVertical,nodes:[],title:{anchor:resolveTitleAnchor(ctx.settings),textMetrics:titleTextMetrics,textBounds:titleTextBounds,requiredWidth:()=>{if(!titleStgns.show){return 0;}let w=titleTextBounds.width;let mw=titleStgns.maxLengthPx;if(!isVertical){w+=titleStgns.padding;mw+=titleStgns.padding;}return Math.min(w,mw,state.rect.width);},requiredHeight:()=>{if(!titleStgns.show){return 0;}let h=titleTextBounds.height;if(isVertical){h+=titleStgns.padding;}return Math.min(h,state.rect.height);}},ticks:{values:tickValues,anchor:tickAnchor,length:Math.min(Math.max(...tickValues.map(t=>t.textMetrics.width)),ctx.stgns.tick.maxLengthPx),requiredHeight:()=>tickAnchor==='top'?Math.max(...state.ticks.values.map(t=>t.textMetrics.height))+ctx.stgns.tick.padding:0,height:Math.max(...tickValues.map(t=>t.textMetrics.height))},legend:{fillScale,majorScale,length:()=>{const pos=isVertical?'height':'width';const fnPos=isVertical?'requiredHeight':'requiredWidth';const len=Math.min(state.rect[pos],state.rect[pos]*ctx.stgns.length)-state.title[fnPos]();return Math.max(0,Math.min(len,ctx.stgns.maxLengthPx));}}};return state;}/**
   * Component settings
   * @typedef {object} ComponentLegendSeq.settings
   * @property {string} fill - Reference to definition of sequential color scale
   * @property {string} major - Reference to definition of linear scale
   * @property {number} [size=15] - Size in pixels of the legend, if vertical is the width and height otherwise
   * @property {number} [length=1] - A value in the range 0-1 indicating the length of the legend node
   * @property {number} [maxLengthPx=250] - Max length in pixels
   * @property {number} [align=0.5] - A value in the range 0-1 indicating horizontal alignment of the legend's content. 0 aligns to the left, 1 to the right.
   * @property {number} [justify=0] - A value in the range 0-1 indicating vertical alignment of the legend's content. 0 aligns to the top, 1 to the bottom.
   * @property {object} [padding]
   * @property {number} [padding.left=5] - Size in pixels
   * @property {number} [padding.right=5] - Size in pixels
   * @property {number} [padding.top=5] - Size in pixels
   * @property {number} [padding.bottom=5] - Size in pixels
   * @property {object} [tick]
   * @property {function} [tick.label] - Function applied to all tick values. Return value should be a string and is used as label
   * @property {string} [tick.fill='#595959'] - Tick color
   * @property {string} [tick.fontSize='12px'] - Font size in pixels
   * @property {string} [tick.fontFamily='Arial'] - Font family
   * @property {number} [tick.maxLengthPx=150] - Max length in pixels
   * @property {string} [tick.anchor=''] - Where to anchor the tick in relation to the legend node, supported values are [top, bottom, left and right] or empty string to auto anchor
   * @property {number} [tick.padding=5] - padding in pixels to the legend node
   * @property {object} [title] - Title settings
   * @property {boolean} [title.show=true] - Toggle title on/off
   * @property {string} [title.text=''] - Title text. Defaults to the title of the provided data field
   * @property {string} [title.fill='#595959'] - Title color
   * @property {string} [title.fontSize='12px'] - Font size in pixels
   * @property {string} [title.fontFamily='Arial'] - Font family
   * @property {number} [title.maxLengthPx=100] - Max length in pixels
   * @property {number} [title.padding=5] - padding in pixels to the legend node
   * @property {string} [title.anchor=''] - Where to anchor the title in relation to the legend node, supported values are [top, left and right] or empty string to auto anchor
   * @property {string} [title.wordBreak='none'] - How overflowing title is handled, if it should insert line breaks at word boundries (break-word) or character boundries (break-all)
   * @property {string} [title.hyphens='auto'] - How words should be hyphenated when text wraps across multiple lines (only applicable with wordBreak)
   * @property {number} [title.maxLines=2] - Number of allowed lines if title contains line breaks (only applicable with wordBreak)
   * @property {number} [title.lineHeight=1.2] - A multiplier defining the distance between lines (only applicable with wordBreak)
   */const legendDef={require:['chart','settings','renderer'],defaultSettings:{layout:{displayOrder:0,dock:'right'},settings:{size:15,length:0.5,maxLengthPx:250,align:0.5,justify:0,padding:{left:5,right:5,top:5,bottom:5},tick:{label:null,fill:'#595959',fontSize:'12px',fontFamily:'Arial',maxLengthPx:100,anchor:null,// Use default based on dock
  padding:5},title:{show:true,text:undefined,fill:'#595959',fontSize:'12px',fontFamily:'Arial',maxLengthPx:100,padding:5,maxLines:2,wordBreak:'none',lineHeight:1.2,hyphens:'auto',anchor:null// Use default based on dock
  }}},preferredSize(opts){const state=this.state;state.rect=initRect(this,opts.inner);// Init with size of legend
  let prefSize=this.stgns.size;// Append paddings
  const paddings=state.isVertical?this.stgns.padding.left+this.stgns.padding.right:this.stgns.padding.top+this.stgns.padding.bottom;prefSize+=paddings;// Append tick size
  const maxSize=Math.max(opts.inner.width,opts.inner.height);if(state.ticks.anchor==='left'||state.ticks.anchor==='right'){const tHeight=state.ticks.values.reduce((sum,t)=>sum+t.textMetrics.height,0);if(tHeight>this.state.legend.length()){return maxSize;}prefSize+=state.ticks.length;}else {const tWidth=state.ticks.length;if(tWidth>this.state.legend.length()){return maxSize;}prefSize+=Math.max(...state.ticks.values.map(t=>t.textMetrics.height));}prefSize+=this.stgns.tick.padding;// Append or use title size
  if(this.stgns.title.show){if(state.title.anchor==='left'||state.title.anchor==='right'){prefSize=Math.max(state.title.textBounds.height+paddings,prefSize);}else {prefSize=Math.max(prefSize,state.title.requiredWidth()+paddings);}}this.state.preferredSize=prefSize;return prefSize;},created(){this.stgns=this.settings.settings;this.state=initState(this);},beforeUpdate(opts){this.stgns=opts.settings.settings;this.state=initState(this);},beforeRender(opts){this.state.nodes=[];this.state.rect=initRect(this,opts.size);if(this.stgns.title.show){const titleNode=createTitleNode(this);this.state.nodes.push(titleNode);}const stopNodes=generateStopNodes(this);const rectNode=createLegendRectNode(this,stopNodes);const tickNodes=createTickNodes(this,rectNode);const targetNode={// The target node enables range selection component to limit its range to a specific area
  id:'legend-seq-target',type:'container',children:[rectNode,tickNodes]};this.state.nodes.push(targetNode);},render(){return this.state.nodes;}};/**
   * @typedef {object} ComponentLegendSeq
   * @extends ComponentSettings
   * @property {'legend-seq'} type component type
   * @example
  {
    type: 'legend-seq',
    settings: {
      fill: '<sequential-color-scale>',
      major: '<linear-scale>',
    }
  }
   */function sequentialLegend(picasso){picasso.component('legend-seq',legendDef);}/**
   * Callback function for layer sort
   * @callback ComponentLine~LayerSort
   * @param {object} a
   * @param {string} a.id
   * @param {Array<DatumExtract>} a.data
   * @param {object} b
   * @param {string} b.id
   * @param {Array<DatumExtract>} b.data
   */ /**
   * Component settings
   * @typedef {object}
   * @alias ComponentLine.settings
   */const SETTINGS={/**
     * @typedef {object}
     */coordinates:{/**
       * @type {number} */minor:0.5,/**
       * @type {number} */major:0.5,/**
       * @type {number=} */layerId:0,/**
       * @type {DatumBoolean=} */defined:true},/**
     * @type {boolean=} */connect:false,/**
     * @type {string=} */orientation:'horizontal',/**
     * @typedef {object} */layers:{/**
       * @type {string=} */curve:'linear',/**
       * @type {boolean=} */show:true,/**
       * @type {ComponentLine~LayerSort=} */sort:undefined,/**
       * @typedef {object} */line:{/**
         * @type {string=} */stroke:'#ccc',/**
         * @type {number=} */strokeWidth:1,/**
         * @type {string=} */strokeLinejoin:'miter',/**
         * @type {string=} */strokeDasharray:undefined,/**
         * @type {number=} */opacity:1,/**
         * @type {boolean=} */show:true,/**
         * @type {boolean=} */showMinor0:true},/**
       * @typedef {object} */area:{/**
         * @type {string=} */fill:'#ccc',/**
         * @type {number=} */opacity:0.8,/**
         * @type {boolean=} */show:true}}};function createDisplayLayer(points,_ref){let{generatorType,item,data,major,minor,layerObj,stngs}=_ref;let fill=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'';const d={type:'path',points,generatorType,major,minor,layerObj,stngs,opacity:item.opacity,stroke:item.stroke,strokeWidth:item.strokeWidth,strokeLinejoin:item.strokeLinejoin,fill:fill||item.fill,data};if(item.strokeDasharray){d.strokeDasharray=item.strokeDasharray;}return d;}function createDisplayLayers(layers,_ref2){let{width,height,missingMinor0,stngs}=_ref2;const nodes=[];const layerStngs=stngs.layers||{};layers.forEach(layer=>{const{lineObj,layerObj,areaObj,points}=layer;let minor={size:height,p:'y'};let major={size:width,p:'x'};if(stngs.orientation==='vertical'){const temp=extend$1(true,{},major);major=extend$1(true,{},minor);minor=extend$1(true,{},temp);}// area layer
  if(layerStngs.area&&areaObj.show!==false){nodes.push(createDisplayLayer(points,{data:layer.consumableData,item:areaObj,generatorType:'area',major,minor,layerObj,stngs}));}// main line layer
  if(lineObj&&lineObj.show!==false){nodes.push(createDisplayLayer(points,{data:layer.consumableData,item:lineObj,generatorType:"line".concat(minor.p.toUpperCase(),"1"),major,minor,layerObj,stngs},'none'));// secondary line layer, used only when rendering area
  if(!missingMinor0&&layerStngs.area&&areaObj.show!==false&&lineObj.showMinor0!==false){nodes.push(createDisplayLayer(points,{data:layer.consumableData,item:lineObj,generatorType:"line".concat(minor.p.toUpperCase(),"0"),major,minor,layerObj,stngs},'none'));}}});return nodes;}function resolve$2(_ref3){let{data,stngs,rect,resolver,style,domain}=_ref3;const{width,height}=rect;const coordinates=resolver.resolve({data,defaults:SETTINGS.coordinates,settings:stngs.coordinates||{},scaled:{major:stngs.orientation==='vertical'?height:width,minor:stngs.orientation==='vertical'?width:height}});// there are two cases when a line should be interrupted:
  // 1. When the minor value is undefined (this case is easily handled by the lineGenerator.defined).
  // 2. When a line is moving over a domain that may not coincide with the domain on the major scale.
  // For the second case, dummy points need to be injected in order to create values which will cause gaps as they fulfill the first case.
  // These dummy points need to be injected only when: the domain is discrete, connect !== false and multiple layers are defined
  const injectDummy=!stngs.connect&&domain.length>2&&(typeof stngs.coordinates.layerId==='function'||typeof stngs.coordinates.layerId==='object');// collect points into layers
  const layerIds={};let numLines=0;for(let i=0;i<coordinates.items.length;i++){let p=coordinates.items[i];let lid=p.layerId;if(injectDummy){// inject dummy if the previous point on the major domain is not the same as the prev point on the line's domain.
  // this works only if a datum's value property is the same primitive as in the domain.
  const lastItem=layerIds[lid]?layerIds[lid].items[layerIds[lid].items.length-1]:null;const lastOrderIdx=lastItem?domain.indexOf(lastItem.data.major?lastItem.data.major.value:lastItem.data.value):null;if(lastItem&&domain.indexOf(p.data.major?p.data.major.value:p.data.value)-1!==lastOrderIdx){layerIds[lid].items.push({dummy:true});}}layerIds[lid]=layerIds[lid]||{order:numLines++,id:lid,items:[],dataItems:[],consumableData:{}};layerIds[lid].dataItems.push(p.data);layerIds[lid].items.push(p);}const metaLayers=Object.keys(layerIds).map(lid=>{layerIds[lid].consumableData=_objectSpread2$1({points:layerIds[lid].dataItems},layerIds[lid].dataItems[0]);return layerIds[lid];});const layersData={items:metaLayers.map(layer=>layer.consumableData)};const layerStngs=stngs.layers||{};const layersResolved=resolver.resolve({data:layersData,defaults:{curve:SETTINGS.layers.curve,show:SETTINGS.layers.show},settings:{curve:layerStngs.curve,show:layerStngs.show}});const linesResolved=resolver.resolve({data:layersData,defaults:extend$1({},SETTINGS.layers.line,style.line),settings:layerStngs.line});const areasResolved=resolver.resolve({data:layersData,defaults:extend$1({},SETTINGS.layers.area,style.area),settings:layerStngs.area});return {coordinates,metaLayers,layers:layersResolved,lines:linesResolved,areas:areasResolved};}function calculateVisibleLayers(opts){const{metaLayers,coordinates,layers,lines,areas}=resolve$2(opts);const visibleLayers=[];metaLayers.forEach((layer,ix)=>{const layerObj=layers.items[ix];if(layerObj.show===false){return;}// layerObj.points = [];
  layerObj.datum=layerObj.data;layerObj.data=[];layerObj.id=layer.id;const values=[];const points=[];let point;let pData;for(let i=0;i<layer.items.length;i++){point=layer.items[i];pData=point.data;if(!point.dummy){if(isNaN(point.major)){continue;}if(opts.missingMinor0){point.minor0=coordinates.settings.minor.scale?coordinates.settings.minor.scale(pData.minor0?pData.minor0.value:0):0;}if(!isNaN(point.minor)){values.push(point.minor);}layerObj.data.push(point.data);}points.push(point);}const median=values.sort((a,b)=>a-b)[Math.floor((values.length-1)/2)];visibleLayers.push({layerObj,lineObj:lines.items[ix],areaObj:areas.items[ix],median,points,consumableData:layer.consumableData});});return visibleLayers;}const lineMarkerComponent={require:['chart','resolver'],defaultSettings:{style:{area:'$shape',line:'$shape-outline'}},created(){},render(_ref4){let{data}=_ref4;// console.log("DATA", data);
  const{width,height}=this.rect;this.stngs=this.settings.settings||{};const missingMinor0=!this.stngs.coordinates||typeof this.stngs.coordinates.minor0==='undefined';const visibleLayers=calculateVisibleLayers({data,stngs:this.stngs,rect:this.rect,resolver:this.resolver,style:this.style,missingMinor0,domain:this.stngs.coordinates&&this.stngs.coordinates.major&&this.stngs.coordinates.major.scale?this.chart.scale(this.stngs.coordinates.major.scale).domain():[]});if(this.stngs.layers&&this.stngs.layers.sort){const sortable=visibleLayers.map(v=>({id:v.layerObj.id,data:v.layerObj.data})).sort(this.stngs.layers.sort).map(s=>s.id);visibleLayers.sort((a,b)=>sortable.indexOf(a.layerObj.id)-sortable.indexOf(b.layerObj.id));}else {visibleLayers.sort((a,b)=>a.median-b.median);}// generate visuals
  return createDisplayLayers(visibleLayers,{width,height,missingMinor0,stngs:this.stngs});}};/**
   * @typedef {object} ComponentLine
   * @extends ComponentSettings
   * @property {'line'} type component type
   * @example
  {
    type: "line",
    data: {
      extract: {
        field: "Year",
        props: {
          sales: { field: "Sales" },
        },
      },
    },
    settings: {
      coordinates: {
        major: { scale: "t" },
        minor: { scale: "y", ref: "sales" },
      },
    },
  }
   */const type='line';function line(picasso){picasso.component(type,lineMarkerComponent);}/**
   * @typedef {object}
   * @alias ComponentBrushArea.settings
   */const DEFAULT_SETTINGS$1={/**
     * @type {object}
     */brush:{/**
       * @type {Array<BrushTargetConfig>}
       */components:[]}};/**
   * Transform the incoming event into point in the local coordinate system. That is the coordinate system of the component.
   * @private
   * @param {object} ctx - Context
   * @param {object} event - Incoming event, either native event or hammer event
   * @param {boolean} clamp - True to clamp the point inside the component bounds
   * @returns {point}
   */function getLocalPoint(ctx,event){let clamp=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;let x;let y;if(typeof event.center==='object'){x=event.center.x;y=event.center.y;}else {x=event.clientX;y=event.clientY;}const localX=x-ctx.state.boundingRect.left;const localY=y-ctx.state.boundingRect.top;return {x:clamp?Math.max(0,Math.min(localX,ctx.rect.width)):localX,y:clamp?Math.max(0,Math.min(localY,ctx.rect.height)):localY};}/**
   * Transform a local point into a point in the chart coordinate system.
   * @private
   * @param {object} ctx - Context
   * @param {object} p - Point to transform
   * @returns {point}
   */function localToChartPoint(ctx,p){return {x:p.x+ctx.rect.x,y:p.y+ctx.rect.y};}/**
   * Extract and apply default brush configuration.
   * @private
   * @param {object} settings
   * @returns {object[]} An Array of brush configurations
   */function getBrushConfig(settings){return settings.settings.brush.components.map(b=>({key:b.key,contexts:b.contexts,data:b.data,action:b.action||'set'}));}/**
   * End all active brush contexts.
   * @private
   * @param {oject} state
   * @param {object} chart - Chart instance
   */function doEndBrush(state,chart){state.brushConfig.forEach(config=>{if(Array.isArray(config.contexts)){config.contexts.forEach(context=>{chart.brush(context).end();});}});}/**
   * Convert two points into a rectangle.
   * @private
   * @param {Point} p0
   * @param {Point} p1
   * @returns {Rect}
   */function toRect(p0,p1){const xMin=Math.min(p0.x,p1.x);const yMin=Math.min(p0.y,p1.y);const xMax=Math.max(p0.x,p1.x);const yMax=Math.max(p0.y,p1.y);return {x:xMin,y:yMin,width:xMax-xMin,height:yMax-yMin};}/**
   * Perform a brush on the given area.
   * @private
   * @param {object} ctx
   */function doAreaBrush(ctx){if(ctx.state.active){const start=localToChartPoint(ctx,ctx.state.start);const end=localToChartPoint(ctx,ctx.state.end);const shapes=ctx.chart.shapesAt(toRect(start,end),{components:ctx.state.brushConfig});ctx.chart.brushFromShapes(shapes,{components:ctx.state.brushConfig});}}function render$6(ctx){ctx.renderer.render([extend$1({type:'rect'},toRect(ctx.state.start,ctx.state.end),ctx.style.area)]);}function resetState(){return {start:{x:0,y:0},end:{x:0,y:0},active:false};}const definition={require:['chart','renderer'],defaultSettings:{layout:{displayOrder:99},settings:DEFAULT_SETTINGS$1,style:{area:'$selection-area-target'}},on:{areaStart(e){this.start(e);},areaMove(e){this.move(e);},areaEnd(e){this.end(e);},areaCancel(){this.cancel();}},created(){this.state=resetState();},preferredSize(){return 0;},render(){},start(e){this.state.boundingRect=this.renderer.element().getBoundingClientRect();const p=getLocalPoint(this,e,false);// Require event to be inside the component bounds
  if(!testRectPoint({x:0,y:0,width:this.rect.width,height:this.rect.height},p)){return;}this.state.brushConfig=getBrushConfig(this.settings);this.state.start=getLocalPoint(this,e);this.state.active=true;},move(e){if(!this.state.active){return;}this.state.end=getLocalPoint(this,e);doAreaBrush(this);render$6(this);},end(){if(!this.state.active){return;}this.state=resetState();this.renderer.render([]);},cancel(){if(!this.state.active){return;}doEndBrush(this.state,this.chart);this.state=resetState();this.renderer.render([]);}};/**
   * A component that can brush a rectangular area
   * @typedef {object} ComponentBrushArea
   * @extends ComponentSettings
   * @property {'brush-area'} type component type
   * @example
   * {
   *  type: 'brush-area',
   *  brush: {
   *    components: [{ key: '<target-component>', contexts: ['highlight'] }]
   *  }
   * }
   */function areaBrush(picasso){picasso.component('brush-area',definition);}function extractor(nodes,_ref){let{chart,scale,props,h}=_ref;const dataCtx={resources:{dataset:chart.dataset,scale:chart.scale,formatter:chart.formatter},scale,h};const data=[];nodes.forEach(node=>{if(typeof props.extract==='function'){const ctx=extend$1({node},dataCtx);data.push(props.extract(ctx));}});return data;}function resolveClasses(props,opts){return {tooltip:typeof props.tooltipClass==='function'?props.tooltipClass({dock:opts.dock}):props.tooltipClass,content:typeof props.contentClass==='function'?props.contentClass({dock:opts.dock}):props.contentClass,arrow:typeof props.arrowClass==='function'?props.arrowClass({dock:opts.dock}):props.arrowClass};}function resolveContent(h,data,style,props){return props.content({h,style,data});}function render$5(data,placement,_ref){let{renderer,style,props,h}=_ref;const classes=resolveClasses(props,placement);const content=resolveContent(h,data,style,props);const tooltipDefaultStyle={position:'relative',display:'inline-block'};const tooltipNode=h("div",{dir:props.direction,class:classString(extend$1({'pic-tooltip':true},classes.tooltip)),style:extend$1(tooltipDefaultStyle,placement.computedTooltipStyle)},h("div",{style:style.content,class:classString(extend$1({'pic-tooltip-content':true},classes.content))},content),h("div",{class:classString(extend$1({'pic-tooltip-arrow':true},classes.arrow)),style:extend$1({},style.arrow,style["arrow-".concat(placement.dock)],placement.computedArrowStyle)}));renderer.render(tooltipNode);return renderer.element().children[0];}// Successfull flow: pending -> active -> fulfilled (only with duration)
  // Cancelled flow: pending -> active -> cancelled
  // Rejected flow: pending -> rejected
  // Debounced flow: pending -> debounced -> pending -> [rejected|fulfilled]
  function dispatcherState(){const fn=function fn(){};const on={pending:[],debounced:[],active:[],cancelled:[],rejected:[],fulfilled:[]};let state;fn.set=s=>{state=s;on[state].forEach(event=>event(s));};fn.on=(key,event)=>{if(Array.isArray(key)){key.forEach(k=>on[k].push(event));}else {on[key].push(event);}};fn.destroy=()=>{Object.keys(on).forEach(key=>{on[key].length=0;});};// fn.on(['pending', 'debounced', 'active', 'cancelled', 'rejected', 'fulfilled'], (e) => {
  //   console.log(e);
  // });
  return fn;}function timeSpanDispatcher(_ref){let{defaultDuration,defaultDelay}=_ref;let actionId=null;let fulfilledId=null;let isActive=false;const state=dispatcherState();const fn=function fn(){};const fulfilled=()=>{actionId=null;fulfilledId=null;isActive=false;state.set('fulfilled');};fn.invoke=function(action){let duration=arguments.length>1&&arguments[1]!==undefined?arguments[1]:defaultDuration;let delay=arguments.length>2&&arguments[2]!==undefined?arguments[2]:defaultDelay;if(actionId){clearTimeout(actionId);state.set('debounced');}state.set('pending');actionId=setTimeout(()=>{action();isActive=true;actionId=null;state.set('active');},delay);if(duration>0){if(fulfilledId){clearTimeout(fulfilledId);}fulfilledId=setTimeout(fulfilled,duration+Math.max(delay,0));}};fn.clear=()=>{if(isActive){state.set('cancelled');}else if(actionId){clearTimeout(actionId);state.set('rejected');}if(fulfilledId){clearTimeout(fulfilledId);}actionId=null;fulfilledId=null;isActive=false;};fn.on=(key,event)=>{state.on(key,event);};fn.destroy=()=>{fn.clear();state.destroy();};return fn;}function getDockTransform(){let offset=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;return {left:"translate(-100%,-50%) translateX(".concat(-offset,"px)"),right:"translate(".concat(offset,"px, -50%)"),top:"translate(-50%, -100%) translateY(".concat(-offset,"px)"),bottom:"translate(-50%, ".concat(offset,"px)"),inside:"translate(-50%, -50%)"};}function getDockOffset(width,height){let offset=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;return {left:{x:-width-offset,y:-height/2},right:{x:offset,y:-height/2},top:{x:-width/2,y:-height-offset},bottom:{x:-width/2,y:offset},inside:{x:-width/2,y:-height/2}};}function getComputedArrowStyle(offset){return {left:{left:'100%',top:"calc(50% - ".concat(offset,"px)"),borderWidth:"".concat(offset,"px")},right:{left:"".concat(-offset*2,"px"),top:"calc(50% - ".concat(offset,"px)"),borderWidth:"".concat(offset,"px")},top:{left:"calc(50% - ".concat(offset,"px)"),top:'100%',borderWidth:"".concat(offset,"px")},bottom:{left:"calc(50% - ".concat(offset,"px)"),top:"".concat(-offset*2,"px"),borderWidth:"".concat(offset,"px")},inside:{left:'0px',top:'0px',borderWidth:'0px'}};}function isInsideArea(area,vx,vy,width,height,offset){const rect={x:vx+offset.x,y:vy+offset.y,width,height};if(rect.x<0||rect.y<0){return false;}if(rect.x+rect.width>area.width||rect.y+rect.height>area.height){return false;}return true;}/**
   * @private
   * @param {vx} vx X-coordinate realative to the area
   * @param {vy} vy Y-coordinate realative to the area
   */function calcOffset(_ref){let{area,vx,vy,width,height,offset}=_ref;const rect={x:vx+offset.x,y:vy+offset.y,width,height};let offsetX=rect.x<0?-rect.x:0;let offsetY=rect.y<0?-rect.y:0;offsetX+=rect.x+rect.width>area.width?-(rect.x+rect.width-area.width):0;offsetY+=rect.y+rect.height>area.height?-(rect.y+rect.height-area.height):0;return {x:offsetX,y:offsetY};}function alignToBounds(_ref2){let{resources,nodes,pointer,width:elmWidth,height:elmHeight,options}=_ref2;const{targetBounds}=pointer;const{x,y,width,height}=resources.getNodeBoundsRelativeToTarget(nodes[0]);const docks={left:{x,y:y+height/2},right:{x:x+width,y:y+height/2},top:{x:x+width/2,y},bottom:{x:x+width/2,y:y+height},inside:{x:x+width/2,y:y+height/2}};// Check if explicit dock
  const dockTransforms=getDockTransform(options.offset);const transform=dockTransforms[options.dock];if(transform){return {computedTooltipStyle:{left:"".concat(docks[options.dock].x,"px"),top:"".concat(docks[options.dock].y,"px"),transform},computedArrowStyle:getComputedArrowStyle(options.offset)[options.dock],dock:options.dock};}const area={width:options.area==='target'?targetBounds.width:window.innerWidth,height:options.area==='target'?targetBounds.height:window.innerHeight};const dockOffsets=getDockOffset(elmWidth,elmHeight,options.offset);const dockOrder=['top','left','right','bottom','inside'];for(let i=0;i<dockOrder.length;i+=1){const dock=dockOrder[i];const vx=options.area==='target'?docks[dock].x:targetBounds.left+docks[dock].x;const vy=options.area==='target'?docks[dock].y:targetBounds.top+docks[dock].y;if(isInsideArea(area,vx,vy,elmWidth,elmHeight,dockOffsets[dock])){return {computedTooltipStyle:{left:"".concat(docks[dock].x,"px"),top:"".concat(docks[dock].y,"px"),transform:dockTransforms[dock]},computedArrowStyle:getComputedArrowStyle(options.offset)[dock],dock};}}return {computedTooltipStyle:{left:"".concat(docks.top.x,"px"),top:"".concat(docks.top.y,"px"),transform:dockTransforms.top},computedArrowStyle:getComputedArrowStyle(options.offset).top,dock:'top'};}function alignToPoint(_ref3){let{options,pointer,width,height,dockOrder,x,y}=_ref3;const{targetBounds}=pointer;// Check if explicit dock
  const dockTransforms=getDockTransform(options.offset);const transform=dockTransforms[options.dock];if(transform){return {computedTooltipStyle:{left:"".concat(x,"px"),top:"".concat(y,"px"),transform},computedArrowStyle:getComputedArrowStyle(options.offset)[options.dock],dock:options.dock};}const area={width:options.area==='target'?targetBounds.width:window.innerWidth,height:options.area==='target'?targetBounds.height:window.innerHeight};const dockOffsets=getDockOffset(width,height,options.offset);const results=[];const edgeMargin=20;const vx=options.area==='target'?x:targetBounds.left+x;const vy=options.area==='target'?y:targetBounds.top+y;for(let i=0;i<dockOrder.length;i+=1){const dock=dockOrder[i];const offset=calcOffset({area,vx,vy,width,height,offset:dockOffsets[dock]});const computedTooltipStyle={left:"".concat(x,"px"),top:"".concat(y,"px"),transform:dockTransforms[dock]};const computedArrowStyle=getComputedArrowStyle(options.offset)[dock];if(offset.x!==0){computedTooltipStyle.width="".concat(width-edgeMargin-Math.abs(offset.x),"px");if(dock==='top'||dock==='bottom'){computedTooltipStyle.left="".concat(x+offset.x,"px");computedArrowStyle.left="calc(50% ".concat(offset.x>0?'-':'+'," ").concat(Math.abs(offset.x),"px)");}}const result={computedTooltipStyle,computedArrowStyle,dock,rect:{width,height}};if(offset.x===0&&offset.y===0){return result;}result.offset=offset;results.push(result);}results.sort((a,b)=>Math.abs(a.offset.x)-Math.abs(b.offset.x));return results[0];}function alignToPointer(_ref4){let{options,pointer,width,height}=_ref4;const{x,y}=pointer;return alignToPoint({x,y,pointer,width,height,options,dockOrder:['top','left','right','bottom']});}function alignToSlice(_ref5){let{options,pointer,width,height,nodes,resources}=_ref5;const node=nodes[0];const{dx,dy}=pointer;const componentBounds=resources.getComponentBoundsFromNode(node);// cx and cy relative to targetBounds
  const center={x:dx+componentBounds.x+componentBounds.width/2,y:dy+componentBounds.y+componentBounds.height/2};const{start,end,outerRadius}=node.desc.slice;// Node origin is at 12 o clock, clockwise, but Math uses 3 a clock, so it's transformed to origin at 3 a clock
  const middle=(start+end)/2-Math.PI/2;const PI2=Math.PI*2;const radians=(middle%PI2+PI2)%PI2;let dockOrder=['top','left','right','bottom'];if(options.dock==='auto'){if(radians<=Math.PI/4||radians>=Math.PI*7/4){dockOrder=['right','top','bottom','left'];}else if(radians<=Math.PI*3/4){dockOrder=['bottom','left','right','top'];}else if(radians<=Math.PI*5/4){dockOrder=['left','top','bottom','right'];}else {dockOrder=['top','left','right','bottom'];}}return alignToPoint({x:center.x+outerRadius*componentBounds.scaleRatio.x*Math.cos(radians),y:center.y+outerRadius*componentBounds.scaleRatio.y*Math.sin(radians),pointer,width,height,options,dockOrder});}function getComponentBoundsFromNode(node,pointer,chart){const comp=node.key?chart.component(node.key):chart.componentsFromPoint({x:pointer.clientX,y:pointer.clientY})[0];if(!comp){return {x:0,y:0,width:0,height:0,scaleRatio:{x:1,y:1}};}const componentSize=comp.rect;return extend$1({scaleRatio:componentSize.scaleRatio},componentSize.computedInner);}function getNodeBoundsRelativeToTarget(node,pointer,chart){const componentBounds=getComponentBoundsFromNode(node,pointer,chart);const bounds=node.bounds;return {x:componentBounds.x+pointer.dx+bounds.x,y:componentBounds.y+pointer.dy+bounds.y,width:bounds.width,height:bounds.height};}const STRATEGIES={bounds:alignToBounds,pointer:alignToPointer,slice:alignToSlice};function placement(_ref6,_ref7){let{width,height}=_ref6;let{chart,state,props}=_ref7;const propCtx={resources:{formatter:chart.formatter,scale:chart.scale,component:chart.component,getComponentBoundsFromNode:node=>getComponentBoundsFromNode(node,state.pointer,chart),getNodeBoundsRelativeToTarget:node=>getNodeBoundsRelativeToTarget(node,state.pointer,chart)},nodes:state.activeNodes,pointer:state.pointer,width,height};const type=typeof props.placement;if(type==='object'&&typeof props.placement.fn==='function'){// Custom placement strategy function
  return props.placement.fn(propCtx);}let opts={type:'pointer',offset:8,dock:'auto',area:'viewport'};if(type==='function'){// Custom placement function
  opts=extend$1(opts,props.placement(propCtx));}if(type==='object'&&STRATEGIES[props.placement.type]){// Predefined placement function with options
  opts=extend$1(opts,props.placement);}else if(type==='string'&&STRATEGIES[props.placement]){// Predefined placement function without options
  opts=extend$1(opts,{type:props.placement});}propCtx.options=opts;const plcm=STRATEGIES[opts.type](propCtx);let{x:minX,y:minY,width:maxX,height:maxY}=propCtx.resources.getComponentBoundsFromNode(propCtx.nodes[0]);minX+=propCtx.pointer.dx;maxX+=minX;minY+=propCtx.pointer.dy;maxY+=minY;// Clamp tooltip position
  plcm.computedTooltipStyle.left="".concat(Math.min(Math.max(0,minX,parseFloat(plcm.computedTooltipStyle.left)),maxX),"px");plcm.computedTooltipStyle.top="".concat(Math.min(Math.max(0,minY,parseFloat(plcm.computedTooltipStyle.top)),maxY),"px");return plcm;}let instance;function setActive(action){instance=action;}function removeActive(action){if(instance===action){instance=null;return true;}return false;}function cancelActive(a){if(instance&&instance!==a){instance();}}function remove(){instance=null;}/**
   * @typedef {object}
   * @alias ComponentTooltip.settings
   */const DEFAULT_SETTINGS$9={/**
     * How long the tooltip is visible, in milliseconds
     * @type {number=}
     */duration:8000,/**
     * Delay before the tooltip is rendered, in milliseconds
     * @type {number=}
     */delay:500,/**
     * Callback function to filter incoming nodes to only a set of applicable nodes. Is called as a part of the `show` event.
     *
     * Should return an array of SceneNodes.
     * @type {function=}
     * @callback
     * @param {SceneNode[]} nodes Array of SceneNodes
     * @returns {SceneNode[]} An array of SceneNodes
     * @example
     * filter: (nodes) => nodes.filter((node) => node.data && typeof node.data.value !== 'undefined')
     */filter:nodes=>nodes.filter(node=>node.data&&typeof node.data.value!=='undefined'),/**
     * Callback function called for each node to extract data. Can return any type.
     * @type {function=}
     * @callback
     * @param {object} ctx Callback context
     * @param {SceneNode} ctx.node Node
     * @returns {any} Return data
     * @example
     * (ctx) => ctx.node.data.value
     */extract:ctx=>ctx.node.data.value,/**
     * Callback function to generate content. Should return an array of Virtual DOM Elements.
     * @type {function=}
     * @callback
     * @param {object} ctx Callback context
     * @param {any[]} ctx.data An array of data generated from the `extract` function
     * @param {object} ctx.h A function for creating Virtual DOM Elements. See API reference for preactjs `h` function
     * @returns {object[]} An array of Virtual DOM Elements
     * @example
     * ({ h, data }) => data.map((datum) => h('div', {}, datum))
     */content:_ref=>{let{h,data}=_ref;return data.map(datum=>h('div',{},datum));},/**
     * Comparison function. If evaluted to true, the incoming nodes in the `show` event are ignored. If evaluated to false, any active tooltip is cleared and a new tooltip is queued.
     *
     * The function gets two parameters, the first is the currently active set of nodes, if any, and the second is the incoming set of nodes. By default the two set of nodes are considered equal if their data attributes are the same.
     * @type {function=}
     * @callback
     * @param {SceneNode[]} prev Previous array of SceneNodes
     * @param {SceneNode[]} curr Current array of SceneNodes
     * @returns {boolean}
     */isEqual:(prev,curr)=>prev.length&&prev.length===curr.length&&prev.every((p,i)=>curr[i]&&JSON.stringify(p.data)===JSON.stringify(curr[i].data)),/**
     * @typedef {object=}
     */placement:{/**
       * Available types: [pointer | bounds | slice]
       * @type {string=}
       */type:'pointer',/**
       * Docking position of the tooltip. Available positions: [left | right | top | bottom | auto]
       * @type {string=}
       */dock:'auto',/**
       * Distance from the content area to the tooltip position, in px.
       * @type {number=}
       */offset:8,/**
       * Specify the limiting area, where target is the component area unless the appendTo property is set, in which case it referes to the appendTo element. Viewport is the browser viewport.
       *
       * Available options are: [viewport | target]
       * @type {number=}
       */area:'viewport'},/**
     * Set tooltip class.
     * @type {object<string, boolean>=}
     */tooltipClass:{},/**
     * Set content class.
     * @type {object<string, boolean>=}
     */contentClass:{},/**
     * Set arrow class.
     * @type {object<string, boolean>=}
     */arrowClass:{},/**
     * Content direction [ltr | rtl]
     * @type {string=}
     */direction:'ltr',/**
     * Explicitly set a target element. This allows the tooltip to attach itself outside the picasso container.
     * @type {HTMLElement=}
     */appendTo:undefined,/**
     * Component lifecycle hook. Called before the tooltip is displayed.
     * @type {function=}
     * @callback
     */beforeShow:undefined,/**
     * Component lifecycle hook. Called after the tooltip have been displayed.
     * @type {function=}
     * @callback
     */afterShow:undefined,/**
     * Component lifecycle hook. Called before the tooltip is hidden.
     * @type {function=}
     * @callback
     * @param {object} ctx Callback paramater
     * @param {HTMLElement} ctx.element The element the tooltip is appended to
     */beforeHide:undefined,/**
     * Component lifecycle hook. Called when the toolip is hidden. By default this deletes the tooltip element.
     * @type {function=}
     * @callback
     * @param {object} ctx Callback paramater
     * @param {HTMLElement} ctx.element The element the tooltip is appended to
     */onHide:undefined,/**
     * Component lifecycle hook. Called after the tooltip is hidden.
     * @type {function=}
     * @callback
     */afterHide:undefined};const DEFAULT_STYLE={tooltip:{},content:{backgroundColor:'$gray-25',color:'$font-color--inverted',fontFamily:'$font-family',fontSize:'$font-size',lineHeight:'$line-height',borderRadius:'4px',padding:'8px',opacity:0.9},arrow:{position:'absolute',width:'0px',height:'0px',borderStyle:'solid',color:'$gray-25',opacity:0.9},'arrow-bottom':{borderTopColor:'transparent',borderLeftColor:'transparent',borderRightColor:'transparent'},'arrow-top':{borderBottomColor:'transparent',borderLeftColor:'transparent',borderRightColor:'transparent'},'arrow-right':{borderTopColor:'transparent',borderLeftColor:'transparent',borderBottomColor:'transparent'},'arrow-left':{borderTopColor:'transparent',borderBottomColor:'transparent',borderRightColor:'transparent'}};function toPoint(event,_ref2){let{chart,state}=_ref2;let x=0;let y=0;if(event.center){x+=event.center.x;y+=event.center.y;}else {x+=event.clientX;y+=event.clientY;}// TODO Don't do getBoundingClientRect lookup here. It's performance heavy.
  const chartBounds=chart.element.getBoundingClientRect();const targetBounds=state.targetElement.getBoundingClientRect();const clientX=x;const clientY=y;const dx=chartBounds.left-targetBounds.left;const dy=chartBounds.top-targetBounds.top;const cx=x-chartBounds.left;const cy=y-chartBounds.top;x-=targetBounds.left;y-=targetBounds.top;return {x,// Target point relative to the target bounds
  y,dx,// Delta from target bounds to the chart bounds
  dy,cx,// Target point relative to the chart bounds
  cy,clientX,clientY,targetBounds,// Target bounding rect
  chartBounds// Chart bounding rect
  };}const component={require:['chart','renderer'],defaultSettings:{settings:DEFAULT_SETTINGS$9,style:DEFAULT_STYLE},renderer:'dom',on:{hide(){this.hide();},show(event){let opts=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.show(event,opts);},prevent(p){this.prevent(p);}},hide(){this.dispatcher.clear();this.state.activeNodes=[];this.state.pointer={};},show(event){let{nodes,duration,delay}=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(this.state.prevent||!this.state.targetElement){return;}// Set pointer here to always expose latest pointer to invokeRenderer
  this.state.pointer=toPoint(event,this);let fNodes;if(Array.isArray(nodes)){fNodes=this.props.filter(nodes);}else {fNodes=this.props.filter(this.chart.shapesAt({x:this.state.pointer.cx,y:this.state.pointer.cy}));}if(this.props.isEqual(this.state.activeNodes,fNodes)){return;}this.dispatcher.clear();this.state.activeNodes=fNodes;if(this.state.activeNodes.length){this.dispatcher.invoke(()=>this.invokeRenderer(this.state.activeNodes),duration,delay);}},prevent(p){this.state.prevent=!!p;},init(settings){this.state={activeNodes:[],pointer:{},targetElement:null,prevent:false};this.props=settings.settings;this.dispatcher=timeSpanDispatcher({defaultDuration:this.props.duration,defaultDelay:this.props.delay});const instanceId=this.dispatcher.clear;this.dispatcher.on('pending',()=>{// Cancel only if the active is another instance
  cancelActive(instanceId);setActive(instanceId);if(typeof this.props.beforeShow==='function'){this.props.beforeShow.call(undefined,{resources:{formatter:this.chart.formatter,scale:this.chart.scale}});}});this.dispatcher.on(['cancelled','fulfilled'],()=>{const listenerCtx={resources:{formatter:this.chart.formatter,scale:this.chart.scale}};if(typeof this.props.beforeHide==='function'){this.props.beforeHide.call(undefined,extend$1({element:this.state.tooltipElm},listenerCtx));}if(typeof this.props.onHide==='function'){this.props.onHide.call(undefined,extend$1({element:this.state.tooltipElm},listenerCtx));}else {this.renderer.clear([]);// Hide tooltip
  }if(typeof this.props.afterHide==='function'){this.props.afterHide.call(undefined,listenerCtx);}removeActive(instanceId);this.state.tooltipElm=undefined;});this.dispatcher.on('active',()=>{if(typeof this.props.afterShow==='function'){this.props.afterShow.call(undefined,{element:this.state.tooltipElm,resources:{formatter:this.chart.formatter,scale:this.chart.scale}});}});},created(){this.init(this.settings);},beforeUpdate(_ref3){let{settings}=_ref3;if(this.dispatcher){this.dispatcher.destroy();remove();}this.init(settings);},render(h){this.h=h;return [];// Nothing to render initially.
  },beforeDestroy(){this.dispatcher.destroy();remove();},appendTo(){if(this.props.appendTo){this.state.targetElement=typeof this.props.appendTo==='function'?this.props.appendTo({resources:{formatter:this.chart.formatter,scale:this.chart.scale}}):this.props.appendTo;const{width,height}=this.state.targetElement.getBoundingClientRect();this.renderer.destroy();this.renderer.size({width,height});this.renderer.appendTo(this.state.targetElement);}else {this.state.targetElement=this.renderer.element();}},mounted(){this.appendTo();},updated(){// Append here to, otherwise the picasso displayOrder logic screw things up
  this.appendTo();},invokeRenderer(nodes){const items=extractor(nodes,this);const pseudoElement=render$5(items,{style:{left:'0px',top:'0px',visibility:'hidden'}},this);const pos=placement(pseudoElement.getBoundingClientRect(),this);this.state.tooltipElm=render$5(items,pos,this);}};/**
   * @typedef {object} ComponentTooltip
   * @extends ComponentSettings
   * @property {'tooltip'} type component type
   * @example
   * picasso.chart({
    settings: {
      interactions: [{
        type: 'native',
        events: {
          mousemove(e) {
            const tooltip = this.chart.component('<tooltip-key>');
            tooltip.emit('show', e);
          },
          mouseleave(e) {
            const tooltip = this.chart.component('<tooltip-key>');
            tooltip.emit('hide');
          }
        }
      }],
      components: [
        {
          key: '<tooltip-key>',
          type: 'tooltip'
        }
      ]
    },
    ...
  });
   */function addTooltip(picasso){picasso.component('tooltip',component);}const debugColliderDef={require:['renderer','chart'],defaultSettings:{settings:{target:'',selector:'*',fill:'rgba(0, 255, 0, 0.1)',stroke:'lime',opacity:1,useOuterRect:false}},on:{update(){this.draw();}},draw(){const shapes=this.chart.findShapes(this.props.selector).filter(s=>s.key===this.props.target);// Find all shapes
  const colliders=shapes.filter(s=>s.collider).map(s=>s.collider);colliders.forEach(c=>{c.fill=this.props.fill;c.stroke=this.props.stroke;c.opacity=this.props.opacity;c.collider={type:null};});this.renderer.render(colliders);},created(){this.props=this.settings.settings;},resize(_ref){let{outer,inner}=_ref;if(this.props.useOuterRect){return outer;}return inner;},render(){},mounted(){this.draw();},updated(){this.props=this.settings.settings;this.draw();}};const PI_X2=Math.PI*2;/**
   * Implementation of F.6.5 https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
   * @ignore
   * @param {number} rx - Arc x-radius
   * @param {number} ry - Arc y-radius
   * @param {number} rotation - Arc rotation in degrees (0-360)
   * @param {boolean} largeArcFlag
   * @param {boolean} sweepFlag
   * @param {number} endX - X-coordinate for end of arc
   * @param {number} endY - Y-coordinate for end of arc
   * @param {number} startX - X-coordinate for start of arc
   * @param {number} startY - Y-coordinate for start of arc
   * @returns {object}
   */function arcToCenter(rx,ry,rotation,largeArcFlag,sweepFlag,endX,endY,startX,startY){let startAngle;let endAngle;let sweepAngle;let cx;let cy;let radiusRatio;const rad=toRadians(rotation%360);// F.6.5.1
  const cos=Math.cos(rad);const sin=Math.sin(rad);const hdx=(startX-endX)/2;const hdy=(startY-endY)/2;const x1d=cos*hdx+sin*hdy;const y1d=cos*hdy-sin*hdx;// F.6.6
  rx=Math.abs(rx);ry=Math.abs(ry);radiusRatio=x1d**2/rx**2+y1d**2/ry**2;if(radiusRatio>1){radiusRatio=Math.sqrt(radiusRatio);rx*=radiusRatio;ry*=radiusRatio;}// F.6.5.2
  const rxry=rx*ry;const rxy1d=rx*y1d;const ryx1d=ry*x1d;const den=rxy1d**2+ryx1d**2;const num=rxry**2-den;let frac=Math.sqrt(Math.max(num/den,0));if(largeArcFlag===sweepFlag){frac=-frac;}const cxd=frac*(rxy1d/ry);const cyd=frac*-(ryx1d/rx);// F.6.5.3
  const mx=(startX+endX)/2;const my=(startY+endY)/2;cx=cos*cxd-sin*cyd+mx;cy=sin*cxd+cos*cyd+my;// F.6.5.6 clockwise angle
  const ux=(x1d-cxd)/rx;const uy=(y1d-cyd)/ry;const vx=(-x1d-cxd)/rx;const vy=(-y1d-cyd)/ry;startAngle=Math.atan2(uy,ux);startAngle+=startAngle<0?PI_X2:0;endAngle=Math.atan2(vy,vx);endAngle+=endAngle<0?PI_X2:0;sweepAngle=endAngle-startAngle;if(!sweepFlag&&startAngle<endAngle){sweepAngle-=PI_X2;}else if(sweepFlag&&endAngle<startAngle){sweepAngle+=PI_X2;}sweepAngle%=PI_X2;return {startAngle,sweepAngle,cx,cy,rx,ry};}/**
   * Measure the flatnass of a cubic bezier curve
   * @ignore
   * @param {Point} s - Start point
   * @param {Point} cp1 - First control point
   * @param {Point} cp2 - Second control point
   * @param {Point} e - End point
   */function flatness(s,cp1,cp2,e){const ux=Math.abs(s.x+cp2.x-(cp1.x+cp1.x));const uy=Math.abs(s.y+cp2.y-(cp1.y+cp1.y));const vx=Math.abs(cp1.x+e.x-(cp2.x+cp2.x));const vy=Math.abs(cp1.y+e.y-(cp2.y+cp2.y));return ux+uy+vx+vy;}function mid(p0,p1){return {x:(p0.x+p1.x)*0.5,y:(p0.y+p1.y)*0.5};}function interpolate$4(t,s,cp1,cp2,e){const td=1-t;const t0=td**3*s;const t1=3*td**2*t*cp1;const t2=3*td*t**2*cp2;const t3=t**3*e;return t0+t1+t2+t3;}/**
   * Recursive subdivision of a curve using de Casteljau algorithm.
   * Splits the curve into multiple line segments where each segments is choosen based on a level of flatness.
   *
   * At most it will be able to generate 2**maxNbrOfSplits + 1 = 257 points
   * @ignore
   * @param {Point} s - Start point
   * @param {Point} cp1 - First control point
   * @param {Point} cp2 - Second control point
   * @param {Point} e - End point
   * @param {array} points - Initial set of points
   * @returns {point[]} Array of points
   */function toPoints$1(s,cp1,cp2,e){let points=arguments.length>4&&arguments[4]!==undefined?arguments[4]:[];let maxNbrOfSplits=arguments.length>5&&arguments[5]!==undefined?arguments[5]:8;if(maxNbrOfSplits<1||flatness(s,cp1,cp2,e)<=10){if(points[points.length-1]!==s){points.push(s);}points.push(e);return points;}const t=0.5;const m0=mid(s,cp1);const m1=mid(cp1,cp2);const m2=mid(cp2,e);const b={// Split curve at point
  x:interpolate$4(t,s.x,cp1.x,cp2.x,e.x),y:interpolate$4(t,s.y,cp1.y,cp2.y,e.y)};const q0=mid(m0,m1);// New cp2 for left curve
  const q1=mid(m1,m2);// New cp1 for right curve
  toPoints$1(s,m0,q0,b,points,maxNbrOfSplits-1);// left curve
  toPoints$1(b,q1,m2,e,points,maxNbrOfSplits-1);// Right curve
  return points;}function toCubic(s,cp,e){const cp1x=s.x+2/3*(cp.x-s.x);const cp1y=s.y+2/3*(cp.y-s.y);const cp2x=e.x+2/3*(cp.x-e.x);const cp2y=e.y+2/3*(cp.y-e.y);const cp1={x:cp1x,y:cp1y};const cp2={x:cp2x,y:cp2y};return {cp1,cp2};}/**
   * Recursive subdivision of a curve using de Casteljau algorithm.
   * Splits the curve into multiple line segments where each segments is choosen based on a level of flatness.
   * @ignore
   * @param {Point} s - Start point
   * @param {Point} cp - Control point
   * @param {Point} e - End point
   * @returns {Point[]} Array of points
   */function toPoints(s,cp,e){const{cp1,cp2}=toCubic(s,cp,e);return toPoints$1(s,cp1,cp2,e);}const EPSILON$1=1e-12;function removeDuplicates$2(points){for(let i=0;i<points.length-1;i++){const p0=points[i];const p1=points[i+1];if(Math.abs(p0.x-p1.x)<EPSILON$1&&Math.abs(p0.y-p1.y)<EPSILON$1){points.splice(i,1);i--;}}}/**
   * Transform an arc to a set of points a long the arc.
   * Specifiction F.6 (https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes)
   * @ignore
   * @param {array} s - Segments
   * @param {number} startX - X-coordinate for start of arc
   * @param {number} startY - Y-coordinate for start of arc
   */function arcToPoints(s,startX,startY){const points=[];const largeArcFlag=!!s[4];// F.6.3
  const sweepFlag=!!s[5];// F.6.3
  const rotation=s[3];let endX=s[6];let endY=s[7];let rx=s[1];let ry=s[2];let cx;let cy;let sweepAngle;let startAngle;if(s[0]==='a'){endX+=startX;endY+=startY;}// F.6.2
  if(startX===endY&&startY===endY){return points;}// Given no radius, threat as lineTo command
  if(!rx||!ry){points.push({x:endX,y:endY});return points;}({cx,cy,rx,ry,sweepAngle,startAngle}=arcToCenter(rx,ry,rotation,largeArcFlag,sweepFlag,endX,endY,startX,startY));// Approximation of perimeter
  const p=Math.abs(sweepAngle*Math.sqrt((rx**2+ry**2)/2));// Generate a point every 10th pixel. Scaling of the node should probably be included in this calculation
  const res=Math.ceil(p/10);const resAngle=sweepAngle/res;for(let k=1;k<=res;k++){const deltaAngle=resAngle*k;const radians=(startAngle+deltaAngle)%PI_X2;const cos=Math.cos(radians);const sin=Math.sin(radians);// F.6.3 https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
  points.push({x:cx+cos*rx+-sin*cos,y:cy+sin*ry+cos*sin});}// points.push({ x: cx, y: cy });
  return points;}/**
   * Converts a SVG path data string into a set of points.
   * @ignore
   * @param {string} path
   * @returns {Array<point[]>} Array of points
   */function pathToPoints(path){const commands=src.parsePath(path);const segments=[];const points=[];let x=0;// Current point
  let y=0;let cpx=null;// Last control point on a cubic curve
  let cpy=null;let qcpx=null;// Last control point on a quad curve
  let qcpy=null;for(let i=0;i<commands.length;++i){const cmd=commands[i];const pathType=cmd[0];// Reset control point if command is not cubic
  if(pathType!=='S'&&pathType!=='s'&&pathType!=='C'&&pathType!=='c'){cpx=null;cpy=null;}if(pathType!=='T'&&pathType!=='t'&&pathType!=='Q'&&pathType!=='q'){qcpx=null;qcpy=null;}switch(pathType){case'm':if(points.length){segments.push(points.splice(0));}// Fall through
  case'l':// eslint-disable-line no-fallthrough
  x+=cmd[1];y+=cmd[2];points.push({x,y});break;case'M':if(points.length){segments.push(points.splice(0));}// Fall through
  case'L':// eslint-disable-line no-fallthrough
  x=cmd[1];y=cmd[2];points.push({x,y});break;case'H':x=cmd[1];points.push({x,y});break;case'h':x+=cmd[1];points.push({x,y});break;case'V':y=cmd[1];points.push({x,y});break;case'v':y+=cmd[1];points.push({x,y});break;case'a':points.push(...arcToPoints(cmd,x,y));x+=cmd[6];y+=cmd[7];break;case'A':points.push(...arcToPoints(cmd,x,y));x=cmd[6];y=cmd[7];break;case'c':points.push(...toPoints$1({x,y},{x:cmd[1]+x,y:cmd[2]+y},{x:cmd[3]+x,y:cmd[4]+y},{x:cmd[5]+x,y:cmd[6]+y}));cpx=cmd[3]+x;// Last control point
  cpy=cmd[4]+y;x+=cmd[5];y+=cmd[6];break;case'C':points.push(...toPoints$1({x,y},{x:cmd[1],y:cmd[2]},{x:cmd[3],y:cmd[4]},{x:cmd[5],y:cmd[6]}));cpx=cmd[3];// Last control point
  cpy=cmd[4];x=cmd[5];y=cmd[6];break;case's':if(cpx===null||cpx===null){cpx=x;cpy=y;}points.push(...toPoints$1({x,y},{x:2*x-cpx,y:2*y-cpy},{x:cmd[1]+x,y:cmd[2]+y},{x:cmd[3]+x,y:cmd[4]+y}));cpx=cmd[1]+x;// last control point
  cpy=cmd[2]+y;x+=cmd[3];y+=cmd[4];break;case'S':if(cpx===null||cpx===null){cpx=x;cpy=y;}points.push(...toPoints$1({x,y},{x:2*x-cpx,y:2*y-cpy},{x:cmd[1],y:cmd[2]},{x:cmd[3],y:cmd[4]}));cpx=cmd[1];// last control point
  cpy=cmd[2];x=cmd[3];y=cmd[4];break;case'Q':points.push(...toPoints({x,y},{x:cmd[1],y:cmd[2]},{x:cmd[3],y:cmd[4]}));qcpx=cmd[1];// last control point
  qcpy=cmd[2];x=cmd[3];y=cmd[4];break;case'q':points.push(...toPoints({x,y},{x:cmd[1]+x,y:cmd[2]+y},{x:cmd[3]+x,y:cmd[4]+y}));qcpx=cmd[1]+x;// last control point
  qcpy=cmd[2]+y;x+=cmd[3];y+=cmd[4];break;case'T':if(qcpx===null||qcpx===null){qcpx=x;qcpy=y;}qcpx=2*x-qcpx;// last control point
  qcpy=2*y-qcpy;points.push(...toPoints({x,y},{x:qcpx,y:qcpy},{x:cmd[1],y:cmd[2]}));x=cmd[1];y=cmd[2];break;case't':if(qcpx===null||qcpx===null){qcpx=x;qcpy=y;}qcpx=2*x-qcpx;// last control point
  qcpy=2*y-qcpy;points.push(...toPoints({x,y},{x:qcpx,y:qcpy},{x:cmd[1]+x,y:cmd[2]+y}));x+=cmd[1];y+=cmd[2];break;case'z':case'Z':if(points.length){points.push({x:points[0].x,y:points[0].y});}break;// Do nothing
  }}removeDuplicates$2(points);segments.push(points.splice(0));return segments;}const debugPathToPointsDef={require:['renderer','chart'],defaultSettings:{settings:{target:'',fill:'transparent',stroke:'lime',opacity:1,radius:2,useOuterRect:false}},on:{update(){this.draw();}},draw(){const shapes=this.chart.findShapes('path').filter(s=>s.key===this.props.target);// Find all shapes
  const circles=[];shapes.forEach(s=>{pathToPoints(s.attrs.d).forEach(segment=>{segment.forEach(p=>{circles.push({type:'circle',cx:p.x,cy:p.y,r:this.props.radius,fill:this.props.fill,stroke:this.props.stroke,opacity:this.props.opacity,collider:{type:null}});});});});this.renderer.render(circles);},created(){this.props=this.settings.settings;},resize(_ref){let{outer,inner}=_ref;if(this.props.useOuterRect){return outer;}return inner;},render(){},mounted(){this.draw();},updated(){this.props=this.settings.settings;this.draw();}};function debugCollider(picasso){picasso.component('debug-collider',debugColliderDef);}function debugPathToPoints(picasso){picasso.component('debug-path-to-points',debugPathToPointsDef);}var components=[box,pointMarker,pie,gridLine,refLine,axis,container,text,scrollbar,rangeBrush$1,rangeBrush$2,lassoBrush,labels,categoricalLegend,sequentialLegend,line,areaBrush,addTooltip,debugCollider,debugPathToPoints];let Node$1 = class Node{/**
     * @private
     */constructor(type){this._parent=null;this._children=[];this._ancestors=null;this.type=type;this.data=null;}/**
     * Detaches this node from its parent, if such exists.
     * @returns {Node}
     */detach(){if(this._parent){this._parent.removeChild(this);}return this;}/**
     * Parent of this node.
     * @readonly
     * @type {Node}
     */get parent(){return this._parent;}/**
     * Checks whether this node is a branch.
     *
     * True if this node has children, false otherwise.
     * @readonly
     * @type {Boolean}
     */get isBranch(){return this._children&&this._children.length;}/**
     * Children of this node.
     * @readonly
     * @type {Node[]}
     */get children(){return this._children;}/**
     * Ancestors of this node, including parent.
     * @readonly
     * @type {Node[]}
     */get ancestors(){if(!this._ancestors){this._ancestors=[];if(this.parent){this._ancestors.push(this.parent,...this.parent.ancestors);}}return this._ancestors;}/**
     * Descendants of this node.
     * @readonly
     * @type {Node[]}
     */get descendants(){let r=[];const len=this.children.length;let i;let c;for(i=0,len;i<len;i++){c=this.children[i];r.push(c);if(c.children.length){r=[...r,...c.descendants];}}return r;}/**
     *
     * @returns {Boolean}
     */equals(n){const children=this.children;const nChildren=n.children;if(children.length!==nChildren.length){return false;}// Requires deterministic child order
  for(let i=0;i<children.length;i++){if(!children[i].equals(nChildren[i])){return false;}}return true;}toJSON(){return {type:this.type,children:this.children.map(ch=>ch.toJSON())};}};/**
   * Construct a new GeoRect instance
   * @private
   */class GeoRect{constructor(){let{x=0,y=0,width=0,height=0,minWidth=0,minHeight=0}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.set({x,y,width,height,minWidth,minHeight});}set(){let{x=0,y=0,width=0,height=0,minWidth=0,minHeight=0}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.type='rect';if(width>=0){this.x=x;this.width=Math.max(width,minWidth);}else {this.x=x+Math.min(width,-minWidth);this.width=-Math.min(width,-minWidth);}if(height>=0){this.y=y;this.height=Math.max(height,minHeight);}else {this.y=y+Math.min(height,-minHeight);this.height=-Math.min(height,-minHeight);}}/**
     * @param {Point} p
     * @returns {boolean} True if there is an intersection, false otherwise
     */containsPoint(p){return testRectPoint(this,p);}/**
     * @param {Point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsLine(points){const line=pointsToLine(points);return testRectLine(this,line);}/**
     * @param {Point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsRect(points){const rect=pointsToRect(points);return testRectRect(this,rect);}/**
     * @param {Circle} c
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsCircle(c){return testCircleRect(c,this);}/**
     * @param {Polygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsPolygon(polygon){return testPolygonRect(polygon,this);}/**
     * @param {Geopolygon} geopolygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsGeoPolygon(geopolygon){return testGeoPolygonRect(geopolygon,this);}/**
     * Get the points
     * @returns {Point[]}
     */points(){return [{x:this.x,y:this.y},{x:this.x+this.width,y:this.y},{x:this.x+this.width,y:this.y+this.height},{x:this.x,y:this.y+this.height}];}}function create$k(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return new GeoRect(...args);}/**
   * Construct a new GeoCircle instance
   * @private
   */class GeoCircle{constructor(){let{cx=0,cy=0,r=0,minRadius=0}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.set({cx,cy,r,minRadius});}set(){let{cx=0,cy=0,r=0,minRadius=0}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.type='circle';this.cx=cx;this.cy=cy;this.r=Math.max(r,minRadius);this.vector={x:this.cx,y:this.cy};}/**
     * @param {Point} p
     * @returns {boolean} True if there is an intersection, false otherwise
     */containsPoint(p){return testCirclePoint(this,p);}/**
     * @param {Point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsLine(points){const line=pointsToLine(points);return testCircleLine(this,line);}/**
     * @param {Point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsRect(points){const rect=pointsToRect(points);return testCircleRect(this,rect);}/**
     * @param {Circle} c
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsCircle(c){return testCircleCircle(this,c);}/**
     * @param {Polygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsPolygon(polygon){return testCirclePolygon(this,polygon);}/**
     * @param {Geopolygon} geopolygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsGeoPolygon(geopolygon){return testCircleGeoPolygon(this,geopolygon);}/**
     * Get the points
     * @returns {Point[]}
     */points(){return [{x:this.cx,y:this.cy}];}}function create$j(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return new GeoCircle(...args);}/**
   * Construct a new GeoLine instance
   * @private
   */class GeoLine{constructor(){let{x1=0,y1=0,x2=0,y2=0,tolerance=0}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.set({x1,y1,x2,y2,tolerance});}set(){let{x1=0,y1=0,x2=0,y2=0,tolerance=0}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.type='line';this.x1=x1;this.y1=y1;this.x2=x2;this.y2=y2;this.tolerance=Math.max(0,Math.round(tolerance));this.vectors=this.points();this.zeroSize=x1===x2&&y1===y2;}/**
     * @param {Point} p
     * @returns {boolean} True if there is an intersection, false otherwise
     */containsPoint(p){if(this.tolerance>0){const c={cx:p.x,cy:p.y,r:this.tolerance};return testCircleLine(c,this);}return testLinePoint(this,p);}/**
     * @param {Point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsLine(points){const line=pointsToLine(points);return testLineLine(this,line);}/**
     * @param {Point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsRect(points){const rect=pointsToRect(points);return testRectLine(rect,this);}/**
     * @param {Circle} c
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsCircle(c){return testCircleLine(c,this);}/**
     * @param {Polygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsPolygon(polygon){return testPolygonLine(polygon,this);}/**
     * @param {Geopolygon} geopolygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsGeoPolygon(geopolygon){return testGeoPolygonLine(geopolygon,this);}/**
     * Get the points
     * @returns {Point[]}
     */points(){return [{x:this.x1,y:this.y1},{x:this.x2,y:this.y2}];}}function create$i(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return new GeoLine(...args);}function close$1(vertices){const first=vertices[0];const last=vertices[vertices.length-1];if(first.x!==last.x||first.y!==last.y){vertices.push(first);}}function removeDuplicates$1(vertices){for(let i=0;i<vertices.length-1;i++){const v0=vertices[i];const v1=vertices[i+1];if(v0.x===v1.x&&v0.y===v1.y){vertices.splice(i,1);i--;}}}/**
   * Construct a new Polygon instance
   * Added ignore flag as the name collide with definition in index.js
   * @private
   */class Polygon{constructor(){let{vertices=[]}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.set({vertices});}/**
     * Set the vertices.
     * If vertices doesn't close the polygon, a closing vertice is appended.
     * @ignore
     * @param {object} input An object with a vertices property
     * @param {Point[]} [input.vertices=[]] Vertices are represented as an array of points.
     */set(){let{vertices=[]}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.type='polygon';this.vertices=vertices.slice();this.edges=[];removeDuplicates$1(this.vertices);if(this.vertices.length<=2){return;}close$1(this.vertices);this.xMin=NaN;this.yMin=NaN;this.xMax=NaN;this.yMax=NaN;for(let i=0;i<this.vertices.length;i++){if(i<this.vertices.length-1){this.edges.push([this.vertices[i],this.vertices[i+1]]);}this.xMin=isNaN(this.xMin)?this.vertices[i].x:Math.min(this.xMin,this.vertices[i].x);this.xMax=isNaN(this.xMax)?this.vertices[i].x:Math.max(this.xMax,this.vertices[i].x);this.yMin=isNaN(this.yMin)?this.vertices[i].y:Math.min(this.yMin,this.vertices[i].y);this.yMax=isNaN(this.yMax)?this.vertices[i].y:Math.max(this.yMax,this.vertices[i].y);}this._bounds=null;this._boundingRect=null;}/**
     * Check if a point is inside the area of the polygon.
     * Supports convex, concave and self-intersecting polygons (filled area).
     * @ignore
     * @param {Point} point
     * @returns {boolean} True if there is an intersection, false otherwise
     */containsPoint(point){return testPolygonPoint(this,point);}/**
     * Check if circle is inside the area of the polygon.
     * Supports convex, concave and self-intersecting polygons (filled area).
     * @ignore
     * @param {Circle} circle
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsCircle(circle){return testCirclePolygon(circle,this);}/**
     * @ignore
     * @param {Point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsLine(points){return testPolygonLine(this,pointsToLine(points));}/**
     * @ignore
     * @param {Point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsRect(points){return testPolygonRect(this,pointsToRect(points));}/**
     * Check if polygon intersects another polygon.
     * Supports convex, concave and self-intersecting polygons (filled area).
     * @ignore
     * @param {Polygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsPolygon(polygon){return testPolygonPolygon(this,polygon);}/**
     * Check if polygon intersects a geopolygon.
     * @ignore
     * @param {Geopolygon} geopolygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsGeoPolygon(geopolygon){return testGeoPolygonPolygon(geopolygon,this);}/**
     * Get the points
     * @ignore
     * @returns {Point[]}
     */points(){return this.vertices;}/**
     * Get the bounds of the polygon, as an array of points
     * @ignore
     * @returns {Point[]}
     */bounds(){if(!this._bounds){this._bounds=[{x:this.xMin,y:this.yMin},{x:this.xMax,y:this.yMin},{x:this.xMax,y:this.yMax},{x:this.xMin,y:this.yMax}];}return this._bounds;}/**
     * Get the bounding rect of the polygon
     * @ignore
     * @returns {Rect}
     */boundingRect(){if(!this._boundingRect){this._boundingRect={x:this.xMin,y:this.yMin,width:this.xMax-this.xMin,height:this.yMax-this.yMin};}return this._boundingRect;}}function create$h(){for(var _len=arguments.length,a=new Array(_len),_key=0;_key<_len;_key++){a[_key]=arguments[_key];}return new Polygon(...a);}function close(vertices){const first=vertices[0];const last=vertices[vertices.length-1];if(first.x!==last.x||first.y!==last.y){vertices.push(first);}}function removeDuplicates(vertices){for(let i=0;i<vertices.length-1;i++){const v0=vertices[i];const v1=vertices[i+1];if(v0.x===v1.x&&v0.y===v1.y){vertices.splice(i,1);i--;}}}/**
   * A geo-polygon is a polygon which is similar to a polygon in GeoJson. A typical geopolygon is an array of polygons where the first polygon is an outer polygon and the rest are inner polygons
   * @private
   */class GeoPolygon{constructor(){let{vertices=[[]]}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.set({vertices});}/**
     * Set the vertices.
     * If vertices doesn't close the polygon, a closing vertice is appended.
     * @param {object} input An object with a vertices property
     * @param {Array} [input.vertices=[]] Vertices are represented as an array of arrays of points.
     */set(){let{vertices=[]}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.type='geopolygon';this.vertices=vertices.slice();this.numPolygons=this.vertices.length;this.polygons=[];this.xMin=NaN;this.yMin=NaN;this.xMax=NaN;this.yMax=NaN;for(let i=0;i<this.numPolygons;i++){removeDuplicates(this.vertices[i]);if(this.vertices[i].length>2){close(this.vertices[i]);}this.polygons[i]=create$h({vertices:this.vertices[i]});this.xMin=isNaN(this.xMin)?this.polygons[i].xMin:Math.min(this.xMin,this.polygons[i].xMin);this.xMax=isNaN(this.xMax)?this.polygons[i].xMax:Math.max(this.xMax,this.polygons[i].xMax);this.yMin=isNaN(this.yMin)?this.polygons[i].yMin:Math.min(this.yMin,this.polygons[i].yMin);this.yMax=isNaN(this.yMax)?this.polygons[i].yMax:Math.max(this.yMax,this.polygons[i].yMax);}this._bounds=null;this._boundingRect=null;}/**
     * Check if a point is inside the area of the geopolygon.
     * Supports convex, concave and self-intersecting polygons (filled area).
     * @param {Point} point
     * @returns {boolean} True if there is an intersection, false otherwise
     */containsPoint(point){return testGeoPolygonPoint(this,point);}/**
     * Check if circle is inside the area of the polygon.
     * Supports convex, concave and self-intersecting polygons (filled area).
     * @param {Circle} circle
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsCircle(circle){return testCircleGeoPolygon(circle,this);}/**
     * @param {Point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsLine(points){return testGeoPolygonLine(this,pointsToLine(points));}/**
     * @param {Point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsRect(points){return testGeoPolygonRect(this,pointsToRect(points));}/**
     * Check if geopolygon intersects another polygon.
     * Supports convex, concave and self-intersecting polygons (filled area).
     * @param {Polygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsPolygon(polygon){return testGeoPolygonPolygon(this,polygon);}/**
     * Check if geopolygon intersects another geopolygon.
     * Supports convex, concave and self-intersecting polygons (filled area).
     * @param {Geopolygon} geopolygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsGeoPolygon(geopolygon){return testGeoPolygonGeoPolygon(this,geopolygon);}/**
     * Get the points
     * @returns {Point[]}
     */points(){return this.vertices;}/**
     * Get the bounds of the polygon, as an array of points
     * @ignore
     * @returns {Point[]}
     */bounds(){if(!this._bounds){this._bounds=[{x:this.xMin,y:this.yMin},{x:this.xMax,y:this.yMin},{x:this.xMax,y:this.yMax},{x:this.xMin,y:this.yMax}];}return this._bounds;}/**
     * Get the bounding rect of the polygon
     * @ignore
     * @returns {Rect}
     */boundingRect(){if(!this._boundingRect){this._boundingRect={x:this.xMin,y:this.yMin,width:this.xMax-this.xMin,height:this.yMax-this.yMin};}return this._boundingRect;}}function create$g(){for(var _len=arguments.length,a=new Array(_len),_key=0;_key<_len;_key++){a[_key]=arguments[_key];}return new GeoPolygon(...a);}function pointsAreNotEqual(p0,p1){return p0.x!==p1.x||p0.y!==p1.y;}/**
   * Construct a new GeoPolyline instance
   * @private
   */class GeoPolyline{constructor(){let{points=[]}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.set({points});}set(){let{points=[]}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.type='polyline';this.segments=[];this._points=points.slice();if(this._points.length>1){for(let i=0,len=this._points.length-1;i<len;i++){if(pointsAreNotEqual(this._points[i],this._points[i+1])){this.segments.push({x1:this._points[i].x,y1:this._points[i].y,x2:this._points[i+1].x,y2:this._points[i+1].y});}}}}/**
     * @param {Point} point
     * @returns {boolean} True if there is an intersection, false otherwise
     */containsPoint(point){return this.segments.some(line=>testLinePoint(line,point));}/**
     * @param {Circle} circle
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsCircle(circle){return this.segments.some(line=>testCircleLine(circle,line));}/**
     * @param {Point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsLine(points){const testLine=pointsToLine(points);return this.segments.some(line=>testLineLine(line,testLine));}/**
     * @param {Point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsRect(points){const rect=pointsToRect(points);return this.segments.some(line=>testRectLine(rect,line));}/**
     * @param {Polygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsPolygon(polygon){// This is a unoptimized solution and should be replaced by a more efficient algorithm.
  return this.segments.some(line=>testPolygonLine(polygon,line));}/**
     * @param {Geopolygon} geopolygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsGeoPolygon(geopolygon){// This is a unoptimized solution and should be replaced by a more efficient algorithm.
  return this.segments.some(line=>testGeoPolygonLine(geopolygon,line));}/**
     * Get the points
     * @returns {Point[]}
     */points(){return this._points;}}function create$f(){for(var _len=arguments.length,a=new Array(_len),_key=0;_key<_len;_key++){a[_key]=arguments[_key];}return new GeoPolyline(...a);}const reg$2=registryFactory();reg$2.add('rect',create$k);reg$2.add('circle',create$j);reg$2.add('line',create$i);reg$2.add('polygon',create$h);reg$2.add('geopolygon',create$g);reg$2.add('polyline',create$f);/* eslint-disable import/prefer-default-export */function create$e(type,input){return reg$2.get(type)(input);}/* eslint-enable import/prefer-default-export */ /**
   * @typedef {object} Rect
   * @property {number} x - X-coordinate
   * @property {number} y - Y-coordinate
   * @property {number} width - Width
   * @property {number} height - Height
   */ /**
   * @typedef {object} Line
   * @property {number} x1 - Start x-coordinate
   * @property {number} y1 - Start y-coordinate
   * @property {number} x2 - End x-coordinate
   * @property {number} y2 - End y-coordinate
   */ /**
   * @typedef {object} Point
   * @property {number} x - X-coordinate
   * @property {number} y - Y-coordinate
   */ /**
   * @typedef {object} Circle
   * @property {number} cx - Center x-coordinate
   * @property {number} cy - Center y-coordinate
   * @property {number} r - Circle radius
   */ /**
   * @typedef {object} Polygon
   * @property {Array<Point>} points - Array of connected points
   */ /**
   * @typedef {object} Geopolygon
   * @property {Array<Polygon>} polygons - Array of polygons
   */ /**
   * @typedef {object} Polyline
   * @property {Array<Point>} points - Array of connected points
   */ /**
   * @typedef {object} Path
   * @property {string} d - Path definition
   */ /**
   * Construct a new GeometryCollection instance
   * @private
   */class GeometryCollection{constructor(){let collection=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];this.set(collection);}set(){let collection=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];this.geometries=[];collection.forEach(geo=>{const geoInstance=create$e(geo.type,geo);if(geoInstance){this.geometries.push(geoInstance);}});}/**
     * @param {Point} p
     * @returns {boolean} True if there is an intersection, false otherwise
     */containsPoint(p){return this.geometries.some(geo=>geo.containsPoint(p));}/**
     * @param {Point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsLine(points){return this.geometries.some(geo=>geo.intersectsLine(points));}/**
     * @param {Point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsRect(points){return this.geometries.some(geo=>geo.intersectsRect(points));}/**
     * @param {Circle} c
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsCircle(c){return this.geometries.some(geo=>geo.intersectsCircle(c));}/**
     * @param {Polygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsPolygon(polygon){return this.geometries.some(geo=>geo.intersectsPolygon(polygon));}/**
     * @param {Geopolygon} geopolygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */intersectsGeoPolygon(geopolygon){return this.geometries.some(geo=>geo.intersectsGeoPolygon(geopolygon));}}function create$d(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return new GeometryCollection(...args);}class Matrix{/**
     * Creates a matrix with identity values.
     * @private
     */constructor(){this._elements=[[1,0,0],[0,1,0],[0,0,1]];this._stack=[];}/**
     * Creates a new matrix with a copy of the current values.
     */clone(){const mt=new Matrix();return mt.multiply(this);}/**
     * Sets the matrix values
     * @param {Number[][]} arr A 3x3 array.
     */set(arr){this._elements=arr;return this;}/**
     * Saves the current matrix values to a stack.
     */save(){this._stack.push(this.elements);return this;}/**
     * Sets the current matrix values to the last ones saved on to the stack.
     */restore(){if(this._stack.length){this._elements=this._stack.pop();// TODO - use a copy instead
  }return this;}/**
     * Adds a scalar value to each element in the matrix.
     * @param {Number} value
     */add(value){// assume scalar
  let i,j;for(i=0;i<this._elements.length;i++){for(j=0;j<this._elements[i].length;j++){this._elements[i][j]+=value;}}return this;}/**
     * Translates the current matrix along the x and y axis.
     * @param {Number} x
     * @param {Number} y
     */translate(x,y){this.multiply([[1,0,x],[0,1,y],[0,0,1]]);return this;}/**
     * Rotates the current matrix.
     * @param {Number} radianAngle Angle in radians.
     */rotate(radianAngle){let cos=Math.cos(-radianAngle),sin=Math.sin(-radianAngle);this.multiply([[cos,sin,0],[-sin,cos,0],[0,0,1]]);return this;}/**
     *
     * If value is a number; multiplies each element in the matrix by the given value.
     * If value is a matrix; multiplies the two matrices.
     * @param {Number|Array|Matrix} value
     */multiply(value){let i,j,m,k;if(value instanceof Matrix){value=value._elements;}if(Array.isArray(value)){// matrix multiplication
  m=[[0,0,0],[0,0,0],[0,0,0]];for(i=0;i<this._elements.length;i++){// row
  for(j=0;j<this._elements[i].length;j++){// column
  for(k=0;k<3;k++){// row
  m[i][j]+=this._elements[i][k]*value[k][j];}}}this._elements=m;}else {// scalar multiplication
  for(i=0;i<this._elements.length;i++){for(j=0;j<this._elements[i].length;j++){this._elements[i][j]*=value;}}}return this;}/**
     * Scales the matrix along x and y axis.
     * @param {Number} x The value to scale the matrix with along the x direction
     * @param {Number} [y=x] The value to scale the matrix with along the y direction.
     */scale(x){let y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:x;// if ( arguments.length < 2 || typeof y === "undefined" ) {
  //  y = x;
  // }
  this.multiply([[x,0,0],[0,y,0],[0,0,1]]);return this;}/**
     * Multiples the matrix with the supplied transformation values
     * @param {Number} a Horizontal scaling
     * @param {Number} b Horizontal skewing
     * @param {Number} c Vertical skewing
     * @param {Number} d Vertical scaling
     * @param {Number} e Horizontal moving
     * @param {Number} f Vertical scaling
     */transform(a,b,c,d,e,f){this.multiply([[a,c,e],[b,d,f],[0,0,1]]);return this;}/**
     * Gets the value of the determinant.
     * @return {Number}
     */determinant(){let a=this._elements[0][0],b=this._elements[0][1],c=this._elements[0][2],d=this._elements[1][0],e=this._elements[1][1],f=this._elements[1][2],g=this._elements[2][0],h=this._elements[2][1],i=this._elements[2][2],p=0;p=a*e*i+b*f*g+c*d*h-c*e*g-b*d*i-a*f*h;return p;}/**
     * Inverts the matrix.
     */invert(){let dt=this.determinant(),a=this._elements[0][0],b=this._elements[0][1],c=this._elements[0][2],d=this._elements[1][0],e=this._elements[1][1],f=this._elements[1][2],g=this._elements[2][0],h=this._elements[2][1],k=this._elements[2][2];this._elements=[[e*k-f*h,c*h-b*k,b*f-c*e],[f*g-d*k,a*k-c*g,c*d-a*f],[d*h-e*g,g*b-a*h,a*e-b*d]];this.multiply(1/dt);// TODO - handle when dt === 0 ?
  return this;}/**
     * Transposes the elements of the matrix.
     */transpose(){const m=Object.create(this._elements);// ?
  this._elements=[[m[0][0],m[1][0],m[2][0]],[m[0][1],m[1][1],m[2][1]],[m[0][2],m[1][2],m[2][2]]];return this;}/**
     * Resets the inner elements of the matrix to identity values.
     */identity(){this._elements=[[1,0,0],[0,1,0],[0,0,1]];return this;}toString(){return "".concat(this._elements.map(r=>r.join('\t')).join('\n'));}isIdentity(){const m=this._elements;return m[0][0]===1&&m[0][1]===0&&m[0][2]===0&&m[1][0]===0&&m[1][1]===1&&m[1][2]===0&&m[2][0]===0&&m[2][1]===0&&m[2][2]===1;}/**
     * Transforms the given point by this matrix and returns a new point
     */transformPoint(p){let vec=[p.x,p.y,1],i,j,e=this._elements,m=[0,0,0];for(i=0;i<this._elements.length;i++){// row
  for(j=0;j<this._elements[i].length;j++){// column
  m[i]+=vec[j]*e[i][j];}}return {x:m[0],y:m[1]};}/**
     * Transforms the given points by this matrix and returns the new points
     */transformPoints(array){let vec,i,j,k,m,e=this._elements,ret=[];for(k=0;k<array.length;k++){vec=[array[k].x,array[k].y,1];m=[0,0,0];for(i=0;i<this._elements.length;i++){// row
  for(j=0;j<this._elements[i].length;j++){// column
  m[i]+=vec[j]*e[i][j];}}ret.push({x:m[0],y:m[1]});}return ret;}get elements(){const m=this._elements;return [[m[0][0],m[0][1],m[0][2]],[m[1][0],m[1][1],m[1][2]],[m[2][0],m[2][1],m[2][2]]];}}const transformRegEx=/(translate|scale|rotate|matrix)\(([0-9,.eE+-\s]+)(?:,|\s?)+\)/g;function parseTransform(transform){let m,commands=[];/* eslint-disable no-cond-assign */while((m=transformRegEx.exec(transform))!==null){const argsStr=m[2].trim();const args=argsStr.indexOf(',')===-1?argsStr.split(' '):argsStr.split(',');commands.push({cmd:m[1],args:args.filter(a=>a.trim().length>0).map(a=>Number(a))});}/* eslint-enable no-cond-assign */return commands;}function resolveRotateCmd(matrix,transform){const radians=transform.args[0]*(Math.PI/180);if(transform.args.length>2){const x=transform.args[1];const y=transform.args[2];matrix.translate(x,y);matrix.rotate(radians);matrix.translate(-x,-y);}else if(transform.args.length===1){matrix.rotate(radians);}}function resolveScaleCmd(matrix,transform){const x=transform.args[0];const y=isNaN(transform.args[1])?transform.args[0]:transform.args[1];matrix.scale(x,y);}function resolveTranslateCmd(matrix,transform){const x=transform.args[0];const y=isNaN(transform.args[1])?0:transform.args[1];matrix.translate(x,y);}function resolveMatrixCmd(matrix,transform){if(transform.args.length>=6){matrix.transform(...transform.args);}}function resolveTransform(t,matrix){const transforms=parseTransform(t);let transform;for(let i=0,len=transforms.length;i<len;i++){transform=transforms[i];if(transform.cmd==='rotate'){resolveRotateCmd(matrix,transform);}else if(transform.cmd==='scale'){resolveScaleCmd(matrix,transform);}else if(transform.cmd==='matrix'){resolveMatrixCmd(matrix,transform);}else if(transform.cmd==='translate'){resolveTranslateCmd(matrix,transform);}}}/* eslint-disable no-useless-escape */const SELECTOR_MAPS={type:/^\w[\w-]+/,attr:/^\[\w(?:[\w\._-]+)?(?:[!]?=['\"][\w\s*#_-]*['\"])?\]/,universal:/^(\*)/,tag:/^\.(\w+)/};const FILTERS={type:(c,objects)=>// eslint-disable-line arrow-body-style
  objects.filter(o=>{const type=o.type;if(type){return type.toLowerCase()===c.toLowerCase();}return false;}),attr:(attr,operator,value,objects)=>// eslint-disable-line arrow-body-style
  objects.filter(o=>{const v=o.attrs[attr];if(!operator){// TODO handle undefined differently for != operator? As display object may very well have a default rendering color
  return typeof v!=='undefined';}if(typeof v==='undefined'){return false;}switch(operator){case'=':return value===String(v);case'!=':return value!==String(v);default:return false;}}),universal:objects=>objects,tag:(selector,objects)=>// eslint-disable-line arrow-body-style
  objects.filter(o=>{const tag=o.tag;if(tag){return tag.trim().split(/\s+/).indexOf(selector.replace('.',''))!==-1;}return false;})};/**
   * Filters out objects of given type and value
   * @ignore
   * @example
   * filter(
   *   {type:'type', value:'Circle'},
   *   [new Circle(), new Rectangle()]
   * )
   * // [Circle]
   * @param {Object} token
   * @param {Array} objects
   * @returns {Object[]} Objects that fulfill the type and value
   */function filter(token,objects){if(!objects||!objects.length||!token||typeof FILTERS[token.type]!=='function'){return [];}switch(token.type){case'type':return FILTERS[token.type](token.value,objects);case'attr':return FILTERS[token.type](token.attribute,token.operator,token.attributeValue,objects);case'universal':return FILTERS[token.type](objects);case'tag':return FILTERS[token.type](token.value,objects);default:return [];}}/**
   * Tokenizes a string into supported selectors
   * @ignore
   *
   * @example
   * tokenize("Circle[color='red']")
   *
   * @param {String} s
   */function tokenize(s){const groups=[];let sub;let info;let match;let validSelector;s.split(/\s*,\s*/).forEach(group=>{group=group.trim();sub=[];const selectorMapsIterator=key=>{match=group.match(SELECTOR_MAPS[key]);if(match){validSelector=true;group=group.slice(match[0].length);info={type:key,value:match[0]};if(key==='attr'){// extract parts of attribute from e.g. [color='red'] => (color, =, red)
  match=match[0].match(/\[(\w[\w\._-]+)?(?:([!]?=)['\"]([\w\s#_-]*)['\"])?\]/);info.attribute=match[1];info.operator=match[2];info.attributeValue=match[3];}sub.push(info);}};while(group){validSelector=false;match=group.match(/^\s*([>+~]|\s)\s*/);if(match){validSelector=true;sub.push({type:' ',value:match[0]});group=group.slice(match[0].length);}Object.keys(SELECTOR_MAPS).forEach(selectorMapsIterator);if(sub&&sub.length&&groups.indexOf(sub)<0){groups.push(sub);}if(!validSelector){break;}}});return groups;}function find(s,object){const result=[];const groupResults=[];let groups;let descendants;if(object.isBranch){groups=tokenize(s);descendants=object.descendants;let tokens;for(let gi=0,glen=groups.length;gi<glen;gi++){tokens=groups[gi];const levels=[];let filtered=descendants.slice();let hasRemainder=false;tokens.reverse().forEach(token=>{if(token.type===' '){levels.push(filtered);filtered=descendants.slice();hasRemainder=false;return;}filtered=filter(token,filtered);hasRemainder=true;});if(hasRemainder){levels.push(filtered);}const selected=levels[0].filter(node=>{let ancestor=node.parent;let idx;for(let i=1;i<levels.length;i++){idx=levels[i].indexOf(ancestor);while(ancestor&&idx<0){ancestor=ancestor.parent;idx=levels[i].indexOf(ancestor);}if(idx<0){return false;}}return true;});groupResults.push(selected);}for(let i=0,len=groupResults.length;i<len;i++){for(let ni=0,nlen=groupResults[i].length;ni<nlen;ni++){if(result.indexOf(groupResults[i][ni])<0){result.push(groupResults[i][ni]);}}}}return result||[];}var nodeSelector={find};function appendDpi(points,dpi){for(let i=0,len=points.length;i<len;i++){points[i].x/=dpi;points[i].y/=dpi;}}function geometryToDef(geometry,dpi,mvm){const type=geometry.type;let points=geometry.points();if(mvm){if(points.every(item=>Array.isArray(item))){points=points.map(item=>mvm.transformPoints(item));}else {points=mvm.transformPoints(points);}}appendDpi(points,dpi);let def=null;if(type==='rect'||type==='bounds'){def=pointsToRect(points);def.type=type;}else if(type==='circle'){def=pointsToCircle(points,geometry.r);def.type=type;}else if(type==='line'){def=pointsToLine(points);def.type=type;}else if(type==='polygon'||type==='polyline'){const path=pointsToPath(points,type==='polygon');def={type:'path',d:path};}else if(type==='geopolygon'){let path='';for(let i=0;i<points.length;i++){path+=pointsToPath(points[i],true);}def={type:'path',d:path};}return def;}/**
   * @ignore
   * @returns {object} Returns a node definition of the collider
   */function colliderToShape(node,dpi){if(node.collider){const mvm=node.modelViewMatrix;const isCollection=node.colliderType==='collection';if(isCollection){const children=node.collider.geometries.map(geometry=>geometryToDef(geometry,dpi,mvm));return {type:'container',children};}return geometryToDef(node.collider,dpi,mvm);}return null;}/**
   * Read-only object representing a node on the scene.
   */class SceneNode{constructor(node){this._bounds=function(){let includeTransform=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;const{x,y,width,height}=node.boundingRect?node.boundingRect(includeTransform):{x:0,y:0,width:0,height:0};return {x,y,width,height};};this._attrs=node.attrs;this._type=node.type;this._data=node.data;this._dpi=node.stage?node.stage.dpi:1;this._collider=()=>colliderToShape(node,this._dpi);this._desc=node.desc;this._tag=node.tag;this._children=()=>node.children.map(n=>new SceneNode(n));this._parent=()=>node.parent?new SceneNode(node.parent):null;this._cache={elementBoundingRect:null};this._getElementBoundingRect=()=>{if(!this._cache.elementBoundingRect&&this.element){this._cache.elementBoundingRect=this.element.getBoundingClientRect();}return this._cache.elementBoundingRect||{left:0,top:0};};}/**
     * Get child nodes
     * @type {SceneNode[]}
     */get children(){return this._children();}/**
     * Get parent node
     * @type {SceneNode}
     */get parent(){return this._parent();}/**
     * Node type
     * @type {string}
     */get type(){return this._type;}/**
     * Get the associated data
     * @type {any}
     */get data(){return this._data;}/**
     * Node attributes
     * @type {object}
     */get attrs(){return this._attrs;}/**
     * Element the scene is attached to
     * @type {HTMLElement}
     * @private
     */set element(e){this._cache.elementBoundingRect=null;this._element=e;}/**
     * Element the scene is attached to
     * @type {HTMLElement}
     */get element(){return this._element;}/**
     * Key of the component this shape belongs to
     * @type {string}
     * @private
     */set key(k){this._key=k;}/**
     * Key of the component this shape belongs to
     * @type {string}
     */get key(){return this._key;}/**
     * Bounding rectangle of the node. After any transform has been applied, if any, but excluding scaling transform related to devicePixelRatio.
     * Origin is in the top-left corner of the scene element.
     * @type {Rect}
     */get bounds(){const bounds=this._bounds();bounds.x/=this._dpi;bounds.y/=this._dpi;bounds.width/=this._dpi;bounds.height/=this._dpi;return bounds;}/**
     * Bounding rectangle of the node within its local coordinate system.
     * Origin is in the top-left corner of the scene element.
     * @type {Rect}
     */get localBounds(){const bounds=this._bounds(false);return bounds;}/**
     * Bounding rectangle of the node, relative a target.
     *
     * If target is an HTMLElement, the bounds are relative to the HTMLElement.
     * Any other target type will return the bounds relative to the viewport of the browser.
     *
     * @param {HTMLElement|any} target
     * @param {boolean} includeTransform - Whether to include any applied transforms on the node
     * @returns {Rect}
     * @example
     *
     * node.boundsRelativeTo($('div'));
     * node.boundsRelativeTo('viewport');
     */boundsRelativeTo(target){let includeTransform=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;const type=typeof target;const bounds=includeTransform?this.bounds:this.localBounds;const selfRect=this._getElementBoundingRect();let dx=selfRect.left;let dy=selfRect.top;if(type==='object'&&target!==null&&typeof target.getBoundingClientRect==='function'){const{left=0,top=0}=target.getBoundingClientRect();dx-=left;dy-=top;}bounds.x+=dx;bounds.y+=dy;return bounds;}/**
     * Collider of the node. Transform on the node has been applied to the collider shape, if any, but excluding scaling transform related to devicePixelRatio.
     * Origin is in the top-left corner of the scene element.
     *
     * If node has no collider, null is returned.
     * @type {Line|Rect|Circle|Path}
     */get collider(){return this._collider();}/**
     * Node description
     * @type {object}
     */get desc(){return this._desc;}/**
     * Node tag
     * @type {string}
     */get tag(){return this._tag;}}function create$c(){for(var _len=arguments.length,a=new Array(_len),_key=0;_key<_len;_key++){a[_key]=arguments[_key];}return new SceneNode(...a);}class Collision{constructor(node){this._node=create$c(node);this._parent=null;this._input=null;}get node(){return this._node;}set parent(p){this._parent=p;}get parent(){return this._parent;}set input(i){this._input=i;}get input(){return this._input;}}function create$b(){for(var _len=arguments.length,a=new Array(_len),_key=0;_key<_len;_key++){a[_key]=arguments[_key];}return new Collision(...a);}function appendParentNode(node,collision){const p=node.parent;if(p&&p.type!=='stage'){collision.parent=create$b(p);const pp=p.parent;if(pp&&pp.type!=='stage'){appendParentNode(pp,collision.parent);}}}function appendInputShape(shape,collisions){for(let i=0,len=collisions.length;i<len;i++){collisions[i].input=shape;}}function resolveFrontChildCollision(node,type,input){const num=node.descendants.length;for(let i=num-1;i>=0;i--){const desc=node.descendants[i];if(desc.collider===null){continue;}if(desc.collider[type](input)){const collision=create$b(desc);appendParentNode(desc,collision);return collision;}}return null;}function resolveGeometryCollision(node,type,input){if(node.collider[type](input)){const c=create$b(node);appendParentNode(node,c);return c;}return null;}function inverseTransform(node,input){let transformedInput={};if(node.modelViewMatrix){if(Array.isArray(input)){// Rect or Line
  transformedInput=node.inverseModelViewMatrix.transformPoints(input);}else if(!isNaN(input.r)){// Circle
  const p={x:input.cx,y:input.cy};({x:transformedInput.cx,y:transformedInput.cy}=node.inverseModelViewMatrix.transformPoint(p));transformedInput.r=input.r;}else if(Array.isArray(input.vertices)){// Polygon
  transformedInput.vertices=node.inverseModelViewMatrix.transformPoints(input.vertices);}else {// Point
  transformedInput=node.inverseModelViewMatrix.transformPoint(input);}}else {transformedInput=input;}if(Array.isArray(transformedInput.vertices)){if(transformedInput.vertices.every(item=>Array.isArray(item))){transformedInput=create$g(transformedInput);}else {transformedInput=create$h(transformedInput);// TODO Shouldn't have to do this here, currently its beacause a collision algorithm optimization, i.e. caching of polygon bounds
  }}return transformedInput;}function resolveCollision(node,intersectionType,input){if(node.colliderType===null){return null;}const transformedInput=inverseTransform(node,input);if(node.colliderType==='frontChild'){return resolveFrontChildCollision(node,intersectionType,transformedInput);}return resolveGeometryCollision(node,intersectionType,transformedInput);}function findAllCollisions(nodes,intersectionType,ary,input){const num=nodes.length;for(let i=0;i<num;i++){const node=nodes[i];const collision=resolveCollision(node,intersectionType,input);if(collision){ary.push(collision);}// Only traverse children if no match is found on parent and it doesnt have any custom collider
  if(node.children&&!collision&&!node.collider){findAllCollisions(node.children,intersectionType,ary,input);}}}function hasCollision(nodes,intersectionType,input){const num=nodes.length;for(let i=0;i<num;i++){const node=nodes[i];const collision=resolveCollision(node,intersectionType,input);if(collision!==null){return true;}if(node.children&&!node.collider){return hasCollision(node.children,intersectionType,input);}}return false;}function resolveShape(shape){let ratio=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;const type=getShapeType(shape);let _shape={};switch(type){case'circle':_shape.cx=shape.cx*ratio;_shape.cy=shape.cy*ratio;_shape.r=shape.r;return ['intersectsCircle',_shape];case'rect':_shape=rectToPoints(shape).map(p=>scalarMultiply(p,ratio));return ['intersectsRect',_shape];case'line':_shape=lineToPoints(shape).map(p=>scalarMultiply(p,ratio));return ['intersectsLine',_shape];case'point':_shape=scalarMultiply(shape,ratio);return ['containsPoint',_shape];case'polygon':_shape.vertices=shape.vertices.map(vertex=>scalarMultiply(vertex,ratio));return ['intersectsPolygon',_shape];case'geopolygon':_shape.vertices=shape.vertices.map(vertices=>vertices.map(vertex=>scalarMultiply(vertex,ratio)));return ['intersectsGeoPolygon',_shape];default:return [];}}function resolveCollionsOnNode(node,shape){const[intersectionType,_shape]=resolveShape(shape,node.dpi);const collisions=[];if(intersectionType){findAllCollisions([node],intersectionType,collisions,_shape);appendInputShape(shape,collisions);}return collisions;}function hasCollisionOnNode(node,shape){const[intersectionType,_shape]=resolveShape(shape,node.dpi);return hasCollision([node],intersectionType,_shape);}/**
   * @private
   * @typedef {object} DisplayObject
   * @property {string} type
   * @property {string|GradientNode|PatternNode} [fill] - {@link https://www.w3.org/TR/fill-stroke-3/#fill-shorthand}
   * @property {string|GradientNode|PatternNode} [stroke] - {@link https://www.w3.org/TR/fill-stroke-3/#propdef-stroke}
   * @property {number} [strokeWidth] - {@link https://www.w3.org/TR/fill-stroke-3/#propdef-stroke-width}
   * @property {string|number[]} [strokeDasharray] - {@link https://www.w3.org/TR/fill-stroke-3/#propdef-stroke-dasharray}
   * @property {number} [opacity] - {@link https://www.w3.org/TR/css-color-4/#propdef-opacity}
   * @property {string} [transform] - {@link https://www.w3.org/TR/SVG/coords.html#TransformAttribute}
   * @property {object} [data] - Data object, may contain any properties
   * @property {object} [desc] - Meta-data object, may contain any properties
   * @property {string} [tag] - White-space seperated list of tags
   * @property {string} [id] - Unique identifier of the node
   * @property {object} [collider]
   */class DisplayObject extends Node$1{constructor(type){super(type);this._stage=null;this._collider={type:null,definition:null,fn:null};this._attrs={};this._node=null;}set(){let v=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.node=v;const{data,desc,tag,strokeReference,fillReference}=v;assignMappedAttribute(this.attrs,v);if(typeof data!=='undefined'){this.data=data;}if(typeof desc==='object'){this.desc=extend$1(true,{},desc);}if(typeof tag==='string'){this.tag=tag;}if(typeof strokeReference==='string'){this.strokeReference=strokeReference;}if(typeof fillReference==='string'){this.fillReference=fillReference;}}findShapes(selector){return nodeSelector.find(selector,this).map(node=>create$c(node));}getItemsFrom(shape){return resolveCollionsOnNode(this,shape);}containsPoint(p){return hasCollisionOnNode(this,p);}intersectsLine(line){return hasCollisionOnNode(this,line);}intersectsRect(rect){return hasCollisionOnNode(this,rect);}intersectsCircle(circle){return hasCollisionOnNode(this,circle);}intersectsPolygon(polygon){return hasCollisionOnNode(this,polygon);}intersectsGeoPolygon(geopolygon){return hasCollisionOnNode(this,geopolygon);}resolveLocalTransform(){let m=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Matrix();if(typeof this.attrs.transform!=='undefined'){resolveTransform(this.attrs.transform,m);}this.modelViewMatrix=m.clone();}resolveGlobalTransform(){let m=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Matrix();const a=this.ancestors;if(a.length>0){for(let i=a.length-1;i>=0;i--){a[i].resolveLocalTransform(m);m=a[i].modelViewMatrix;}}this.resolveLocalTransform(m);}/**
     * Returns the value of attribute a.
     * @private
     * @param a
     * @returns {*} The value of attribute a.
     */attr(a){return this.attrs[a];}equals(d){const attrs=this.attrs;const attrKeys=Object.keys(attrs);const dAttrs=d.attrs;const dAttrKeys=Object.keys(dAttrs);if(attrKeys.length!==dAttrKeys.length){return false;}for(let i=0;i<attrKeys.length;i++){const key=attrKeys[i];if(!Object.hasOwnProperty.call(dAttrs,key)){return false;}if(attrs[key]!==dAttrs[key]){return false;}}return super.equals(d);}toJSON(){const json=super.toJSON();json.attrs=this.attrs;return json;}get attrs(){return this._attrs;}get stage(){if(this._parent&&!this._stage){// lazy evaluation
  this._stage=this._parent.stage;}else if(!this._parent&&this._stage!==this){this._stage=null;}return this._stage;}set modelViewMatrix(m){this._mvm=m;this._imvm=null;}get modelViewMatrix(){return this._mvm;}get inverseModelViewMatrix(){this._imvm=this._imvm?this._imvm:this._mvm.clone().invert();return this._imvm;}set node(n){this._node=n;}get node(){return this._node;}set collider(definition){const type=Array.isArray(definition)?'collection':definition&&definition.type;if(typeof type!=='string'){// Non string type definition resets the collider
  this._collider.type=null;this._collider.definition=null;this._collider.fn=null;return;}// Check if a collider of the same type is already defined, if so, do an update
  if(this._collider!==null&&this._collider.type===type&&this._collider.fn!==null){this._collider.fn.set(definition);this._collider.definition=definition;return;}// Store the definition so that it can be lazy evaluated
  this._collider.type=type;this._collider.definition=definition;}get collider(){// Resolve geometry function from cache
  if(this._collider.fn!==null){return this._collider.fn;}// Resolve geometry function and store it in cache
  switch(this._collider.type){case'collection':this._collider.fn=create$d(this._collider.definition);break;case'frontChild':// TODO Deprecate
  // Front child is not resolved by a function on this node, but instead on one of its child nodes
  return true;case'bounds':this._collider.fn=create$e('rect',this.boundingRect());break;case'line':case'rect':case'circle':case'polygon':case'geopolygon':case'polyline':this._collider.fn=create$e(this._collider.type,this._collider.definition);break;default:return null;}return this._collider.fn;}get colliderType(){return this._collider.type;}}class NodeContainer extends Node$1{addChild(c){if(!c||!(c instanceof Node$1)){throw new TypeError("Expecting a Node as argument, but got ".concat(c));}if(c===this){throw new Error('Can not add itself as child!');}if(c._children&&c._children.length&&this.ancestors.indexOf(c)>=0){throw new Error('Can not add an ancestor as child!');}if(c._parent&&c._parent!==this){c._parent.removeChild(c);}this._children.push(c);c._parent=this;c._ancestors=null;return this;}addChildren(children){let i,num=children?children.length:0;for(i=0;i<num;i++){this.addChild(children[i]);}return this;}/**
     * Removes given child node from this node.
     * @private
     * @param {Node} c
     * @returns {Node} This object, for chaining purposes.
     */removeChild(c){const indx=this._children.indexOf(c);if(indx>=0){this._children.splice(indx,1);c._parent=null;c._ancestors=null;}return this;}removeChildren(children){let i,num;if(!this._children){return this;}if(children){num=children.length;for(i=0;i<num;i++){this.removeChild(children[i]);}}else {while(this._children.length){this.removeChild(this._children[0]);}}return this;}}/**
   * @private
   * @extends DisplayObject
   * @typedef {object} ContainerNode
   * @property {DisplayObject[]} children - Array of child nodes
   */const NC$2=NodeContainer.prototype;class Container extends DisplayObject{constructor(){let s=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{type='container'}=s;super(type);this.set(s);}set(){let v=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};super.set(v);const{collider}=v;const opts=extend$1({type:null},collider);this.collider=opts;this.__boundingRect={true:null,false:null};this.__bounds={true:null,false:null};}appendChildRect(child,includeTransform){if(typeof child.bounds!=='undefined'){const rect=this.__boundingRect[includeTransform]||{};const[p0,,p2]=child.bounds(includeTransform);const{x:xMin,y:yMin}=p0;const{x:xMax,y:yMax}=p2;const _xMax=isNaN(rect.width)?xMax:Math.max(xMax,rect.width+rect.x);const _yMax=isNaN(rect.height)?yMax:Math.max(yMax,rect.height+rect.y);rect.x=isNaN(rect.x)?xMin:Math.min(xMin,rect.x);rect.y=isNaN(rect.y)?yMin:Math.min(yMin,rect.y);rect.width=_xMax-rect.x;rect.height=_yMax-rect.y;this.__boundingRect[includeTransform]=rect;}}boundingRect(){let includeTransform=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(this.__boundingRect[includeTransform]!==null){return this.__boundingRect[includeTransform];}const num=this.children.length;for(let i=0;i<num;i++){this.appendChildRect(this.children[i],includeTransform);}this.__boundingRect[includeTransform]=extend$1({x:0,y:0,width:0,height:0},this.__boundingRect[includeTransform]);return this.__boundingRect[includeTransform];}bounds(){let includeTransform=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(this.__bounds[includeTransform]!==null){return this.__bounds[includeTransform];}const rect=this.boundingRect(includeTransform);this.__bounds[includeTransform]=[{x:rect.x,y:rect.y},{x:rect.x+rect.width,y:rect.y},{x:rect.x+rect.width,y:rect.y+rect.height},{x:rect.x,y:rect.y+rect.height}];return this.__bounds[includeTransform];}addChild(c){const r=NC$2.addChild.call(this,c);if(this._collider&&this._collider.type==='bounds'){this.appendChildRect(c,true);const opts=extend$1({type:'bounds',x:0,y:0,width:0,height:0},this.__boundingRect.true);this.collider=opts;}return r;}addChildren(children){const r=NC$2.addChildren.call(this,children);const num=children.length;if(this._collider&&this._collider.type==='bounds'&&num>0){for(let i=0;i<num;i++){this.appendChildRect(children[i],true);}const opts=extend$1({type:'bounds',x:0,y:0,width:0,height:0},this.__boundingRect.true);this.collider=opts;}return r;}removeChild(c){c._stage=null;let desc=c.descendants,num=desc?desc.length:0,i;// remove reference to stage from all descendants
  for(i=0;i<num;i++){desc[i]._stage=null;}NC$2.removeChild.call(this,c);if(this._collider&&this._collider.type==='bounds'){this.__boundingRect={true:null,false:null};this.__bounds={true:null,false:null};const opts=extend$1(this.boundingRect(true),{type:'bounds'});this.collider=opts;}return this;}removeChildren(children){NC$2.removeChildren.call(this,children);if(this._collider&&this._collider.type==='bounds'){this.__boundingRect={true:null,false:null};this.__bounds={true:null,false:null};const opts=extend$1(this.boundingRect(true),{type:'bounds'});this.collider=opts;}return this;}}function create$a(){for(var _len=arguments.length,s=new Array(_len),_key=0;_key<_len;_key++){s[_key]=arguments[_key];}return new Container(...s);}class Stage extends Container{constructor(dpi){super('stage');this._stage=this;this._dpiRatio=dpi||1;}get dpi(){return this._dpiRatio;}}function create$9(){for(var _len=arguments.length,a=new Array(_len),_key=0;_key<_len;_key++){a[_key]=arguments[_key];}return new Stage(...a);}/**
   * @private
   * @typedef {object} GradientNode
   * @property {string} type
   * @property {object[]} stops
   * @property {string} [stops[].type=linearGradient] - radialGradient|linearGradient
   * @property {string} stops[].color - {@link https://www.w3.org/TR/SVG/types.html#DataTypeColor}
   * @property {string} [stops[].opacity=1] - {@link https://www.w3.org/TR/css-color-4/#propdef-opacity}
   * @property {number} stops[].offset - {@link https://www.w3.org/TR/SVG/pservers.html#StopElementOffsetAttribute}
   * @property {number} [degree] - Gradient rotation angle
   */ /**
   * @private
   * @typedef {object} GradientItemNode
   * @property {string} id - Gradient identifier
   * @property {number} x1 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementX1Attribute}
   * @property {number} y1 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementY1Attribute}
   * @property {number} x2 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementX2Attribute}
   * @property {number} y2 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementY2Attribute}
   * @property {number} offset - {@link https://www.w3.org/TR/SVG/pservers.html#StopElementOffsetAttribute}
   * @property {object} style - {@link https://www.w3.org/TR/SVG/styling.html#StyleAttribute}
   */const NC$1=NodeContainer.prototype;const allowedAttrs$1=['x1','x2','y1','y2','id','offset','style'];class GradientItem extends DisplayObject{constructor(){let s=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{type='container'}=s;super(type);this.set(s);this._boundingRect={};}set(){let v=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};super.set(v);const attrs=this.attrs;let attrKey='';for(let i=0,len=allowedAttrs$1.length;i!==len;i++){attrKey=allowedAttrs$1[i];if(typeof v[attrKey]!=='undefined'){attrs[attrKey]=v[attrKey];}}}addChild(c){const r=NC$1.addChild.call(this,c);return r;}addChildren(children){const r=NC$1.addChildren.call(this,children);return r;}removeChild(c){c._stage=null;let desc=c.descendants,num=desc?desc.length:0,i;// remove reference to stage from all descendants
  for(i=0;i<num;i++){desc[i]._stage=null;}NC$1.removeChild.call(this,c);return this;}removeChildren(children){NC$1.removeChildren.call(this,children);return this;}}function create$8(){for(var _len=arguments.length,s=new Array(_len),_key=0;_key<_len;_key++){s[_key]=arguments[_key];}return new GradientItem(...s);}/**
   * @private
   * @experimental
   * @typedef {object} PatternNode
   * @property {string} [type='pattern']
   * @property {string} fill
   * @property {number} width
   * @property {number} height
   * @property {object[]} shapes
   * @example
   * // Stripe pattern
   * {
   *   type: 'pattern',
   *   fill: 'red',
   *   width: 4,
   *   height: 4,
   *   shapes: [
   *     { type: 'rect', x: 3, y: 0, width: 1, height: 1 },
   *     { type: 'rect', x: 2, y: 1, width: 1, height: 1 },
   *     { type: 'rect', x: 1, y: 2, width: 1, height: 1 },
   *     { type: 'rect', x: 0, y: 3, width: 1, height: 1 },
   *   ]
   * }
   */const NC=NodeContainer.prototype;const allowedAttrs=['patternUnits','x','y','width','height','id'];class PatternItem extends DisplayObject{constructor(){let s=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{type='container'}=s;super(type);this.set(s);this._boundingRect={};}set(){let v=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};super.set(v);const attrs=this.attrs;let attrKey='';for(let i=0,len=allowedAttrs.length;i!==len;i++){attrKey=allowedAttrs[i];if(typeof v[attrKey]!=='undefined'){attrs[attrKey]=v[attrKey];}}}addChild(c){const r=NC.addChild.call(this,c);return r;}addChildren(children){const r=NC.addChildren.call(this,children);return r;}removeChild(c){c._stage=null;let desc=c.descendants,num=desc?desc.length:0,i;// remove reference to stage from all descendants
  for(i=0;i<num;i++){desc[i]._stage=null;}NC.removeChild.call(this,c);return this;}removeChildren(children){NC.removeChildren.call(this,children);return this;}}function create$7(){for(var _len=arguments.length,s=new Array(_len),_key=0;_key<_len;_key++){s[_key]=arguments[_key];}return new PatternItem(...s);}/**
   * @private
   * @extends DisplayObject
   * @typedef {object} RectNode
   * @property {number} x - X coordinate
   * @property {number} y - Y coordinate
   * @property {number} width - Width
   * @property {number} height- Height
   */class Rect extends DisplayObject{constructor(){super('rect');this.set(...arguments);}set(){let v=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{x=0,y=0,width=0,height=0,rx=0,ry=0,collider}=v;const opts=extend$1({type:'rect',x,y,width,height},collider);super.set(v);if(width>=0){this.attrs.x=x;this.attrs.width=width;}else {this.attrs.x=x+width;this.attrs.width=-width;}if(height>=0){this.attrs.y=y;this.attrs.height=height;}else {this.attrs.y=y+height;this.attrs.height=-height;}if(rx>0){this.attrs.rx=rx;}if(ry>0){this.attrs.ry=ry;}this.collider=opts;this.__boundingRect={true:null,false:null};this.__bounds={true:null,false:null};}boundingRect(){let includeTransform=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(this.__boundingRect[includeTransform]!==null){return this.__boundingRect[includeTransform];}const p=rectToPoints(this.attrs);const pt=includeTransform&&this.modelViewMatrix?this.modelViewMatrix.transformPoints(p):p;const[xMin,yMin,xMax,yMax]=getMinMax$1$1(pt);this.__boundingRect[includeTransform]={x:xMin,y:yMin,width:xMax-xMin,height:yMax-yMin};return this.__boundingRect[includeTransform];}bounds(){let includeTransform=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(this.__bounds[includeTransform]!==null){return this.__bounds[includeTransform];}const rect=this.boundingRect(includeTransform);this.__bounds[includeTransform]=[{x:rect.x,y:rect.y},{x:rect.x+rect.width,y:rect.y},{x:rect.x+rect.width,y:rect.y+rect.height},{x:rect.x,y:rect.y+rect.height}];return this.__bounds[includeTransform];}}function create$6(){for(var _len=arguments.length,s=new Array(_len),_key=0;_key<_len;_key++){s[_key]=arguments[_key];}return new Rect(...s);}/**
   * @private
   * @extends DisplayObject
   * @typedef {object} CircleNode
   * @property {number} cx - {@link https://www.w3.org/TR/SVG/shapes.html#CircleElementCXAttribute}
   * @property {number} cy - {@link https://www.w3.org/TR/SVG/shapes.html#CircleElementCYAttribute}
   * @property {number} r - {@link https://www.w3.org/TR/SVG/shapes.html#CircleElementRAttribute}
   */class Circle extends DisplayObject{constructor(){super('circle');this.set(...arguments);}set(){let v=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{cx=0,cy=0,r=0,collider}=v;const opts=extend$1({type:'circle',cx,cy,r},collider);super.set(v);this.attrs.cx=cx;this.attrs.cy=cy;this.attrs.r=r;this.collider=opts;this.__boundingRect={true:null,false:null};this.__bounds={true:null,false:null};}boundingRect(){let includeTransform=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(this.__boundingRect[includeTransform]!==null){return this.__boundingRect[includeTransform];}// TODO Handle Circle bounds correctly for a circle transformed to an non axis aligned ellipse/circle
  // Current solution only rotate the bounds, giving a larger boundingRect if rotated
  const p=this.bounds(includeTransform);this.__boundingRect[includeTransform]={x:p[0].x,y:p[0].y,width:p[2].x-p[0].x,height:p[2].y-p[0].y};return this.__boundingRect[includeTransform];}bounds(){let includeTransform=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(this.__bounds[includeTransform]!==null){return this.__bounds[includeTransform];}// TODO Handle Circle bounds correctly for a circle transformed to an non axis aligned ellipse/circle
  const{cx,cy,r:rX,r:rY}=this.attrs;const x=cx-rX;const y=cy-rY;let w=rX*2;let h=rY*2;let p=[{x,y},{x:x+w,y},{x:x+w,y:y+h},{x,y:y+h}];if(includeTransform&&this.modelViewMatrix){p=this.modelViewMatrix.transformPoints(p);const[xMin,yMin,xMax,yMax]=getMinMax$1$1(p);w=xMax-xMin;h=yMax-yMin;this.__bounds[includeTransform]=[{x:xMin,y:yMin},{x:xMin+w,y:yMin},{x:xMin+w,y:yMin+h},{x:xMin,y:yMin+h}];}else {this.__bounds[includeTransform]=p;}return this.__bounds[includeTransform];}}function create$5(){for(var _len=arguments.length,s=new Array(_len),_key=0;_key<_len;_key++){s[_key]=arguments[_key];}return new Circle(...s);}/**
   * @private
   * @extends DisplayObject
   * @typedef {object} LineNode
   * @property {number} x1 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementX1Attribute}
   * @property {number} y1 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementY1Attribute}
   * @property {number} x2 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementX2Attribute}
   * @property {number} y2 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementY2Attribute}
   */class Line extends DisplayObject{constructor(){super('line');this.set(...arguments);}set(){let v=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{x1=0,y1=0,x2=0,y2=0,collider}=v;super.set(v);this.attrs.x1=x1;this.attrs.y1=y1;this.attrs.x2=x2;this.attrs.y2=y2;const defaultCollider={type:'line',x1,y1,x2,y2};this.collider=extend$1(defaultCollider,collider);this.__boundingRect={true:null,false:null};this.__bounds={true:null,false:null};}boundingRect(){let includeTransform=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(this.__boundingRect[includeTransform]!==null){return this.__boundingRect[includeTransform];}let p=lineToPoints(this.attrs);if(includeTransform&&this.modelViewMatrix){p=this.modelViewMatrix.transformPoints(p);}const[xMin,yMin,xMax,yMax]=getMinMax$1$1(p);const hasSize=xMin!==xMax||yMin!==yMax;this.__boundingRect[includeTransform]={x:xMin,y:yMin,width:hasSize?Math.max(1,xMax-xMin):0,height:hasSize?Math.max(1,yMax-yMin):0};return this.__boundingRect[includeTransform];}bounds(){let includeTransform=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(this.__bounds[includeTransform]!==null){return this.__bounds[includeTransform];}const rect=this.boundingRect(includeTransform);this.__bounds[includeTransform]=[{x:rect.x,y:rect.y},{x:rect.x+rect.width,y:rect.y},{x:rect.x+rect.width,y:rect.y+rect.height},{x:rect.x,y:rect.y+rect.height}];return this.__bounds[includeTransform];}}function create$4(){for(var _len=arguments.length,s=new Array(_len),_key=0;_key<_len;_key++){s[_key]=arguments[_key];}return new Line(...s);}const PI_2=Math.PI/2;function lineAngle(p0,p1){const t=Math.atan2(p1.y-p0.y,p1.x-p0.x);return t<0?t+Math.PI*2:t;}// TODO Find a more accurate method to find the open and closed points
  function rotatePoint(p,angle,radius){return {x:p.x+Math.cos(angle)*radius,y:p.y+Math.sin(angle)*radius};}function polylineToPolygonCollider(points,radius){let opts=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const open=[];const close=[];// TODO handle case if points.length === 2
  if(opts.forceOrientation==='h'){const start=points[0].x<points[1].x?-1:1;const end=points[points.length-1].x>points[points.length-2].x?1:-1;points.unshift({x:points[0].x+start,y:points[0].y});points.push({x:points[points.length-1].x+end,y:points[points.length-1].y});}else if(opts.forceOrientation==='v'){const start=points[0].y<points[1].y?-1:1;const end=points[points.length-1].y>points[points.length-2].y?1:-1;points.unshift({x:points[0].x,y:points[0].y+start});points.push({x:points[points.length-1].x,y:points[points.length-1].y+end});}const len=points.length-1;for(let i=1;i<len;i++){const prev=points[i-1];const curr=points[i];const next=points[i+1];const currToPrev=lineAngle(curr,prev);const currToNext=lineAngle(curr,next);const openAngle=(currToPrev+currToNext)/2;const closeAngle=openAngle+Math.PI;const maxAngle=Math.max(openAngle,closeAngle);const minAngle=Math.min(openAngle,closeAngle);const openClose=currToPrev>currToNext;if(i===1){const prevToCurr=lineAngle(prev,curr);open.push(rotatePoint(prev,prevToCurr-PI_2,radius));close.unshift(rotatePoint(prev,prevToCurr+PI_2,radius));}const opened=openClose?maxAngle:minAngle;const closed=openClose?minAngle:maxAngle;open.push(rotatePoint(curr,opened,radius));close.unshift(rotatePoint(curr,closed,radius));if(i===len-1){const nextToCurr=lineAngle(next,curr);open.push(rotatePoint(next,nextToCurr+PI_2,radius));close.unshift(rotatePoint(next,nextToCurr-PI_2,radius));}}return {type:'polygon',vertices:[...open,...close]};}function flatten2d(ary){const newAry=[];let a;let len=ary.length;for(let i=0;i<len;i++){a=ary[i];for(let k=0;k<a.length;k++){newAry.push(a[k]);}}return newAry;}const EPSILON$3=1e-12;const CURVES={step:curveStep,stepAfter:stepAfter,stepBefore:stepBefore,linear:curveLinear,basis:curveBasis,cardinal:curveCardinal.tension(0),catmullRom:curveCatmullRom,monotonex:monotoneX,monotoney:monotoneY,natural:curveNatural};/**
   * @private
   * @extends DisplayObject
   * @typedef {object} PathNode
   * @property {string} d - {@link https://www.w3.org/TR/SVG/paths.html#DAttribute}
   */function isClosed(points){if(points.length<2){return false;}const p0=points[0];const p1=points[points.length-1];return Math.abs(p0.x-p1.x)<EPSILON$3&&Math.abs(p0.y-p1.y)<EPSILON$3;}class Path extends DisplayObject{constructor(){super('path');this.set(...arguments);}set(){let v=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};super.set(v);this.segments=[];this.points=[];if(v.arcDatum){const arcGen=arc();arcGen.innerRadius(v.desc.slice.innerRadius);arcGen.outerRadius(v.desc.slice.outerRadius);arcGen.cornerRadius(v.desc.slice.cornerRadius);const d=arcGen(v.arcDatum);this.attrs.d=d;}else if(v.points){const{major,minor,layerObj,points,stngs,generatorType}=v;const areaGenerator=area$5();const defined=stngs.coordinates?stngs.coordinates.defined:null;areaGenerator[major.p](d=>d.major*major.size)// eslint-disable-line no-unexpected-multiline
  ["".concat(minor.p,"1")](d=>d.minor*minor.size)// eslint-disable-line no-unexpected-multiline
  ["".concat(minor.p,"0")](d=>d.minor0*minor.size)// eslint-disable-line no-unexpected-multiline
  .curve(CURVES[layerObj.curve==='monotone'?"monotone".concat(major.p):layerObj.curve]);if(defined){areaGenerator.defined(d=>!d.dummy&&typeof d.minor==='number'&&!isNaN(d.minor)&&d.defined);}else {areaGenerator.defined(d=>!d.dummy&&typeof d.minor==='number'&&!isNaN(d.minor));}const filteredPoints=stngs.connect?points.filter(areaGenerator.defined()):points;const generator=generatorType==='area'?areaGenerator:areaGenerator[generatorType]();const d=generator(filteredPoints);this.attrs.d=d;}else if(v.d){this.attrs.d=v.d;}this.__boundingRect={true:null,false:null};this.__bounds={true:null,false:null};if(Array.isArray(v.collider)||typeof v.collider==='object'&&typeof v.collider.type!=='undefined'){this.collider=v.collider;}else if(this.attrs.d){this.segments=pathToPoints(this.attrs.d);if(this.segments.length>1&&this.segments.every(segment=>isClosed(segment))){this.collider=extend$1({type:'geopolygon',vertices:this.segments},v.collider);return;}this.segments.forEach(segment=>{if(segment.length<=1);else if(isClosed(segment)){this.collider=extend$1({type:'polygon',vertices:segment},v.collider);}else if(typeof v.collider==='object'&&v.collider.visual){const size=this.attrs['stroke-width']/2;this.collider=polylineToPolygonCollider(segment,size,v.collider);}else {this.collider=extend$1({type:'polyline',points:segment},v.collider);}});}}boundingRect(){let includeTransform=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(this.__boundingRect[includeTransform]!==null){return this.__boundingRect[includeTransform];}if(!this.points.length){this.segments=this.segments.length?this.segments:pathToPoints(this.attrs.d);this.points=flatten2d(this.segments);}const pt=includeTransform&&this.modelViewMatrix?this.modelViewMatrix.transformPoints(this.points):this.points;const[xMin,yMin,xMax,yMax]=getMinMax$1$1(pt);this.__boundingRect[includeTransform]={x:xMin||0,y:yMin||0,width:xMax-xMin||0,height:yMax-yMin||0};return this.__boundingRect[includeTransform];}bounds(){let includeTransform=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(this.__bounds[includeTransform]!==null){return this.__bounds[includeTransform];}const rect=this.boundingRect(includeTransform);this.__bounds[includeTransform]=[{x:rect.x,y:rect.y},{x:rect.x+rect.width,y:rect.y},{x:rect.x+rect.width,y:rect.y+rect.height},{x:rect.x,y:rect.y+rect.height}];return this.__bounds[includeTransform];}}function create$3(){for(var _len=arguments.length,s=new Array(_len),_key=0;_key<_len;_key++){s[_key]=arguments[_key];}return new Path(...s);}function hasData$1(_ref){let{data,_boundingRect,_textBoundsFn}=_ref;return typeof data!=='undefined'&&data!==null&&(_boundingRect||_textBoundsFn);}/**
   * @private
   * @extends DisplayObject
   * @typedef {object} TextNode
   * @property {string} text
   * @property {number} x - {@link https://www.w3.org/TR/SVG/text.html#TextElementXAttribute}
   * @property {number} y - {@link https://www.w3.org/TR/SVG/text.html#TextElementYAttribute}
   * @property {number} [dx] - {@link https://www.w3.org/TR/SVG/text.html#TextElementDXAttribute}
   * @property {number} [dy] - {@link https://www.w3.org/TR/SVG/text.html#TextElementDYAttribute}
   * @property {string} [fontSize] - {@link https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG}
   * @property {string} [fontFamily] - {@link https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG}
   * @property {Rect} [boundingRect] - Explicitly set the bounding rectangle of the node. Has predence over textBoundsFn
   * @property {function} [textBoundsFn] - Implicitly set the bounding rectangle of the node, the function must return an object with x, y, width and height attributes
   * @property {string} [baseline] - Alias for dominantBaseline
   * @property {string} [dominantBaseline] - {@link https://www.w3.org/TR/SVG/text.html#BaselineAlignmentProperties}
   * @property {string} [anchor] - Alias for textAnchor
   * @property {string} [textAnchor] - {@link https://www.w3.org/TR/SVG/text.html#TextAnchorProperty}
   * @property {string} [wordBreak] - Word-break option
   * @property {number} [maxWidth] - Maximum allowed text width
   * @property {number} [maxHeight] - Maximum allowed text height. If both maxLines and maxHeight are set, the property that results in the fewest number of lines is used
   * @property {number} [maxLines] - Maximum number of lines allowed
   * @property {number} [lineHeight=1.2] - Line height
   */class Text extends DisplayObject{constructor(){super('text');this.set(...arguments);}set(){let v=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{x=0,y=0,dx=0,dy=0,textBoundsFn,text,title,collider,boundingRect,ellipsed}=v;super.set(v);this.attrs.x=x;this.attrs.y=y;this.attrs.dx=dx;this.attrs.dy=dy;this.attrs.text=text;if(typeof title!=='undefined'){this.attrs.title=String(title);}if(typeof boundingRect==='object'){this._textBoundsFn=()=>boundingRect;}else if(typeof textBoundsFn==='function'){this._textBoundsFn=textBoundsFn;}if(typeof ellipsed==='string'){this.ellipsed=ellipsed;}this.collider=extend$1({type:hasData$1(this)?'bounds':null},collider);this.__boundingRect={true:null,false:null};this.__bounds={true:null,false:null};}boundingRect(){let includeTransform=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(this.__boundingRect[includeTransform]!==null){return this.__boundingRect[includeTransform];}let rect;if(typeof this._textBoundsFn==='function'){rect=this._textBoundsFn(this.attrs);}else {return {x:0,y:0,width:0,height:0};}const p=rectToPoints(rect);const pt=includeTransform&&this.modelViewMatrix?this.modelViewMatrix.transformPoints(p):p;const[xMin,yMin,xMax,yMax]=getMinMax$1$1(pt);this.__boundingRect[includeTransform]={x:xMin,y:yMin,width:xMax-xMin,height:yMax-yMin};return this.__boundingRect[includeTransform];}bounds(){let includeTransform=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(this.__bounds[includeTransform]!==null){return this.__bounds[includeTransform];}const rect=this.boundingRect(includeTransform);this.__bounds[includeTransform]=[{x:rect.x,y:rect.y},{x:rect.x+rect.width,y:rect.y},{x:rect.x+rect.width,y:rect.y+rect.height},{x:rect.x,y:rect.y+rect.height}];return this.__bounds[includeTransform];}}function create$2(){for(var _len=arguments.length,s=new Array(_len),_key=0;_key<_len;_key++){s[_key]=arguments[_key];}return new Text(...s);}const reg$1=registryFactory();reg$1.add('rect',create$6);reg$1.add('circle',create$5);reg$1.add('text',create$2);reg$1.add('line',create$4);reg$1.add('path',create$3);reg$1.add('stage',create$9);reg$1.add('container',create$a);reg$1.add('defs',create$a);reg$1.add('linearGradient',create$8);reg$1.add('radialGradient',create$8);reg$1.add('stop',create$8);reg$1.add('pattern',create$7);/* eslint-disable import/prefer-default-export */function create$1(type,input){return reg$1.get(type)(input);}/* eslint-enable import/prefer-default-export */ /**
   * Creates a context. Input an array of strings that should be inherited by the context.
   * @private
   *
   * @param  {Array}  [whitelist=[]]  An array of whitelisted string keys to inherit
   * @return {Function}               A context function
   */function contextFactory(){let whitelist=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];const states=[{}];/**
     * Returns the current context as an object. The object is mutable.
     * @private
     *
     * @return {Object}   Current context
     */function context(){// Returns the current context, the last in the stack.
  const item=states[states.length-1];return item;}/**
     * Call context.save() to save the current context and move down the stack.
     *
     * @param  {Object} [item={}]   Optional item to save.
     * @return {Object}             The current context, just as context()
     */context.save=function save(){let item=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const current=context();const obj={};let key='';// Only inherit whitelisted properties
  for(let i=0;i<whitelist.length;i++){key=whitelist[i];if(typeof current[key]!=='undefined'){obj[key]=current[key];}}// Extend the new object with the saved item
  extend$1(obj,item);// Push it to the stack
  states.push(obj);// Return the new current context
  return context();};/**
     * Restore the previous context. Returns the context.
     *
     * @return {Undefined}   Returns nothing
     */context.restore=function restore(){// Remove the last element from the stack
  states.splice(states.length-1,1);};return context;}const styleContext=contextFactory(['stroke','fill','strokeWidth','opacity','fontFamily','fontSize','baseline']);function doEvent(state,listeners){if(!Array.isArray(listeners)){return;}for(let i=0,len=listeners.length;i<len;i++){listeners[i](state);}}function updateState(state,index,nodes){state.node=nodes[index];state.index=index;}function traverse(items,parent,matrix,on){let disabled=false;const state={siblings:items,node:null,index:0};for(let i=0,len=items.length;i<len;i++){updateState(state,i,items);doEvent(state,on.create);disabled=typeof state.node.disabled==='function'?state.node.disabled():state.node.disabled;if(disabled){continue;}// Save the current style context to be able to inherit styles
  state.node=styleContext.save(state.node);const displayNode=create$1(state.node.type,state.node);if(displayNode){if(state.node.transform){matrix.save();resolveTransform(state.node.transform,matrix);}if(!matrix.isIdentity()){displayNode.modelViewMatrix=matrix.clone();}parent.addChild(displayNode);if(state.node.children){traverse(state.node.children,displayNode,matrix,on);}if(state.node.transform){matrix.restore();}}// Revert to previous style context
  styleContext.restore();}}function scene(_ref){let{items,stage,dpi,on={}}=_ref;if(!stage){stage=create$1('stage',dpi);}traverse(items,stage,new Matrix(),on);return stage;}/**
   * Get or create a gradient
   * @ignore
   * @param  {Object} g        Canvas 2d context
   * @param  {Object} node    Current node (for width/height properties)
   * @param  {Object} gradient The gradient properties
   * @return {Object}          A canvas compatible radial or linear gradient object
   */function createCanvasGradient(g,node,gradient){const{orientation,degree,stops=[]}=gradient;let newGradient=null;if(orientation==='radial'){const bounds=node.boundingRect();newGradient=g.createRadialGradient(bounds.x+bounds.width/2,bounds.y+bounds.height/2,1e-5,bounds.x+bounds.width/2,bounds.y+bounds.height/2,Math.max(bounds.width,bounds.height)/2);}else {const points=degreesToPoints(degree);['x1','x2','y1','y2'].forEach(c=>{if(c in gradient){points[c]=gradient[c];}});const bounds=node.boundingRect();newGradient=g.createLinearGradient(bounds.x+points.x1*bounds.width,bounds.y+points.y1*bounds.height,bounds.x+points.x2*bounds.width,bounds.y+points.y2*bounds.height);}for(let i=0,len=stops.length;i<len;i++){let stop=stops[i];newGradient.addColorStop(stop.offset,stop.color);}return newGradient;}function getPattern(pattern,dummyCanvas,ctx){dummyCanvas.width=pattern.width;dummyCanvas.height=pattern.height;ctx.save();ctx.fillStyle=pattern.fill;pattern.shapes.forEach(s=>{switch(s.type){case'rect':ctx.rect(s.x,s.y,s.width,s.height);break;}});ctx.fill();ctx.restore();return ctx.createPattern(dummyCanvas,'repeat');}function patternizer$1(document){const dummyCanvas=document.createElement('canvas');const ctx=dummyCanvas.getContext('2d');let cache={};return {create(pattern){const key=pattern.key;if(key){cache[key]=cache[key]||getPattern(pattern,dummyCanvas,ctx);return cache[key];}return getPattern(pattern,dummyCanvas,ctx);},clear(){cache={};}};}/**
   * @typedef {object} Renderer~SizeDefinition
   * @property {number} [x] - x-coordinate
   * @property {number} [y] - y-coordinate
   * @property {number} [width] - Width
   * @property {number} [height] - Height
   * @property {object} [scaleRatio]
   * @property {number} [scaleRatio.x] - Scale ratio on x-axis
   * @property {number} [scaleRatio.y] - Scale ratio on y-axis
   * @property {object} [margin]
   * @property {number} [margin.left] - Left margin
   * @property {number} [margin.top] - Top margin
   */ /**
   * Create the renderer box
   * @private
   * @param {Renderer~SizeDefinition} [opts]
   * @returns {Renderer~SizeDefinition} A svg renderer instance
   */function createRendererBox(){let{x,y,width,height,scaleRatio,margin,edgeBleed}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const box={x:0,y:0,width:0,height:0,scaleRatio:{x:1,y:1},margin:{left:0,top:0},edgeBleed:{left:0,right:0,top:0,bottom:0,bool:false}};box.x=isNaN(x)?box.x:x;box.y=isNaN(y)?box.y:y;box.width=isNaN(width)?box.width:width;box.height=isNaN(height)?box.height:height;if(typeof scaleRatio!=='undefined'){box.scaleRatio.x=isNaN(scaleRatio.x)?box.scaleRatio.x:scaleRatio.x;box.scaleRatio.y=isNaN(scaleRatio.y)?box.scaleRatio.y:scaleRatio.y;}if(typeof margin!=='undefined'){box.margin.left=isNaN(margin.left)?0:margin.left;box.margin.top=isNaN(margin.top)?0:margin.top;}if(typeof edgeBleed==='object'){['left','right','top','bottom'].forEach(prop=>{if(!isNaN(edgeBleed[prop])&&edgeBleed[prop]>0){box.edgeBleed[prop]=edgeBleed[prop];box.edgeBleed.bool=true;}});}box.computedPhysical={x:Math.round(box.margin.left+(box.x-box.edgeBleed.left)*box.scaleRatio.x),y:Math.round(box.margin.top+(box.y-box.edgeBleed.top)*box.scaleRatio.y),width:Math.round((box.width+box.edgeBleed.left+box.edgeBleed.right)*box.scaleRatio.x),height:Math.round((box.height+box.edgeBleed.top+box.edgeBleed.bottom)*box.scaleRatio.y)};return box;}/**
   * Base renderer factory
   * @private
   */function create$q(){/**
     * @interface
     * @alias Renderer
     */const renderer={/**
       * Get the element this renderer is attached to
       * @returns {HTMLElement}
       */element:()=>{},/**
       * Get the root element of the renderer
       * @returns {HTMLElement}
       */root:()=>{},/**
       * Set or Get renderer settings
       * @param {object} [settings] Settings for the renderer
       */settings:()=>{},/**
       * @param {HTMLElement} element - Element to attach renderer to
       * @returns {HTMLElement} Root element of the renderer
       */appendTo:()=>{},/**
       * Get Scene based on provided nodes, constructed in the same way as in the render function.
       * Only the canvas and svg renderer uses scene nodes.
       * @private
       * @param {object[]} nodes - Nodes on which the scene will be constructed
       * @returns {Scene}
       */getScene:()=>[],/**
       * @param {object[]} nodes - Nodes to render
       * @returns {boolean} True if the nodes were rendered, otherwise false
       */render:()=>false,/**
       * Get nodes renderer at area
       * @param {Point|Circle|Rect|Line|Polygon|Geopolygon} geometry - Get nodes that intersects with geometry
       * @returns {SceneNode[]}
       */itemsAt:()=>[],/**
       * Get all nodes matching the provided selector
       * @param {string} selector CSS selector [type, attribute, universal, class]
       * @returns {SceneNode[]} Array of objects containing matching nodes
       */findShapes:()=>[],/**
       * Clear all child elements from the renderer root element
       * @returns {Renderer} The renderer instance
       */clear:()=>{},/**
       * Remove the renderer root element from its parent element
       */destory:()=>{},/**
       * Set or Get the size definition of the renderer container.
       * @param {Renderer~SizeDefinition} [opts] - Size definition
       * @returns {Renderer~SizeDefinition} The current size definition
       */size:()=>{},/**
       * @function
       * @param {object} opts
       * @param {string} opts.text - Text to measure
       * @param {string} opts.fontSize - Font size
       * @param {string} opts.fontFamily - Font family
       * @returns {object} Width and height of text
       * @example
       * measureText({
       *  text: 'my text',
       *  fontSize: '12px',
       *  fontFamily: 'Arial'
       * }); // returns { width: 20, height: 12 }
       */measureText,/**
       * Calculates the bounding rectangle of a text node. Including any potential line breaks.
       * @function
       * @private
       * @param {TextNode} node
       * @return {Rect} The bounding rectangle
       */textBounds,setKey:key=>{renderer.element().setAttribute('data-key',key);}};return renderer;}function hasData(data){return typeof data!=='undefined'&&data!==null;}function injectTextBoundsFn(renderer){return _ref=>{let{node}=_ref;if(node.type==='text'&&hasData(node.data)&&!node.textBoundsFn){node.textBoundsFn=renderer.textBounds;}};}const DEFAULT_PADDING={horizontal:200,vertical:200};/**
   * Creates a canvas element, preferrably larger than the target canvas.
   * This "buffer canvas" is detached from the DOM and allows rendering of shapes outside of the visible area.
   * Especially useful when applying transforms to target canvas.
   * @private
   */class CanvasBuffer{constructor(targetCanvas){this.targetCanvas=targetCanvas;this.bufferCanvas=targetCanvas.cloneNode();}/**
     * @param {object|function} [canvasBufferSize] object containing width and height or a function which returns it
     */updateSize(_ref){let{rect,dpiRatio,canvasBufferSize}=_ref;let bufferSize;if(canvasBufferSize){bufferSize=typeof canvasBufferSize==='function'?canvasBufferSize(rect):canvasBufferSize;}else {bufferSize={width:rect.computedPhysical.width+DEFAULT_PADDING.horizontal*2,height:rect.computedPhysical.height+DEFAULT_PADDING.vertical*2};}this.bufferCanvas.style.width="".concat(bufferSize.width,"px");this.bufferCanvas.style.height="".concat(bufferSize.height,"px");this.bufferCanvas.width=Math.round(bufferSize.width*dpiRatio);this.bufferCanvas.height=Math.round(bufferSize.height*dpiRatio);}/**
     * Draws buffer canvas on the target canvas.
     */apply(){const g=this.targetCanvas.getContext('2d');g.drawImage(this.bufferCanvas,0,0);}clear(){// clear canvas
  this.bufferCanvas.width=this.bufferCanvas.width;// eslint-disable-line
  }getContext(){return this.bufferCanvas.getContext('2d');}}const reg=registryFactory();function toLineDash(p){if(Array.isArray(p)){return p;}if(typeof p==='string'){if(p.indexOf(',')!==-1){return p.split(',');}return p.split(' ');}return [];}function dpiScale(g){const dpr=typeof window==='undefined'?1:window.devicePixelRatio||1;const backingStorePixelRatio=g.webkitBackingStorePixelRatio||g.mozBackingStorePixelRatio||g.msBackingStorePixelRatio||g.oBackingStorePixelRatio||g.backingStorePixelRatio||1;return dpr/backingStorePixelRatio;}function resolveMatrix(p,g){g.setTransform(p[0][0],p[1][0],p[0][1],p[1][1],p[0][2],p[1][2]);}function applyContext(g,s,shapeToCanvasMap){let computed=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};const computedKeys=Object.keys(computed);for(let i=0,len=shapeToCanvasMap.length;i<len;i++){let cmd=shapeToCanvasMap[i];const shapeCmd=cmd[0];const canvasCmd=cmd[1];const convertCmd=cmd[2];if(shapeCmd in s.attrs&&!(canvasCmd in computed)&&g[canvasCmd]!==s.attrs[shapeCmd]){const val=convertCmd?convertCmd(s.attrs[shapeCmd]):s.attrs[shapeCmd];if(typeof g[canvasCmd]==='function'){g[canvasCmd](val);}else {g[canvasCmd]=val;}}}for(let i=0,len=computedKeys.length;i<len;i++){const key=computedKeys[i];g[key]=computed[key];}}function renderShapes(shapes,g,shapeToCanvasMap,deps){for(let i=0,len=shapes.length;i<len;i++){let shape=shapes[i];let computed={};g.save();if(shape.attrs&&(shape.attrs.fill||shape.attrs.stroke)){if(shape.attrs.fill&&typeof shape.attrs.fill==='object'&&shape.attrs.fill.type==='gradient'){computed.fillStyle=createCanvasGradient(g,shape,shape.attrs.fill);}else if(shape.attrs.fill&&typeof shape.attrs.fill==='object'&&shape.attrs.fill.type==='pattern'){computed.fillStyle=deps.patterns.create(shape.attrs.fill);}if(shape.attrs.stroke&&typeof shape.attrs.stroke==='object'&&shape.attrs.stroke.type==='gradient'){computed.strokeStyle=createCanvasGradient(g,shape,shape.attrs.stroke);}else if(shape.attrs.stroke&&typeof shape.attrs.stroke==='object'&&shape.attrs.stroke.type==='pattern'){computed.strokeStyle=deps.patterns.create(shape.attrs.stroke);}}applyContext(g,shape,shapeToCanvasMap,computed);if(shape.modelViewMatrix){resolveMatrix(shape.modelViewMatrix.elements,g);}if(reg.has(shape.type)){reg.get(shape.type)(shape.attrs,{g,doFill:'fill'in shape.attrs&&shape.attrs.fill!=='none',doStroke:'stroke'in shape.attrs&&shape.attrs['stroke-width']!==0,ellipsed:shape.ellipsed});}if(shape.children){renderShapes(shape.children,g,shapeToCanvasMap,deps);}g.restore();}}/**
   * Sets transform on target element.
   * @param {Element} el Target canvas element
   * @param {number} dpiRatio
   * @param {TransformObject}
   * @private
   */function applyTransform(_ref){let{el,dpiRatio,transform}=_ref;if(typeof transform==='object'){const adjustedTransform=[transform.horizontalScaling,transform.horizontalSkewing,transform.verticalSkewing,transform.verticalScaling,transform.horizontalMoving*dpiRatio,transform.verticalMoving*dpiRatio];const g=el.getContext('2d');g.setTransform(...adjustedTransform);}}/**
   * Create a new canvas renderer
   * @typedef {function} canvasRendererFactory
   * @param {function} [sceneFn] - Scene factory
   * @returns {Renderer} A canvas renderer instance
   */function renderer$2(){let sceneFn=arguments.length>0&&arguments[0]!==undefined?arguments[0]:scene;let el;let buffer;const settings={transform:undefined,canvasBufferSize:undefined,progressive:undefined};let scene$1;let hasChangedRect=false;let rect=createRendererBox();const shapeToCanvasMap=[['fill','fillStyle'],['stroke','strokeStyle'],['opacity','globalAlpha'],['globalAlpha','globalAlpha'],['stroke-width','lineWidth'],['stroke-linejoin','lineJoin'],['stroke-dasharray','setLineDash',toLineDash]];let patterns;const canvasRenderer=create$q();canvasRenderer.element=()=>el;canvasRenderer.root=()=>el;canvasRenderer.settings=rendererSettings=>{if(rendererSettings){Object.keys(settings).forEach(key=>{if(rendererSettings[key]!==undefined){settings[key]=rendererSettings[key];}});}return settings;};canvasRenderer.appendTo=element=>{if(!el){el=element.ownerDocument.createElement('canvas');el.style.position='absolute';el.style['-webkit-font-smoothing']='antialiased';el.style['-moz-osx-font-smoothing']='antialiased';el.style.pointerEvents='none';}if(typeof settings.transform==='function'&&!buffer){buffer=new CanvasBuffer(el);}element.appendChild(el);return el;};canvasRenderer.getScene=shapes=>{const g=buffer&&buffer.getContext()||el.getContext('2d');const dpiRatio=dpiScale(g);const scaleX=rect.scaleRatio.x;const scaleY=rect.scaleRatio.y;const sceneContainer={type:'container',children:shapes,transform:rect.edgeBleed.bool?"translate(".concat(rect.edgeBleed.left*dpiRatio*scaleX,", ").concat(rect.edgeBleed.top*dpiRatio*scaleY,")"):''};if(dpiRatio!==1||scaleX!==1||scaleY!==1){sceneContainer.transform+="scale(".concat(dpiRatio*scaleX,", ").concat(dpiRatio*scaleY,")");}return sceneFn({items:[sceneContainer],dpi:dpiRatio,on:{create:[onLineBreak(canvasRenderer.measureText),injectTextBoundsFn(canvasRenderer)]}});};canvasRenderer.render=shapes=>{if(!el){return false;}if(!patterns){patterns=patternizer$1(el.ownerDocument);}const g=buffer&&buffer.getContext()||el.getContext('2d');const dpiRatio=dpiScale(g);const transform=buffer&&settings.transform();if(transform){// clear canvas
  el.width=el.width;// eslint-disable-line
  applyTransform({el,dpiRatio,transform});buffer.apply();return true;}if(hasChangedRect){el.style.left="".concat(rect.computedPhysical.x,"px");el.style.top="".concat(rect.computedPhysical.y,"px");el.style.width="".concat(rect.computedPhysical.width,"px");el.style.height="".concat(rect.computedPhysical.height,"px");el.width=Math.round(rect.computedPhysical.width*dpiRatio);el.height=Math.round(rect.computedPhysical.height*dpiRatio);if(buffer){buffer.updateSize({rect,dpiRatio,canvasBufferSize:settings.canvasBufferSize});}}const newScene=canvasRenderer.getScene(shapes);const hasChangedScene=scene$1?!newScene.equals(scene$1):true;patterns.clear();const doRender=hasChangedRect||hasChangedScene;const progressive=typeof settings.progressive==='function'&&settings.progressive();if(doRender){if(!progressive||progressive.isFirst){canvasRenderer.clear();}renderShapes(newScene.children,g,shapeToCanvasMap,{patterns});}if(buffer){// clear canvas
  el.width=el.width;// eslint-disable-line
  buffer.apply();}hasChangedRect=false;if(progressive&&!progressive.isFirst){newScene.children.unshift(...scene$1.children);}scene$1=newScene;return doRender;};canvasRenderer.itemsAt=input=>scene$1?scene$1.getItemsFrom(input):[];canvasRenderer.findShapes=selector=>scene$1?scene$1.findShapes(selector):[];canvasRenderer.clear=()=>{if(el){el.width=el.width;// eslint-disable-line
  }if(buffer){buffer.clear();}scene$1=null;return canvasRenderer;};canvasRenderer.size=opts=>{if(opts){const newRect=createRendererBox(opts);if(JSON.stringify(rect)!==JSON.stringify(newRect)){hasChangedRect=true;rect=newRect;}}return rect;};canvasRenderer.destroy=()=>{if(el){if(el.parentElement){el.parentElement.removeChild(el);}el=null;}if(buffer){buffer=null;}scene$1=null;};return canvasRenderer;}function register(type,renderFn){reg.add(type,renderFn);}function clampRadius(max,value){return Math.max(0,Math.min(max,value));}/**
   * Implementation details follow rx/ry restrictions from https://svgwg.org/svg2-draft/geometry.html#RX
   *
   * Using Quadratic Bézier curve it's not possible accurately represent a circle or ellipse but should for the case of a rounded rectangle be sufficent.
   * @private
   */function quadraticRoundedRect(g,x,y,width,height,rx,ry){rx=clampRadius(width/2,rx>0?rx:ry);ry=clampRadius(height/2,ry>0?ry:rx);g.moveTo(x,y+ry);g.lineTo(x,y+height-ry);g.quadraticCurveTo(x,y+height,x+rx,y+height);g.lineTo(x+width-rx,y+height);g.quadraticCurveTo(x+width,y+height,x+width,y+height-ry);g.lineTo(x+width,y+ry);g.quadraticCurveTo(x+width,y,x+width-rx,y);g.lineTo(x+rx,y);g.quadraticCurveTo(x,y,x,y+ry);}function render$4(rect,_ref){let{g,doFill,doStroke}=_ref;g.beginPath();if(rect.rx>0||rect.ry>0){quadraticRoundedRect(g,rect.x,rect.y,rect.width,rect.height,rect.rx,rect.ry);}else {g.rect(rect.x,rect.y,rect.width,rect.height);}if(doFill){g.fill();}if(doStroke){g.stroke();}}function render$3(circle,_ref){let{g,doFill,doStroke}=_ref;g.beginPath();g.moveTo(circle.cx+circle.r,circle.cy);g.arc(circle.cx,circle.cy,circle.r,0,Math.PI*2,false);if(doFill){g.fill();}if(doStroke){g.stroke();}}function render$2(line,_ref){let{g,doStroke}=_ref;g.beginPath();g.moveTo(line.x1,line.y1);g.lineTo(line.x2,line.y2);if(doStroke){g.stroke();}}/* eslint no-misleading-character-class: 0 */ // Source: https://en.wikipedia.org/wiki/Bi-directional_text and http://www.unicode.org/Public/6.0.0/ucd/UnicodeData.txt
  // 3 types of strong direction characters: L (strong left-to-right), R(strong right-to-left, Hebrew) and AL(strong right-to-left, Arabic language)
  const rangesOfLChars='[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02B8\u02BB-\u02C1\u02D0-\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376-\u037D\u0386\u0388-\u03F5\u03F7-\u0482\u048A-\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u097F\u0982-\u09B9\u09BD-\u09C0\u09C7-\u09CC\u09CE-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u0A03-\u0A39\u0A3E-\u0A40\u0A59-\u0A6F\u0A72-\u0A74\u0A83-\u0AB9\u0ABD-\u0AC0\u0AC9-\u0ACC\u0AD0-\u0AE1\u0AE6-\u0AEF\u0B02-\u0B39\u0B3D-\u0B3E\u0B40\u0B47-\u0B4C\u0B57-\u0B61\u0B66-\u0B77\u0B83-\u0BBF\u0BC1-\u0BCC\u0BD0-\u0BF2\u0C01-\u0C3D\u0C41-\u0C44\u0C58-\u0C61\u0C66-\u0C6F\u0C7F-\u0CB9\u0CBD-\u0CCB\u0CD5-\u0CE1\u0CE6-\u0D40\u0D46-\u0D4C\u0D4E-\u0D61\u0D66-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0E30\u0E32-\u0E33\u0E40-\u0E46\u0E4F-\u0EB0\u0EB2-\u0EB3\u0EBD-\u0EC6\u0ED0-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u102C\u1031\u1038\u103B-\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083-\u1084\u1087-\u108C\u108E-\u109C\u109E-\u135A\u1360-\u138F\u13A0-\u13F4\u1401-\u167F\u1681-\u169A\u16A0-\u1711\u1720-\u1731\u1735-\u1751\u1760-\u1770\u1780-\u17B6\u17BE-\u17C5\u17C7-\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u18A8\u18AA-\u191C\u1923-\u1926\u1929-\u1931\u1933-\u1938\u1946-\u19DA\u1A00-\u1A16\u1A19-\u1A55\u1A57\u1A61\u1A63-\u1A64\u1A6D-\u1A72\u1A80-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B6A\u1B74-\u1B7C\u1B82-\u1BA1\u1BA6-\u1BA7\u1BAA-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2-\u1C2B\u1C34-\u1C35\u1C3B-\u1C7F\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1DBF\u1E00-\u1FBC\u1FBE\u1FC2-\u1FCC\u1FD0-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E-\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2D00-\u2D70\u2D80-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u31BA\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DB5\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA66E\uA680-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA925\uA92E-\uA946\uA952-\uA97C\uA983-\uA9B2\uA9B4-\uA9B5\uA9BA-\uA9BB\uA9BD-\uAA28\uAA2F-\uAA30\uAA33-\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D-\uAAAF\uAAB1\uAAB5-\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2-\uABE4\uABE6-\uABE7\uABE9-\uABEC\uABF0-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFDC]';const rangesOfRChars='[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u07C0-\u07EA\u07F4-\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB4F]';const rangesOfALChars='[\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5-\u06E6\u06EE-\u06EF\u06FA-\u070D\u0710\u0712-\u072F\u074D-\u07A5\u07B1\uFB50-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]';// let rangesOfNChars = '[\u0009-\u000D\u001C-\u0022\u0026-\u002A\u003B-\u0040\u005B-\u0060\u007B-\u007E\u0085\u00A1\u00A6-\u00A9\u00AB-\u00AC\u00AE-\u00AF\u00B4\u00B6-\u00B8\u00BB-\u00BF\u00D7\u00F7\u02B9-\u02BA\u02C2-\u02CF\u02D2-\u02DF\u02E5-\u02ED\u02EF-\u02FF\u0374-\u0375\u037E-\u0385\u0387\u03F6\u058A\u0606-\u0607\u060E-\u060F\u06DE\u06E9\u07F6-\u07F9\u0BF3-\u0BF8\u0BFA\u0C78-\u0C7E\u0F3A-\u0F3D\u1390-\u1399\u1400\u1680\u169B-\u169C\u17F0-\u180A\u180E\u1940-\u1945\u19DE-\u19FF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD-\u200A\u2010-\u2029\u2035-\u2043\u2045-\u205F\u207C-\u207E\u208C-\u208E\u2100-\u2101\u2103-\u2106\u2108-\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u213A-\u213B\u2140-\u2144\u214A-\u214D\u2150-\u215F\u2189-\u2211\u2214-\u2335\u237B-\u2394\u2396-\u2487\u24EA-\u26AB\u26AD-\u27FF\u2900-\u2B59\u2CE5-\u2CEA\u2CF9-\u2CFF\u2E00-\u3004\u3008-\u3020\u3030\u3036-\u3037\u303D-\u303F\u309B-\u309C\u30A0\u30FB\u31C0-\u31E3\u321D-\u321E\u3250-\u325F\u327C-\u327E\u32B1-\u32BF\u32CC-\u32CF\u3377-\u337A\u33DE-\u33DF\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA60D-\uA60F\uA673\uA67E-\uA67F\uA700-\uA721\uA788\uA828-\uA82B\uA874-\uA877\uFD3E-\uFD3F\uFDFD\uFE10-\uFE19\uFE30-\uFE4F\uFE51\uFE54\uFE56-\uFE5E\uFE60-\uFE61\uFE64-\uFE68\uFE6B\uFF01-\uFF02\uFF06-\uFF0A\uFF1B-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFE2-\uFFE4\uFFE8-\uFFFD]';
  const rangesOfLRgExp=new RegExp(rangesOfLChars);const rangesOfRRgExp=new RegExp(rangesOfRChars);const rangesOfALRgExp=new RegExp(rangesOfALChars);// let rangesOfNRgExp = new RegExp(rangesOfNChars);
  // let lrm = String.fromCharCode(8206); // left-to-right marker
  // let rlm = String.fromCharCode(8207); // right-to-left marker
  function isLtrChar(c){return rangesOfLRgExp.test(c);}function isRtlChar(c){return rangesOfRRgExp.test(c)||rangesOfALRgExp.test(c);}function detectTextDirection(s){let n=s?s.length:0,i,c;for(i=0;i<n;i++){c=s[i];if(isLtrChar(c)){return 'ltr';}if(isRtlChar(c)){return 'rtl';}}return 'ltr';}const textAnchorRTLMap={start:'end',end:'start',center:'center',middle:'middle'};/* let flippedTextAnchor = true;
  let detected = false;
  export function detectRtlSvgSupport(ns, ownerDoc) {
    if (!detected) {
      const body = ownerDoc.body;
      if (body) {
        const rtlTestSVG = ownerDoc.createElementNS(ns, 'svg');
        const textNode = ownerDoc.createElementNS(ns, 'text');
        const group = ownerDoc.createElementNS(ns, 'g');

        rtlTestSVG.setAttribute('xmlns', ns);
        rtlTestSVG.setAttribute('style', 'position: absolute; width: 100px; height: 100px; top: -100px; left: 0px');

        textNode.setAttribute('text-anchor', 'start');
        textNode.setAttribute('direction', 'rtl');
        textNode.setAttribute('font-size', '14px');
        textNode.setAttribute('x', 50);
        textNode.setAttribute('y', 50);
        textNode.textContent = 'ثعبان';

        group.appendChild(textNode);
        rtlTestSVG.appendChild(group);
        body.appendChild(rtlTestSVG);

        flippedTextAnchor = textNode.getBoundingClientRect().left < 50;
        body.removeChild(rtlTestSVG);
      }
    }
    detected = true;
  } */function flipTextAnchor(value,dir){if(dir==='rtl'){return textAnchorRTLMap[value];}return value;}function render$1(t,_ref){let{g,ellipsed,doStroke}=_ref;const text=ellipsed||ellipsText(t,measureText);if(t['font-weight']){g.font="".concat(t['font-weight']," ").concat(t['font-size']," ").concat(t['font-family']);}else {g.font="".concat(t['font-size']," ").concat(t['font-family']);}const dir=detectTextDirection(t.text);if(g.canvas.dir!==dir){g.canvas.dir=dir;}const textAnchor=t['text-anchor']==='middle'?'center':t['text-anchor'];const textAlign=flipTextAnchor(textAnchor,g.canvas.dir);if(textAlign&&g.textAlign!==textAlign){g.textAlign=textAlign;}const bdy=baselineHeuristic(t);g.fillText(text,t.x+t.dx,t.y+t.dy+bdy);if(doStroke){g.strokeText(text,t.x+t.dx,t.y+t.dy+bdy);}}function render(path,_ref){let{g,doStroke,doFill}=_ref;const p=new Path2D(path.d);if(doFill){g.fill(p);}if(doStroke){g.stroke(p);}}register('rect',render$4);register('circle',render$3);register('line',render$2);register('path',render);register('text',render$1);function rendererComponent$2(picasso){picasso.renderer('canvas',renderer$2);}function diff(from,to){const added=[];let items;const removed=[];const updatedNew=[];const updatedOld=[];let fromIds;let toIds;const idMapper=a=>a.id;const nodeMapper=(node,i)=>{let id;if(typeof node==='object'){if('id'in node){id=node.id;}else {id=i;}}else {id=node;}return {content:node,id:"".concat(id,"__").concat(node.type||'')};};if(!from.isTree){from=from.map(nodeMapper);}to=to.map(nodeMapper);fromIds=from.map(idMapper);toIds=to.map(idMapper);// TODO - handle duplicate values
  // added = to.filter( v => fromIds.indexOf( v.id ) < 0 );
  // updatedNew = to.filter( v => fromIds.indexOf( v.id ) >= 0 );
  // removed = from.filter( v => toIds.indexOf( v.id ) < 0 );
  // updatedOld = from.filter( v => toIds.indexOf( v.id ) >= 0 );
  for(let i=0,len=to.length;i<len;i++){const idx=fromIds.indexOf(to[i].id);if(idx===-1){added.push(to[i]);}else {updatedNew.push(to[i]);}}for(let i=0,len=from.length;i<len;i++){const idx=toIds.indexOf(from[i].id);if(idx===-1){removed.push(from[i]);}else {updatedOld.push(from[i]);}}for(let i=0,len=added.length;i<len;i++){if(added[i].content.children){added[i].diff=diff([],added[i].content.children);added[i].children=added[i].diff.updatedNew.concat(added[i].diff.added);added[i].children.isTree=true;}}for(let i=0,len=updatedNew.length;i<len;i++){updatedNew[i].diff=diff(updatedOld[i].children||[],updatedNew[i].content.children||[]);updatedNew[i].object=updatedOld[i].object;updatedNew[i].children=updatedNew[i].diff.items;}items=updatedNew.concat(added);added.isTree=true;removed.isTree=true;updatedNew.isTree=true;updatedOld.isTree=true;items.isTree=true;return {added,updatedNew,updatedOld,removed,items};}function createNodes(nodes,parent,create){for(let i=0,len=nodes.length;i<len;i++){nodes[i].object=create(nodes[i].content.type,parent);}}function destroyNodes(nodes,destroy){for(let i=0,len=nodes.length;i<len;i++){if(nodes[i].object!==null&&typeof nodes[i].object!=='undefined'){destroy(nodes[i].object);nodes[i].object=null;}}}function updateNodes(nodes,creator,maintainer,destroyer){let item;for(let i=0,len=nodes.length;i<len;i++){item=nodes[i];if(item.object!==null&&typeof item.object!=='undefined'){maintainer(item.object,item.content);if(item.diff){createNodes(item.diff.added,item.object,creator);destroyNodes(item.diff.removed,destroyer);updateNodes(item.diff.items,creator,maintainer,destroyer);}}}}function createTree(oldItems,newItems,root,creator,maintainer,destroyer){const d=diff(oldItems,newItems);createNodes(d.added,root,creator);destroyNodes(d.removed,destroyer);updateNodes(d.items,creator,maintainer,destroyer);return d.items;}const svgNs='http://www.w3.org/2000/svg';// const badValues = ['', NaN, 'NaN', undefined, null, false, true];
  const creator=(type,parent)=>{if(!type||typeof type!=='string'){throw new Error("Invalid type: ".concat(type));}const el=parent.ownerDocument.createElementNS(svgNs,type==='container'?'g':type);parent.appendChild(el);return el;};const destroyer=el=>{if(el.parentNode){el.parentNode.removeChild(el);}};// isValid - is a way to bring a more consistent rendering behaviour between SVG and canvas.
  // Where SVG would treat NaN values as 0, canvas would simple not render anything.
  const isValid=item=>{switch(item.type){case'circle':return !isNaN(item.attrs.cx)&&!isNaN(item.attrs.cy)&&!isNaN(item.attrs.r);case'line':return !isNaN(item.attrs.x1)&&!isNaN(item.attrs.y1)&&!isNaN(item.attrs.x2)&&!isNaN(item.attrs.y2);case'rect':return !isNaN(item.attrs.x)&&!isNaN(item.attrs.y)&&!isNaN(item.attrs.width)&&!isNaN(item.attrs.height);case'text':return !isNaN(item.attrs.x)&&!isNaN(item.attrs.y);default:return true;}};const maintainer=(element,item)=>{if(isValid(item)){for(const attr in item.attrs){if(attr==='stroke'&&item.strokeReference){element.setAttribute('stroke',item.strokeReference);}else if(attr==='fill'&&item.fillReference){element.setAttribute('fill',item.fillReference);}else if(attr==='text'){element.setAttribute('style','white-space: pre');element.textContent=item.ellipsed||ellipsText(item.attrs,measureText);const dir=detectTextDirection(item.attrs.text);if(dir==='rtl'){element.setAttribute('direction','rtl');element.setAttribute('dir','rtl');element.setAttribute('text-anchor',flipTextAnchor(element.getAttribute('text-anchor'),dir));}}else if(item.type==='text'&&(attr==='dy'||attr==='dominant-baseline')){const dy=+element.getAttribute(attr)||0;let val=0;if(attr==='dominant-baseline'){val=baselineHeuristic(item.attrs);}else {val=item.attrs[attr];}element.setAttribute('dy',val+dy);}else if(item.type==='text'&&attr==='title'&&item.attrs.title){const t=element.ownerDocument.createElementNS(svgNs,'title');t.textContent=item.attrs.title;element.appendChild(t);}else {element.setAttribute(attr,item.attrs[attr]);}}if(typeof item.data==='string'||typeof item.data==='number'||typeof item.data==='boolean'){element.setAttribute('data',item.data);}else if(typeof item.data==='object'&&item.data!==null){for(const d in item.data){if(typeof item.data[d]==='string'||typeof item.data[d]==='number'||typeof item.data[d]==='boolean'){element.setAttribute("data-".concat(d),item.data[d]);}}}}};class TreeItemRenderer{/**
     * Constructor
     * @private
     * @param  {TreeCreator} treeCreator - Function used to create the DOM tree..
     * @param  {SVGCreator} nodeCreator - Function used to create nodes.
     * @param  {SVGMaintainer} nodeMaintainer - Function used to update nodes.
     * @param  {SVGDestroyer} nodeDestroyer - Function used to destroy nodes.
     */constructor(treeCreator,nodeCreator,nodeMaintainer,nodeDestroyer){this.create=treeCreator;this.nodeCreator=nodeCreator;this.nodeMaintainer=nodeMaintainer;this.nodeDestroyer=nodeDestroyer;}render(newItems,root){return this.create([],newItems,root,this.nodeCreator,this.nodeMaintainer,this.nodeDestroyer);}}function tree(){return new TreeItemRenderer(createTree,creator,maintainer,destroyer);}/**
   * Create an SVGElement and attach to parent.
   * @private
   * @callback SVGCreator
   * @param {String} type - The type of element to create.
   * @param {SVGElement} parent - The parent element to append the new element to.
   * @return {SVGElement} The created element
   */ /**
   * Update the element with content from item.
   * @private
   * @callback SVGMaintainer
   * @param {SVGElement} el - The element to update
   * @param {Object} item - The object to use as input for the update
   */ /**
   * Detach element from its parent.
   * @private
   * @callback SVGDestroyer
   * @param {SVGElement} el - Element to destroy.
   */ /**
   * Create, update and destroy nodes.
   * @private
   * @callback TreeCreator
   * @param {Object[]} existing - The existing items in the tree.
   * @param {Object[]} active - The new items to create the tree from.
   * @param {SVGCreator} creator - Function used to create nodes.
   * @param {SVGMaintainer} maintainer - Function used to update nodes.
   * @param {SVGDestroyer} destroyer - Function used to destroy nodes.
   */ /* eslint import/prefer-default-export: 0 */ /**
   * Hash an object
   * Modified version of Java's HashCode function
   * Source: {@link http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/}
   * @ignore
   *
   * @param  {Object} item Item to hash
   * @return {String}      Unique hash id
   */function hashObject(item){let hash=0;let i;let chr;let len;item=JSON.stringify(item);if(item.length===0){return hash;}for(i=0,len=item.length;i<len;i++){chr=item.charCodeAt(i);hash=(hash<<5)-hash+chr;hash&=hash;// Convert to 32bit integer
  }return hash;}function gradienter(bucket){let hasher=arguments.length>1&&arguments[1]!==undefined?arguments[1]:hashObject;let cache={};let uid=Date.now();const p={getOrCreateGradient(){let item=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let attr=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'fill';let url=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'';let gradientHash=hasher(item[attr]);let gradientId="picasso-gradient-".concat(uid,"-").concat(gradientHash);if(!cache[gradientHash]){let{orientation,degree,stops=[]}=item[attr];let gradient={};if(degree===undefined){degree=90;}// Default to linear
  if(orientation==='radial'){gradient.type='radialGradient';}else {gradient=degreesToPoints(degree);['x1','x2','y1','y2'].forEach(c=>{if(c in item[attr]){gradient[c]=item[attr][c];}});gradient.type='linearGradient';}gradient.id=gradientId;gradient.children=stops.map(_ref=>{let{offset,color,opacity}=_ref;return {type:'stop',offset:"".concat(offset*100,"%"),style:"stop-color:".concat(color,";stop-opacity:").concat(typeof opacity!=='undefined'?opacity:1)};});bucket.push(gradient);cache[gradientHash]=gradientId;}return "url('".concat(url,"#").concat(gradientId,"')");},onCreate(state){let url='';if(typeof window!=='undefined'){url=window.location.href.split('#')[0];}const item=state.node;if(item.fill&&typeof item.fill==='object'&&item.fill.type==='gradient'){item.fillReference=p.getOrCreateGradient(item,'fill',url);}if(item.stroke&&typeof item.stroke==='object'&&item.stroke.type==='gradient'){item.strokeReference=p.getOrCreateGradient(item,'stroke',url);}},clear(){cache={};}};return p;}function patternizer(bucket){let hasher=arguments.length>1&&arguments[1]!==undefined?arguments[1]:hashObject;let cache={};let uid=Date.now();const p={onCreate(state){let inputs={};if(state.node&&typeof state.node.fill==='object'&&state.node.fill.type==='pattern'&&state.node.fill.shapes){inputs.fill=state.node.fill;}if(state.node&&typeof state.node.stroke==='object'&&state.node.stroke.type==='pattern'&&state.node.stroke.shapes){inputs.stroke=state.node.stroke;}Object.keys(inputs).forEach(key=>{let url='';const input=inputs[key];const patternHash=hasher(input);const pnid="picasso-pattern-".concat(uid,"-").concat(patternHash);if(typeof window!=='undefined'){url=window.location.href.split('#')[0];}if(!cache[patternHash]){const pn={patternUnits:'userSpaceOnUse',x:0,y:0,width:input.width,height:input.height,type:'pattern',id:pnid,children:[],fill:input.fill};input.shapes.forEach(s=>{pn.children.push(s);});bucket.push(pn);cache[patternHash]=true;}state.node["".concat(key,"Reference")]="url('".concat(url,"#").concat(pnid,"')");});},clear(){cache={};}};return p;}/**
   * Create a new svg renderer
   * @typedef {function} svgRendererFactory
   * @param {function} [treeFactory] - Node tree factory
   * @param {string} [ns] - Namespace definition
   * @param {function} [sceneFn] - Scene factory
   * @returns {Renderer} A svg renderer instance
   */function renderer$1(){let treeFn=arguments.length>0&&arguments[0]!==undefined?arguments[0]:tree;let ns=arguments.length>1&&arguments[1]!==undefined?arguments[1]:svgNs;let sceneFn=arguments.length>2&&arguments[2]!==undefined?arguments[2]:scene;const tree$1=treeFn();let el;let group;let hasChangedRect=false;let rect=createRendererBox();let scene$1;const settings={transform:undefined};const svg=create$q();const defs={type:'defs',children:[]};const patterns=patternizer(defs.children);const gradients=gradienter(defs.children);svg.element=()=>el;svg.root=()=>group;svg.settings=rendererSettings=>{if(rendererSettings){Object.keys(settings).forEach(key=>{if(rendererSettings[key]!==undefined){settings[key]=rendererSettings[key];}});}return settings;};svg.appendTo=element=>{if(!el){el=element.ownerDocument.createElementNS(ns,'svg');el.style.position='absolute';el.style['-webkit-font-smoothing']='antialiased';el.style['-moz-osx-font-smoothing']='antialiased';el.style.pointerEvents='none';el.setAttribute('xmlns',ns);group=element.ownerDocument.createElementNS(ns,'g');group.style.pointerEvents='auto';el.appendChild(group);}element.appendChild(el);return el;};svg.getScene=nodes=>{const scaleX=rect.scaleRatio.x;const scaleY=rect.scaleRatio.y;const sceneContainer={type:'container',children:Array.isArray(nodes)?[...nodes,defs]:nodes,transform:rect.edgeBleed.bool?"translate(".concat(rect.edgeBleed.left*scaleX,", ").concat(rect.edgeBleed.top*scaleY,")"):''};if(scaleX!==1||scaleY!==1){sceneContainer.transform+="scale(".concat(scaleX,", ").concat(scaleY,")");}return sceneFn({items:[sceneContainer],on:{create:[state=>{state.node.fillReference=undefined;state.node.strokeReference=undefined;},gradients.onCreate,patterns.onCreate,onLineBreak(svg.measureText),injectTextBoundsFn(svg)]}});};svg.render=nodes=>{if(!el){return false;}const transformation=typeof settings.transform==='function'&&settings.transform();if(transformation){const{a,b,c,d,e,f}=transformation;group.style.transform="matrix(".concat(a,", ").concat(b,", ").concat(c,", ").concat(d,", ").concat(e,", ").concat(f,")");return true;}group.style.transform='';if(hasChangedRect){el.style.left="".concat(rect.computedPhysical.x,"px");el.style.top="".concat(rect.computedPhysical.y,"px");el.setAttribute('width',rect.computedPhysical.width);el.setAttribute('height',rect.computedPhysical.height);}gradients.clear();patterns.clear();defs.children.length=0;const newScene=svg.getScene(nodes);const hasChangedScene=scene$1?!newScene.equals(scene$1):true;const doRender=hasChangedRect||hasChangedScene;if(doRender){svg.clear();tree$1.render(newScene.children,group);}hasChangedRect=false;scene$1=newScene;return doRender;};svg.itemsAt=input=>scene$1?scene$1.getItemsFrom(input):[];svg.findShapes=selector=>scene$1?scene$1.findShapes(selector):[];svg.clear=()=>{if(!group){return svg;}scene$1=null;const g=group.cloneNode(false);el.replaceChild(g,group);group=g;return svg;};svg.destroy=()=>{// parentElement is not supported in IE11 for SVGElement.
  if(el&&el.parentNode){el.parentNode.removeChild(el);}el=null;group=null;};svg.size=opts=>{if(opts){const newRect=createRendererBox(opts);if(JSON.stringify(rect)!==JSON.stringify(newRect)){hasChangedRect=true;rect=newRect;}}return rect;};return svg;}function rendererComponent$1(picasso){picasso.renderer('svg',renderer$1);}var n,l,u,t,r$2,o,f,c={},s=[],a=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function h(n,l){for(var u in l)n[u]=l[u];return n;}function v(n){var l=n.parentNode;l&&l.removeChild(n);}function y(l,u,i){var t,r,o,f={};for(o in u)"key"==o?t=u[o]:"ref"==o?r=u[o]:f[o]=u[o];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),"function"==typeof l&&null!=l.defaultProps)for(o in l.defaultProps)void 0===f[o]&&(f[o]=l.defaultProps[o]);return p$1(l,f,t,r,null);}function p$1(n,i,t,r,o){var f={type:n,props:i,key:t,ref:r,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==o?++u:o};return null==o&&null!=l.vnode&&l.vnode(f),f;}function _(n){return n.children;}function k(n,l){this.props=n,this.context=l;}function b(n,l){if(null==l)return n.__?b(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return "function"==typeof n.type?b(n):null;}function g(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break;}return g(n);}}function m$1(n){(!n.__d&&(n.__d=!0)&&t.push(n)&&!w.__r++||r$2!==l.debounceRendering)&&((r$2=l.debounceRendering)||o)(w);}function w(){var n,l,u,i,r,o,e,c;for(t.sort(f);n=t.shift();)n.__d&&(l=t.length,i=void 0,r=void 0,e=(o=(u=n).__v).__e,(c=u.__P)&&(i=[],(r=h({},o)).__v=o.__v+1,L(c,o,r,u.__n,void 0!==c.ownerSVGElement,null!=o.__h?[e]:null,i,null==e?b(o):e,o.__h),M(i,o),o.__e!=e&&g(o)),t.length>l&&t.sort(f));w.__r=0;}function x(n,l,u,i,t,r,o,f,e,a){var h,v,y,d,k,g,m,w=i&&i.__k||s,x=w.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(d=u.__k[h]=null==(d=l[h])||"boolean"==typeof d||"function"==typeof d?null:"string"==typeof d||"number"==typeof d||"bigint"==typeof d?p$1(null,d,null,null,d):Array.isArray(d)?p$1(_,{children:d},null,null,null):d.__b>0?p$1(d.type,d.props,d.key,d.ref?d.ref:null,d.__v):d)){if(d.__=u,d.__b=u.__b+1,null===(y=w[h])||y&&d.key==y.key&&d.type===y.type)w[h]=void 0;else for(v=0;v<x;v++){if((y=w[v])&&d.key==y.key&&d.type===y.type){w[v]=void 0;break;}y=null;}L(n,d,y=y||c,t,r,o,f,e,a),k=d.__e,(v=d.ref)&&y.ref!=v&&(m||(m=[]),y.ref&&m.push(y.ref,null,d),m.push(v,d.__c||k,d)),null!=k?(null==g&&(g=k),"function"==typeof d.type&&d.__k===y.__k?d.__d=e=A(d,e,n):e=C(n,d,y,w,k,e),"function"==typeof u.type&&(u.__d=e)):e&&y.__e==e&&e.parentNode!=n&&(e=b(y));}for(u.__e=g,h=x;h--;)null!=w[h]&&("function"==typeof u.type&&null!=w[h].__e&&w[h].__e==u.__d&&(u.__d=$(i).nextSibling),S(w[h],w[h]));if(m)for(h=0;h<m.length;h++)O(m[h],m[++h],m[++h]);}function A(n,l,u){for(var i,t=n.__k,r=0;t&&r<t.length;r++)(i=t[r])&&(i.__=n,l="function"==typeof i.type?A(i,l,u):C(u,i,i,t,i.__e,l));return l;}function C(n,l,u,i,t,r){var o,f,e;if(void 0!==l.__d)o=l.__d,l.__d=void 0;else if(null==u||t!=r||null==t.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(t),o=null;else {for(f=r,e=0;(f=f.nextSibling)&&e<i.length;e+=1)if(f==t)break n;n.insertBefore(t,r),o=r;}return void 0!==o?o:t.nextSibling;}function $(n){var l,u,i;if(null==n.type||"string"==typeof n.type)return n.__e;if(n.__k)for(l=n.__k.length-1;l>=0;l--)if((u=n.__k[l])&&(i=$(u)))return i;return null;}function H(n,l,u,i,t){var r;for(r in u)"children"===r||"key"===r||r in l||T(n,r,null,u[r],i);for(r in l)t&&"function"!=typeof l[r]||"children"===r||"key"===r||"value"===r||"checked"===r||u[r]===l[r]||T(n,r,l[r],u[r],i);}function I(n,l,u){"-"===l[0]?n.setProperty(l,null==u?"":u):n[l]=null==u?"":"number"!=typeof u||a.test(l)?u:u+"px";}function T(n,l,u,i,t){var r;n:if("style"===l){if("string"==typeof u)n.style.cssText=u;else {if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||I(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||I(n.style,l,u[l]);}}else if("o"===l[0]&&"n"===l[1])r=l!==(l=l.replace(/Capture$/,"")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+r]=u,u?i||n.addEventListener(l,r?z:j,r):n.removeEventListener(l,r?z:j,r);else if("dangerouslySetInnerHTML"!==l){if(t)l=l.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if("width"!==l&&"height"!==l&&"href"!==l&&"list"!==l&&"form"!==l&&"tabIndex"!==l&&"download"!==l&&l in n)try{n[l]=null==u?"":u;break n;}catch(n){}"function"==typeof u||(null==u||!1===u&&"-"!==l[4]?n.removeAttribute(l):n.setAttribute(l,u));}}function j(n){return this.l[n.type+!1](l.event?l.event(n):n);}function z(n){return this.l[n.type+!0](l.event?l.event(n):n);}function L(n,u,i,t,r,o,f,e,c){var s,a,v,y,p,d,b,g,m,w,A,P,C,$,H,I=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,o=[e]),(s=l.__b)&&s(u);try{n:if("function"==typeof I){if(g=u.props,m=(s=I.contextType)&&t[s.__c],w=s?m?m.props.value:s.__:t,i.__c?b=(a=u.__c=i.__c).__=a.__E:("prototype"in I&&I.prototype.render?u.__c=a=new I(g,w):(u.__c=a=new k(g,w),a.constructor=I,a.render=q$1),m&&m.sub(a),a.props=g,a.state||(a.state={}),a.context=w,a.__n=t,v=a.__d=!0,a.__h=[],a._sb=[]),null==a.__s&&(a.__s=a.state),null!=I.getDerivedStateFromProps&&(a.__s==a.state&&(a.__s=h({},a.__s)),h(a.__s,I.getDerivedStateFromProps(g,a.__s))),y=a.props,p=a.state,a.__v=u,v)null==I.getDerivedStateFromProps&&null!=a.componentWillMount&&a.componentWillMount(),null!=a.componentDidMount&&a.__h.push(a.componentDidMount);else {if(null==I.getDerivedStateFromProps&&g!==y&&null!=a.componentWillReceiveProps&&a.componentWillReceiveProps(g,w),!a.__e&&null!=a.shouldComponentUpdate&&!1===a.shouldComponentUpdate(g,a.__s,w)||u.__v===i.__v){for(u.__v!==i.__v&&(a.props=g,a.state=a.__s,a.__d=!1),a.__e=!1,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u);}),A=0;A<a._sb.length;A++)a.__h.push(a._sb[A]);a._sb=[],a.__h.length&&f.push(a);break n;}null!=a.componentWillUpdate&&a.componentWillUpdate(g,a.__s,w),null!=a.componentDidUpdate&&a.__h.push(function(){a.componentDidUpdate(y,p,d);});}if(a.context=w,a.props=g,a.__P=n,P=l.__r,C=0,"prototype"in I&&I.prototype.render){for(a.state=a.__s,a.__d=!1,P&&P(u),s=a.render(a.props,a.state,a.context),$=0;$<a._sb.length;$++)a.__h.push(a._sb[$]);a._sb=[];}else do{a.__d=!1,P&&P(u),s=a.render(a.props,a.state,a.context),a.state=a.__s;}while(a.__d&&++C<25);a.state=a.__s,null!=a.getChildContext&&(t=h(h({},t),a.getChildContext())),v||null==a.getSnapshotBeforeUpdate||(d=a.getSnapshotBeforeUpdate(y,p)),H=null!=s&&s.type===_&&null==s.key?s.props.children:s,x(n,Array.isArray(H)?H:[H],u,i,t,r,o,f,e,c),a.base=u.__e,u.__h=null,a.__h.length&&f.push(a),b&&(a.__E=a.__=null),a.__e=!1;}else null==o&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=N(i.__e,u,i,t,r,o,f,c);(s=l.diffed)&&s(u);}catch(n){u.__v=null,(c||null!=o)&&(u.__e=e,u.__h=!!c,o[o.indexOf(e)]=null),l.__e(n,u,i);}}function M(n,u){l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u);});}catch(n){l.__e(n,u.__v);}});}function N(l,u,i,t,r,o,f,e){var s,a,h,y=i.props,p=u.props,d=u.type,_=0;if("svg"===d&&(r=!0),null!=o)for(;_<o.length;_++)if((s=o[_])&&"setAttribute"in s==!!d&&(d?s.localName===d:3===s.nodeType)){l=s,o[_]=null;break;}if(null==l){if(null===d)return document.createTextNode(p);l=r?document.createElementNS("http://www.w3.org/2000/svg",d):document.createElement(d,p.is&&p),o=null,e=!1;}if(null===d)y===p||e&&l.data===p||(l.data=p);else {if(o=o&&n.call(l.childNodes),a=(y=i.props||c).dangerouslySetInnerHTML,h=p.dangerouslySetInnerHTML,!e){if(null!=o)for(y={},_=0;_<l.attributes.length;_++)y[l.attributes[_].name]=l.attributes[_].value;(h||a)&&(h&&(a&&h.__html==a.__html||h.__html===l.innerHTML)||(l.innerHTML=h&&h.__html||""));}if(H(l,p,y,r,e),h)u.__k=[];else if(_=u.props.children,x(l,Array.isArray(_)?_:[_],u,i,t,r&&"foreignObject"!==d,o,f,o?o[0]:i.__k&&b(i,0),e),null!=o)for(_=o.length;_--;)null!=o[_]&&v(o[_]);e||("value"in p&&void 0!==(_=p.value)&&(_!==l.value||"progress"===d&&!_||"option"===d&&_!==y.value)&&T(l,"value",_,y.value,!1),"checked"in p&&void 0!==(_=p.checked)&&_!==l.checked&&T(l,"checked",_,y.checked,!1));}return l;}function O(n,u,i){try{"function"==typeof n?n(u):n.current=u;}catch(n){l.__e(n,i);}}function S(n,u,i){var t,r;if(l.unmount&&l.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||O(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount();}catch(n){l.__e(n,u);}t.base=t.__P=null,n.__c=void 0;}if(t=n.__k)for(r=0;r<t.length;r++)t[r]&&S(t[r],u,i||"function"!=typeof n.type);i||null==n.__e||v(n.__e),n.__=n.__e=n.__d=void 0;}function q$1(n,l,u){return this.constructor(n,u);}function B(u,i,t){var r,o,f;l.__&&l.__(u,i),o=(r="function"==typeof t)?null:t&&t.__k||i.__k,f=[],L(i,u=(!r&&t||i).__k=y(_,null,[u]),o||c,c,void 0!==i.ownerSVGElement,!r&&t?[t]:o?null:i.firstChild?n.call(i.childNodes):null,f,!r&&t?t:o?o.__e:i.firstChild,r),M(f,u);}n=s.slice,l={__e:function(n,l,u,i){for(var t,r,o;l=l.__;)if((t=l.__c)&&!t.__)try{if((r=t.constructor)&&null!=r.getDerivedStateFromError&&(t.setState(r.getDerivedStateFromError(n)),o=t.__d),null!=t.componentDidCatch&&(t.componentDidCatch(n,i||{}),o=t.__d),o)return t.__E=t;}catch(l){n=l;}throw n;}},u=0,k.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=h({},this.state),"function"==typeof n&&(n=n(h({},u),this.props)),n&&h(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),m$1(this));},k.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),m$1(this));},k.prototype.render=_,t=[],o="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,f=function(n,l){return n.__v.__b-l.__v.__b;},w.__r=0;function renderer(){let opts=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{createElement=document.createElement.bind(document)}=opts;let el;let rect=createRendererBox();let dNode;const settings={transform:undefined};const dom=create$q();dom.element=()=>el;dom.root=()=>el;dom.settings=rendererSettings=>{if(rendererSettings){Object.keys(settings).forEach(key=>{if(rendererSettings[key]!==undefined){settings[key]=rendererSettings[key];}});}return settings;};dom.appendTo=element=>{if(!el){el=createElement('div');el.style.position='absolute';el.style['-webkit-font-smoothing']='antialiased';el.style['-moz-osx-font-smoothing']='antialiased';el.style.pointerEvents='none';}element.appendChild(el);return el;};dom.render=nodes=>{if(!el){return false;}const transformation=typeof settings.transform==='function'&&settings.transform();if(transformation){const{a,b,c,d,e,f}=transformation;el.style.transform="matrix(".concat(a,", ").concat(b,", ").concat(c,", ").concat(d,", ").concat(e,", ").concat(f,")");return true;}el.style.transform='';el.style.left="".concat(rect.computedPhysical.x,"px");el.style.top="".concat(rect.computedPhysical.y,"px");el.style.width="".concat(rect.computedPhysical.width,"px");el.style.height="".concat(rect.computedPhysical.height,"px");let vNode;if(Array.isArray(nodes)){vNode=y("div",null,nodes);}else {vNode=nodes;}dNode=B(vNode,el,dNode);return true;};dom.renderArgs=[y];// Arguments to render functions using the DOM renderer
  dom.clear=()=>{if(el){let first=el.firstChild;while(first){el.removeChild(first);first=el.firstChild;}dNode=null;}return dom;};dom.destroy=()=>{if(el&&el.parentElement){el.parentElement.removeChild(el);}el=null;dNode=null;};dom.size=inner=>{if(inner){rect=createRendererBox(inner);}return rect;};return dom;}function rendererComponent(picasso){picasso.renderer('dom',renderer);}var renderers=[rendererComponent$1,rendererComponent$2,rendererComponent];var scales=[];const LOG_LEVEL={OFF:0,ERROR:1,WARN:2,INFO:3,DEBUG:4};const loggerFn=function(){let{level=LOG_LEVEL.OFF,pipe=console}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let currentlevel=level;const LOG_FN={[LOG_LEVEL.OFF]:()=>{},[LOG_LEVEL.ERROR]:function(){return pipe.error(...arguments);},[LOG_LEVEL.WARN]:function(){return pipe.warn(...arguments);},[LOG_LEVEL.INFO]:function(){return pipe.info(...arguments);},[LOG_LEVEL.DEBUG]:function(){return pipe.log(...arguments);}};const log=function(lev){if(!lev||currentlevel<lev){return;}for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}(LOG_FN[lev]||LOG_FN[LOG_LEVEL.DEBUG])(...args);};/**
     * @typedef {object} logger
     * @private
     */return/** @lends logger */{/**
         * Log a message
         * @param {number} lev - The log level
         * @param {...any} args
         * @kind function
         */log,/**
         * Log an error message
         * @param {...any} args
         */error:function(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}return log(LOG_LEVEL.ERROR,...args);},/**
         * Log a warning message
         * @param {...any} args
         */warn:function(){for(var _len3=arguments.length,args=new Array(_len3),_key3=0;_key3<_len3;_key3++){args[_key3]=arguments[_key3];}return log(LOG_LEVEL.WARN,...args);},/**
         * Log an info message
         * @param {...any} args
         */info:function(){for(var _len4=arguments.length,args=new Array(_len4),_key4=0;_key4<_len4;_key4++){args[_key4]=arguments[_key4];}return log(LOG_LEVEL.INFO,...args);},/**
         * Log a debug message
         * @param {...any} args
         */debug:function(){for(var _len5=arguments.length,args=new Array(_len5),_key5=0;_key5<_len5;_key5++){args[_key5]=arguments[_key5];}return log(LOG_LEVEL.DEBUG,...args);},/**
         * Set the current log level
         * @param {number} lev - The log level
         */level:lev=>{if(typeof lev==='number'){currentlevel=lev;}return currentlevel;},LOG_LEVEL};};const palettes=[{key:'categorical',colors:[['#a54343','#d76c6c','#ec983d','#ecc43d','#f9ec86','#cbe989','#70ba6e','#578b60','#79d69f','#26a0a7','#138185','#65d3da']// breeze colors
  ]},{key:'diverging',colors:[['#3d52a1','#3a89c9','#77b7e5','#b4ddf7','#e6f5fe','#ffe3aa','#f9bd7e','#ed875e','#d24d3e','#ae1c3e']]},{key:'sequential',colors:[['rgb(180,221,212)','rgb(34, 83, 90)']]}];/* eslint quote-props: 0 */const style$1={// -- FOUNDATION --
  // fonts
  '$font-family':"'Source Sans Pro', Arial, sans-serif",'$font-size':'12px','$line-height':'16px','$font-size--l':'16px','$font-weight':'normal',// base grays
  '$gray-100':'#ffffff','$gray-98':'#f9f9f9','$gray-95':'#f2f2f2','$gray-90':'#e6e6e6','$gray-35':'#595959','$gray-30':'#4d4d4d','$gray-25':'#404040','$gray-20':'#333333',// borders
  '$border-95':'rgba(255, 255, 255, 0.05)','$border-90':'rgba(255, 255, 255, 0.1)','$border-80':'rgba(255, 255, 255, 0.2)','$border-20':'rgba(0, 0, 0, 0.2)','$border-10':'rgba(0, 0, 0, 0.1)','$border-5':'rgba(0, 0, 0, 0.05)',// primary colors
  '$primary-blue':'#3F8AB3','$primary-green':'#6CB33F','$primary-red':'#DC423F','$primary-orange':'#EF960F',// spacing
  '$spacing--s':4,$spacing:8,'$spacing--l':12,// -------------------------
  // -- ALIASES --
  '$font-color':'$gray-35','$font-color--inverted':'$gray-90','$guide-color':'$gray-90','$guide-color--inverted':'$gray-35',$border:'$border-80','$border--inverted':'$border-10',// -------------------------
  // -- MIXINS --
  // data points
  $shape:{// data shape
  fill:'$primary-blue',strokeWidth:1,stroke:'$border'},'$shape-outline':{// data shape which usually does not have a fill, e.g. the line in a linechart
  stroke:'$primary-blue',strokeWidth:2},'$shape-guide':{// lines that somehow belongs to a data shape, e.g. whiskers in a boxplot
  stroke:'$guide-color',strokeWidth:1},'$shape-guide--inverted':{'@extend':'$shape-guide',stroke:'$guide-color--inverted'},$label:{fontSize:'$font-size',fontFamily:'$font-family',fill:'$font-color'},'$label--inverted':{$extend:'$label',fill:'$font-color--inverted'},// user interface
  '$label-overlay':{// e.g. selection range bubble
  fontSize:'$font-size--l',fontFamily:'$font-family',fill:'$gray-100',// background fill
  color:'$font-color',stroke:'$guide-color--inverted',strokeWidth:1,borderRadius:4},$title:{'@extend':'$label',fontSize:'$font-size--l',fontWeight:'$font-weight',stroke:'$guide-color--inverted',strokeWidth:0},'$guide-line':{strokeWidth:1,stroke:'$guide-color'},'$guide-line--minor':{strokeWidth:1,stroke:'$gray-95'// needs alias
  },'$padding--s':{left:'$spacing--s',right:'$spacing--s',top:'$spacing--s',bottom:'$spacing--s'},$padding:{left:'$spacing',right:'$spacing',top:'$spacing',bottom:'$spacing'},'$selection-area-target':{fill:'$primary-green',strokeWidth:0,opacity:0.2}};function usePlugin(plugin){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let api=arguments.length>2?arguments[2]:undefined;plugin(api,options);}function pic(){let config=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let registries=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const logger=loggerFn(config.logger);/**
     * @lends picassojs
     */const regis={// -- registries --
  /**
       * Component registry
       * @type {registry}
       */component:registryFactory(registries.component,'component',logger),/**
       * Data registry
       * @type {registry}
       */data:registryFactory(registries.data,'data',logger),/**
       * Formatter registry
       * @type {registry}
       */formatter:registryFactory(registries.formatter,'formatter',logger),/**
       * Interaction registry
       * @type {registry}
       */interaction:registryFactory(registries.interaction,'interaction',logger),/**
       * Renderer registry
       * @type {registry}
       * @example
       * const svgFactory = picassojs.renderer('svg');
       * const svgRenderer = svgFactory();
       */renderer:rendererRegistry(registries.renderer),/**
       * Scale registry
       * @type {registry}
       */scale:registryFactory(registries.scale,'scale',logger),/**
       * Symbol registry
       * @type {registry}
       * @private
       */symbol:registryFactory(registries.symbol,'symbol',logger),// -- misc --
  /**
       * log some some stuff
       * @type {logger}
       * @private
       */logger};if(config.renderer&&config.renderer.prio){regis.renderer.default(config.renderer.prio[0]);}/**
     * picasso.js entry point
     * @entry
     * @alias picassojs
     * @param {object=} cfg
     * @param {object=} cfg.renderer
     * @param {Array<string>} cfg.renderer.prio
     * @param {object=} cfg.logger
     * @param {0|1|2|3|4} cfg.logger.level
     * @param {object=} cfg.style
     * @param {Array<object>=} cfg.palettes
     * @returns {picassojs}
     * @example
     * import picasso from 'picasso.js';
     *
     * const configuredPicasso = picasso({ renderer: { prio: ['canvas'] } }) // All components will render using the canvas renderer
     */function picassojs(){let cfg=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let cc={palettes:config.palettes.concat(cfg.palettes||[]),style:extend$1({},config.style,cfg.style),logger:cfg.logger||config.logger,renderer:cfg.renderer||config.renderer};return pic(cc,regis);}/**
     * @typedef {object} Registries
     * @property {registry} component Component registry
     * @property {registry} data Data registry
     * @property {registry} formatter Formatter registry
     * @property {registry} interaction Interaction registry
     * @property {registry} renderer Renderer registry
     * @property {registry} scale Scale registry
     */ /**
     * Callback function to register a plugin
     * @callback plugin
     * @param {Registries} registries
     * @param {object} options
     */ /**
     * Plugin registry
     * @param {plugin} plugin
     * @param {object} [options]
     */picassojs.use=function(plugin){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return usePlugin(plugin,options,regis);};/**
     * @param {ChartDefinition} definition
     * @returns {Chart}
     * @example
     * picasso.chart({
      element: document.querySelector('#container'), // This is the element to render the chart in
      data: [
        {
          type: 'matrix',
          data: [
            ['Month', 'Sales', 'Margin'],
            ['Jan', 1106, 7],
            ['Feb', 5444, 53],
            ['Mar', 147, 64],
            ['Apr', 7499, 47],
            ['May', 430, 62],
            ['June', 9735, 13],
            ['July', 5832, 13],
            ['Aug', 7435, 15],
            ['Sep', 3467, 35],
            ['Oct', 3554, 78],
            ['Nov', 5633, 23],
            ['Dec', 6354, 63],
          ],
        },
      ],
      settings: {
        scales: {
          x: { data: { field: 'Margin' } },
          y: { data: { field: 'Sales' } },
        },
        components: [
          {
            // specify how to render the chart
            type: 'axis',
            scale: 'y',
            layout: {
              dock: 'left',
            },
          },
          {
            type: 'axis',
            scale: 'x',
            layout: {
              dock: 'bottom',
            },
          },
          {
            type: 'point',
            data: {
              extract: {
                field: 'Month',
                props: {
                  x: { field: 'Margin' },
                  y: { field: 'Sales' },
                },
              },
            },
            settings: {
              x: { scale: 'x' },
              y: { scale: 'y' },
              size: function () {
                return Math.random();
              },
            },
          },
        ],
      },
    });
     */picassojs.chart=definition=>chartFn(definition,{registries:regis,logger,style:config.style,palettes:config.palettes});picassojs.config=()=>config;Object.keys(regis).forEach(key=>{picassojs[key]=regis[key];});/**
     * picasso.js version
     * @type {string}
     */picassojs.version=about.version;return picassojs;}const p=pic({renderer:{prio:['svg','canvas']},logger:{level:0},style: style$1,palettes},{component:componentRegistry,data:dataRegistry,formatter:formatterRegistry,interaction:reg$3,renderer:rendererRegistry(),scale:scaleRegistry,symbol:parentReg});components.forEach(p.use);renderers.forEach(p.use);scales.forEach(p.use);

  /*
  * picasso-plugin-q v2.2.5
  * Copyright (c) 2023 QlikTech International AB
  * Released under the MIT license.
  */

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1(obj, key, value) {
    key = _toPropertyKey$1(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPrimitive$1(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey$1(arg) {
    var key = _toPrimitive$1(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var defineProperty$1 = Object.defineProperty;
  var gOPD = Object.getOwnPropertyDescriptor;
  var isArray = function isArray(arr) {
    if (typeof Array.isArray === 'function') {
      return Array.isArray(arr);
    }
    return toStr.call(arr) === '[object Array]';
  };
  var isPlainObject$1 = function isPlainObject(obj) {
    if (!obj || toStr.call(obj) !== '[object Object]') {
      return false;
    }
    var hasOwnConstructor = hasOwn.call(obj, 'constructor');
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
    // Not own constructor property must be Object
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }

    // Own properties are enumerated firstly, so to speed up,
    // if last one is own, then all properties are own.
    var key;
    for (key in obj) {/**/}
    return typeof key === 'undefined' || hasOwn.call(obj, key);
  };

  // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
  var setProperty$1 = function setProperty(target, options) {
    if (defineProperty$1 && options.name === '__proto__') {
      defineProperty$1(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
      });
    } else {
      target[options.name] = options.newValue;
    }
  };

  // Return undefined instead of __proto__ if '__proto__' is not an own property
  var getProperty = function getProperty(obj, name) {
    if (name === '__proto__') {
      if (!hasOwn.call(obj, name)) {
        return void 0;
      } else if (gOPD) {
        // In early versions of node, obj['__proto__'] is buggy when obj has
        // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
        return gOPD(obj, name).value;
      }
    }
    return obj[name];
  };
  var extend = function extend() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;

    // Handle a deep copy situation
    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[1] || {};
      // skip the boolean and the target
      i = 2;
    }
    if (target == null || typeof target !== 'object' && typeof target !== 'function') {
      target = {};
    }
    for (; i < length; ++i) {
      options = arguments[i];
      // Only deal with non-null/undefined values
      if (options != null) {
        // Extend the base object
        for (name in options) {
          src = getProperty(target, name);
          copy = getProperty(options, name);

          // Prevent never-ending loop
          if (target !== copy) {
            // Recurse if we're merging plain objects or arrays
            if (deep && copy && (isPlainObject$1(copy) || (copyIsArray = isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray(src) ? src : [];
              } else {
                clone = src && isPlainObject$1(src) ? src : {};
              }

              // Never move original objects, clone them
              setProperty$1(target, {
                name: name,
                newValue: extend(deep, clone, copy)
              });

              // Don't bring in undefined values
            } else if (typeof copy !== 'undefined') {
              setProperty$1(target, {
                name: name,
                newValue: copy
              });
            }
          }
        }
      }
    }

    // Return the modified object
    return target;
  };

  /* eslint no-nested-ternary: 0 */
  function getFieldAccessor$1(field, page, deps, columnOrder) {
    if (!field) {
      return -1;
    }
    const cache = deps.cache;
    const origin = field.origin ? field.origin() : null;
    if (origin) {
      field = origin;
    }
    let fieldIdx = cache.fields.indexOf(field);
    let attrIdx = -1;
    let attrDimIdx = -1;
    if (fieldIdx === -1) {
      for (let i = 0; i < cache.wrappedFields.length; i++) {
        attrDimIdx = cache.wrappedFields[i].attrDims.map(v => v.instance).indexOf(field);
        attrIdx = cache.wrappedFields[i].attrExps.map(v => v.instance).indexOf(field);
        if (attrDimIdx !== -1 || attrIdx !== -1) {
          fieldIdx = i;
          break;
        }
      }
    }
    if (Array.isArray(columnOrder) && columnOrder.some((el, i) => el !== i)) {
      const correctIndex = columnOrder.indexOf(fieldIdx);
      if (correctIndex !== -1) {
        fieldIdx = correctIndex;
      }
    }
    fieldIdx -= page.qArea.qLeft;
    if (fieldIdx < 0 || fieldIdx >= page.qArea.qWidth) {
      // throw new Error('Field out of range');
      return -1;
    }
    if (attrDimIdx >= 0) {
      return row => row[fieldIdx].qAttrDims.qValues[attrDimIdx];
    }
    if (attrIdx >= 0) {
      return row => row[fieldIdx].qAttrExps.qValues[attrIdx];
    }
    return row => row[fieldIdx];
  }

  // TODO - handle 'other' value
  // const specialTextValues = {
  //   '-3': (meta) => {
  //     if ('othersLabel' in meta) {
  //       return meta.othersLabel;
  //     }
  //     return '';
  //   }
  // };

  function datumExtract$1(propCfg, cell, _ref) {
    let {
      key
    } = _ref;
    const datum = {
      value: typeof propCfg.value === 'function' ? propCfg.value(cell) : typeof propCfg.value !== 'undefined' ? propCfg.value : cell // eslint-disable-line no-nested-ternary
    };

    datum.label = typeof propCfg.label === 'function' ? propCfg.label(cell) : typeof propCfg.label !== 'undefined' ? String(propCfg.label) : String(datum.value); // eslint-disable-line no-nested-ternary

    if (propCfg.field) {
      datum.source = {
        key,
        field: propCfg.field.key()
      };
    }
    return datum;
  }
  function cellToValue(_ref2) {
    let {
      cache,
      f,
      mainCell,
      p,
      prop,
      page,
      rowIdx,
      row,
      sourceKey,
      target,
      targetProp,
      columnOrder
    } = _ref2;
    let propCell = mainCell;
    if (p.field && p.field !== f) {
      const propCellFn = getFieldAccessor$1(p.field, page, {
        cache
      }, columnOrder);
      if (propCellFn === -1) {
        return;
      }
      propCell = extend({
        qRow: rowIdx
      }, propCellFn(row));
    }
    target[targetProp] = datumExtract$1(p, propCell, {
      key: sourceKey
    });
  }
  function extract$1(config, dataset, cache, util) {
    const cfgs = Array.isArray(config) ? config : [config];
    let dataItems = [];
    for (let i = 0; i < cfgs.length; i++) {
      if (typeof cfgs[i].field !== 'undefined') {
        const cube = dataset.raw();
        const sourceKey = dataset.key();
        const f = typeof cfgs[i].field === 'object' ? cfgs[i].field : dataset.field(cfgs[i].field);
        const {
          props,
          main
        } = util.normalizeConfig(cfgs[i], dataset);
        const propsArr = Object.keys(props);
        const track = !!cfgs[i].trackBy;
        const trackType = typeof cfgs[i].trackBy;
        const tracker = {};
        const trackedItems = [];
        const items = [];
        for (let j = 0; j < cube.qDataPages.length; j++) {
          const fn = getFieldAccessor$1(f, cube.qDataPages[j], {
            cache
          }, cube.qColumnOrder);
          if (fn === -1) {
            continue;
          }
          for (let k = 0; k < cube.qDataPages[j].qMatrix.length; k++) {
            const rowIdx = cube.qDataPages[j].qArea.qTop + k;
            const mainCell = extend({
              qRow: rowIdx
            }, fn(cube.qDataPages[j].qMatrix[k]));
            const ret = datumExtract$1(main, mainCell, {
              key: sourceKey
            });
            const exclude = main.filter && !main.filter(mainCell);
            if (exclude) {
              continue;
            }
            for (let l = 0; l < propsArr.length; l++) {
              const p = props[propsArr[l]];
              let arr = p.fields || [p];
              if (p.fields) {
                ret[propsArr[l]] = [];
              }

              // loop through all props that need to be mapped and
              // assign 'value' and 'source' to each property
              for (let m = 0; m < arr.length; m++) {
                cellToValue({
                  cache,
                  f,
                  mainCell,
                  p: arr[m],
                  prop: propsArr[l],
                  props,
                  page: cube.qDataPages[j],
                  rowIdx,
                  row: cube.qDataPages[j].qMatrix[k],
                  sourceKey,
                  target: p.fields ? ret[propsArr[l]] : ret,
                  targetProp: p.fields ? m : propsArr[l],
                  columnOrder: cube.qColumnOrder
                });
              }
              if (p.fields) {
                const fieldValues = ret[propsArr[l]].map(v => v.value);
                const fieldLabels = ret[propsArr[l]].map(v => v.label);
                ret[propsArr[l]] = {
                  value: typeof p.value === 'function' ? p.value(fieldValues) : typeof p.value !== 'undefined' ? p.value : fieldValues,
                  label: typeof p.label === 'function' ? p.label(fieldLabels) : typeof p.label !== 'undefined' ? String(p.label) : String(ret[propsArr[l]].value)
                };
              }
            }

            // collect items based on the trackBy value
            // items with the same trackBy value are placed in an array and reduced later
            if (track) {
              util.track({
                cfg: cfgs[i],
                itemData: mainCell,
                obj: ret,
                target: trackedItems,
                tracker,
                trackType
              });
            }
            items.push(ret);
          }
        }

        // reduce if items have been grouped
        const tmp = track ? util.collect(trackedItems, {
          main,
          propsArr,
          props
        }) : items;
        dataItems = [...dataItems, ...tmp];
      }
    }
    return dataItems;
  }
  function count(node) {
    var sum = 0,
      children = node.children,
      i = children && children.length;
    if (!i) sum = 1;else while (--i >= 0) sum += children[i].value;
    node.value = sum;
  }
  function node_count() {
    return this.eachAfter(count);
  }
  function node_each(callback, that) {
    let index = -1;
    for (const node of this) {
      callback.call(that, node, ++index, this);
    }
    return this;
  }
  function node_eachBefore(callback, that) {
    var node = this,
      nodes = [node],
      children,
      i,
      index = -1;
    while (node = nodes.pop()) {
      callback.call(that, node, ++index, this);
      if (children = node.children) {
        for (i = children.length - 1; i >= 0; --i) {
          nodes.push(children[i]);
        }
      }
    }
    return this;
  }
  function node_eachAfter(callback, that) {
    var node = this,
      nodes = [node],
      next = [],
      children,
      i,
      n,
      index = -1;
    while (node = nodes.pop()) {
      next.push(node);
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          nodes.push(children[i]);
        }
      }
    }
    while (node = next.pop()) {
      callback.call(that, node, ++index, this);
    }
    return this;
  }
  function node_find(callback, that) {
    let index = -1;
    for (const node of this) {
      if (callback.call(that, node, ++index, this)) {
        return node;
      }
    }
  }
  function node_sum(value) {
    return this.eachAfter(function (node) {
      var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
      while (--i >= 0) sum += children[i].value;
      node.value = sum;
    });
  }
  function node_sort(compare) {
    return this.eachBefore(function (node) {
      if (node.children) {
        node.children.sort(compare);
      }
    });
  }
  function node_path(end) {
    var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
    while (start !== ancestor) {
      start = start.parent;
      nodes.push(start);
    }
    var k = nodes.length;
    while (end !== ancestor) {
      nodes.splice(k, 0, end);
      end = end.parent;
    }
    return nodes;
  }
  function leastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
    a = aNodes.pop();
    b = bNodes.pop();
    while (a === b) {
      c = a;
      a = aNodes.pop();
      b = bNodes.pop();
    }
    return c;
  }
  function node_ancestors() {
    var node = this,
      nodes = [node];
    while (node = node.parent) {
      nodes.push(node);
    }
    return nodes;
  }
  function node_descendants() {
    return Array.from(this);
  }
  function node_leaves() {
    var leaves = [];
    this.eachBefore(function (node) {
      if (!node.children) {
        leaves.push(node);
      }
    });
    return leaves;
  }
  function node_links() {
    var root = this,
      links = [];
    root.each(function (node) {
      if (node !== root) {
        // Don’t include the root’s parent, if any.
        links.push({
          source: node.parent,
          target: node
        });
      }
    });
    return links;
  }
  function* node_iterator() {
    var node = this,
      current,
      next = [node],
      children,
      i,
      n;
    do {
      current = next.reverse(), next = [];
      while (node = current.pop()) {
        yield node;
        if (children = node.children) {
          for (i = 0, n = children.length; i < n; ++i) {
            next.push(children[i]);
          }
        }
      }
    } while (next.length);
  }
  function hierarchy(data, children) {
    if (data instanceof Map) {
      data = [undefined, data];
      if (children === undefined) children = mapChildren;
    } else if (children === undefined) {
      children = objectChildren;
    }
    var root = new Node(data),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;
    while (node = nodes.pop()) {
      if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
        node.children = childs;
        for (i = n - 1; i >= 0; --i) {
          nodes.push(child = childs[i] = new Node(childs[i]));
          child.parent = node;
          child.depth = node.depth + 1;
        }
      }
    }
    return root.eachBefore(computeHeight);
  }
  function node_copy() {
    return hierarchy(this).eachBefore(copyData);
  }
  function objectChildren(d) {
    return d.children;
  }
  function mapChildren(d) {
    return Array.isArray(d) ? d[1] : null;
  }
  function copyData(node) {
    if (node.data.value !== undefined) node.value = node.data.value;
    node.data = node.data.data;
  }
  function computeHeight(node) {
    var height = 0;
    do node.height = height; while ((node = node.parent) && node.height < ++height);
  }
  function Node(data) {
    this.data = data;
    this.depth = this.height = 0;
    this.parent = null;
  }
  Node.prototype = hierarchy.prototype = {
    constructor: Node,
    count: node_count,
    each: node_each,
    eachAfter: node_eachAfter,
    eachBefore: node_eachBefore,
    find: node_find,
    sum: node_sum,
    sort: node_sort,
    path: node_path,
    ancestors: node_ancestors,
    descendants: node_descendants,
    leaves: node_leaves,
    links: node_links,
    copy: node_copy,
    [Symbol.iterator]: node_iterator
  };
  function optional(f) {
    return f == null ? null : required(f);
  }
  function required(f) {
    if (typeof f !== "function") throw new Error();
    return f;
  }
  var preroot = {
      depth: -1
    },
    ambiguous = {},
    imputed = {};
  function defaultId(d) {
    return d.id;
  }
  function defaultParentId(d) {
    return d.parentId;
  }
  function stratify() {
    var id = defaultId,
      parentId = defaultParentId,
      path;
    function stratify(data) {
      var nodes = Array.from(data),
        currentId = id,
        currentParentId = parentId,
        n,
        d,
        i,
        root,
        parent,
        node,
        nodeId,
        nodeKey,
        nodeByKey = new Map();
      if (path != null) {
        const I = nodes.map((d, i) => normalize(path(d, i, data)));
        const P = I.map(parentof);
        const S = new Set(I).add("");
        for (const i of P) {
          if (!S.has(i)) {
            S.add(i);
            I.push(i);
            P.push(parentof(i));
            nodes.push(imputed);
          }
        }
        currentId = (_, i) => I[i];
        currentParentId = (_, i) => P[i];
      }
      for (i = 0, n = nodes.length; i < n; ++i) {
        d = nodes[i], node = nodes[i] = new Node(d);
        if ((nodeId = currentId(d, i, data)) != null && (nodeId += "")) {
          nodeKey = node.id = nodeId;
          nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
        }
        if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
          node.parent = nodeId;
        }
      }
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (nodeId = node.parent) {
          parent = nodeByKey.get(nodeId);
          if (!parent) throw new Error("missing: " + nodeId);
          if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
          if (parent.children) parent.children.push(node);else parent.children = [node];
          node.parent = parent;
        } else {
          if (root) throw new Error("multiple roots");
          root = node;
        }
      }
      if (!root) throw new Error("no root");

      // When imputing internal nodes, only introduce roots if needed.
      // Then replace the imputed marker data with null.
      if (path != null) {
        while (root.data === imputed && root.children.length === 1) {
          root = root.children[0], --n;
        }
        for (let i = nodes.length - 1; i >= 0; --i) {
          node = nodes[i];
          if (node.data !== imputed) break;
          node.data = null;
        }
      }
      root.parent = preroot;
      root.eachBefore(function (node) {
        node.depth = node.parent.depth + 1;
        --n;
      }).eachBefore(computeHeight);
      root.parent = null;
      if (n > 0) throw new Error("cycle");
      return root;
    }
    stratify.id = function (x) {
      return arguments.length ? (id = optional(x), stratify) : id;
    };
    stratify.parentId = function (x) {
      return arguments.length ? (parentId = optional(x), stratify) : parentId;
    };
    stratify.path = function (x) {
      return arguments.length ? (path = optional(x), stratify) : path;
    };
    return stratify;
  }

  // To normalize a path, we coerce to a string, strip the trailing slash if any
  // (as long as the trailing slash is not immediately preceded by another slash),
  // and add leading slash if missing.
  function normalize(path) {
    path = `${path}`;
    let i = path.length;
    if (slash(path, i - 1) && !slash(path, i - 2)) path = path.slice(0, -1);
    return path[0] === "/" ? path : `/${path}`;
  }

  // Walk backwards to find the first slash that is not the leading slash, e.g.:
  // "/foo/bar" ⇥ "/foo", "/foo" ⇥ "/", "/" ↦ "". (The root is special-cased
  // because the id of the root must be a truthy value.)
  function parentof(path) {
    let i = path.length;
    if (i < 2) return "";
    while (--i > 1) if (slash(path, i)) break;
    return path.slice(0, i);
  }

  // Slashes can be escaped; to determine whether a slash is a path delimiter, we
  // count the number of preceding backslashes escaping the forward slash: an odd
  // number indicates an escaped forward slash.
  function slash(path, i) {
    if (path[i] === "/") {
      let k = 0;
      while (i > 0 && path[--i] === "\\") ++k;
      if ((k & 1) === 0) return true;
    }
    return false;
  }

  /**
   * Resolves the value at the given JSON path
   * @private
   * @param  {String} path [description]
   * @param  {Object} obj  [description]
   * @return {Object}      [description]
   *
   * @example
   * let path = "/path/to/paradise";
   * let obj = {
   *   path: {
   *     to: { paradise: "heaven"},
   *     from: {...}
   *   }
   * };
   * resolve( path, obj ); // "heaven"
   */
  function resolve(path, obj) {
    if (path.charAt(0) === '/') {
      path = path.substring(1);
    }
    const arr = path.split('/');
    let subpath;
    let container = obj;
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] === '*' && Array.isArray(container)) {
        const carr = [];
        subpath = arr.slice(i + 1).join('/');
        for (let c = 0; c < container.length; c++) {
          let v = resolve(subpath, container[c]);
          // v.forEach(_ => _._parent = container[c]);
          if (Array.isArray(v)) {
            carr.push(...v);
          } else {
            carr.push(v);
          }
        }
        return carr;
        // return container.map(v => resolve(arr.slice(i + 1).join('/'), v));
      }

      if (!arr[i] && Array.isArray(container)) {
        const carr = new Array(container.length);
        subpath = arr.slice(i + 1).join('/');
        for (let c = 0; c < container.length; c++) {
          carr[c] = resolve(subpath, container[c]);
        }
        return carr;
        // return container.map(v => resolve(arr.slice(i + 1).join('/'), v));
      }

      if (arr[i] in container) {
        container = container[arr[i]];
      }
    }
    return container;
  }
  function flattenTree(children, steps, arrIndexAtTargetDepth) {
    let arr = [];
    if (!children || !children.length) {
      return arr;
    }
    if (steps <= 0) {
      const nodes = arrIndexAtTargetDepth >= 0 ? [children[arrIndexAtTargetDepth]] : children;
      arr = [...arr, ...nodes];
    } else {
      for (let i = 0; i < children.length; i++) {
        if (children[i].children && children[i].children.length) {
          arr = [...arr, ...flattenTree(children[i].children, steps - 1, arrIndexAtTargetDepth)];
        }
      }
    }
    return arr;
  }
  function treeAccessor(sourceDepth, targetDepth, arrIndexAtTargetDepth) {
    if (sourceDepth === targetDepth) {
      return d => d;
    }
    if (sourceDepth > targetDepth) {
      // traverse upwards
      const steps = Math.max(0, Math.min(100, sourceDepth - targetDepth));
      return node => {
        let n = node;
        for (let i = 0; i < steps; ++i) {
          n = n.parent;
        }
        return n;
      };
    }
    if (targetDepth > sourceDepth) {
      // flatten descendants
      const steps = Math.max(0, Math.min(100, targetDepth - sourceDepth));
      return node => flattenTree(node.children, steps - 1, arrIndexAtTargetDepth);
    }
    return false;
  }
  function findField(query, _ref) {
    let {
      cache
    } = _ref;
    if (typeof query === 'number') {
      return cache.fields[query];
    }
    const allFields = cache.allFields;
    if (typeof query === 'function') {
      for (let i = 0; i < allFields.length; i++) {
        if (query(allFields[i])) {
          return allFields[i];
        }
      }
      return false;
    }
    if (typeof query === 'string') {
      for (let i = 0; i < allFields.length; i++) {
        if (allFields[i].key() === query || allFields[i].title() === query) {
          return allFields[i];
        }
      }
    } else if (query && allFields.indexOf(query) !== -1) {
      // assume 'query' is a field instance
      return query;
    }
    throw Error("Field not found: ".concat(query));
  }
  const DIM_RX$1 = /^qDimensionInfo(?:\/(\d+))?/;
  const M_RX$1 = /^\/?qMeasureInfo\/(\d+)/;
  const ATTR_EXPR_RX$1 = /\/qAttrExprInfo\/(\d+)/;
  const ATTR_DIM_RX$1 = /\/qAttrDimInfo\/(\d+)/;
  function getColumnOrder(dataset) {
    const qColumnOrder = dataset.raw().qColumnOrder;
    const fields = dataset.fields();
    return qColumnOrder && qColumnOrder.length === fields.length ? qColumnOrder : fields.map((f, i) => i);
  }
  function getDimensionColumnOrder(cube) {
    const order = cube.qColumnOrder && cube.qColumnOrder.length ? cube.qColumnOrder : cube.qDimensionInfo.map((d, ii) => ii);
    return order.filter(ii => ii < cube.qDimensionInfo.length);
  }
  function getFieldDepth(field, _ref) {
    let {
      cube
    } = _ref;
    if (!field) {
      return -1;
    }
    let key = field.origin && field.origin() ? field.origin().key() : field.key();
    let isFieldDimension = false;
    let fieldIdx = -1; // cache.fields.indexOf(field);
    let attrIdx = -1;
    let attrDimIdx = -1;
    let fieldDepth = -1;
    let pseudoMeasureIndex = -1;
    let measureIdx = -1;
    let remainder = key;
    const treeOrder = cube.qEffectiveInterColumnSortOrder;
    const columnOrder = getDimensionColumnOrder(cube);
    if (DIM_RX$1.test(remainder)) {
      isFieldDimension = true;
      fieldIdx = +DIM_RX$1.exec(remainder)[1];
      remainder = key.replace(DIM_RX$1, '');
    }
    if (M_RX$1.test(remainder)) {
      if (cube.qMode === 'K') {
        pseudoMeasureIndex = +M_RX$1.exec(remainder)[1];
      } else if (treeOrder && treeOrder.indexOf(-1) !== -1) {
        pseudoMeasureIndex = +M_RX$1.exec(remainder)[1];
        measureIdx = 0;
      } else {
        measureIdx = +M_RX$1.exec(remainder)[1];
      }
      remainder = remainder.replace(M_RX$1, '');
    }
    if (remainder) {
      if (ATTR_DIM_RX$1.exec(remainder)) {
        attrDimIdx = +ATTR_DIM_RX$1.exec(remainder)[1];
      } else if (ATTR_EXPR_RX$1.exec(remainder)) {
        attrIdx = +ATTR_EXPR_RX$1.exec(remainder)[1];
      }
    }
    if (isFieldDimension) {
      if (cube.qMode === 'S') {
        fieldDepth = columnOrder[fieldIdx];
      } else {
        fieldDepth = treeOrder ? treeOrder.indexOf(fieldIdx) : fieldIdx;
      }
    } else if (treeOrder && treeOrder.indexOf(-1) !== -1) {
      // if pseudo dimension exists in sort order
      fieldDepth = treeOrder.indexOf(-1); // depth of pesudodimension
    } else {
      // assume measure is at the bottom of the tree
      fieldDepth = cube.qDimensionInfo.length - (cube.qMode === 'K' ? 0 : 1);
    }
    return {
      fieldDepth: fieldDepth + 1,
      // +1 due to root node
      pseudoMeasureIndex,
      measureIdx,
      attrDimIdx,
      attrIdx
    };
  }
  function getFieldAccessor(sourceDepthObject, targetDepthObject) {
    let nodeFn = treeAccessor(sourceDepthObject.fieldDepth, targetDepthObject.fieldDepth, targetDepthObject.pseudoMeasureIndex);
    let valueFn;
    if (targetDepthObject.measureIdx >= 0) {
      valueFn = node => node.data.qValues[targetDepthObject.measureIdx];
    } else {
      valueFn = node => node.data;
    }
    let attrFn;
    if (targetDepthObject.attrDimIdx >= 0) {
      attrFn = data => {
        var _data$qAttrDims;
        return data === null || data === void 0 ? void 0 : (_data$qAttrDims = data.qAttrDims) === null || _data$qAttrDims === void 0 ? void 0 : _data$qAttrDims.qValues[targetDepthObject.attrDimIdx];
      };
    } else if (targetDepthObject.attrIdx >= 0) {
      attrFn = data => {
        var _data$qAttrExps;
        return data === null || data === void 0 ? void 0 : (_data$qAttrExps = data.qAttrExps) === null || _data$qAttrExps === void 0 ? void 0 : _data$qAttrExps.qValues[targetDepthObject.attrIdx];
      };
    }
    return {
      nodeFn,
      attrFn,
      valueFn
    };
  }
  function datumExtract(propCfg, cell, _ref2) {
    let {
      key
    } = _ref2;
    const datum = {
      value: typeof propCfg.value === 'function' ? propCfg.value(cell) : typeof propCfg.value !== 'undefined' ? propCfg.value : cell // eslint-disable-line no-nested-ternary
    };

    datum.label = typeof propCfg.label === 'function' ? propCfg.label(cell) : typeof propCfg.label !== 'undefined' ? String(propCfg.label) : String(datum.value); // eslint-disable-line no-nested-ternary

    if (propCfg.field) {
      datum.source = {
        key,
        field: propCfg.field.key()
      };
    }
    return datum;
  }
  function doIt(_ref3) {
    let {
      propsArr,
      props,
      item,
      itemData,
      ret,
      sourceKey
    } = _ref3;
    for (let i = 0; i < propsArr.length; i++) {
      const pCfg = props[propsArr[i]];
      const arr = pCfg.fields || [pCfg];
      let coll;
      let collStr;
      if (pCfg.fields) {
        coll = [];
        collStr = [];
      }
      for (let j = 0; j < arr.length; j++) {
        const p = arr[j];
        let fn;
        let str;
        let value;
        let nodes;
        let cells;
        let label;
        if (p.type === 'primitive') {
          value = p.value;
          label = String(p.value);
        } else {
          if (typeof p.value === 'function') {
            fn = v => p.value(v, item);
          }
          if (typeof p.label === 'function') {
            str = v => p.label(v, item);
          }
          if (p.accessor) {
            nodes = p.accessor(item);
            if (Array.isArray(nodes)) {
              // propably descendants
              cells = nodes.map(p.valueAccessor);
              if (p.attrAccessor) {
                cells = cells.map(p.attrAccessor);
              }
              if (fn) {
                value = cells.map(fn);
                fn = null;
              }
              if (str) {
                label = cells.map(str);
                str = null;
              }
              value = p.reduce ? p.reduce(value) : value;
              label = p.reduceLabel ? p.reduceLabel(label, value) : String(value);
            } else {
              value = p.attrAccessor ? p.attrAccessor(p.valueAccessor(nodes)) : p.valueAccessor(nodes);
              label = value;
            }
          } else {
            value = itemData;
            label = itemData;
          }
        }
        if (pCfg.fields) {
          const v = fn ? fn(value) : value;
          coll.push(v);
          collStr.push(str && label != null ? str(label) : label != null ? label : String(v));
        } else {
          const v = fn ? fn(value) : value;
          ret[propsArr[i]] = {
            value: v,
            label: str ? str(label) : label != null ? label : String(v)
          };
          if (p.field) {
            ret[propsArr[i]].source = {
              field: p.field.key(),
              key: sourceKey
            };
          }
        }
      }
      if (coll) {
        ret[propsArr[i]] = {
          value: typeof pCfg.value === 'function' ? pCfg.value(coll, item) : coll,
          label: typeof pCfg.label === 'function' ? pCfg.label(collStr, item) : collStr
        };
      }
    }
  }
  const getHierarchy = (cube, cache, config) => {
    const rootPath = cube.qMode === 'K' ? '/qStackedDataPages/*/qData' : '/qTreeDataPages/*';
    const childNodes = cube.qMode === 'K' ? 'qSubNodes' : 'qNodes';
    const root = resolve(rootPath, cube);
    if (!root || !root[0]) {
      return null;
    }
    cache.tree = hierarchy(root[0], config.children || (node => node[childNodes]));
    return cache.tree;
  };
  function getHierarchyForSMode(dataset) {
    const matrix = dataset.raw().qDataPages.length ? dataset.raw().qDataPages[0].qMatrix : [];
    const order = getColumnOrder(dataset);
    const fields = dataset.fields();
    const dimensions = dataset.fields().filter(f => f.type() === 'dimension').map(f => order.indexOf(fields.indexOf(f)));
    const measures = dataset.fields().filter(f => f.type() === 'measure').map(f => order.indexOf(fields.indexOf(f)));
    const root = {
      __id: '__root',
      qValues: []
    };
    const keys = {
      __root: root
    };
    for (let r = 0; r < matrix.length; r++) {
      const row = matrix[r];
      let id = '__root';
      // let parent = root;
      let isNew = false;
      for (let c = 0; c < dimensions.length; c++) {
        var _cell$qElemNumber;
        const cell = row[dimensions[c]];
        const key = "".concat(id, "__").concat((_cell$qElemNumber = cell.qElemNumber) !== null && _cell$qElemNumber !== void 0 ? _cell$qElemNumber : cell.qElemNo);
        if (!keys[key]) {
          keys[key] = _objectSpread2({
            __id: key,
            __parent: id,
            qValues: []
          }, cell);
          isNew = true;
        }
        id = key;
      }
      if (isNew) {
        for (let c = 0; c < measures.length; c++) {
          const cell = row[measures[c]];
          keys[id].qValues.push(cell);
        }
      }
    }
    const nodes = Object.keys(keys).map(key => keys[key]);
    const h = stratify().id(d => d.__id).parentId(d => d.__parent)(nodes);
    return h;
  }
  const attachPropsAccessors = _ref4 => {
    let {
      propsArr,
      props,
      cube,
      cache,
      itemDepthObject,
      f
    } = _ref4;
    for (let i = 0; i < propsArr.length; i++) {
      const pCfg = props[propsArr[i]];
      const arr = pCfg.fields ? pCfg.fields : [pCfg];
      for (let j = 0; j < arr.length; j++) {
        const p = arr[j];
        if (p.field !== f) {
          const depthObject = getFieldDepth(p.field, {
            cube,
            cache
          });
          const accessors = getFieldAccessor(itemDepthObject, depthObject);
          p.accessor = accessors.nodeFn; // nodes accessor
          p.valueAccessor = accessors.valueFn; // cell accessor
          p.attrAccessor = accessors.attrFn; // attr cell accessor
        }
      }
    }
  };

  function augment() {
    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let dataset = arguments.length > 1 ? arguments[1] : undefined;
    let cache = arguments.length > 2 ? arguments[2] : undefined;
    let util = arguments.length > 3 ? arguments[3] : undefined;
    const cube = dataset.raw();
    const sourceKey = dataset.key();
    const h = cube.qMode === 'S' ? getHierarchyForSMode(dataset) : getHierarchy(cube, cache, config);
    if (!h) {
      return null;
    }
    const height = h.height;
    const propDefs = [];
    for (let i = 0; i <= height; i++) {
      let f = null;
      if (i > 0) {
        if (cube.qMode === 'S') {
          const order = getDimensionColumnOrder(cube);
          let idx = order[i - 1];
          f = cache.fields[idx];
        } else {
          let idx = cube.qEffectiveInterColumnSortOrder[i - 1];
          // if (idx === -1) { // pseudo
          //   let childIdx = node.parent.children.indexOf(node);
          //   idx = cube.qDimensionInfo.length + childIdx; // measure field
          // }
          if (i > cube.qEffectiveInterColumnSortOrder.length) {
            idx = cube.qDimensionInfo.length;
          }
          f = cache.fields[idx];
        }
      }
      const {
        props,
        main
      } = util.normalizeConfig(_objectSpread2(_objectSpread2({}, config), {}, {
        field: f ? f.key() : undefined
      }), dataset);
      const propsArr = Object.keys(props);
      propDefs[i] = {
        propsArr,
        props,
        main
      };
      const itemDepthObject = f ? getFieldDepth(f, {
        cube,
        cache
      }) : {
        fieldDepth: 0
      };
      attachPropsAccessors({
        propsArr,
        props,
        cube,
        cache,
        itemDepthObject,
        f
      });
    }
    const replica = h.copy();
    const replicaDescendants = replica.descendants();
    const descendants = h.descendants();
    for (let i = 0; i < descendants.length; i++) {
      const propsArr = propDefs[descendants[i].depth].propsArr;
      const props = propDefs[descendants[i].depth].props;
      const main = propDefs[descendants[i].depth].main;
      const item = replicaDescendants[i];
      const itemData = item.data; // main.valueAccessor(currentOriginal);

      const ret = datumExtract(main, itemData, {
        key: sourceKey
      });
      doIt({
        propsArr,
        props,
        item,
        itemData,
        ret,
        sourceKey,
        isTree: true
      });
      descendants[i].data = ret;
    }
    return h;
  }
  function extract(config, dataset, cache, util) {
    const cfgs = Array.isArray(config) ? config : [config];
    let dataItems = [];
    for (let g = 0; g < cfgs.length; g++) {
      if (typeof cfgs[g].field !== 'undefined') {
        const cube = dataset.raw();
        const sourceKey = dataset.key();
        const h = getHierarchy(cube, cache, config);
        if (!h) {
          continue;
        }
        const f = typeof cfgs[g].field === 'object' ? cfgs[g].field : dataset.field(cfgs[g].field);
        const {
          props,
          main
        } = util.normalizeConfig(cfgs[g], dataset);
        const propsArr = Object.keys(props);
        const itemDepthObject = getFieldDepth(f, {
          cube,
          cache
        });
        const {
          nodeFn,
          attrFn,
          valueFn
        } = getFieldAccessor({
          fieldDepth: 0
        }, itemDepthObject);
        attachPropsAccessors({
          propsArr,
          props,
          cube,
          cache,
          itemDepthObject,
          f
        });
        const track = !!cfgs[g].trackBy;
        const trackType = typeof cfgs[g].trackBy;
        const tracker = {};
        const trackedItems = [];
        const items = nodeFn(cache.tree);
        const mapped = [];
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          const itemData = attrFn ? attrFn(valueFn(item)) : valueFn(item);
          const exclude = main.filter && !main.filter(itemData);
          if (exclude) {
            continue;
          }
          const ret = datumExtract(main, itemData, {
            key: sourceKey
          });
          doIt({
            propsArr,
            props,
            item,
            itemData,
            ret,
            sourceKey
          });
          // collect items based on the trackBy value
          // items with the same trackBy value are placed in an array and reduced later
          if (track) {
            util.track({
              cfg: cfgs[g],
              itemData,
              obj: ret,
              target: trackedItems,
              tracker,
              trackType
            });
          }
          mapped.push(ret);
        }
        // reduce if items have been grouped
        const tmp = track ? util.collect(trackedItems, {
          main,
          propsArr,
          props
        }) : mapped;
        dataItems = [...dataItems, ...tmp];
      }
    }
    return dataItems;
  }
  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
  function createCommonjsModule(fn, module) {
    return module = {
      exports: {}
    }, fn(module, module.exports), module.exports;
  }
  var format_min = createCommonjsModule(function (module) {
    /*! javascript-number-formatter - v1.1.11 - http://mottie.github.com/javascript-number-formatter/ * © ecava */
    !function (a, b) {
      module.exports = b();
    }(commonjsGlobal, function () {
      return function (a, b) {
        if (!a || isNaN(+b)) return b;
        var c,
          d,
          e,
          f,
          g,
          h,
          i,
          j,
          k,
          l,
          m = a.length,
          n = a.search(/[0-9\-\+#]/),
          o = n > 0 ? a.substring(0, n) : "",
          p = a.split("").reverse().join(""),
          q = p.search(/[0-9\-\+#]/),
          r = m - q,
          s = a.substring(r, r + 1),
          t = r + ("." === s || "," === s ? 1 : 0),
          u = q > 0 ? a.substring(t, m) : "";
        if (a = a.substring(n, t), b = "-" === a.charAt(0) ? -b : +b, c = b < 0 ? b = -b : 0, d = a.match(/[^\d\-\+#]/g), e = d && d[d.length - 1] || ".", f = d && d[1] && d[0] || ",", a = a.split(e), b = b.toFixed(a[1] && a[1].length), b = +b + "", h = a[1] && a[1].lastIndexOf("0"), j = b.split("."), (!j[1] || j[1] && j[1].length <= h) && (b = (+b).toFixed(h + 1)), k = a[0].split(f), a[0] = k.join(""), g = a[0] && a[0].indexOf("0"), g > -1) for (; j[0].length < a[0].length - g;) j[0] = "0" + j[0];else 0 === +j[0] && (j[0] = "");
        if (b = b.split("."), b[0] = j[0], i = k[1] && k[k.length - 1].length) {
          for (l = b[0], p = "", r = l.length % i, m = l.length, t = 0; t < m; t++) p += l.charAt(t), !((t - r + 1) % i) && t < m - i && (p += f);
          b[0] = p;
        }
        return b[1] = a[1] && b[1] ? e + b[1] : "", d = b.join(""), "0" !== d && "" !== d || (c = !1), o + ((c ? "-" : "") + d) + u;
      };
    });
  });
  const EPSILON = 1e-15; // To compensate floating error

  function escapeRegExp(str) {
    return str.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&');
  }
  const SIprefixes = {
      3: 'k',
      6: 'M',
      9: 'G',
      12: 'T',
      15: 'P',
      18: 'E',
      21: 'Z',
      24: 'Y',
      '-3': 'm',
      '-6': 'μ',
      '-9': 'n',
      '-12': 'p',
      '-15': 'f',
      '-18': 'a',
      '-21': 'z',
      '-24': 'y'
    },
    percentage = /%\)?$/,
    //    scientific = /e[\+\-][0-9]+/,
    radix = /^\(r(0[2-9]|[12]\d|3[0-6])\)/i,
    oct = /^\(oct\)/i,
    dec = /^\(dec\)/i,
    hex = /^\(hex\)/i,
    bin = /^\(bin\)/i,
    rom = /^\(rom\)/i,
    functional = /^(\(rom\)|\(bin\)|\(hex\)|\(dec\)|\(oct\)|\(r(0[2-9]|[12]\d|3[0-6])\))/i,
    prec = /#|0/g;
  function formatRadix(value, fradix, pattern, decimal) {
    value = value.toString(fradix);
    if (pattern[1] === pattern[1].toUpperCase()) {
      value = value.toUpperCase();
    }
    if (value.length - value.indexOf('.') > 10) {
      // limit to 10 decimal places
      value = value.slice(0, value.indexOf('.') + 11);
    }
    return value.replace('.', decimal || '.');
  }

  // value must be an integer
  // value must not be in scientific notation
  function formatRoman(value, pattern) {
    let i,
      s = '',
      v = Number(String(value).slice(-3)),
      nThousands = (value - v) / 1000,
      decimal = [0, 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900].reverse(),
      numeral = ['0', 'I', 'IV', 'V', 'IX', 'X', 'XL', 'L', 'XC', 'C', 'CD', 'D', 'CM'].reverse();
    while (v > 0) {
      for (i = 0; i < decimal.length; i++) {
        if (decimal[i] <= v) {
          s += numeral[i];
          v -= decimal[i];
          break;
        }
      }
    }
    for (i = 0; i < nThousands; i++) {
      s = "M".concat(s);
    }
    if (pattern[1] !== pattern[1].toUpperCase()) {
      s = s.toLowerCase();
    }
    return s;
  }
  function formatFunctional(value, pattern, d) {
    let temp;
    if (radix.test(pattern)) {
      value = formatRadix(value, Number(/\d{2}/.exec(pattern)[0]), pattern, d);
    } else if (oct.test(pattern)) {
      value = formatRadix(value, 8, pattern, d);
    } else if (dec.test(pattern)) {
      value = formatRadix(value, 10, pattern, d);
    } else if (hex.test(pattern)) {
      value = formatRadix(value, 16, pattern, d);
    } else if (bin.test(pattern)) {
      value = formatRadix(value, 2, pattern, d);
    } else if (rom.test(pattern)) {
      temp = '';
      if (value < 0) {
        temp = '-';
        value = -value;
      }
      value = Math.floor(value);
      if (value === 0) {
        value = '0';
      } else if (value <= 500000) {
        // limit in engine
        value = formatRoman(value, pattern);
        value = temp + value;
      } else {
        value = pattern + temp + value.toExponential(0); // to return same result as engine
      }
    }

    return value;
  }
  function escape$1(value, flags, justStr) {
    const str = escapeRegExp(value);
    if (justStr) {
      return str;
    }
    return new RegExp(str || '', flags);
  }
  function createRegExp(thousand, decimal) {
    if (decimal) {
      decimal = escapeRegExp(decimal);
    }
    if (thousand) {
      thousand = escapeRegExp(thousand);
    }
    return new RegExp("(?:[#0]+".concat(thousand, ")?[#0]+(?:").concat(decimal, "[#0]+)?"));
  }
  function getAbbreviations(localeInfo, listSeparator) {
    if (!localeInfo || !localeInfo.qNumericalAbbreviation) {
      return SIprefixes;
    }
    const abbreviations = {};
    let abbrs = localeInfo.qNumericalAbbreviation.split(listSeparator);
    abbrs.forEach(abbreviation => {
      let abbreviationTuple = abbreviation.split(':');
      if (abbreviationTuple.length === 2) {
        abbreviations[abbreviationTuple[0]] = abbreviationTuple[1];
      }
    });
    return abbreviations;
  }
  function preparePattern(o, t, d, abbreviate) {
    let parts,
      lastPart,
      pattern = o.pattern,
      numericPattern,
      prefix,
      postfix,
      groupTemp,
      decTemp,
      temp,
      regex;
    if (abbreviate) {
      o.abbreviate = true;
    }

    // extract the numeric part from the pattern
    regex = createRegExp(t, d);
    numericPattern = pattern.match(regex);
    numericPattern = numericPattern ? numericPattern[0] : '';
    prefix = numericPattern ? pattern.substr(0, pattern.indexOf(numericPattern)) : pattern;
    postfix = numericPattern ? pattern.substring(pattern.indexOf(numericPattern) + numericPattern.length) : '';
    if (!numericPattern) {
      numericPattern = pattern ? '#' : '##########';
    }
    if (t && t === d) {
      // ignore grouping if grouping separator is same as decimal separator
      // extract decimal part
      parts = numericPattern.split(d);
      lastPart = parts.pop();
      numericPattern = parts.join('') + d + lastPart;
      t = '';
    }

    // formatting library does not support multiple characters as separator (nor +-).
    // do a temporary replacement
    groupTemp = t;
    t = /,/.test(d) ? '¤' : ',';
    if (groupTemp) {
      numericPattern = numericPattern.replace(escape$1(groupTemp, 'g'), t);
    }
    decTemp = d;
    d = '.';
    if (decTemp) {
      numericPattern = numericPattern.replace(escape$1(decTemp, 'g'), d);
    }
    temp = numericPattern.match(/#/g);
    temp = temp ? temp.length : 0;
    const splitPattern = pattern.split(decTemp);
    let matchPrecisionResult;
    if (splitPattern[1]) {
      matchPrecisionResult = splitPattern[1].match(prec);
    }
    o.prefix = prefix || '';
    o.postfix = postfix || '';
    o.pattern = pattern;
    o.maxPrecision = matchPrecisionResult ? matchPrecisionResult.length : 2;
    o.percentage = percentage.test(pattern);
    o.numericPattern = numericPattern || '';
    o.numericRegex = new RegExp("".concat(escape$1(t, null, true), "|").concat(escape$1(d, null, true)), 'g');
    o.groupTemp = groupTemp;
    o.decTemp = decTemp;
    o.t = t;
    o.d = d;
    o.temp = temp;
  }
  class NumberFormatter {
    /**
     * @name NumberFormatter
     * @constructs
     * @param {Object} localeInfo
     * @param {String} pattern
     * @param {String} [thousand]
     * @param {String} [decimal]
     * @param {String} [type]
     */
    constructor(localeInfo, pattern, thousand, decimal, type) {
      this.localeInfo = localeInfo;
      this.pattern = pattern;
      this.thousandDelimiter = thousand || ',';
      this.decimalDelimiter = decimal || '.';
      this.type = type || 'numeric';

      // FIXME qListSep?
      // this.patternSeparator = this.localeInfo && this.localeInfo.qListSep ? this.localeInfo.qListSep : ';';
      this.patternSeparator = ';';
      this.abbreviations = getAbbreviations(localeInfo, this.patternSeparator);
      this.prepare();
    }
    clone() {
      const n = new NumberFormatter(this.localeInfo, this.pattern, this.thousandDelimiter, this.decimalDelimiter, this.type);
      n.subtype = this.subtype;
      return n;
    }

    /**
     * Formats a number according to a specific pattern.
     * Use # for optional numbers and 0 for padding.
     * @param {Number} value Number to format.
     * @param {String} [pattern] The pattern to apply.
     * @param {String} [t] Grouping separator.
     * @param {String} [d] Decimal delimiter.
     * @example
     * format(10, "0") // 10;
     * format(10, "#") // 10;
     * format(10, "##.#") // 10;
     * format(10, "##.0") // 10.0;
     * format(10, "000") // 010;
     * format(10.123, "0.0") // 10.1;
     * format(10.123, "0.00##") // 10.123; // at least 2 decimals, never more than 4
     * format(123456789, "#,###") // 123,456,789;
     * format(123456789, "####-####", "-") // 1-2345-6789;
     *
     * format(0.257, "0.0%") // 25.7%; // will multiply by 100
     * format(9876, "$#,###") // $9,876;
     * format(-9876, "$#,###;$(#,###)") // $(9,876); // use ; for alternative formatting for negative values
     * format(10, "(r16)") // a; // radix 16
     * format(15, "(hex)") // f; // same as (r16)
     * format(15, "(HEX)") // F;
     * format(10, "(bin)") // 1010; // same as (r02)
     * format(10, "(oct)") // 12; // same as (r08)
     */
    format(value, pattern, t, d) {
      this.prepare(pattern, t, d);
      return this.formatValue(value);
    }
    prepare(pattern, t, d) {
      let prep;
      if (typeof pattern === 'undefined') {
        pattern = this.pattern;
      }
      if (typeof t === 'undefined') {
        t = this.thousandDelimiter;
      }
      if (typeof d === 'undefined') {
        d = this.decimalDelimiter;
      }
      if (!pattern) {
        this._prepared = {
          pattern: false
        };
        return;
      }
      this._prepared = {
        positive: {
          d,
          t,
          abbreviate: false,
          isFunctional: false,
          prefix: '',
          postfix: ''
        },
        negative: {
          d,
          t,
          abbreviate: false,
          isFunctional: false,
          prefix: '',
          postfix: ''
        },
        zero: {
          d,
          t,
          abbreviate: false,
          isFunctional: false,
          prefix: '',
          postfix: ''
        }
      };
      prep = this._prepared;
      pattern = pattern.split(this.patternSeparator);
      prep.positive.pattern = pattern[0];
      prep.negative.pattern = pattern[1];
      prep.zero.pattern = pattern[2];
      if (functional.test(pattern[0])) {
        prep.positive.isFunctional = true;
      }
      if (!pattern[1]) {
        prep.negative = false;
      } else if (functional.test(pattern[1])) {
        prep.negative.isFunctional = true;
      }
      if (!pattern[2]) {
        prep.zero = false;
      } else if (functional.test(pattern[2])) {
        prep.zero.isFunctional = true;
      }
      const abbreviate = this.type === 'U';
      if (!prep.positive.isFunctional) {
        preparePattern(prep.positive, t, d, abbreviate);
      }
      if (prep.negative && !prep.negative.isFunctional) {
        preparePattern(prep.negative, t, d, abbreviate);
      }
      if (prep.zero && !prep.zero.isFunctional) {
        preparePattern(prep.zero, t, d, abbreviate);
      }
    }
    formatValue(value) {
      let prep = this._prepared,
        temp,
        exponent,
        abbr = '',
        absValue,
        num,
        sciValue = '',
        d,
        t,
        i,
        numericPattern,
        decimalPartPattern,
        original = value;
      if (isNaN(value)) {
        return "".concat(original);
      }
      value = +value;
      if (prep.pattern === false) {
        return value.toString();
      }
      if (value === 0 && prep.zero) {
        prep = prep.zero;
        return prep.pattern;
      }
      if (value < 0 && prep.negative) {
        prep = prep.negative;
        value = -value;
      } else {
        prep = prep.positive;
      }
      d = prep.d;
      t = prep.t;
      if (prep.isFunctional) {
        value = formatFunctional(value, prep.pattern, d);
      } else {
        if (prep.percentage) {
          value *= 100;
        }
        if (prep.abbreviate) {
          const abbrArray = Object.keys(this.abbreviations).map(key => parseInt(key, 10)).sort((a, b) => a - b);
          let lowerAbbreviation;
          let upperAbbreviation = abbrArray[0];
          i = 0;
          exponent = Number(Number(value).toExponential().split('e')[1]);
          while (upperAbbreviation <= exponent && i < abbrArray.length) {
            i++;
            upperAbbreviation = abbrArray[i];
          }
          if (i > 0) {
            lowerAbbreviation = abbrArray[i - 1];
          }
          let suggestedAbbrExponent;

          // value and lower abbreviation is for values above 10, use the lower (move to the left <==)
          if (lowerAbbreviation && exponent > 0 && lowerAbbreviation > 0) {
            suggestedAbbrExponent = lowerAbbreviation;
            // value and lower abbreviation is for values below 0.1 (move to the right ==>)
          } else if (exponent < 0 && lowerAbbreviation < 0 || !lowerAbbreviation) {
            // upper abbreviation is also for values below 0.1 and precision allows for using the upper abbreviation(move to the right ==>)
            if (upperAbbreviation < 0 && upperAbbreviation - exponent <= prep.maxPrecision) {
              suggestedAbbrExponent = upperAbbreviation;
              // lower abbrevaition is smaller than exponent and we can't get away with not abbreviating
            } else if (lowerAbbreviation <= exponent && !(upperAbbreviation > 0 && -exponent <= prep.maxPrecision)) {
              // (move to left <==)
              suggestedAbbrExponent = lowerAbbreviation;
            }
          }
          if (suggestedAbbrExponent) {
            abbr = this.abbreviations[suggestedAbbrExponent];
            value /= 10 ** suggestedAbbrExponent;
          }
        }
        absValue = Math.abs(value);
        temp = prep.temp;
        numericPattern = prep.numericPattern;
        decimalPartPattern = numericPattern.split(d)[1];
        if (this.type === 'I') {
          value = Math.round(value);
        }
        num = value;
        if (!decimalPartPattern && numericPattern.slice(-1)[0] === '#') {
          if (absValue >= 10 ** temp || absValue < 1 || absValue < 1e-4) {
            if (value === 0) {
              value = '0';
            } else if (absValue < 1e-4 || absValue >= 1e20) {
              // engine always formats values < 1e-4 in scientific form, values >= 1e20 can only be represented in scientific form
              value = num.toExponential(Math.max(1, Math.min(14, temp)) - 1);
              value = value.replace(/\.?0+(?=e)/, '');
              sciValue = '';
            } else {
              value = value.toPrecision(Math.max(1, Math.min(14, temp)));
              if (value.indexOf('.') >= 0) {
                value = value.replace(value.indexOf('e') < 0 ? /0+$/ : /\.?0+(?=e)/, '');
                value = value.replace('.', d);
              }
            }
          } else {
            numericPattern += d;
            temp = Math.max(0, Math.min(20, temp - Math.ceil(Math.log(absValue) / Math.log(10))));
            for (i = 0; i < temp; i++) {
              numericPattern += '#';
            }
            value = format_min(numericPattern, value);
          }
        } else if (absValue >= 1e15 || absValue > 0 && absValue <= 1e-14) {
          value = absValue ? absValue.toExponential(15).replace(/\.?0+(?=e)/, '') : '0';
        } else {
          const wholePart = Number(value.toFixed(Math.min(20, decimalPartPattern ? decimalPartPattern.length : 0)).split('.')[0]);
          let wholePartPattern = numericPattern.split(d)[0];
          wholePartPattern += d;
          value = format_min(wholePartPattern, wholePart) || '0';
          if (decimalPartPattern) {
            const nDecimals = Math.max(0, Math.min(14, decimalPartPattern.length)); // the length of e.g. 0000#####
            const nZeroes = decimalPartPattern.replace(/#+$/, '').length;
            let decimalPart = (this.type === 'I' ? 0 : absValue % 1 + EPSILON).toFixed(nDecimals).slice(2).replace(/0+$/, ''); // remove trailing zeroes

            for (i = decimalPart.length; i < nZeroes; i++) {
              decimalPart += '0';
            }
            if (decimalPart) {
              value += d + decimalPart;
            }
          } else if (wholePart === 0) {
            // to avoid "-" being prefixed to value
            num = 0;
          }
        }
        value = value.replace(prep.numericRegex, m => {
          if (m === t) {
            return prep.groupTemp;
          }
          if (m === d) {
            return prep.decTemp;
          }
          return '';
        });
        if (num < 0 && !/^-/.test(value)) {
          value = "-".concat(value);
        }
      }
      return prep.prefix + value + sciValue + abbr + prep.postfix;
    }
    static getStaticFormatter() {
      return {
        prepare() {},
        formatValue(v) {
          return "".concat(v);
        }
      };
    }
  }
  function numberFormatFactory() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new NumberFormatter(...args);
  }
  function memoize$1(func) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      size = 5000,
      multipleArguments = false,
      toKey = arg => arg
    } = opts;
    let cache = Object.create(null);
    let index = Object.create(null);
    let counter = 0;
    let fifo = 0; // First-In-First-Out index
    let cacher;
    let k;
    if (multipleArguments) {
      cacher = function () {
        k = toKey(...arguments);
        if (cacher.has(k)) {
          return cacher.get(k);
        }
        return cacher.set(k, func(...arguments));
      };
    } else {
      cacher = arg => {
        k = toKey(arg);
        if (cacher.has(k)) {
          return cacher.get(k);
        }
        return cacher.set(k, func(arg));
      };
    }
    cacher.set = (key, val) => {
      if (counter >= size) {
        delete cache[index[fifo]];
        delete index[fifo];
        counter--;
        fifo++;
      }
      cache[key] = val;
      index[counter] = key;
      counter++;
      return val;
    };
    cacher.get = key => cache[key];
    cacher.has = key => key in cache;
    cacher.clear = () => {
      cache = Object.create(null);
      index = Object.create(null);
      counter = 0;
      fifo = 0;
    };
    cacher.size = () => counter;
    return cacher;
  }
  function formatter$1(pattern, thousand, decimal, qType, localeInfo) {
    const qformat = numberFormatFactory(localeInfo, pattern, thousand, decimal, qType);
    const memoized = memoize$1(qformat.formatValue.bind(qformat), {
      // Handle NaN and cases where toString yields different result than +operator. Ex. a Date.
      toKey: value => isNaN(value) ? value : +value
    });

    /**
     * Format a value according to the specified pattern created at construct
     *
     * @param  {Number} value   The number to be formatted
     * @return {String}         [description]
     */
    function format(value) {
      return memoized(value);
    }

    /**
     * Format a value according to a specific pattern
     * that is not the one specified in the constructor
     *
     * @param  {String} p   Pattern
     * @param  {Number} v   Value
     * @param  {String} t   Thousand
     * @param  {String} d   Decimal
     * @return {String}     Formatted value
     */
    format.format = function formatFn(p, v, t, d) {
      memoized.clear();
      return qformat.format(v, p, t, d);
    };

    /**
     * Change the pattern on existing formatter
     *
     * @param  {String} p     Pattern (optional)
     * @return {String}       Returns the pattern
     */
    format.pattern = function patternFn(p) {
      if (p) {
        memoized.clear();
        qformat.pattern = p;
        qformat.prepare();
      }
      return qformat.pattern;
    };

    /**
     * Set the locale for the formatter
     *
     * @param  {Object} args   Locale object for formatting
     * @return {Undefined}      Returns nothing
     */
    /* format.locale = function( ...args ) {
      locale = formatLocale( ...args );
      d3format = locale.format( pattern );
       return this;
    }; */

    return format;
  }

  /* eslint import/prefer-default-export: 0 */

  const TYPES = {
    AUTO: 'U',
    INTEGER: 'I',
    NUMBER: 'R',
    FIXED_TO: 'F',
    MONEY: 'M',
    DATE: 'D',
    TIME: 'T',
    DATE_TIME: 'TS',
    INTERVAL: 'IV'
  };
  const DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
  const DAYS_ABBR = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
  const MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  const MONTHS_ABBR = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const SECONDS_PER_DAY = 86400;
  function pad(s, n) {
    for (let i = s.length; i < n; i++) {
      s = "0".concat(s);
    }
    return s;
  }
  function parseDate(d, twelveFormat) {
    let h = d.getUTCHours();
    let day = d.getUTCDay() - 1;
    if (twelveFormat) {
      h %= 12;
      if (!h) {
        // h == 0 -> 12
        h = 12;
      }
    }
    if (day < 0) {
      day = 6;
    }
    return {
      year: d.getUTCFullYear(),
      month: d.getUTCMonth(),
      day,
      date: d.getUTCDate(),
      h,
      m: d.getUTCMinutes(),
      s: d.getUTCSeconds(),
      f: d.getUTCMilliseconds(),
      t: d.getUTCHours() >= 12 ? 'pm' : 'am'
    };
  }
  function getRemainder(value) {
    let s = value.toString().split('.');
    if (s[1]) {
      s = Number("0.".concat(s[1]));
    } else {
      return 0;
    }
    return s;
  }
  function parseIntervalDays(days) {
    const d = days;
    const h = 24 * getRemainder(d);
    const m = 60 * getRemainder(h);
    const s = 60 * getRemainder(m);
    const ms = 1000 * getRemainder(s);
    return {
      d: Math.floor(d),
      h: Math.floor(h),
      m: Math.floor(m),
      s: Math.floor(s),
      f: Math.round(ms)
    };
  }
  function parseInterval(days, pattern) {
    let units = parseIntervalDays(days),
      d = units.d,
      h = units.h,
      m = units.m,
      s = units.s,
      f = units.f,
      w = 0,
      date;
    if (/w+|t+/gi.test(pattern)) {
      date = new Date(Date.UTC(1899, 11, 30 + Math.floor(days), 0, 0, Math.round(SECONDS_PER_DAY * (days - Math.floor(days)))));
      if (isNaN(date.getTime())) {
        date = null;
      }
    }
    if (!/D+/gi.test(pattern)) {
      h += d * 24;
    }
    if (!/h+/gi.test(pattern)) {
      m += h * 60;
    }
    if (!/m+/gi.test(pattern)) {
      s += m * 60;
    }
    if (/w+/gi.test(pattern)) {
      w = date ? date.getDay() - 1 : 0;
      if (w < 0) {
        w = 6;
      }
    }
    let someT = '';
    if (date) {
      someT = date.getUTCHours() >= 12 ? 'pm' : 'am';
    }
    return {
      year: 0,
      month: 0,
      day: w,
      date: d,
      h,
      m,
      s,
      f,
      t: someT
    };
  }
  function getMasks(inst, d) {
    return {
      'Y+|y+': {
        Y: "".concat(Number("".concat(d.year).slice(-2))),
        YY: pad("".concat(d.year).slice(-2), 2),
        YYY: pad("".concat(d.year).slice(-3), 3),
        def(m) {
          // default
          return pad("".concat(d.year), m.length);
        }
      },
      'M+': {
        M: d.month + 1,
        MM: pad("".concat(d.month + 1), 2),
        MMM: inst.locale_months_abbr[d.month],
        def: inst.locale_months[d.month]
      },
      'W+|w+': {
        W: d.day,
        WW: pad("".concat(d.day), 2),
        WWW: inst.locale_days_abbr[d.day],
        def: inst.locale_days[d.day]
      },
      'D+|d+': {
        D: d.date,
        def(m) {
          return pad("".concat(d.date), m.length);
        }
      },
      'h+|H+': {
        h: d.h,
        def(m) {
          return pad("".concat(d.h), m.length);
        }
      },
      'm+': {
        m: d.m,
        def(m) {
          return pad("".concat(d.m), m.length);
        }
      },
      's+|S+': {
        s: d.s,
        def(m) {
          return pad("".concat(d.s), m.length);
        }
      },
      'f+|F+': {
        def(m) {
          let f = "".concat(d.f),
            n = m.length - f.length;
          if (n > 0) {
            for (let i = 0; i < n; i++) {
              f += '0';
            }
          } else if (n < 0) {
            f = f.slice(0, m.length);
          }
          return f;
        }
      },
      't{1,2}|T{1,2}': {
        def(m) {
          let t = d.t;
          if (m[0].toUpperCase() === m[0]) {
            t = t.toUpperCase();
          }
          t = t.slice(0, m.length);
          return t;
        }
      }
    };
  }
  class DateFormatter {
    /**
     * @name DateFormatter
     * @constructs
     * @param {Object} localeInfo
     * @param {String} pattern
     */
    constructor(localeInfo, pattern, qtype) {
      const info = localeInfo || {};
      if (!info.qCalendarStrings) {
        info.qCalendarStrings = {
          qLongDayNames: DAYS,
          qDayNames: DAYS_ABBR,
          qLongMonthNames: MONTHS,
          qMonthNames: MONTHS_ABBR
        };
      }
      this.localeInfo = info;
      this.locale_days = info.qCalendarStrings.qLongDayNames.slice();
      this.locale_days_abbr = info.qCalendarStrings.qDayNames.slice();
      this.locale_months = info.qCalendarStrings.qLongMonthNames.slice();
      this.locale_months_abbr = info.qCalendarStrings.qMonthNames.slice();
      if (!pattern) {
        const patternMap = {
          [TYPES.TIME]: info.qTimeFmt || 'hh:mm:ss',
          [TYPES.DATE]: info.qDateFmt || 'YYYY-MM-DD',
          [TYPES.DATE_TIME]: info.qTimestampFmt || 'YYYY-MM-DD hh:mm:ss'
        };
        pattern = patternMap[qtype];
      }
      this.pattern = pattern;
    }
    clone() {
      const n = new DateFormatter(this.localeInfo, this.pattern);
      n.subtype = this.subtype;
      return n;
    }

    /**
     * Formats a date according to given pattern
     * @param {Date} date The date to format.
     * @param {String} pattern The desired format of the date
     * var d = new Date(2013, 8, 15, 13, 55, 40, 987);
     * var n = new DateFormatter();
     * @example
     * m.format( d, 'YYYY-MM-DD hh:mm:ss.ffff') // 2013-08-15 13:55:40.9870
     * m.format( d, 'h:m:s tt') // 1:55:40 pm
     * m.format( d, 'h:m:s TT') // 1:55:40 PM
     * m.format( d, 'M/D/YYYY') // 8/15/2013
     * m.format( d, 'WWWW DD MMM') // Thursday 15 Aug
     * m.format( d, 'WWW DD MMMM @ hh:mm:ss') // Thu 15 August @ 13:55:40
     */
    format(date, pattern) {
      // Fallback pattern is set in constructor
      if (!pattern) {
        pattern = this.pattern ? this.pattern : 'YYYY-MM-DD hh:mm:ss';
      }
      pattern = pattern.replace(/\[.+]|\[|]/g, '');
      const hasTwelveFlag = /t+/gi.test(pattern);
      let parsedDate;
      if (date instanceof Date) {
        parsedDate = parseDate(date, hasTwelveFlag);
      } else {
        if (date < 0) {
          // parseInterval don't support for negative values
          date = -date;
          pattern = "-".concat(pattern);
        }
        parsedDate = parseInterval(date, pattern);
      }
      // remove [] and everything inside it

      const masks = getMasks(this, parsedDate);
      const masksArr = [];
      for (const mask in masks) {
        if (Object.prototype.hasOwnProperty.call(masks, mask)) {
          masksArr.push(mask);
        }
      }
      const dateTimeRegex = new RegExp(masksArr.join('|'), 'g');
      const result = pattern.replace(dateTimeRegex, m => {
        let r;
        let mask;
        for (mask in masks) {
          if (Object.prototype.hasOwnProperty.call(masks, mask)) {
            r = new RegExp(mask);
            if (r.test(m)) {
              break;
            }
          }
        }
        if (!r) {
          return '';
        }
        let value;
        for (const submask in masks[mask]) {
          if (submask === m || submask.toLowerCase() === m) {
            value = masks[mask][submask];
            if (typeof value === 'undefined') {
              value = masks[mask][submask.toLowerCase()];
            }
            break;
          }
        }
        if (typeof value === 'undefined') {
          value = masks[mask].def;
        }
        if (typeof value === 'function') {
          value = value(m);
        }
        return value;
      });
      return result;
    }
  }
  function dateFormatFactory() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new DateFormatter(...args);
  }
  const MS_PER_DAY = 86400000;
  function QlikTimeToDate(value) {
    return new Date(Date.UTC(1899, 11, 30 + Math.floor(value), 0, 0, 0, Math.round(MS_PER_DAY * (value - Math.floor(value)))));
  }
  function formatter(pattern) {
    let qtype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'TS';
    let localeInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let qformat = dateFormatFactory(localeInfo, pattern, qtype);
    let memoized = memoize$1(qformat.format.bind(qformat), {
      toKey: date => typeof date === 'object' && typeof date.getTime === 'function' ? date.getTime() : date
    });

    /**
     * Prepare a value according to the specified qtype
     *
     * @param  {Number} value The value to be formatted
     * @return {Number}       The converted value (if applied)
     */
    function prepare(value) {
      if (qtype !== TYPES.INTERVAL) {
        return QlikTimeToDate(value);
      }
      return value;
    }

    /**
     * Format a value according to the specified pattern created at construct
     *
     * @param  {Date} value   The number to be formatted
     * @return {String}         [description]
     */
    function format(value) {
      value = prepare(value);
      return memoized(value);
    }

    /**
     * Format a value according to a specific pattern
     * that is not the one specified in the constructor
     *
     * @param  {String} p   Pattern
     * @param  {Date} v   Value
     * @return {String}     Formatted value
     */
    format.format = function formatFn(p, v) {
      memoized.clear();
      v = prepare(v);
      return qformat.format(v, p);
    };

    /**
     * Set the locale for the formatter
     *
     * @param  {Object} args   Locale object for formatting
     * @return {Undefined}      Returns nothing
     */
    format.locale = function locale(li) {
      qformat = dateFormatFactory(li, pattern, qtype);
      memoized = memoize$1(qformat.format.bind(qformat), {
        toKey: date => typeof date === 'object' ? date.getTime() : date
      });
      return this;
    };

    /**
     * Get or set the QType
     *
     * @param  {String} nqt New qType (optional)
     * @return {String}     Current qtype
     */
    format.qtype = function qtypeFn(nqt) {
      if (nqt !== undefined) {
        qtype = nqt;
        memoized.clear();
      }
      return qtype;
    };
    return format;
  }
  function createFromMetaInfo(meta, localeInfo) {
    if (meta && meta.qNumFormat && ['D', 'T', 'TS', 'IV'].indexOf(meta.qNumFormat.qType) !== -1) {
      return formatter(meta.qNumFormat.qFmt, meta.qNumFormat.qType, localeInfo);
    }
    let pattern = '#';
    let thousand = localeInfo && typeof localeInfo.qThousandSep !== 'undefined' ? localeInfo.qThousandSep : ',';
    let decimal = localeInfo && typeof localeInfo.qDecimalSep !== 'undefined' ? localeInfo.qDecimalSep : '.';
    let type = 'U';
    let isAuto = meta && !!meta.qIsAutoFormat;
    if (meta && meta.qNumFormat) {
      pattern = meta.qNumFormat.qFmt || pattern;
      thousand = meta.qNumFormat.qThou || thousand;
      decimal = meta.qNumFormat.qDec || decimal;
      type = meta.qNumFormat.qType || type;
      isAuto = isAuto && ['M'].indexOf(meta.qNumFormat.qType) === -1;
    } else {
      isAuto = true;
    }
    if (isAuto || type === 'U') {
      pattern = "#".concat(decimal, "##");
      type = 'U';
    }
    return formatter$1(pattern, thousand, decimal, type, localeInfo);
  }
  function qField() {
    let {
      meta,
      id,
      key,
      localeInfo,
      fieldExtractor,
      value,
      type,
      sourceField
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let values;
    const valueFn = value || (type === 'dimension' ? d => d === null || d === void 0 ? void 0 : d.qElemNo : d => d === null || d === void 0 ? void 0 : d.qValue);
    const labelFn = d => (d === null || d === void 0 ? void 0 : d.qText) || '';
    const reduce = type === 'dimension' ? 'first' : 'avg';
    const formatter = createFromMetaInfo(meta, localeInfo);
    const reduceLabel = type === 'dimension' ? 'first' : (labels, v) => formatter(v);
    const f = {
      id: () => id,
      key: () => key,
      raw: () => meta,
      title: () => meta.qFallbackTitle || meta.label,
      type: () => type,
      origin: () => sourceField,
      items: () => {
        if (!values) {
          values = fieldExtractor(f);
        }
        return values;
      },
      min: () => meta.qMin,
      max: () => meta.qMax,
      value: valueFn,
      label: labelFn,
      reduce,
      reduceLabel,
      formatter: () => formatter,
      tags: () => meta.qTags
    };
    return f;
  }
  function createFields(path, obj, prefix, parentKey, opts) {
    return (obj[path] || []).map((meta, i) => {
      const fieldKey = "".concat(parentKey ? "".concat(parentKey, "/") : '').concat(path, "/").concat(i);
      const f = {
        instance: qField(extend({
          id: "".concat(prefix ? "".concat(prefix, "/") : '').concat(fieldKey),
          key: fieldKey,
          meta
        }, opts))
      };
      f.attrDims = createFields('qAttrDimInfo', meta, prefix, fieldKey, extend({}, opts, {
        value: v => v === null || v === void 0 ? void 0 : v.qElemNo,
        type: 'dimension'
      }));
      f.attrExps = createFields('qAttrExprInfo', meta, prefix, fieldKey, extend({}, opts, {
        value: v => v === null || v === void 0 ? void 0 : v.qNum,
        type: 'measure'
      }));
      f.measures = createFields('qMeasureInfo', meta, prefix, fieldKey, extend({}, opts, {
        value: v => v === null || v === void 0 ? void 0 : v.qValue,
        type: 'measure'
      }));
      return f;
    });
  }
  function q() {
    let {
      key,
      data,
      config = {}
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const cache = {
      fields: [],
      wrappedFields: [],
      allFields: [],
      virtualFields: []
    };
    const cube = data;
    if (!cube) {
      throw new Error('Missing "data" input');
    }
    if (!cube.qDimensionInfo) {
      throw new Error('The "data" input is not recognized as a hypercube');
    }
    const deps = q.util;
    const opts = {
      cache,
      cube,
      localeInfo: config.localeInfo,
      fieldExtractor: null,
      pages: null,
      hierarchy: () => null,
      virtualFields: config.virtualFields
    };
    const dataset = {
      key: () => key,
      raw: () => cube,
      field: query => findField(query, opts),
      fields: () => cache.fields.slice(),
      extract: extractionConfig => opts.extractor(extractionConfig, dataset, cache, deps),
      hierarchy: hierarchyConfig => opts.hierarchy(hierarchyConfig, dataset, cache, deps),
      _cache: () => cache
    };
    if (cube.qMode === 'K' || cube.qMode === 'T' || !cube.qMode && cube.qNodesOnDim) {
      opts.extractor = extract;
      opts.hierarchy = augment;
      opts.pages = cube.qMode === 'K' ? cube.qStackedDataPages : cube.qTreeDataPages;
    } else if (cube.qMode === 'S') {
      opts.extractor = extract$1;
      opts.pages = cube.qDataPages;
      opts.hierarchy = augment;
    } else {
      opts.extractor = () => []; // TODO - throw unsupported error?
    }

    opts.fieldExtractor = f => opts.extractor({
      field: f
    }, dataset, cache, deps);
    const dimAcc = cube.qMode === 'S' ? d => d.qElemNumber : undefined;
    const measAcc = cube.qMode === 'S' ? d => d.qNum : undefined;
    cache.wrappedFields.push(...createFields('qDimensionInfo', cube, key, '', extend({}, opts, {
      value: dimAcc,
      type: 'dimension'
    })));
    cache.wrappedFields.push(...createFields('qMeasureInfo', cube, key, '', extend({}, opts, {
      value: measAcc,
      type: 'measure'
    })));
    cache.fields = cache.wrappedFields.map(f => f.instance);
    const traverse = arr => {
      arr.forEach(f => {
        cache.allFields.push(f.instance);
        traverse(f.measures);
        traverse(f.attrDims);
        traverse(f.attrExps);
      });
    };
    traverse(cache.wrappedFields);
    (config.virtualFields || []).forEach(v => {
      // key: 'temporal',
      // from: 'qDimensionInfo/0',
      // override: {
      //   value: v => v.qNum,
      // },
      const sourceField = dataset.field(v.from);
      const f = qField(_objectSpread2({
        meta: sourceField.raw(),
        id: "".concat(key, "/").concat(v.key),
        sourceField,
        fieldExtractor: ff => opts.extractor({
          field: ff
        }, dataset, cache, deps),
        key: v.key,
        type: sourceField.type(),
        localeInfo: opts.localeInfo,
        value: sourceField.value
      }, v.override || {}));
      cache.virtualFields.push(f);
    });
    cache.allFields.push(...cache.virtualFields);
    return dataset;
  }
  const LAYOUT_TO_PROP = [['qHyperCube', 'qHyperCubeDef'], ['qTreeData', 'qTreeDataDef'], ['qDimensionInfo', 'qDimensions'], ['qMeasureInfo', 'qMeasures'], ['qAttrDimInfo', 'qAttributeDimensions'], ['qAttrExprInfo', 'qAttributeExpressions']];
  const DIM_RX = /\/qDimensionInfo(?:\/(\d+))?/;
  const M_RX = /\/qMeasureInfo\/(\d+)/;
  const ATTR_DIM_RX = /\/qAttrDimInfo\/(\d+)(?:\/(\d+))?/;
  const ATTR_EXPR_RX = /\/qAttrExprInfo\/(\d+)/;
  const HC_RX = /\/?qHyperCube/;
  const TD_RX = /\/?qTreeData/;
  const SHORTEN_HC = path => "".concat(path.substr(0, path.indexOf('/qHyperCubeDef') + 14)); // 14 = length of '/qHyperCubeDef'
  const SHORTEN_TD = path => "".concat(path.substr(0, path.indexOf('/qTreeDataDef') + 13)); // 13 = length of '/qTreeDataDef'

  function extractFieldFromId(id, layout) {
    let path = id;
    let dimensionIdx = -1;
    let measureIdx = -1;
    let pathToCube = '';
    let shortenizer = p => p;
    if (HC_RX.test(id)) {
      pathToCube = "".concat(path.substr(0, path.indexOf('qHyperCube') + 10)); // 10 = length of 'qHyperCube'
      shortenizer = SHORTEN_HC;
    } else if (TD_RX.test(id)) {
      pathToCube = "".concat(path.substr(0, path.indexOf('qTreeData') + 9)); // 9 = length of 'qTreeData'
      shortenizer = SHORTEN_TD;
    }
    let shortenPath = true;
    if (DIM_RX.test(id)) {
      dimensionIdx = +DIM_RX.exec(id)[1];
    }
    if (M_RX.test(id)) {
      measureIdx = +M_RX.exec(id)[1];
    }
    if (ATTR_DIM_RX.test(id)) {
      measureIdx = -1;
      dimensionIdx = 0;
      const attrCol = +ATTR_DIM_RX.exec(path)[2];
      if (!isNaN(attrCol)) {
        dimensionIdx = attrCol;
        path = path.replace(/\/\d+$/, '');
      }
      shortenPath = false;
    }
    if (ATTR_EXPR_RX.test(id)) {
      // depends on number of measures + number of attr expressions
      // in dimensions and measures before this one
      const offset = measureIdx;
      if (layout) {
        measureIdx = 0;
        const hc = resolve(pathToCube, layout);

        // offset by number of measures
        measureIdx += (hc.qMeasureInfo || []).length;

        // offset by total number of attr expr in dimensions
        // (assuming attr expr in dimensions are ordered first)
        if (dimensionIdx > -1) {
          measureIdx = hc.qDimensionInfo.slice(0, dimensionIdx).reduce((v, dim) => v + dim.qAttrExprInfo.length, measureIdx);
          dimensionIdx = -1;
        } else {
          measureIdx = hc.qDimensionInfo.reduce((v, dim) => v + dim.qAttrExprInfo.length, measureIdx);
          // offset by total number of attr expr in measures before 'index'
          measureIdx = hc.qMeasureInfo.slice(0, offset).reduce((v, meas) => v + meas.qAttrExprInfo.length, measureIdx);
        }

        // offset by the actual column value for the attribute expression itself
        measureIdx += +ATTR_EXPR_RX.exec(path)[1];
      } else if (dimensionIdx > -1) {
        dimensionIdx = -1;
        measureIdx = +ATTR_EXPR_RX.exec(path)[1];
      } else {
        measureIdx += +ATTR_EXPR_RX.exec(path)[1] + 1;
      }
    }
    LAYOUT_TO_PROP.forEach(_ref => {
      let [v, prop] = _ref;
      path = path.replace(v, prop);
    });
    if (shortenPath) {
      path = shortenizer(path);
    }
    if (path && path[0] !== '/') {
      path = "/".concat(path);
    }
    return {
      measureIdx,
      dimensionIdx,
      path
    };
  }

  /**
   * Helper method to generate suitable QIX selection methods and parameters based on a brush instance.
   * @alias brush
   * @memberof picasso.q
   * @param {Brush} brush A brush instance
   * @param {object} [opts]
   * @param {boolean} [opts.byCells=false] Whether to prefer selection by row index.
   * @param {string} [opts.primarySource] Field source to extract row indices from. If not specified, indices from first source are used.
   * @param {boolean} [opts.orMode=true] If false, combine measure range selections.
   * @param {object} [layout] QIX data layout. Needed only when brushing on attribute expressions, to be able to calculate the measure index.
   * @return {object[]} An array of relevant selections
   */
  function qBrush(brush) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let layout = arguments.length > 2 ? arguments[2] : undefined;
    const byCells = opts.byCells;
    const primarySource = opts.primarySource;
    const selections = [];
    const methods = {};
    const isActive = brush.isActive();
    let hasValues = false;
    brush.brushes().forEach(b => {
      const info = extractFieldFromId(b.id, layout);
      if (b.type === 'range' && info.measureIdx > -1 && info.dimensionIdx > -1) {
        const ranges = b.brush.ranges();
        if (ranges.length) {
          hasValues = true;
          if (!methods.multiRangeSelectTreeDataValues) {
            methods.multiRangeSelectTreeDataValues = {
              path: info.path,
              ranges: []
            };
          }
          ranges.forEach(range => methods.multiRangeSelectTreeDataValues.ranges.push({
            qMeasureIx: info.measureIdx,
            qDimensionIx: info.dimensionIdx,
            qRange: {
              qMin: range.min,
              qMax: range.max,
              qMinInclEq: true,
              qMaxInclEq: true
            }
          }));
        }
      } else {
        if (b.type === 'range' && info.measureIdx > -1) {
          const ranges = b.brush.ranges();
          if (ranges.length) {
            hasValues = true;
            if (!methods.rangeSelectHyperCubeValues) {
              methods.rangeSelectHyperCubeValues = {
                path: info.path,
                ranges: []
              };
            }
            ranges.forEach(range => methods.rangeSelectHyperCubeValues.ranges.push({
              qMeasureIx: info.measureIdx,
              qRange: {
                qMin: range.min,
                qMax: range.max,
                qMinInclEq: true,
                qMaxInclEq: true
              }
            }));
          }
        }
        if (b.type === 'range' && info.dimensionIdx > -1) {
          const ranges = b.brush.ranges();
          if (ranges.length) {
            hasValues = true;
            if (!methods.selectHyperCubeContinuousRange) {
              methods.selectHyperCubeContinuousRange = {
                path: info.path,
                ranges: []
              };
            }
            ranges.forEach(range => methods.selectHyperCubeContinuousRange.ranges.push({
              qDimIx: info.dimensionIdx,
              qRange: {
                qMin: range.min,
                qMax: range.max,
                qMinInclEq: true,
                qMaxInclEq: false
              }
            }));
          }
        }
        if (b.type === 'value' && info.dimensionIdx > -1) {
          if (byCells) {
            if (layout && layout.qHyperCube && (layout.qHyperCube.qMode === 'P' || layout.qHyperCube.qMode === 'T' || layout.qHyperCube.qMode === 'K')) {
              const hyperCube = layout.qHyperCube;
              const noOfLeftDims = hyperCube.qNoOfLeftDims;
              const dimInterColSortIdx = hyperCube.qEffectiveInterColumnSortOrder.indexOf(info.dimensionIdx);
              if (!methods.selectPivotCells) {
                methods.selectPivotCells = {
                  path: info.path,
                  cells: []
                };
              }
              if (b.id === primarySource || !primarySource) {
                const validValues = b.brush.values().map(s => +s).filter(v => !isNaN(v));
                if ((noOfLeftDims === 0 || dimInterColSortIdx >= noOfLeftDims) && noOfLeftDims > -1) {
                  validValues.forEach(val => {
                    methods.selectPivotCells.cells.push({
                      qType: 'T',
                      qCol: val,
                      qRow: dimInterColSortIdx - noOfLeftDims
                    });
                  });
                } else {
                  validValues.forEach(val => {
                    methods.selectPivotCells.cells.push({
                      qType: 'L',
                      qCol: info.dimensionIdx,
                      qRow: val
                    });
                  });
                }
                hasValues = !!methods.selectPivotCells.cells.length;
              }
            } else {
              if (!methods.selectHyperCubeCells) {
                methods.selectHyperCubeCells = {
                  path: info.path,
                  cols: []
                };
              }
              methods.selectHyperCubeCells.cols.push(info.dimensionIdx);
              if (b.id === primarySource || !primarySource && !methods.selectHyperCubeCells.values) {
                methods.selectHyperCubeCells.values = b.brush.values().map(s => +s).filter(v => !isNaN(v));
                hasValues = !!methods.selectHyperCubeCells.values.length;
              }
            }
          } else {
            const values = b.brush.values().map(s => +s).filter(v => !isNaN(v));
            hasValues = !!values.length;
            selections.push({
              params: [info.path, info.dimensionIdx, values, false],
              method: 'selectHyperCubeValues'
            });
          }
        }
      }
    });
    if (!hasValues && isActive) {
      return [{
        method: 'resetMadeSelections',
        params: []
      }];
    }
    if (methods.rangeSelectHyperCubeValues) {
      var _opts$orMode;
      selections.push({
        method: 'rangeSelectHyperCubeValues',
        params: [methods.rangeSelectHyperCubeValues.path, methods.rangeSelectHyperCubeValues.ranges, [], (_opts$orMode = opts.orMode) !== null && _opts$orMode !== void 0 ? _opts$orMode : true]
      });
    }
    if (methods.selectHyperCubeContinuousRange) {
      selections.push({
        method: 'selectHyperCubeContinuousRange',
        params: [methods.selectHyperCubeContinuousRange.path, methods.selectHyperCubeContinuousRange.ranges]
      });
    }
    if (methods.selectHyperCubeCells) {
      selections.push({
        method: 'selectHyperCubeCells',
        params: [methods.selectHyperCubeCells.path, methods.selectHyperCubeCells.values, methods.selectHyperCubeCells.cols]
      });
    }
    if (methods.selectPivotCells) {
      selections.push({
        method: 'selectPivotCells',
        params: [methods.selectPivotCells.path, methods.selectPivotCells.cells]
      });
    }
    if (methods.multiRangeSelectTreeDataValues) {
      selections.push({
        method: 'multiRangeSelectTreeDataValues',
        params: [methods.multiRangeSelectTreeDataValues.path, methods.multiRangeSelectTreeDataValues.ranges]
      });
    }
    return selections;
  }
  function initialize(picasso) {
    q.util = picasso.data('matrix').util;
    picasso.data('q', q);
    picasso.formatter('q-number', formatter$1);
    picasso.formatter('q-time', formatter);
  }
  initialize.qBrushHelper = qBrush; // deprecated
  initialize.selections = qBrush;

  function _extends$1() {
    _extends$1 = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$1.apply(this, arguments);
  }

  var react = {exports: {}};

  var react_development = {};

  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  /* eslint-disable no-unused-vars */
  var getOwnPropertySymbols$1 = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError('Object.assign cannot be called with null or undefined');
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }

      // Detect buggy property enumeration order in older V8 versions.

      // https://bugs.chromium.org/p/v8/issues/detail?id=4118
      var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
      test1[5] = 'de';
      if (Object.getOwnPropertyNames(test1)[0] === '5') {
        return false;
      }

      // https://bugs.chromium.org/p/v8/issues/detail?id=3056
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2['_' + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
        return test2[n];
      });
      if (order2.join('') !== '0123456789') {
        return false;
      }

      // https://bugs.chromium.org/p/v8/issues/detail?id=3056
      var test3 = {};
      'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
        return false;
      }
      return true;
    } catch (err) {
      // We don't expect any of the above to throw, but better to be safe.
      return false;
    }
  }
  var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
      if (getOwnPropertySymbols$1) {
        symbols = getOwnPropertySymbols$1(from);
        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }
    return to;
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var ReactPropTypesSecret$2 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
  var ReactPropTypesSecret_1 = ReactPropTypesSecret$2;

  var has$2 = Function.call.bind(Object.prototype.hasOwnProperty);

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var printWarning$1 = function () {};
  {
    var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
    var loggedTypeFailures = {};
    var has$1 = has$2;
    printWarning$1 = function (text) {
      var message = 'Warning: ' + text;
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {/**/}
    };
  }

  /**
   * Assert that the values match with the type specs.
   * Error messages are memorized and will only be shown once.
   *
   * @param {object} typeSpecs Map of name to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @param {string} componentName Name of the component for error messages.
   * @param {?Function} getStack Returns the component stack.
   * @private
   */
  function checkPropTypes$1(typeSpecs, values, location, componentName, getStack) {
    {
      for (var typeSpecName in typeSpecs) {
        if (has$1(typeSpecs, typeSpecName)) {
          var error;
          // Prop type validation may throw. In case they do, we don't want to
          // fail the render phase where it didn't fail before. So we log it.
          // After these have been cleaned up, we'll let them throw.
          try {
            // This is intentionally an invariant that gets caught. It's the same
            // behavior as without this statement except with a better message.
            if (typeof typeSpecs[typeSpecName] !== 'function') {
              var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
              err.name = 'Invariant Violation';
              throw err;
            }
            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
          } catch (ex) {
            error = ex;
          }
          if (error && !(error instanceof Error)) {
            printWarning$1((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
          }
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            // Only monitor this failure once because there tends to be a lot of the
            // same error.
            loggedTypeFailures[error.message] = true;
            var stack = getStack ? getStack() : '';
            printWarning$1('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
          }
        }
      }
    }
  }

  /**
   * Resets warning cache when testing.
   *
   * @private
   */
  checkPropTypes$1.resetWarningCache = function () {
    {
      loggedTypeFailures = {};
    }
  };
  var checkPropTypes_1 = checkPropTypes$1;

  /** @license React v16.14.0
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  {
    (function () {

      var _assign = objectAssign;
      var checkPropTypes = checkPropTypes_1;
      var ReactVersion = '16.14.0';

      // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
      // nor polyfill, then a plain number is used for performance.
      var hasSymbol = typeof Symbol === 'function' && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
      var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
      var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
      var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
      var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
      var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;
      var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = '@@iterator';
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== 'object') {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === 'function') {
          return maybeIterator;
        }
        return null;
      }

      /**
       * Keeps track of the current dispatcher.
       */
      var ReactCurrentDispatcher = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      };

      /**
       * Keeps track of the current batch's configuration such as how long an update
       * should suspend for if it needs to.
       */
      var ReactCurrentBatchConfig = {
        suspense: null
      };

      /**
       * Keeps track of the current owner.
       *
       * The current owner is the component who should own any components that are
       * currently being constructed.
       */
      var ReactCurrentOwner = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      };
      var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
      function describeComponentFrame(name, source, ownerName) {
        var sourceInfo = '';
        if (source) {
          var path = source.fileName;
          var fileName = path.replace(BEFORE_SLASH_RE, '');
          {
            // In DEV, include code for a common special case:
            // prefer "folder/index.js" instead of just "index.js".
            if (/^index\./.test(fileName)) {
              var match = path.match(BEFORE_SLASH_RE);
              if (match) {
                var pathBeforeSlash = match[1];
                if (pathBeforeSlash) {
                  var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
                  fileName = folderName + '/' + fileName;
                }
              }
            }
          }
          sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
        } else if (ownerName) {
          sourceInfo = ' (created by ' + ownerName + ')';
        }
        return '\n    in ' + (name || 'Unknown') + sourceInfo;
      }
      var Resolved = 1;
      function refineResolvedLazyComponent(lazyComponent) {
        return lazyComponent._status === Resolved ? lazyComponent._result : null;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || '';
        return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
      }
      function getComponentName(type) {
        if (type == null) {
          // Host root, text node or just invalid type.
          return null;
        }
        {
          if (typeof type.tag === 'number') {
            error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
          }
        }
        if (typeof type === 'function') {
          return type.displayName || type.name || null;
        }
        if (typeof type === 'string') {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return 'Fragment';
          case REACT_PORTAL_TYPE:
            return 'Portal';
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return 'StrictMode';
          case REACT_SUSPENSE_TYPE:
            return 'Suspense';
          case REACT_SUSPENSE_LIST_TYPE:
            return 'SuspenseList';
        }
        if (typeof type === 'object') {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              return 'Context.Consumer';
            case REACT_PROVIDER_TYPE:
              return 'Context.Provider';
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, 'ForwardRef');
            case REACT_MEMO_TYPE:
              return getComponentName(type.type);
            case REACT_BLOCK_TYPE:
              return getComponentName(type.render);
            case REACT_LAZY_TYPE:
              {
                var thenable = type;
                var resolvedThenable = refineResolvedLazyComponent(thenable);
                if (resolvedThenable) {
                  return getComponentName(resolvedThenable);
                }
                break;
              }
          }
        }
        return null;
      }
      var ReactDebugCurrentFrame = {};
      var currentlyValidatingElement = null;
      function setCurrentlyValidatingElement(element) {
        {
          currentlyValidatingElement = element;
        }
      }
      {
        // Stack implementation injected by the current renderer.
        ReactDebugCurrentFrame.getCurrentStack = null;
        ReactDebugCurrentFrame.getStackAddendum = function () {
          var stack = ''; // Add an extra top frame while an element is being validated

          if (currentlyValidatingElement) {
            var name = getComponentName(currentlyValidatingElement.type);
            var owner = currentlyValidatingElement._owner;
            stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
          } // Delegate to the injected renderer-specific implementation

          var impl = ReactDebugCurrentFrame.getCurrentStack;
          if (impl) {
            stack += impl() || '';
          }
          return stack;
        };
      }

      /**
       * Used by act() to track whether you're inside an act() scope.
       */
      var IsSomeRendererActing = {
        current: false
      };
      var ReactSharedInternals = {
        ReactCurrentDispatcher: ReactCurrentDispatcher,
        ReactCurrentBatchConfig: ReactCurrentBatchConfig,
        ReactCurrentOwner: ReactCurrentOwner,
        IsSomeRendererActing: IsSomeRendererActing,
        // Used by renderers to avoid bundling object-assign twice in UMD bundles:
        assign: _assign
      };
      {
        _assign(ReactSharedInternals, {
          // These should not be included in production.
          ReactDebugCurrentFrame: ReactDebugCurrentFrame,
          // Shim for React DOM 16.0.0 which still destructured (but not used) this.
          // TODO: remove in React 17.0.
          ReactComponentTreeHook: {}
        });
      }

      // by calls to these methods by a Babel plugin.
      //
      // In PROD (or in packages without access to React internals),
      // they are left as they are instead.

      function warn(format) {
        {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          printWarning('warn', format, args);
        }
      }
      function error(format) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          printWarning('error', format, args);
        }
      }
      function printWarning(level, format, args) {
        // When changing this logic, you might want to also
        // update consoleWithStackDev.www.js as well.
        {
          var hasExistingStack = args.length > 0 && typeof args[args.length - 1] === 'string' && args[args.length - 1].indexOf('\n    in') === 0;
          if (!hasExistingStack) {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== '') {
              format += '%s';
              args = args.concat([stack]);
            }
          }
          var argsWithFormat = args.map(function (item) {
            return '' + item;
          }); // Careful: RN currently depends on this prefix

          argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
          // breaks IE9: https://github.com/facebook/react/issues/13610
          // eslint-disable-next-line react-internal/no-production-logging

          Function.prototype.apply.call(console[level], console, argsWithFormat);
          try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            var argIndex = 0;
            var message = 'Warning: ' + format.replace(/%s/g, function () {
              return args[argIndex++];
            });
            throw new Error(message);
          } catch (x) {}
        }
      }
      var didWarnStateUpdateForUnmountedComponent = {};
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
          var warningKey = componentName + "." + callerName;
          if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
            return;
          }
          error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
          didWarnStateUpdateForUnmountedComponent[warningKey] = true;
        }
      }
      /**
       * This is the abstract API for an update queue.
       */

      var ReactNoopUpdateQueue = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function (publicInstance) {
          return false;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function (publicInstance, callback, callerName) {
          warnNoop(publicInstance, 'forceUpdate');
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
          warnNoop(publicInstance, 'replaceState');
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function (publicInstance, partialState, callback, callerName) {
          warnNoop(publicInstance, 'setState');
        }
      };
      var emptyObject = {};
      {
        Object.freeze(emptyObject);
      }
      /**
       * Base class helpers for the updating state of a component.
       */

      function Component(props, context, updater) {
        this.props = props;
        this.context = context; // If a component has string refs, we will assign a different object later.

        this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
        // renderer.

        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      /**
       * Sets a subset of the state. Always use this to mutate
       * state. You should treat `this.state` as immutable.
       *
       * There is no guarantee that `this.state` will be immediately updated, so
       * accessing `this.state` after calling this method may return the old value.
       *
       * There is no guarantee that calls to `setState` will run synchronously,
       * as they may eventually be batched together.  You can provide an optional
       * callback that will be executed when the call to setState is actually
       * completed.
       *
       * When a function is provided to setState, it will be called at some point in
       * the future (not synchronously). It will be called with the up to date
       * component arguments (state, props, context). These values can be different
       * from this.* because your function may be called after receiveProps but before
       * shouldComponentUpdate, and this new state, props, and context will not yet be
       * assigned to this.
       *
       * @param {object|function} partialState Next partial state or function to
       *        produce next partial state to be merged with current state.
       * @param {?function} callback Called after state is updated.
       * @final
       * @protected
       */

      Component.prototype.setState = function (partialState, callback) {
        if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
          {
            throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
        }
        this.updater.enqueueSetState(this, partialState, callback, 'setState');
      };
      /**
       * Forces an update. This should only be invoked when it is known with
       * certainty that we are **not** in a DOM transaction.
       *
       * You may want to call this when you know that some deeper aspect of the
       * component's state has changed but `setState` was not called.
       *
       * This will not invoke `shouldComponentUpdate`, but it will invoke
       * `componentWillUpdate` and `componentDidUpdate`.
       *
       * @param {?function} callback Called after update is complete.
       * @final
       * @protected
       */

      Component.prototype.forceUpdate = function (callback) {
        this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
      };
      /**
       * Deprecated APIs. These APIs used to exist on classic React classes but since
       * we would like to deprecate them, we're not going to move them over to this
       * modern base class. Instead, we define a getter that warns if it's accessed.
       */

      {
        var deprecatedAPIs = {
          isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
          replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
        };
        var defineDeprecationWarning = function (methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function () {
              warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
              return undefined;
            }
          });
        };
        for (var fnName in deprecatedAPIs) {
          if (deprecatedAPIs.hasOwnProperty(fnName)) {
            defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
          }
        }
      }
      function ComponentDummy() {}
      ComponentDummy.prototype = Component.prototype;
      /**
       * Convenience component with default shallow equality check for sCU.
       */

      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context; // If a component has string refs, we will assign a different object later.

        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

      _assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;

      // an immutable object with a single mutable value
      function createRef() {
        var refObject = {
          current: null
        };
        {
          Object.seal(refObject);
        }
        return refObject;
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, 'ref')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== undefined;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, 'key')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== undefined;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function () {
          {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
            }
          }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, 'key', {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function () {
          {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
            }
          }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, 'ref', {
          get: warnAboutAccessingRef,
          configurable: true
        });
      }
      function warnIfStringRefCannotBeAutoConverted(config) {
        {
          if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
            var componentName = getComponentName(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://fb.me/react-strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      /**
       * Factory method to create a new React element. This no longer adheres to
       * the class pattern, so do not use new to call it. Also, instanceof check
       * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
       * if something is a React Element.
       *
       * @param {*} type
       * @param {*} props
       * @param {*} key
       * @param {string|object} ref
       * @param {*} owner
       * @param {*} self A *temporary* helper to detect places where `this` is
       * different from the `owner` when React.createElement is called, so that we
       * can warn. We want to get rid of owner and replace string `ref`s with arrow
       * functions, and as long as `this` and owner are the same, there will be no
       * change in behavior.
       * @param {*} source An annotation object (added by a transpiler or otherwise)
       * indicating filename, line number, and/or other information.
       * @internal
       */

      var ReactElement = function (type, key, ref, self, source, owner, props) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type: type,
          key: key,
          ref: ref,
          props: props,
          // Record the component responsible for creating this element.
          _owner: owner
        };
        {
          // The validation flag is currently mutative. We put it on
          // an external backing store so that we can freeze the whole object.
          // This can be replaced with a WeakMap once they are implemented in
          // commonly used development environments.
          element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
          // the validation flag non-enumerable (where possible, which should
          // include every environment we run tests in), so the test framework
          // ignores it.

          Object.defineProperty(element._store, 'validated', {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          }); // self and source are DEV only properties.

          Object.defineProperty(element, '_self', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
          }); // Two elements created in two different places should be considered
          // equal for testing purposes and therefore we hide it from enumeration.

          Object.defineProperty(element, '_source', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      /**
       * Create and return a new ReactElement of the given type.
       * See https://reactjs.org/docs/react-api.html#createelement
       */

      function createElement(type, config, children) {
        var propName; // Reserved names are extracted

        var props = {};
        var key = null;
        var ref = null;
        var self = null;
        var source = null;
        if (config != null) {
          if (hasValidRef(config)) {
            ref = config.ref;
            {
              warnIfStringRefCannotBeAutoConverted(config);
            }
          }
          if (hasValidKey(config)) {
            key = '' + config.key;
          }
          self = config.__self === undefined ? null : config.__self;
          source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
        } // Children can be more than one argument, and those are transferred onto
        // the newly allocated props object.

        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);
          for (var i = 0; i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }
          {
            if (Object.freeze) {
              Object.freeze(childArray);
            }
          }
          props.children = childArray;
        } // Resolve default props

        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;
          for (propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
        }
        {
          if (key || ref) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
      }
      /**
       * Clone and return a new ReactElement using element as the starting point.
       * See https://reactjs.org/docs/react-api.html#cloneelement
       */

      function cloneElement(element, config, children) {
        if (!!(element === null || element === undefined)) {
          {
            throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
          }
        }
        var propName; // Original props are copied

        var props = _assign({}, element.props); // Reserved names are extracted

        var key = element.key;
        var ref = element.ref; // Self is preserved since the owner is preserved.

        var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
        // transpiler, and the original source is probably a better indicator of the
        // true owner.

        var source = element._source; // Owner will be preserved, unless ref is overridden

        var owner = element._owner;
        if (config != null) {
          if (hasValidRef(config)) {
            // Silently steal the ref from the parent.
            ref = config.ref;
            owner = ReactCurrentOwner.current;
          }
          if (hasValidKey(config)) {
            key = '' + config.key;
          } // Remaining properties override existing props

          var defaultProps;
          if (element.type && element.type.defaultProps) {
            defaultProps = element.type.defaultProps;
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              if (config[propName] === undefined && defaultProps !== undefined) {
                // Resolve default props
                props[propName] = defaultProps[propName];
              } else {
                props[propName] = config[propName];
              }
            }
          }
        } // Children can be more than one argument, and those are transferred onto
        // the newly allocated props object.

        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);
          for (var i = 0; i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }
          props.children = childArray;
        }
        return ReactElement(element.type, key, ref, self, source, owner, props);
      }
      /**
       * Verifies the object is a ReactElement.
       * See https://reactjs.org/docs/react-api.html#isvalidelement
       * @param {?object} object
       * @return {boolean} True if `object` is a ReactElement.
       * @final
       */

      function isValidElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      var SEPARATOR = '.';
      var SUBSEPARATOR = ':';
      /**
       * Escape and wrap key so it is safe to use as a reactid
       *
       * @param {string} key to be escaped.
       * @return {string} the escaped key.
       */

      function escape(key) {
        var escapeRegex = /[=:]/g;
        var escaperLookup = {
          '=': '=0',
          ':': '=2'
        };
        var escapedString = ('' + key).replace(escapeRegex, function (match) {
          return escaperLookup[match];
        });
        return '$' + escapedString;
      }
      /**
       * TODO: Test that a single child and an array with one item have the same key
       * pattern.
       */

      var didWarnAboutMaps = false;
      var userProvidedKeyEscapeRegex = /\/+/g;
      function escapeUserProvidedKey(text) {
        return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
      }
      var POOL_SIZE = 10;
      var traverseContextPool = [];
      function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
        if (traverseContextPool.length) {
          var traverseContext = traverseContextPool.pop();
          traverseContext.result = mapResult;
          traverseContext.keyPrefix = keyPrefix;
          traverseContext.func = mapFunction;
          traverseContext.context = mapContext;
          traverseContext.count = 0;
          return traverseContext;
        } else {
          return {
            result: mapResult,
            keyPrefix: keyPrefix,
            func: mapFunction,
            context: mapContext,
            count: 0
          };
        }
      }
      function releaseTraverseContext(traverseContext) {
        traverseContext.result = null;
        traverseContext.keyPrefix = null;
        traverseContext.func = null;
        traverseContext.context = null;
        traverseContext.count = 0;
        if (traverseContextPool.length < POOL_SIZE) {
          traverseContextPool.push(traverseContext);
        }
      }
      /**
       * @param {?*} children Children tree container.
       * @param {!string} nameSoFar Name of the key path so far.
       * @param {!function} callback Callback to invoke with each child found.
       * @param {?*} traverseContext Used to pass information throughout the traversal
       * process.
       * @return {!number} The number of children in this subtree.
       */

      function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
        var type = typeof children;
        if (type === 'undefined' || type === 'boolean') {
          // All of the above are perceived as null.
          children = null;
        }
        var invokeCallback = false;
        if (children === null) {
          invokeCallback = true;
        } else {
          switch (type) {
            case 'string':
            case 'number':
              invokeCallback = true;
              break;
            case 'object':
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
              }
          }
        }
        if (invokeCallback) {
          callback(traverseContext, children,
          // If it's the only child, treat the name as if it was wrapped in an array
          // so that it's consistent if the number of children grows.
          nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
          return 1;
        }
        var child;
        var nextName;
        var subtreeCount = 0; // Count of children found in the current subtree.

        var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (Array.isArray(children)) {
          for (var i = 0; i < children.length; i++) {
            child = children[i];
            nextName = nextNamePrefix + getComponentKey(child, i);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else {
          var iteratorFn = getIteratorFn(children);
          if (typeof iteratorFn === 'function') {
            {
              // Warn about using Maps as children
              if (iteratorFn === children.entries) {
                if (!didWarnAboutMaps) {
                  warn('Using Maps as children is deprecated and will be removed in ' + 'a future major release. Consider converting children to ' + 'an array of keyed ReactElements instead.');
                }
                didWarnAboutMaps = true;
              }
            }
            var iterator = iteratorFn.call(children);
            var step;
            var ii = 0;
            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getComponentKey(child, ii++);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          } else if (type === 'object') {
            var addendum = '';
            {
              addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
            }
            var childrenString = '' + children;
            {
              {
                throw Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + ")." + addendum);
              }
            }
          }
        }
        return subtreeCount;
      }
      /**
       * Traverses children that are typically specified as `props.children`, but
       * might also be specified through attributes:
       *
       * - `traverseAllChildren(this.props.children, ...)`
       * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
       *
       * The `traverseContext` is an optional argument that is passed through the
       * entire traversal. It can be used to store accumulations or anything else that
       * the callback might find relevant.
       *
       * @param {?*} children Children tree object.
       * @param {!function} callback To invoke upon traversing each child.
       * @param {?*} traverseContext Context for traversal.
       * @return {!number} The number of children in this subtree.
       */

      function traverseAllChildren(children, callback, traverseContext) {
        if (children == null) {
          return 0;
        }
        return traverseAllChildrenImpl(children, '', callback, traverseContext);
      }
      /**
       * Generate a key string that identifies a component within a set.
       *
       * @param {*} component A component that could contain a manual key.
       * @param {number} index Index that is used if a manual key is not provided.
       * @return {string}
       */

      function getComponentKey(component, index) {
        // Do some typechecking here since we call this blindly. We want to ensure
        // that we don't block potential future ES APIs.
        if (typeof component === 'object' && component !== null && component.key != null) {
          // Explicit key
          return escape(component.key);
        } // Implicit key determined by the index in the set

        return index.toString(36);
      }
      function forEachSingleChild(bookKeeping, child, name) {
        var func = bookKeeping.func,
          context = bookKeeping.context;
        func.call(context, child, bookKeeping.count++);
      }
      /**
       * Iterates through children that are typically specified as `props.children`.
       *
       * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
       *
       * The provided forEachFunc(child, index) will be called for each
       * leaf child.
       *
       * @param {?*} children Children tree container.
       * @param {function(*, int)} forEachFunc
       * @param {*} forEachContext Context for forEachContext.
       */

      function forEachChildren(children, forEachFunc, forEachContext) {
        if (children == null) {
          return children;
        }
        var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
        traverseAllChildren(children, forEachSingleChild, traverseContext);
        releaseTraverseContext(traverseContext);
      }
      function mapSingleChildIntoContext(bookKeeping, child, childKey) {
        var result = bookKeeping.result,
          keyPrefix = bookKeeping.keyPrefix,
          func = bookKeeping.func,
          context = bookKeeping.context;
        var mappedChild = func.call(context, child, bookKeeping.count++);
        if (Array.isArray(mappedChild)) {
          mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {
            return c;
          });
        } else if (mappedChild != null) {
          if (isValidElement(mappedChild)) {
            mappedChild = cloneAndReplaceKey(mappedChild,
            // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
          }
          result.push(mappedChild);
        }
      }
      function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
        var escapedPrefix = '';
        if (prefix != null) {
          escapedPrefix = escapeUserProvidedKey(prefix) + '/';
        }
        var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
        traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
        releaseTraverseContext(traverseContext);
      }
      /**
       * Maps children that are typically specified as `props.children`.
       *
       * See https://reactjs.org/docs/react-api.html#reactchildrenmap
       *
       * The provided mapFunction(child, key, index) will be called for each
       * leaf child.
       *
       * @param {?*} children Children tree container.
       * @param {function(*, int)} func The map function.
       * @param {*} context Context for mapFunction.
       * @return {object} Object containing the ordered map of results.
       */

      function mapChildren(children, func, context) {
        if (children == null) {
          return children;
        }
        var result = [];
        mapIntoWithKeyPrefixInternal(children, result, null, func, context);
        return result;
      }
      /**
       * Count the number of children that are typically specified as
       * `props.children`.
       *
       * See https://reactjs.org/docs/react-api.html#reactchildrencount
       *
       * @param {?*} children Children tree container.
       * @return {number} The number of children.
       */

      function countChildren(children) {
        return traverseAllChildren(children, function () {
          return null;
        }, null);
      }
      /**
       * Flatten a children object (typically specified as `props.children`) and
       * return an array with appropriately re-keyed children.
       *
       * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
       */

      function toArray(children) {
        var result = [];
        mapIntoWithKeyPrefixInternal(children, result, null, function (child) {
          return child;
        });
        return result;
      }
      /**
       * Returns the first child in a collection of children and verifies that there
       * is only one child in the collection.
       *
       * See https://reactjs.org/docs/react-api.html#reactchildrenonly
       *
       * The current implementation of this function assumes that a single child gets
       * passed without a wrapper, but the purpose of this helper function is to
       * abstract away the particular structure of children.
       *
       * @param {?object} children Child collection structure.
       * @return {ReactElement} The first and only `ReactElement` contained in the
       * structure.
       */

      function onlyChild(children) {
        if (!isValidElement(children)) {
          {
            throw Error("React.Children.only expected to receive a single React element child.");
          }
        }
        return children;
      }
      function createContext(defaultValue, calculateChangedBits) {
        if (calculateChangedBits === undefined) {
          calculateChangedBits = null;
        } else {
          {
            if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
              error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
            }
          }
        }
        var context = {
          $$typeof: REACT_CONTEXT_TYPE,
          _calculateChangedBits: calculateChangedBits,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null
        };
        context.Provider = {
          $$typeof: REACT_PROVIDER_TYPE,
          _context: context
        };
        var hasWarnedAboutUsingNestedContextConsumers = false;
        var hasWarnedAboutUsingConsumerProvider = false;
        {
          // A separate object, but proxies back to the original context object for
          // backwards compatibility. It has a different $$typeof, so we can properly
          // warn for the incorrect usage of Context as a Consumer.
          var Consumer = {
            $$typeof: REACT_CONTEXT_TYPE,
            _context: context,
            _calculateChangedBits: context._calculateChangedBits
          }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

          Object.defineProperties(Consumer, {
            Provider: {
              get: function () {
                if (!hasWarnedAboutUsingConsumerProvider) {
                  hasWarnedAboutUsingConsumerProvider = true;
                  error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
                }
                return context.Provider;
              },
              set: function (_Provider) {
                context.Provider = _Provider;
              }
            },
            _currentValue: {
              get: function () {
                return context._currentValue;
              },
              set: function (_currentValue) {
                context._currentValue = _currentValue;
              }
            },
            _currentValue2: {
              get: function () {
                return context._currentValue2;
              },
              set: function (_currentValue2) {
                context._currentValue2 = _currentValue2;
              }
            },
            _threadCount: {
              get: function () {
                return context._threadCount;
              },
              set: function (_threadCount) {
                context._threadCount = _threadCount;
              }
            },
            Consumer: {
              get: function () {
                if (!hasWarnedAboutUsingNestedContextConsumers) {
                  hasWarnedAboutUsingNestedContextConsumers = true;
                  error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
                }
                return context.Consumer;
              }
            }
          }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

          context.Consumer = Consumer;
        }
        {
          context._currentRenderer = null;
          context._currentRenderer2 = null;
        }
        return context;
      }
      function lazy(ctor) {
        var lazyType = {
          $$typeof: REACT_LAZY_TYPE,
          _ctor: ctor,
          // React uses these fields to store the result.
          _status: -1,
          _result: null
        };
        {
          // In production, this would just set it on the object.
          var defaultProps;
          var propTypes;
          Object.defineProperties(lazyType, {
            defaultProps: {
              configurable: true,
              get: function () {
                return defaultProps;
              },
              set: function (newDefaultProps) {
                error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                defaultProps = newDefaultProps; // Match production behavior more closely:

                Object.defineProperty(lazyType, 'defaultProps', {
                  enumerable: true
                });
              }
            },
            propTypes: {
              configurable: true,
              get: function () {
                return propTypes;
              },
              set: function (newPropTypes) {
                error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                propTypes = newPropTypes; // Match production behavior more closely:

                Object.defineProperty(lazyType, 'propTypes', {
                  enumerable: true
                });
              }
            }
          });
        }
        return lazyType;
      }
      function forwardRef(render) {
        {
          if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
            error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
          } else if (typeof render !== 'function') {
            error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
          } else {
            if (render.length !== 0 && render.length !== 2) {
              error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
            }
          }
          if (render != null) {
            if (render.defaultProps != null || render.propTypes != null) {
              error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
            }
          }
        }
        return {
          $$typeof: REACT_FORWARD_REF_TYPE,
          render: render
        };
      }
      function isValidElementType(type) {
        return typeof type === 'string' || typeof type === 'function' ||
        // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
        type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
      }
      function memo(type, compare) {
        {
          if (!isValidElementType(type)) {
            error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
          }
        }
        return {
          $$typeof: REACT_MEMO_TYPE,
          type: type,
          compare: compare === undefined ? null : compare
        };
      }
      function resolveDispatcher() {
        var dispatcher = ReactCurrentDispatcher.current;
        if (!(dispatcher !== null)) {
          {
            throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.");
          }
        }
        return dispatcher;
      }
      function useContext(Context, unstable_observedBits) {
        var dispatcher = resolveDispatcher();
        {
          if (unstable_observedBits !== undefined) {
            error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://fb.me/rules-of-hooks' : '');
          } // TODO: add a more generic warning for invalid values.

          if (Context._context !== undefined) {
            var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
            // and nobody should be using this in existing code.

            if (realContext.Consumer === Context) {
              error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
            } else if (realContext.Provider === Context) {
              error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
            }
          }
        }
        return dispatcher.useContext(Context, unstable_observedBits);
      }
      function useState(initialState) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
      }
      function useReducer(reducer, initialArg, init) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useReducer(reducer, initialArg, init);
      }
      function useRef(initialValue) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useRef(initialValue);
      }
      function useEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useEffect(create, deps);
      }
      function useLayoutEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useLayoutEffect(create, deps);
      }
      function useCallback(callback, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useCallback(callback, deps);
      }
      function useMemo(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMemo(create, deps);
      }
      function useImperativeHandle(ref, create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useImperativeHandle(ref, create, deps);
      }
      function useDebugValue(value, formatterFn) {
        {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDebugValue(value, formatterFn);
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
          var name = getComponentName(ReactCurrentOwner.current.type);
          if (name) {
            return '\n\nCheck the render method of `' + name + '`.';
          }
        }
        return '';
      }
      function getSourceInfoErrorAddendum(source) {
        if (source !== undefined) {
          var fileName = source.fileName.replace(/^.*[\\\/]/, '');
          var lineNumber = source.lineNumber;
          return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
        }
        return '';
      }
      function getSourceInfoErrorAddendumForProps(elementProps) {
        if (elementProps !== null && elementProps !== undefined) {
          return getSourceInfoErrorAddendum(elementProps.__source);
        }
        return '';
      }
      /**
       * Warn if there's no key explicitly set on dynamic arrays of children or
       * object keys are not valid. This allows us to keep track of children between
       * updates.
       */

      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
          if (parentName) {
            info = "\n\nCheck the top-level render call using <" + parentName + ">.";
          }
        }
        return info;
      }
      /**
       * Warn if the element doesn't have an explicit key assigned to it.
       * This element is in an array. The array could grow and shrink or be
       * reordered. All children that haven't already been validated are required to
       * have a "key" property assigned to it. Error statuses are cached so a warning
       * will only be shown once.
       *
       * @internal
       * @param {ReactElement} element Element that requires a key.
       * @param {*} parentType element's parent's type.
       */

      function validateExplicitKey(element, parentType) {
        if (!element._store || element._store.validated || element.key != null) {
          return;
        }
        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
        // property, it may be the creator of the child that's responsible for
        // assigning it a key.

        var childOwner = '';
        if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
          // Give the component that originally created this child.
          childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
        }
        setCurrentlyValidatingElement(element);
        {
          error('Each child in a list should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
        }
        setCurrentlyValidatingElement(null);
      }
      /**
       * Ensure that every element either is passed in a static location, in an
       * array with an explicit keys property defined, or in an object literal
       * with valid key property.
       *
       * @internal
       * @param {ReactNode} node Statically passed child of any type.
       * @param {*} parentType node's parent's type.
       */

      function validateChildKeys(node, parentType) {
        if (typeof node !== 'object') {
          return;
        }
        if (Array.isArray(node)) {
          for (var i = 0; i < node.length; i++) {
            var child = node[i];
            if (isValidElement(child)) {
              validateExplicitKey(child, parentType);
            }
          }
        } else if (isValidElement(node)) {
          // This element was passed in a valid location.
          if (node._store) {
            node._store.validated = true;
          }
        } else if (node) {
          var iteratorFn = getIteratorFn(node);
          if (typeof iteratorFn === 'function') {
            // Entry iterators used to provide implicit keys,
            // but now we print a separate warning for them later.
            if (iteratorFn !== node.entries) {
              var iterator = iteratorFn.call(node);
              var step;
              while (!(step = iterator.next()).done) {
                if (isValidElement(step.value)) {
                  validateExplicitKey(step.value, parentType);
                }
              }
            }
          }
        }
      }
      /**
       * Given an element, validate that its props follow the propTypes definition,
       * provided by the type.
       *
       * @param {ReactElement} element
       */

      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === undefined || typeof type === 'string') {
            return;
          }
          var name = getComponentName(type);
          var propTypes;
          if (typeof type === 'function') {
            propTypes = type.propTypes;
          } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||
          // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            setCurrentlyValidatingElement(element);
            checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);
            setCurrentlyValidatingElement(null);
          } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
          }
          if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
            error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
          }
        }
      }
      /**
       * Given a fragment, validate that it can only be provided with fragment props
       * @param {ReactElement} fragment
       */

      function validateFragmentProps(fragment) {
        {
          setCurrentlyValidatingElement(fragment);
          var keys = Object.keys(fragment.props);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key !== 'children' && key !== 'key') {
              error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
              break;
            }
          }
          if (fragment.ref !== null) {
            error('Invalid attribute `ref` supplied to `React.Fragment`.');
          }
          setCurrentlyValidatingElement(null);
        }
      }
      function createElementWithValidation(type, props, children) {
        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
        // succeed and there will likely be errors in render.

        if (!validType) {
          var info = '';
          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
            info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
          }
          var sourceInfo = getSourceInfoErrorAddendumForProps(props);
          if (sourceInfo) {
            info += sourceInfo;
          } else {
            info += getDeclarationErrorAddendum();
          }
          var typeString;
          if (type === null) {
            typeString = 'null';
          } else if (Array.isArray(type)) {
            typeString = 'array';
          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
            typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
            info = ' Did you accidentally export a JSX literal instead of a component?';
          } else {
            typeString = typeof type;
          }
          {
            error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
          }
        }
        var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
        // TODO: Drop this when these are no longer allowed as the type argument.

        if (element == null) {
          return element;
        } // Skip key warning if the type isn't valid since our key validation logic
        // doesn't expect a non-string/function type and can throw confusing errors.
        // We don't want exception behavior to differ between dev and prod.
        // (Rendering will throw with a helpful message and as soon as the type is
        // fixed, the key warnings will appear.)

        if (validType) {
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], type);
          }
        }
        if (type === REACT_FRAGMENT_TYPE) {
          validateFragmentProps(element);
        } else {
          validatePropTypes(element);
        }
        return element;
      }
      var didWarnAboutDeprecatedCreateFactory = false;
      function createFactoryWithValidation(type) {
        var validatedFactory = createElementWithValidation.bind(null, type);
        validatedFactory.type = type;
        {
          if (!didWarnAboutDeprecatedCreateFactory) {
            didWarnAboutDeprecatedCreateFactory = true;
            warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
          } // Legacy hook: remove it

          Object.defineProperty(validatedFactory, 'type', {
            enumerable: false,
            get: function () {
              warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
              Object.defineProperty(this, 'type', {
                value: type
              });
              return type;
            }
          });
        }
        return validatedFactory;
      }
      function cloneElementWithValidation(element, props, children) {
        var newElement = cloneElement.apply(this, arguments);
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], newElement.type);
        }
        validatePropTypes(newElement);
        return newElement;
      }
      {
        try {
          var frozenObject = Object.freeze({});
          var testMap = new Map([[frozenObject, null]]);
          var testSet = new Set([frozenObject]); // This is necessary for Rollup to not consider these unused.
          // https://github.com/rollup/rollup/issues/1771
          // TODO: we can remove these if Rollup fixes the bug.

          testMap.set(0, 0);
          testSet.add(0);
        } catch (e) {}
      }
      var createElement$1 = createElementWithValidation;
      var cloneElement$1 = cloneElementWithValidation;
      var createFactory = createFactoryWithValidation;
      var Children = {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray: toArray,
        only: onlyChild
      };
      react_development.Children = Children;
      react_development.Component = Component;
      react_development.Fragment = REACT_FRAGMENT_TYPE;
      react_development.Profiler = REACT_PROFILER_TYPE;
      react_development.PureComponent = PureComponent;
      react_development.StrictMode = REACT_STRICT_MODE_TYPE;
      react_development.Suspense = REACT_SUSPENSE_TYPE;
      react_development.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
      react_development.cloneElement = cloneElement$1;
      react_development.createContext = createContext;
      react_development.createElement = createElement$1;
      react_development.createFactory = createFactory;
      react_development.createRef = createRef;
      react_development.forwardRef = forwardRef;
      react_development.isValidElement = isValidElement;
      react_development.lazy = lazy;
      react_development.memo = memo;
      react_development.useCallback = useCallback;
      react_development.useContext = useContext;
      react_development.useDebugValue = useDebugValue;
      react_development.useEffect = useEffect;
      react_development.useImperativeHandle = useImperativeHandle;
      react_development.useLayoutEffect = useLayoutEffect;
      react_development.useMemo = useMemo;
      react_development.useReducer = useReducer;
      react_development.useRef = useRef;
      react_development.useState = useState;
      react_development.version = ReactVersion;
    })();
  }

  {
    react.exports = react_development;
  }
  var reactExports = react.exports;
  var React = /*@__PURE__*/getDefaultExportFromCjs(reactExports);

  var propTypes = {exports: {}};

  var reactIs$2 = {exports: {}};

  var reactIs_development$1 = {};

  /** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  {
    (function () {

      // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
      // nor polyfill, then a plain number is used for performance.
      var hasSymbol = typeof Symbol === 'function' && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
      // (unstable) APIs that have been removed. Can we remove the symbols?

      var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
      var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
      var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
      var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
      var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
      var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;
      function isValidElementType(type) {
        return typeof type === 'string' || typeof type === 'function' ||
        // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
        type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
      }
      function typeOf(object) {
        if (typeof object === 'object' && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return undefined;
      } // AsyncMode is deprecated along with isAsyncMode

      var AsyncMode = REACT_ASYNC_MODE_TYPE;
      var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
          }
        }
        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
      }
      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      reactIs_development$1.AsyncMode = AsyncMode;
      reactIs_development$1.ConcurrentMode = ConcurrentMode;
      reactIs_development$1.ContextConsumer = ContextConsumer;
      reactIs_development$1.ContextProvider = ContextProvider;
      reactIs_development$1.Element = Element;
      reactIs_development$1.ForwardRef = ForwardRef;
      reactIs_development$1.Fragment = Fragment;
      reactIs_development$1.Lazy = Lazy;
      reactIs_development$1.Memo = Memo;
      reactIs_development$1.Portal = Portal;
      reactIs_development$1.Profiler = Profiler;
      reactIs_development$1.StrictMode = StrictMode;
      reactIs_development$1.Suspense = Suspense;
      reactIs_development$1.isAsyncMode = isAsyncMode;
      reactIs_development$1.isConcurrentMode = isConcurrentMode;
      reactIs_development$1.isContextConsumer = isContextConsumer;
      reactIs_development$1.isContextProvider = isContextProvider;
      reactIs_development$1.isElement = isElement;
      reactIs_development$1.isForwardRef = isForwardRef;
      reactIs_development$1.isFragment = isFragment;
      reactIs_development$1.isLazy = isLazy;
      reactIs_development$1.isMemo = isMemo;
      reactIs_development$1.isPortal = isPortal;
      reactIs_development$1.isProfiler = isProfiler;
      reactIs_development$1.isStrictMode = isStrictMode;
      reactIs_development$1.isSuspense = isSuspense;
      reactIs_development$1.isValidElementType = isValidElementType;
      reactIs_development$1.typeOf = typeOf;
    })();
  }

  {
    reactIs$2.exports = reactIs_development$1;
  }
  var reactIsExports$1 = reactIs$2.exports;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var ReactIs$1 = reactIsExports$1;
  var assign = objectAssign;
  var ReactPropTypesSecret = ReactPropTypesSecret_1;
  var has = has$2;
  var checkPropTypes = checkPropTypes_1;
  var printWarning = function () {};
  {
    printWarning = function (text) {
      var message = 'Warning: ' + text;
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };
  }
  function emptyFunctionThatReturnsNull() {
    return null;
  }
  var factoryWithTypeCheckers = function (isValidElement, throwOnDirectAccess) {
    /* global Symbol */
    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

    /**
     * Returns the iterator method function contained on the iterable object.
     *
     * Be sure to invoke the function with the iterable as context:
     *
     *     var iteratorFn = getIteratorFn(myIterable);
     *     if (iteratorFn) {
     *       var iterator = iteratorFn.call(myIterable);
     *       ...
     *     }
     *
     * @param {?object} maybeIterable
     * @return {?function}
     */
    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }

    /**
     * Collection of methods that allow declaration and validation of props that are
     * supplied to React components. Example usage:
     *
     *   var Props = require('ReactPropTypes');
     *   var MyArticle = React.createClass({
     *     propTypes: {
     *       // An optional string prop named "description".
     *       description: Props.string,
     *
     *       // A required enum prop named "category".
     *       category: Props.oneOf(['News','Photos']).isRequired,
     *
     *       // A prop named "dialog" that requires an instance of Dialog.
     *       dialog: Props.instanceOf(Dialog).isRequired
     *     },
     *     render: function() { ... }
     *   });
     *
     * A more formal specification of how these methods are used:
     *
     *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
     *   decl := ReactPropTypes.{type}(.isRequired)?
     *
     * Each and every declaration produces a function with the same signature. This
     * allows the creation of custom validation functions. For example:
     *
     *  var MyLink = React.createClass({
     *    propTypes: {
     *      // An optional string or URI prop named "href".
     *      href: function(props, propName, componentName) {
     *        var propValue = props[propName];
     *        if (propValue != null && typeof propValue !== 'string' &&
     *            !(propValue instanceof URI)) {
     *          return new Error(
     *            'Expected a string or an URI for ' + propName + ' in ' +
     *            componentName
     *          );
     *        }
     *      }
     *    },
     *    render: function() {...}
     *  });
     *
     * @internal
     */

    var ANONYMOUS = '<<anonymous>>';

    // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker('array'),
      bigint: createPrimitiveTypeChecker('bigint'),
      bool: createPrimitiveTypeChecker('boolean'),
      func: createPrimitiveTypeChecker('function'),
      number: createPrimitiveTypeChecker('number'),
      object: createPrimitiveTypeChecker('object'),
      string: createPrimitiveTypeChecker('string'),
      symbol: createPrimitiveTypeChecker('symbol'),
      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      elementType: createElementTypeTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker
    };

    /**
     * inlined Object.is polyfill to avoid requiring consumers ship their own
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
     */
    /*eslint-disable no-self-compare*/
    function is(x, y) {
      // SameValue algorithm
      if (x === y) {
        // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
      } else {
        // Step 6.a: NaN == NaN
        return x !== x && y !== y;
      }
    }
    /*eslint-enable no-self-compare*/

    /**
     * We use an Error-like object for backward compatibility as people may call
     * PropTypes directly and inspect their output. However, we don't use real
     * Errors anymore. We don't inspect their stack anyway, and creating them
     * is prohibitively expensive if they are created too often, such as what
     * happens in oneOfType() for any type before the one that matched.
     */
    function PropTypeError(message, data) {
      this.message = message;
      this.data = data && typeof data === 'object' ? data : {};
      this.stack = '';
    }
    // Make `instanceof Error` still work for returned errors.
    PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate) {
      {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }
      function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;
        if (secret !== ReactPropTypesSecret) {
          if (throwOnDirectAccess) {
            // New behavior only for users of `prop-types` package
            var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
            err.name = 'Invariant Violation';
            throw err;
          } else if (typeof console !== 'undefined') {
            // Old behavior for people using React.PropTypes
            var cacheKey = componentName + ':' + propName;
            if (!manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3) {
              printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }
        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
            }
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
          }
          return null;
        } else {
          return validate(props, propName, componentName, location, propFullName);
        }
      }
      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);
      return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== expectedType) {
          // `propValue` being instance of, say, date/regexp, pass the 'object'
          // check, but we can offer a more precise error message here rather than
          // 'of type `object`'.
          var preciseType = getPreciseType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'), {
            expectedType: expectedType
          });
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }
    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
        }
        var propValue = props[propName];
        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
        }
        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createElementTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createElementTypeTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!ReactIs$1.isValidElementType(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        {
          if (arguments.length > 1) {
            printWarning('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
          } else {
            printWarning('Invalid argument supplied to oneOf, expected an array.');
          }
        }
        return emptyFunctionThatReturnsNull;
      }
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }
        var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
          var type = getPreciseType(value);
          if (type === 'symbol') {
            return String(value);
          }
          return value;
        });
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
      }
      return createChainableTypeChecker(validate);
    }
    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
        }
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
        }
        for (var key in propValue) {
          if (has(propValue, key)) {
            var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') ;
        return emptyFunctionThatReturnsNull;
      }
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (typeof checker !== 'function') {
          printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
          return emptyFunctionThatReturnsNull;
        }
      }
      function validate(props, propName, componentName, location, propFullName) {
        var expectedTypes = [];
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
          if (checkerResult == null) {
            return null;
          }
          if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
            expectedTypes.push(checkerResult.data.expectedType);
          }
        }
        var expectedTypesMessage = expectedTypes.length > 0 ? ', expected one of type [' + expectedTypes.join(', ') + ']' : '';
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
      }
      return createChainableTypeChecker(validate);
    }
    function createNodeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        if (!isNode(props[propName])) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function invalidValidatorError(componentName, location, propFullName, key, type) {
      return new PropTypeError((componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + type + '`.');
    }
    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }
        for (var key in shapeTypes) {
          var checker = shapeTypes[key];
          if (typeof checker !== 'function') {
            return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
          }
          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }
        // We need to check all keys in case some are required but missing from props.
        var allKeys = assign({}, props[propName], shapeTypes);
        for (var key in allKeys) {
          var checker = shapeTypes[key];
          if (has(shapeTypes, key) && typeof checker !== 'function') {
            return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
          }
          if (!checker) {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
          }
          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function isNode(propValue) {
      switch (typeof propValue) {
        case 'number':
        case 'string':
        case 'undefined':
          return true;
        case 'boolean':
          return !propValue;
        case 'object':
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }
          if (propValue === null || isValidElement(propValue)) {
            return true;
          }
          var iteratorFn = getIteratorFn(propValue);
          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;
            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              // Iterator will provide entry [k,v] tuples rather than values.
              while (!(step = iterator.next()).done) {
                var entry = step.value;
                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }
          return true;
        default:
          return false;
      }
    }
    function isSymbol(propType, propValue) {
      // Native Symbol.
      if (propType === 'symbol') {
        return true;
      }

      // falsy value can't be a Symbol
      if (!propValue) {
        return false;
      }

      // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
      if (propValue['@@toStringTag'] === 'Symbol') {
        return true;
      }

      // Fallback for non-spec compliant Symbols which are polyfilled.
      if (typeof Symbol === 'function' && propValue instanceof Symbol) {
        return true;
      }
      return false;
    }

    // Equivalent of `typeof` but with special handling for array and regexp.
    function getPropType(propValue) {
      var propType = typeof propValue;
      if (Array.isArray(propValue)) {
        return 'array';
      }
      if (propValue instanceof RegExp) {
        // Old webkits (at least until Android 4.0) return 'function' rather than
        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
        // passes PropTypes.object.
        return 'object';
      }
      if (isSymbol(propType, propValue)) {
        return 'symbol';
      }
      return propType;
    }

    // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.
    function getPreciseType(propValue) {
      if (typeof propValue === 'undefined' || propValue === null) {
        return '' + propValue;
      }
      var propType = getPropType(propValue);
      if (propType === 'object') {
        if (propValue instanceof Date) {
          return 'date';
        } else if (propValue instanceof RegExp) {
          return 'regexp';
        }
      }
      return propType;
    }

    // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"
    function getPostfixForTypeWarning(value) {
      var type = getPreciseType(value);
      switch (type) {
        case 'array':
        case 'object':
          return 'an ' + type;
        case 'boolean':
        case 'date':
        case 'regexp':
          return 'a ' + type;
        default:
          return type;
      }
    }

    // Returns class name of the object, if any.
    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }
      return propValue.constructor.name;
    }
    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  {
    var ReactIs = reactIsExports$1;

    // By explicitly using `prop-types` you are opting into new development behavior.
    // http://fb.me/prop-types-in-prod
    var throwOnDirectAccess = true;
    propTypes.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
  }
  var propTypesExports = propTypes.exports;
  var PropTypes = /*@__PURE__*/getDefaultExportFromCjs(propTypesExports);

  var common = {
    black: '#000',
    white: '#fff'
  };
  var common$1 = common;

  var red = {
    50: '#ffebee',
    100: '#ffcdd2',
    200: '#ef9a9a',
    300: '#e57373',
    400: '#ef5350',
    500: '#f44336',
    600: '#e53935',
    700: '#d32f2f',
    800: '#c62828',
    900: '#b71c1c',
    A100: '#ff8a80',
    A200: '#ff5252',
    A400: '#ff1744',
    A700: '#d50000'
  };
  var red$1 = red;

  var pink = {
    50: '#fce4ec',
    100: '#f8bbd0',
    200: '#f48fb1',
    300: '#f06292',
    400: '#ec407a',
    500: '#e91e63',
    600: '#d81b60',
    700: '#c2185b',
    800: '#ad1457',
    900: '#880e4f',
    A100: '#ff80ab',
    A200: '#ff4081',
    A400: '#f50057',
    A700: '#c51162'
  };
  var pink$1 = pink;

  var indigo = {
    50: '#e8eaf6',
    100: '#c5cae9',
    200: '#9fa8da',
    300: '#7986cb',
    400: '#5c6bc0',
    500: '#3f51b5',
    600: '#3949ab',
    700: '#303f9f',
    800: '#283593',
    900: '#1a237e',
    A100: '#8c9eff',
    A200: '#536dfe',
    A400: '#3d5afe',
    A700: '#304ffe'
  };
  var indigo$1 = indigo;

  var blue = {
    50: '#e3f2fd',
    100: '#bbdefb',
    200: '#90caf9',
    300: '#64b5f6',
    400: '#42a5f5',
    500: '#2196f3',
    600: '#1e88e5',
    700: '#1976d2',
    800: '#1565c0',
    900: '#0d47a1',
    A100: '#82b1ff',
    A200: '#448aff',
    A400: '#2979ff',
    A700: '#2962ff'
  };
  var blue$1 = blue;

  var green = {
    50: '#e8f5e9',
    100: '#c8e6c9',
    200: '#a5d6a7',
    300: '#81c784',
    400: '#66bb6a',
    500: '#4caf50',
    600: '#43a047',
    700: '#388e3c',
    800: '#2e7d32',
    900: '#1b5e20',
    A100: '#b9f6ca',
    A200: '#69f0ae',
    A400: '#00e676',
    A700: '#00c853'
  };
  var green$1 = green;

  var orange = {
    50: '#fff3e0',
    100: '#ffe0b2',
    200: '#ffcc80',
    300: '#ffb74d',
    400: '#ffa726',
    500: '#ff9800',
    600: '#fb8c00',
    700: '#f57c00',
    800: '#ef6c00',
    900: '#e65100',
    A100: '#ffd180',
    A200: '#ffab40',
    A400: '#ff9100',
    A700: '#ff6d00'
  };
  var orange$1 = orange;

  var grey = {
    50: '#fafafa',
    100: '#f5f5f5',
    200: '#eeeeee',
    300: '#e0e0e0',
    400: '#bdbdbd',
    500: '#9e9e9e',
    600: '#757575',
    700: '#616161',
    800: '#424242',
    900: '#212121',
    A100: '#d5d5d5',
    A200: '#aaaaaa',
    A400: '#303030',
    A700: '#616161'
  };
  var grey$1 = grey;

  function chainPropTypes(propType1, propType2) {
    return function validate() {
      return propType1.apply(void 0, arguments) || propType2.apply(void 0, arguments);
    };
  }

  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  function _typeof$1(o) {
    "@babel/helpers - typeof";

    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof$1(o);
  }

  function isPlainObject(item) {
    return item && _typeof$1(item) === 'object' && item.constructor === Object;
  }
  function deepmerge(target, source) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      clone: true
    };
    var output = options.clone ? _extends({}, target) : target;
    if (isPlainObject(target) && isPlainObject(source)) {
      Object.keys(source).forEach(function (key) {
        // Avoid prototype pollution
        if (key === '__proto__') {
          return;
        }
        if (isPlainObject(source[key]) && key in target) {
          output[key] = deepmerge(target[key], source[key], options);
        } else {
          output[key] = source[key];
        }
      });
    }
    return output;
  }

  function isClassComponent$1(elementType) {
    // elementType.prototype?.isReactComponent
    var _elementType$prototyp = elementType.prototype,
      prototype = _elementType$prototyp === void 0 ? {} : _elementType$prototyp;
    return Boolean(prototype.isReactComponent);
  }
  function acceptingRef(props, propName, componentName, location, propFullName) {
    var element = props[propName];
    var safePropName = propFullName || propName;
    if (element == null) {
      return null;
    }
    var warningHint;
    var elementType = element.type;
    /**
     * Blacklisting instead of whitelisting
     *
     * Blacklisting will miss some components, such as React.Fragment. Those will at least
     * trigger a warning in React.
     * We can't whitelist because there is no safe way to detect React.forwardRef
     * or class components. "Safe" means there's no public API.
     *
     */

    if (typeof elementType === 'function' && !isClassComponent$1(elementType)) {
      warningHint = 'Did you accidentally use a plain function component for an element instead?';
    }
    if (warningHint !== undefined) {
      return new Error("Invalid ".concat(location, " `").concat(safePropName, "` supplied to `").concat(componentName, "`. ") + "Expected an element that can hold a ref. ".concat(warningHint, " ") + 'For more information see https://mui.com/r/caveat-with-refs-guide');
    }
    return null;
  }
  var elementAcceptingRef = chainPropTypes(PropTypes.element, acceptingRef);
  elementAcceptingRef.isRequired = chainPropTypes(PropTypes.element.isRequired, acceptingRef);
  var elementAcceptingRef$1 = elementAcceptingRef;

  function isClassComponent(elementType) {
    // elementType.prototype?.isReactComponent
    var _elementType$prototyp = elementType.prototype,
      prototype = _elementType$prototyp === void 0 ? {} : _elementType$prototyp;
    return Boolean(prototype.isReactComponent);
  }
  function elementTypeAcceptingRef(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var safePropName = propFullName || propName;
    if (propValue == null) {
      return null;
    }
    var warningHint;
    /**
     * Blacklisting instead of whitelisting
     *
     * Blacklisting will miss some components, such as React.Fragment. Those will at least
     * trigger a warning in React.
     * We can't whitelist because there is no safe way to detect React.forwardRef
     * or class components. "Safe" means there's no public API.
     *
     */

    if (typeof propValue === 'function' && !isClassComponent(propValue)) {
      warningHint = 'Did you accidentally provide a plain function component instead?';
    }
    if (warningHint !== undefined) {
      return new Error("Invalid ".concat(location, " `").concat(safePropName, "` supplied to `").concat(componentName, "`. ") + "Expected an element type that can hold a ref. ".concat(warningHint, " ") + 'For more information see https://mui.com/r/caveat-with-refs-guide');
    }
    return null;
  }
  var elementTypeAcceptingRef$1 = chainPropTypes(propTypesExports.elementType, elementTypeAcceptingRef);

  function _toPrimitive(input, hint) {
    if (_typeof$1(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof$1(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }

  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof$1(key) === "symbol" ? key : String(key);
  }

  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // This module is based on https://github.com/airbnb/prop-types-exact repository.
  // However, in order to reduce the number of dependencies and to remove some extra safe checks
  // the module was forked.
  // Only exported for test purposes.
  var specialProperty = "exact-prop: \u200B";
  function exactProp(propTypes) {
    return _extends({}, propTypes, _defineProperty({}, specialProperty, function (props) {
      var unsupportedProps = Object.keys(props).filter(function (prop) {
        return !propTypes.hasOwnProperty(prop);
      });
      if (unsupportedProps.length > 0) {
        return new Error("The following props are not supported: ".concat(unsupportedProps.map(function (prop) {
          return "`".concat(prop, "`");
        }).join(', '), ". Please remove them."));
      }
      return null;
    }));
  }

  var reactIs$1 = {exports: {}};

  var reactIs_development = {};

  /** @license React v17.0.2
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  {
    (function () {

      // ATTENTION
      // When adding new symbols to this file,
      // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
      // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
      // nor polyfill, then a plain number is used for performance.
      var REACT_ELEMENT_TYPE = 0xeac7;
      var REACT_PORTAL_TYPE = 0xeaca;
      var REACT_FRAGMENT_TYPE = 0xeacb;
      var REACT_STRICT_MODE_TYPE = 0xeacc;
      var REACT_PROFILER_TYPE = 0xead2;
      var REACT_PROVIDER_TYPE = 0xeacd;
      var REACT_CONTEXT_TYPE = 0xeace;
      var REACT_FORWARD_REF_TYPE = 0xead0;
      var REACT_SUSPENSE_TYPE = 0xead1;
      var REACT_SUSPENSE_LIST_TYPE = 0xead8;
      var REACT_MEMO_TYPE = 0xead3;
      var REACT_LAZY_TYPE = 0xead4;
      var REACT_BLOCK_TYPE = 0xead9;
      var REACT_SERVER_BLOCK_TYPE = 0xeada;
      var REACT_FUNDAMENTAL_TYPE = 0xead5;
      var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
      var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;
      if (typeof Symbol === 'function' && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor('react.element');
        REACT_PORTAL_TYPE = symbolFor('react.portal');
        REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
        REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
        REACT_PROFILER_TYPE = symbolFor('react.profiler');
        REACT_PROVIDER_TYPE = symbolFor('react.provider');
        REACT_CONTEXT_TYPE = symbolFor('react.context');
        REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
        REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
        REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
        REACT_MEMO_TYPE = symbolFor('react.memo');
        REACT_LAZY_TYPE = symbolFor('react.lazy');
        REACT_BLOCK_TYPE = symbolFor('react.block');
        REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
        REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
        symbolFor('react.scope');
        symbolFor('react.opaque.id');
        REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
        symbolFor('react.offscreen');
        REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
      }

      // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

      var enableScopeAPI = false; // Experimental Create Event Handle API.

      function isValidElementType(type) {
        if (typeof type === 'string' || typeof type === 'function') {
          return true;
        } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).

        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
          return true;
        }
        if (typeof type === 'object' && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
            return true;
          }
        }
        return false;
      }
      function typeOf(object) {
        if (typeof object === 'object' && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return undefined;
      }
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
          }
        }
        return false;
      }
      function isConcurrentMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
            hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
          }
        }
        return false;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      reactIs_development.ContextConsumer = ContextConsumer;
      reactIs_development.ContextProvider = ContextProvider;
      reactIs_development.Element = Element;
      reactIs_development.ForwardRef = ForwardRef;
      reactIs_development.Fragment = Fragment;
      reactIs_development.Lazy = Lazy;
      reactIs_development.Memo = Memo;
      reactIs_development.Portal = Portal;
      reactIs_development.Profiler = Profiler;
      reactIs_development.StrictMode = StrictMode;
      reactIs_development.Suspense = Suspense;
      reactIs_development.isAsyncMode = isAsyncMode;
      reactIs_development.isConcurrentMode = isConcurrentMode;
      reactIs_development.isContextConsumer = isContextConsumer;
      reactIs_development.isContextProvider = isContextProvider;
      reactIs_development.isElement = isElement;
      reactIs_development.isForwardRef = isForwardRef;
      reactIs_development.isFragment = isFragment;
      reactIs_development.isLazy = isLazy;
      reactIs_development.isMemo = isMemo;
      reactIs_development.isPortal = isPortal;
      reactIs_development.isProfiler = isProfiler;
      reactIs_development.isStrictMode = isStrictMode;
      reactIs_development.isSuspense = isSuspense;
      reactIs_development.isValidElementType = isValidElementType;
      reactIs_development.typeOf = typeOf;
    })();
  }

  {
    reactIs$1.exports = reactIs_development;
  }
  var reactIsExports = reactIs$1.exports;

  // https://github.com/JamesMGreene/Function.name/blob/58b314d4a983110c3682f1228f845d39ccca1817/Function.name.js#L3

  var fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
  function getFunctionName(fn) {
    var match = "".concat(fn).match(fnNameMatchRegex);
    var name = match && match[1];
    return name || '';
  }
  /**
   * @param {function} Component
   * @param {string} fallback
   * @returns {string | undefined}
   */

  function getFunctionComponentName(Component) {
    var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    return Component.displayName || Component.name || getFunctionName(Component) || fallback;
  }
  function getWrappedName(outerType, innerType, wrapperName) {
    var functionName = getFunctionComponentName(innerType);
    return outerType.displayName || (functionName !== '' ? "".concat(wrapperName, "(").concat(functionName, ")") : wrapperName);
  }
  /**
   * cherry-pick from
   * https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/getComponentName.js
   * originally forked from recompose/getDisplayName with added IE 11 support
   *
   * @param {React.ReactType} Component
   * @returns {string | undefined}
   */

  function getDisplayName(Component) {
    if (Component == null) {
      return undefined;
    }
    if (typeof Component === 'string') {
      return Component;
    }
    if (typeof Component === 'function') {
      return getFunctionComponentName(Component, 'Component');
    }
    if (_typeof$1(Component) === 'object') {
      switch (Component.$$typeof) {
        case reactIsExports.ForwardRef:
          return getWrappedName(Component, Component.render, 'ForwardRef');
        case reactIsExports.Memo:
          return getWrappedName(Component, Component.type, 'memo');
        default:
          return undefined;
      }
    }
    return undefined;
  }

  function HTMLElementType(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var safePropName = propFullName || propName;
    if (propValue == null) {
      return null;
    }
    if (propValue && propValue.nodeType !== 1) {
      return new Error("Invalid ".concat(location, " `").concat(safePropName, "` supplied to `").concat(componentName, "`. ") + "Expected an HTMLElement.");
    }
    return null;
  }

  var refType = PropTypes.oneOfType([PropTypes.func, PropTypes.object]);
  var refType$1 = refType;

  /* eslint-disable no-use-before-define */

  /**
   * Returns a number whose value is limited to the given range.
   *
   * @param {number} value The value to be clamped
   * @param {number} min The lower boundary of the output range
   * @param {number} max The upper boundary of the output range
   * @returns {number} A number in the range [min, max]
   */
  function clamp(value) {
    var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    {
      if (value < min || value > max) {
        console.error("Material-UI: The value provided ".concat(value, " is out of range [").concat(min, ", ").concat(max, "]."));
      }
    }
    return Math.min(Math.max(min, value), max);
  }
  /**
   * Converts a color from CSS hex format to CSS rgb format.
   *
   * @param {string} color - Hex color, i.e. #nnn or #nnnnnn
   * @returns {string} A CSS rgb color string
   */

  function hexToRgb(color) {
    color = color.substr(1);
    var re = new RegExp(".{1,".concat(color.length >= 6 ? 2 : 1, "}"), 'g');
    var colors = color.match(re);
    if (colors && colors[0].length === 1) {
      colors = colors.map(function (n) {
        return n + n;
      });
    }
    return colors ? "rgb".concat(colors.length === 4 ? 'a' : '', "(").concat(colors.map(function (n, index) {
      return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1000) / 1000;
    }).join(', '), ")") : '';
  }
  /**
   * Converts a color from hsl format to rgb format.
   *
   * @param {string} color - HSL color values
   * @returns {string} rgb color values
   */

  function hslToRgb(color) {
    color = decomposeColor(color);
    var _color = color,
      values = _color.values;
    var h = values[0];
    var s = values[1] / 100;
    var l = values[2] / 100;
    var a = s * Math.min(l, 1 - l);
    var f = function f(n) {
      var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + h / 30) % 12;
      return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    };
    var type = 'rgb';
    var rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
    if (color.type === 'hsla') {
      type += 'a';
      rgb.push(values[3]);
    }
    return recomposeColor({
      type: type,
      values: rgb
    });
  }
  /**
   * Returns an object with the type and values of a color.
   *
   * Note: Does not support rgb % values.
   *
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @returns {object} - A MUI color object: {type: string, values: number[]}
   */

  function decomposeColor(color) {
    // Idempotent
    if (color.type) {
      return color;
    }
    if (color.charAt(0) === '#') {
      return decomposeColor(hexToRgb(color));
    }
    var marker = color.indexOf('(');
    var type = color.substring(0, marker);
    if (['rgb', 'rgba', 'hsl', 'hsla'].indexOf(type) === -1) {
      throw new Error("Material-UI: Unsupported `".concat(color, "` color.\nWe support the following formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla().") );
    }
    var values = color.substring(marker + 1, color.length - 1).split(',');
    values = values.map(function (value) {
      return parseFloat(value);
    });
    return {
      type: type,
      values: values
    };
  }
  /**
   * Converts a color object with type and values to a string.
   *
   * @param {object} color - Decomposed color
   * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla'
   * @param {array} color.values - [n,n,n] or [n,n,n,n]
   * @returns {string} A CSS color string
   */

  function recomposeColor(color) {
    var type = color.type;
    var values = color.values;
    if (type.indexOf('rgb') !== -1) {
      // Only convert the first 3 values to int (i.e. not alpha)
      values = values.map(function (n, i) {
        return i < 3 ? parseInt(n, 10) : n;
      });
    } else if (type.indexOf('hsl') !== -1) {
      values[1] = "".concat(values[1], "%");
      values[2] = "".concat(values[2], "%");
    }
    return "".concat(type, "(").concat(values.join(', '), ")");
  }
  /**
   * Calculates the contrast ratio between two colors.
   *
   * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
   *
   * @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @returns {number} A contrast ratio value in the range 0 - 21.
   */

  function getContrastRatio(foreground, background) {
    var lumA = getLuminance(foreground);
    var lumB = getLuminance(background);
    return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
  }
  /**
   * The relative brightness of any point in a color space,
   * normalized to 0 for darkest black and 1 for lightest white.
   *
   * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
   *
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @returns {number} The relative brightness of the color in the range 0 - 1
   */

  function getLuminance(color) {
    color = decomposeColor(color);
    var rgb = color.type === 'hsl' ? decomposeColor(hslToRgb(color)).values : color.values;
    rgb = rgb.map(function (val) {
      val /= 255; // normalized

      return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
    }); // Truncate at 3 digits

    return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
  }
  /**
   * Set the absolute transparency of a color.
   * Any existing alpha value is overwritten.
   *
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @param {number} value - value to set the alpha channel to in the range 0-1
   * @returns {string} A CSS color string. Hex input values are returned as rgb
   */

  function alpha(color, value) {
    color = decomposeColor(color);
    value = clamp(value);
    if (color.type === 'rgb' || color.type === 'hsl') {
      color.type += 'a';
    }
    color.values[3] = value;
    return recomposeColor(color);
  }
  /**
   * Darkens a color.
   *
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @param {number} coefficient - multiplier in the range 0 - 1
   * @returns {string} A CSS color string. Hex input values are returned as rgb
   */

  function darken(color, coefficient) {
    color = decomposeColor(color);
    coefficient = clamp(coefficient);
    if (color.type.indexOf('hsl') !== -1) {
      color.values[2] *= 1 - coefficient;
    } else if (color.type.indexOf('rgb') !== -1) {
      for (var i = 0; i < 3; i += 1) {
        color.values[i] *= 1 - coefficient;
      }
    }
    return recomposeColor(color);
  }
  /**
   * Lightens a color.
   *
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @param {number} coefficient - multiplier in the range 0 - 1
   * @returns {string} A CSS color string. Hex input values are returned as rgb
   */

  function lighten(color, coefficient) {
    color = decomposeColor(color);
    coefficient = clamp(coefficient);
    if (color.type.indexOf('hsl') !== -1) {
      color.values[2] += (100 - color.values[2]) * coefficient;
    } else if (color.type.indexOf('rgb') !== -1) {
      for (var i = 0; i < 3; i += 1) {
        color.values[i] += (255 - color.values[i]) * coefficient;
      }
    }
    return recomposeColor(color);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }

  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  var keys = ['xs', 'sm', 'md', 'lg', 'xl']; // Keep in mind that @media is inclusive by the CSS specification.

  function createBreakpoints(breakpoints) {
    var _breakpoints$values = breakpoints.values,
      values = _breakpoints$values === void 0 ? {
        xs: 0,
        sm: 600,
        md: 960,
        lg: 1280,
        xl: 1920
      } : _breakpoints$values,
      _breakpoints$unit = breakpoints.unit,
      unit = _breakpoints$unit === void 0 ? 'px' : _breakpoints$unit,
      _breakpoints$step = breakpoints.step,
      step = _breakpoints$step === void 0 ? 5 : _breakpoints$step,
      other = _objectWithoutProperties(breakpoints, ["values", "unit", "step"]);
    function up(key) {
      var value = typeof values[key] === 'number' ? values[key] : key;
      return "@media (min-width:".concat(value).concat(unit, ")");
    }
    function down(key) {
      var endIndex = keys.indexOf(key) + 1;
      var upperbound = values[keys[endIndex]];
      if (endIndex === keys.length) {
        // xl down applies to all sizes
        return up('xs');
      }
      var value = typeof upperbound === 'number' && endIndex > 0 ? upperbound : key;
      return "@media (max-width:".concat(value - step / 100).concat(unit, ")");
    }
    function between(start, end) {
      var endIndex = keys.indexOf(end);
      if (endIndex === keys.length - 1) {
        return up(start);
      }
      return "@media (min-width:".concat(typeof values[start] === 'number' ? values[start] : start).concat(unit, ") and ") + "(max-width:".concat((endIndex !== -1 && typeof values[keys[endIndex + 1]] === 'number' ? values[keys[endIndex + 1]] : end) - step / 100).concat(unit, ")");
    }
    function only(key) {
      return between(key, key);
    }
    var warnedOnce = false;
    function width(key) {
      {
        if (!warnedOnce) {
          warnedOnce = true;
          console.warn(["Material-UI: The `theme.breakpoints.width` utility is deprecated because it's redundant.", 'Use the `theme.breakpoints.values` instead.'].join('\n'));
        }
      }
      return values[key];
    }
    return _extends({
      keys: keys,
      values: values,
      up: up,
      down: down,
      between: between,
      only: only,
      width: width
    }, other);
  }

  function createMixins(breakpoints, spacing, mixins) {
    var _toolbar;
    return _extends({
      gutters: function gutters() {
        var styles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        console.warn(['Material-UI: theme.mixins.gutters() is deprecated.', 'You can use the source of the mixin directly:', "\n      paddingLeft: theme.spacing(2),\n      paddingRight: theme.spacing(2),\n      [theme.breakpoints.up('sm')]: {\n        paddingLeft: theme.spacing(3),\n        paddingRight: theme.spacing(3),\n      },\n      "].join('\n'));
        return _extends({
          paddingLeft: spacing(2),
          paddingRight: spacing(2)
        }, styles, _defineProperty({}, breakpoints.up('sm'), _extends({
          paddingLeft: spacing(3),
          paddingRight: spacing(3)
        }, styles[breakpoints.up('sm')])));
      },
      toolbar: (_toolbar = {
        minHeight: 56
      }, _defineProperty(_toolbar, "".concat(breakpoints.up('xs'), " and (orientation: landscape)"), {
        minHeight: 48
      }), _defineProperty(_toolbar, breakpoints.up('sm'), {
        minHeight: 64
      }), _toolbar)
    }, mixins);
  }

  var light = {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: 'rgba(0, 0, 0, 0.87)',
      // Secondary text.
      secondary: 'rgba(0, 0, 0, 0.54)',
      // Disabled text have even lower visual prominence.
      disabled: 'rgba(0, 0, 0, 0.38)',
      // Text hints.
      hint: 'rgba(0, 0, 0, 0.38)'
    },
    // The color used to divide different elements.
    divider: 'rgba(0, 0, 0, 0.12)',
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: common$1.white,
      default: grey$1[50]
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: 'rgba(0, 0, 0, 0.54)',
      // The color of an hovered action.
      hover: 'rgba(0, 0, 0, 0.04)',
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: 'rgba(0, 0, 0, 0.08)',
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: 'rgba(0, 0, 0, 0.26)',
      // The background color of a disabled action.
      disabledBackground: 'rgba(0, 0, 0, 0.12)',
      disabledOpacity: 0.38,
      focus: 'rgba(0, 0, 0, 0.12)',
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
  var dark = {
    text: {
      primary: common$1.white,
      secondary: 'rgba(255, 255, 255, 0.7)',
      disabled: 'rgba(255, 255, 255, 0.5)',
      hint: 'rgba(255, 255, 255, 0.5)',
      icon: 'rgba(255, 255, 255, 0.5)'
    },
    divider: 'rgba(255, 255, 255, 0.12)',
    background: {
      paper: grey$1[800],
      default: '#303030'
    },
    action: {
      active: common$1.white,
      hover: 'rgba(255, 255, 255, 0.08)',
      hoverOpacity: 0.08,
      selected: 'rgba(255, 255, 255, 0.16)',
      selectedOpacity: 0.16,
      disabled: 'rgba(255, 255, 255, 0.3)',
      disabledBackground: 'rgba(255, 255, 255, 0.12)',
      disabledOpacity: 0.38,
      focus: 'rgba(255, 255, 255, 0.12)',
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
  function addLightOrDark(intent, direction, shade, tonalOffset) {
    var tonalOffsetLight = tonalOffset.light || tonalOffset;
    var tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
    if (!intent[direction]) {
      if (intent.hasOwnProperty(shade)) {
        intent[direction] = intent[shade];
      } else if (direction === 'light') {
        intent.light = lighten(intent.main, tonalOffsetLight);
      } else if (direction === 'dark') {
        intent.dark = darken(intent.main, tonalOffsetDark);
      }
    }
  }
  function createPalette(palette) {
    var _palette$primary = palette.primary,
      primary = _palette$primary === void 0 ? {
        light: indigo$1[300],
        main: indigo$1[500],
        dark: indigo$1[700]
      } : _palette$primary,
      _palette$secondary = palette.secondary,
      secondary = _palette$secondary === void 0 ? {
        light: pink$1.A200,
        main: pink$1.A400,
        dark: pink$1.A700
      } : _palette$secondary,
      _palette$error = palette.error,
      error = _palette$error === void 0 ? {
        light: red$1[300],
        main: red$1[500],
        dark: red$1[700]
      } : _palette$error,
      _palette$warning = palette.warning,
      warning = _palette$warning === void 0 ? {
        light: orange$1[300],
        main: orange$1[500],
        dark: orange$1[700]
      } : _palette$warning,
      _palette$info = palette.info,
      info = _palette$info === void 0 ? {
        light: blue$1[300],
        main: blue$1[500],
        dark: blue$1[700]
      } : _palette$info,
      _palette$success = palette.success,
      success = _palette$success === void 0 ? {
        light: green$1[300],
        main: green$1[500],
        dark: green$1[700]
      } : _palette$success,
      _palette$type = palette.type,
      type = _palette$type === void 0 ? 'light' : _palette$type,
      _palette$contrastThre = palette.contrastThreshold,
      contrastThreshold = _palette$contrastThre === void 0 ? 3 : _palette$contrastThre,
      _palette$tonalOffset = palette.tonalOffset,
      tonalOffset = _palette$tonalOffset === void 0 ? 0.2 : _palette$tonalOffset,
      other = _objectWithoutProperties(palette, ["primary", "secondary", "error", "warning", "info", "success", "type", "contrastThreshold", "tonalOffset"]); // Use the same logic as
    // Bootstrap: https://github.com/twbs/bootstrap/blob/1d6e3710dd447de1a200f29e8fa521f8a0908f70/scss/_functions.scss#L59
    // and material-components-web https://github.com/material-components/material-components-web/blob/ac46b8863c4dab9fc22c4c662dc6bd1b65dd652f/packages/mdc-theme/_functions.scss#L54

    function getContrastText(background) {
      var contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
      {
        var contrast = getContrastRatio(background, contrastText);
        if (contrast < 3) {
          console.error(["Material-UI: The contrast ratio of ".concat(contrast, ":1 for ").concat(contrastText, " on ").concat(background), 'falls below the WCAG recommended absolute minimum contrast ratio of 3:1.', 'https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast'].join('\n'));
        }
      }
      return contrastText;
    }
    var augmentColor = function augmentColor(color) {
      var mainShade = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
      var lightShade = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;
      var darkShade = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 700;
      color = _extends({}, color);
      if (!color.main && color[mainShade]) {
        color.main = color[mainShade];
      }
      if (!color.main) {
        throw new Error("Material-UI: The color provided to augmentColor(color) is invalid.\nThe color object needs to have a `main` property or a `".concat(mainShade, "` property.") );
      }
      if (typeof color.main !== 'string') {
        throw new Error("Material-UI: The color provided to augmentColor(color) is invalid.\n`color.main` should be a string, but `".concat(JSON.stringify(color.main), "` was provided instead.\n\nDid you intend to use one of the following approaches?\n\nimport {\xA0green } from \"@material-ui/core/colors\";\n\nconst theme1 = createTheme({ palette: {\n  primary: green,\n} });\n\nconst theme2 = createTheme({ palette: {\n  primary: { main: green[500] },\n} });") );
      }
      addLightOrDark(color, 'light', lightShade, tonalOffset);
      addLightOrDark(color, 'dark', darkShade, tonalOffset);
      if (!color.contrastText) {
        color.contrastText = getContrastText(color.main);
      }
      return color;
    };
    var types = {
      dark: dark,
      light: light
    };
    {
      if (!types[type]) {
        console.error("Material-UI: The palette type `".concat(type, "` is not supported."));
      }
    }
    var paletteOutput = deepmerge(_extends({
      // A collection of common colors.
      common: common$1,
      // The palette type, can be light or dark.
      type: type,
      // The colors used to represent primary interface elements for a user.
      primary: augmentColor(primary),
      // The colors used to represent secondary interface elements for a user.
      secondary: augmentColor(secondary, 'A400', 'A200', 'A700'),
      // The colors used to represent interface elements that the user should be made aware of.
      error: augmentColor(error),
      // The colors used to represent potentially dangerous actions or important messages.
      warning: augmentColor(warning),
      // The colors used to present information to the user that is neutral and not necessarily important.
      info: augmentColor(info),
      // The colors used to indicate the successful completion of an action that user triggered.
      success: augmentColor(success),
      // The grey colors.
      grey: grey$1,
      // Used by `getContrastText()` to maximize the contrast between
      // the background and the text.
      contrastThreshold: contrastThreshold,
      // Takes a background color and returns the text color that maximizes the contrast.
      getContrastText: getContrastText,
      // Generate a rich color object.
      augmentColor: augmentColor,
      // Used by the functions below to shift a color's luminance by approximately
      // two indexes within its tonal palette.
      // E.g., shift from Red 500 to Red 300 or Red 700.
      tonalOffset: tonalOffset
    }, types[type]), other);
    return paletteOutput;
  }

  function round(value) {
    return Math.round(value * 1e5) / 1e5;
  }
  var warnedOnce$1 = false;
  function roundWithDeprecationWarning(value) {
    {
      if (!warnedOnce$1) {
        console.warn(['Material-UI: The `theme.typography.round` helper is deprecated.', 'Head to https://mui.com/r/migration-v4/#theme for a migration path.'].join('\n'));
        warnedOnce$1 = true;
      }
    }
    return round(value);
  }
  var caseAllCaps = {
    textTransform: 'uppercase'
  };
  var defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
  /**
   * @see @link{https://material.io/design/typography/the-type-system.html}
   * @see @link{https://material.io/design/typography/understanding-typography.html}
   */

  function createTypography(palette, typography) {
    var _ref = typeof typography === 'function' ? typography(palette) : typography,
      _ref$fontFamily = _ref.fontFamily,
      fontFamily = _ref$fontFamily === void 0 ? defaultFontFamily : _ref$fontFamily,
      _ref$fontSize = _ref.fontSize,
      fontSize = _ref$fontSize === void 0 ? 14 : _ref$fontSize,
      _ref$fontWeightLight = _ref.fontWeightLight,
      fontWeightLight = _ref$fontWeightLight === void 0 ? 300 : _ref$fontWeightLight,
      _ref$fontWeightRegula = _ref.fontWeightRegular,
      fontWeightRegular = _ref$fontWeightRegula === void 0 ? 400 : _ref$fontWeightRegula,
      _ref$fontWeightMedium = _ref.fontWeightMedium,
      fontWeightMedium = _ref$fontWeightMedium === void 0 ? 500 : _ref$fontWeightMedium,
      _ref$fontWeightBold = _ref.fontWeightBold,
      fontWeightBold = _ref$fontWeightBold === void 0 ? 700 : _ref$fontWeightBold,
      _ref$htmlFontSize = _ref.htmlFontSize,
      htmlFontSize = _ref$htmlFontSize === void 0 ? 16 : _ref$htmlFontSize,
      allVariants = _ref.allVariants,
      pxToRem2 = _ref.pxToRem,
      other = _objectWithoutProperties(_ref, ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"]);
    {
      if (typeof fontSize !== 'number') {
        console.error('Material-UI: `fontSize` is required to be a number.');
      }
      if (typeof htmlFontSize !== 'number') {
        console.error('Material-UI: `htmlFontSize` is required to be a number.');
      }
    }
    var coef = fontSize / 14;
    var pxToRem = pxToRem2 || function (size) {
      return "".concat(size / htmlFontSize * coef, "rem");
    };
    var buildVariant = function buildVariant(fontWeight, size, lineHeight, letterSpacing, casing) {
      return _extends({
        fontFamily: fontFamily,
        fontWeight: fontWeight,
        fontSize: pxToRem(size),
        // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
        lineHeight: lineHeight
      }, fontFamily === defaultFontFamily ? {
        letterSpacing: "".concat(round(letterSpacing / size), "em")
      } : {}, casing, allVariants);
    };
    var variants = {
      h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
      h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
      h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
      h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
      h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
      h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
      subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
      subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
      body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
      body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
      button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
      caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
      overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
    };
    return deepmerge(_extends({
      htmlFontSize: htmlFontSize,
      pxToRem: pxToRem,
      round: roundWithDeprecationWarning,
      // TODO v5: remove
      fontFamily: fontFamily,
      fontSize: fontSize,
      fontWeightLight: fontWeightLight,
      fontWeightRegular: fontWeightRegular,
      fontWeightMedium: fontWeightMedium,
      fontWeightBold: fontWeightBold
    }, variants), other, {
      clone: false // No need to clone deep
    });
  }

  var shadowKeyUmbraOpacity = 0.2;
  var shadowKeyPenumbraOpacity = 0.14;
  var shadowAmbientShadowOpacity = 0.12;
  function createShadow() {
    return ["".concat(arguments.length <= 0 ? undefined : arguments[0], "px ").concat(arguments.length <= 1 ? undefined : arguments[1], "px ").concat(arguments.length <= 2 ? undefined : arguments[2], "px ").concat(arguments.length <= 3 ? undefined : arguments[3], "px rgba(0,0,0,").concat(shadowKeyUmbraOpacity, ")"), "".concat(arguments.length <= 4 ? undefined : arguments[4], "px ").concat(arguments.length <= 5 ? undefined : arguments[5], "px ").concat(arguments.length <= 6 ? undefined : arguments[6], "px ").concat(arguments.length <= 7 ? undefined : arguments[7], "px rgba(0,0,0,").concat(shadowKeyPenumbraOpacity, ")"), "".concat(arguments.length <= 8 ? undefined : arguments[8], "px ").concat(arguments.length <= 9 ? undefined : arguments[9], "px ").concat(arguments.length <= 10 ? undefined : arguments[10], "px ").concat(arguments.length <= 11 ? undefined : arguments[11], "px rgba(0,0,0,").concat(shadowAmbientShadowOpacity, ")")].join(',');
  } // Values from https://github.com/material-components/material-components-web/blob/be8747f94574669cb5e7add1a7c54fa41a89cec7/packages/mdc-elevation/_variables.scss

  var shadows = ['none', createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
  var shadows$1 = shadows;

  var shape = {
    borderRadius: 4
  };
  var shape$1 = shape;

  var responsivePropType = PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.object, PropTypes.array]) ;
  var responsivePropType$1 = responsivePropType;

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = !0,
        o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = !1;
        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  var spacingKeys = ['m', 'mt', 'mr', 'mb', 'ml', 'mx', 'my', 'p', 'pt', 'pr', 'pb', 'pl', 'px', 'py', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'paddingX', 'paddingY'];
  function createUnarySpacing(theme) {
    var themeSpacing = theme.spacing || 8;
    if (typeof themeSpacing === 'number') {
      return function (abs) {
        {
          if (typeof abs !== 'number') {
            console.error("Material-UI: Expected spacing argument to be a number, got ".concat(abs, "."));
          }
        }
        return themeSpacing * abs;
      };
    }
    if (Array.isArray(themeSpacing)) {
      return function (abs) {
        {
          if (abs > themeSpacing.length - 1) {
            console.error(["Material-UI: The value provided (".concat(abs, ") overflows."), "The supported values are: ".concat(JSON.stringify(themeSpacing), "."), "".concat(abs, " > ").concat(themeSpacing.length - 1, ", you need to add the missing values.")].join('\n'));
          }
        }
        return themeSpacing[abs];
      };
    }
    if (typeof themeSpacing === 'function') {
      return themeSpacing;
    }
    {
      console.error(["Material-UI: The `theme.spacing` value (".concat(themeSpacing, ") is invalid."), 'It should be a number, an array or a function.'].join('\n'));
    }
    return function () {
      return undefined;
    };
  }
  spacingKeys.reduce(function (obj, key) {
    obj[key] = responsivePropType$1;
    return obj;
  }, {}) ;

  var warnOnce;
  function createSpacing() {
    var spacingInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;

    // Already transformed.
    if (spacingInput.mui) {
      return spacingInput;
    } // Material Design layouts are visually balanced. Most measurements align to an 8dp grid applied, which aligns both spacing and the overall layout.
    // Smaller components, such as icons and type, can align to a 4dp grid.
    // https://material.io/design/layout/understanding-layout.html#usage

    var transform = createUnarySpacing({
      spacing: spacingInput
    });
    var spacing = function spacing() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      {
        if (!(args.length <= 4)) {
          console.error("Material-UI: Too many arguments provided, expected between 0 and 4, got ".concat(args.length));
        }
      }
      if (args.length === 0) {
        return transform(1);
      }
      if (args.length === 1) {
        return transform(args[0]);
      }
      return args.map(function (argument) {
        if (typeof argument === 'string') {
          return argument;
        }
        var output = transform(argument);
        return typeof output === 'number' ? "".concat(output, "px") : output;
      }).join(' ');
    }; // Backward compatibility, to remove in v5.

    Object.defineProperty(spacing, 'unit', {
      get: function get() {
        {
          if (!warnOnce || "development" === 'test') {
            console.error(['Material-UI: theme.spacing.unit usage has been deprecated.', 'It will be removed in v5.', 'You can replace `theme.spacing.unit * y` with `theme.spacing(y)`.', '', 'You can use the `https://github.com/mui-org/material-ui/tree/master/packages/material-ui-codemod/README.md#theme-spacing-api` migration helper to make the process smoother.'].join('\n'));
          }
          warnOnce = true;
        }
        return spacingInput;
      }
    });
    spacing.mui = true;
    return spacing;
  }

  // Follow https://material.google.com/motion/duration-easing.html#duration-easing-natural-easing-curves
  // to learn the context in which each easing should be used.
  var easing = {
    // This is the most common easing curve.
    easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'
  }; // Follow https://material.io/guidelines/motion/duration-easing.html#duration-easing-common-durations
  // to learn when use what timing

  var duration = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195
  };
  function formatMs(milliseconds) {
    return "".concat(Math.round(milliseconds), "ms");
  }
  /**
   * @param {string|Array} props
   * @param {object} param
   * @param {string} param.prop
   * @param {number} param.duration
   * @param {string} param.easing
   * @param {number} param.delay
   */

  var transitions = {
    easing: easing,
    duration: duration,
    create: function create() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['all'];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _options$duration = options.duration,
        durationOption = _options$duration === void 0 ? duration.standard : _options$duration,
        _options$easing = options.easing,
        easingOption = _options$easing === void 0 ? easing.easeInOut : _options$easing,
        _options$delay = options.delay,
        delay = _options$delay === void 0 ? 0 : _options$delay,
        other = _objectWithoutProperties(options, ["duration", "easing", "delay"]);
      {
        var isString = function isString(value) {
          return typeof value === 'string';
        };
        var isNumber = function isNumber(value) {
          return !isNaN(parseFloat(value));
        };
        if (!isString(props) && !Array.isArray(props)) {
          console.error('Material-UI: Argument "props" must be a string or Array.');
        }
        if (!isNumber(durationOption) && !isString(durationOption)) {
          console.error("Material-UI: Argument \"duration\" must be a number or a string but found ".concat(durationOption, "."));
        }
        if (!isString(easingOption)) {
          console.error('Material-UI: Argument "easing" must be a string.');
        }
        if (!isNumber(delay) && !isString(delay)) {
          console.error('Material-UI: Argument "delay" must be a number or a string.');
        }
        if (Object.keys(other).length !== 0) {
          console.error("Material-UI: Unrecognized argument(s) [".concat(Object.keys(other).join(','), "]."));
        }
      }
      return (Array.isArray(props) ? props : [props]).map(function (animatedProp) {
        return "".concat(animatedProp, " ").concat(typeof durationOption === 'string' ? durationOption : formatMs(durationOption), " ").concat(easingOption, " ").concat(typeof delay === 'string' ? delay : formatMs(delay));
      }).join(',');
    },
    getAutoHeightDuration: function getAutoHeightDuration(height) {
      if (!height) {
        return 0;
      }
      var constant = height / 36; // https://www.wolframalpha.com/input/?i=(4+%2B+15+*+(x+%2F+36+)+**+0.25+%2B+(x+%2F+36)+%2F+5)+*+10

      return Math.round((4 + 15 * Math.pow(constant, 0.25) + constant / 5) * 10);
    }
  };

  // We need to centralize the zIndex definitions as they work
  // like global values in the browser.
  var zIndex = {
    mobileStepper: 1000,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
  };
  var zIndex$1 = zIndex;

  function createTheme() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _options$breakpoints = options.breakpoints,
      breakpointsInput = _options$breakpoints === void 0 ? {} : _options$breakpoints,
      _options$mixins = options.mixins,
      mixinsInput = _options$mixins === void 0 ? {} : _options$mixins,
      _options$palette = options.palette,
      paletteInput = _options$palette === void 0 ? {} : _options$palette,
      spacingInput = options.spacing,
      _options$typography = options.typography,
      typographyInput = _options$typography === void 0 ? {} : _options$typography,
      other = _objectWithoutProperties(options, ["breakpoints", "mixins", "palette", "spacing", "typography"]);
    var palette = createPalette(paletteInput);
    var breakpoints = createBreakpoints(breakpointsInput);
    var spacing = createSpacing(spacingInput);
    var muiTheme = deepmerge({
      breakpoints: breakpoints,
      direction: 'ltr',
      mixins: createMixins(breakpoints, spacing, mixinsInput),
      overrides: {},
      // Inject custom styles
      palette: palette,
      props: {},
      // Provide default props
      shadows: shadows$1,
      typography: createTypography(palette, typographyInput),
      spacing: spacing,
      shape: shape$1,
      transitions: transitions,
      zIndex: zIndex$1
    }, other);
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    muiTheme = args.reduce(function (acc, argument) {
      return deepmerge(acc, argument);
    }, muiTheme);
    {
      var pseudoClasses = ['checked', 'disabled', 'error', 'focused', 'focusVisible', 'required', 'expanded', 'selected'];
      var traverse = function traverse(node, parentKey) {
        var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        var key; // eslint-disable-next-line guard-for-in, no-restricted-syntax

        for (key in node) {
          var child = node[key];
          if (depth === 1) {
            if (key.indexOf('Mui') === 0 && child) {
              traverse(child, key, depth + 1);
            }
          } else if (pseudoClasses.indexOf(key) !== -1 && Object.keys(child).length > 0) {
            {
              console.error(["Material-UI: The `".concat(parentKey, "` component increases ") + "the CSS specificity of the `".concat(key, "` internal state."), 'You can not override it like this: ', JSON.stringify(node, null, 2), '', 'Instead, you need to use the $ruleName syntax:', JSON.stringify({
                root: _defineProperty({}, "&$".concat(key), child)
              }, null, 2), '', 'https://mui.com/r/pseudo-classes-guide'].join('\n'));
            } // Remove the style to prevent global conflicts.

            node[key] = {};
          }
        }
      };
      traverse(muiTheme.overrides);
    }
    return muiTheme;
  }
  var warnedOnce = false;
  function createMuiTheme() {
    {
      if (!warnedOnce) {
        warnedOnce = true;
        console.error(['Material-UI: the createMuiTheme function was renamed to createTheme.', '', "You should use `import { createTheme } from '@material-ui/core/styles'`"].join('\n'));
      }
    }
    return createTheme.apply(void 0, arguments);
  }

  var hasSymbol = typeof Symbol === 'function' && Symbol.for;
  var nested = hasSymbol ? Symbol.for('mui.nested') : '__THEME_NESTED__';

  /**
   * This is the list of the style rule name we use as drop in replacement for the built-in
   * pseudo classes (:checked, :disabled, :focused, etc.).
   *
   * Why do they exist in the first place?
   * These classes are used at a specificity of 2.
   * It allows them to override previously definied styles as well as
   * being untouched by simple user overrides.
   */

  var pseudoClasses = ['checked', 'disabled', 'error', 'focused', 'focusVisible', 'required', 'expanded', 'selected']; // Returns a function which generates unique class names based on counters.
  // When new generator function is created, rule counter is reset.
  // We need to reset the rule counter for SSR for each request.
  //
  // It's inspired by
  // https://github.com/cssinjs/jss/blob/4e6a05dd3f7b6572fdd3ab216861d9e446c20331/src/utils/createGenerateClassName.js

  function createGenerateClassName() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _options$disableGloba = options.disableGlobal,
      disableGlobal = _options$disableGloba === void 0 ? false : _options$disableGloba;
      options.productionPrefix;
      var _options$seed = options.seed,
      seed = _options$seed === void 0 ? '' : _options$seed;
    var seedPrefix = seed === '' ? '' : "".concat(seed, "-");
    var ruleCounter = 0;
    var getNextCounterId = function getNextCounterId() {
      ruleCounter += 1;
      {
        if (ruleCounter >= 1e10) {
          console.warn(['Material-UI: You might have a memory leak.', 'The ruleCounter is not supposed to grow that much.'].join(''));
        }
      }
      return ruleCounter;
    };
    return function (rule, styleSheet) {
      var name = styleSheet.options.name; // Is a global static MUI style?

      if (name && name.indexOf('Mui') === 0 && !styleSheet.options.link && !disableGlobal) {
        // We can use a shorthand class name, we never use the keys to style the components.
        if (pseudoClasses.indexOf(rule.key) !== -1) {
          return "Mui-".concat(rule.key);
        }
        var prefix = "".concat(seedPrefix).concat(name, "-").concat(rule.key);
        if (!styleSheet.options.theme[nested] || seed !== '') {
          return prefix;
        }
        return "".concat(prefix, "-").concat(getNextCounterId());
      }
      var suffix = "".concat(rule.key, "-").concat(getNextCounterId()); // Help with debuggability.

      if (styleSheet.options.classNamePrefix) {
        return "".concat(seedPrefix).concat(styleSheet.options.classNamePrefix, "-").concat(suffix);
      }
      return "".concat(seedPrefix).concat(suffix);
    };
  }

  /* eslint-disable no-restricted-syntax */
  function getThemeProps(params) {
    var theme = params.theme,
      name = params.name,
      props = params.props;
    if (!theme || !theme.props || !theme.props[name]) {
      return props;
    } // Resolve default props, code borrow from React source.
    // https://github.com/facebook/react/blob/15a8f031838a553e41c0b66eb1bcf1da8448104d/packages/react/src/ReactElement.js#L221

    var defaultProps = theme.props[name];
    var propName;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
    return props;
  }

  var isProduction = "development" === 'production';
  function warning(condition, message) {
    if (!isProduction) {
      if (condition) {
        return;
      }
      var text = "Warning: " + message;
      if (typeof console !== 'undefined') {
        console.warn(text);
      }
      try {
        throw Error(text);
      } catch (x) {}
    }
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }

  var plainObjectConstrurctor = {}.constructor;
  function cloneStyle(style) {
    if (style == null || typeof style !== 'object') return style;
    if (Array.isArray(style)) return style.map(cloneStyle);
    if (style.constructor !== plainObjectConstrurctor) return style;
    var newStyle = {};
    for (var name in style) {
      newStyle[name] = cloneStyle(style[name]);
    }
    return newStyle;
  }

  /**
   * Create a rule instance.
   */

  function createRule(name, decl, options) {
    if (name === void 0) {
      name = 'unnamed';
    }
    var jss = options.jss;
    var declCopy = cloneStyle(decl);
    var rule = jss.plugins.onCreateRule(name, declCopy, options);
    if (rule) return rule; // It is an at-rule and it has no instance.

    if (name[0] === '@') {
      warning(false, "[JSS] Unknown rule " + name) ;
    }
    return null;
  }
  var join = function join(value, by) {
    var result = '';
    for (var i = 0; i < value.length; i++) {
      // Remove !important from the value, it will be readded later.
      if (value[i] === '!important') break;
      if (result) result += by;
      result += value[i];
    }
    return result;
  };
  /**
   * Converts JSS array value to a CSS string.
   *
   * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
   * `border: ['1px', '2px']` > `border: 1px, 2px;`
   * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
   * `color: ['red', !important]` > `color: red !important;`
   */

  var toCssValue = function toCssValue(value) {
    if (!Array.isArray(value)) return value;
    var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

    if (Array.isArray(value[0])) {
      for (var i = 0; i < value.length; i++) {
        if (value[i] === '!important') break;
        if (cssValue) cssValue += ', ';
        cssValue += join(value[i], ' ');
      }
    } else cssValue = join(value, ', '); // Add !important, because it was ignored.

    if (value[value.length - 1] === '!important') {
      cssValue += ' !important';
    }
    return cssValue;
  };
  function getWhitespaceSymbols(options) {
    if (options && options.format === false) {
      return {
        linebreak: '',
        space: ''
      };
    }
    return {
      linebreak: '\n',
      space: ' '
    };
  }

  /**
   * Indent a string.
   * http://jsperf.com/array-join-vs-for
   */

  function indentStr(str, indent) {
    var result = '';
    for (var index = 0; index < indent; index++) {
      result += '  ';
    }
    return result + str;
  }
  /**
   * Converts a Rule to CSS string.
   */

  function toCss(selector, style, options) {
    if (options === void 0) {
      options = {};
    }
    var result = '';
    if (!style) return result;
    var _options = options,
      _options$indent = _options.indent,
      indent = _options$indent === void 0 ? 0 : _options$indent;
    var fallbacks = style.fallbacks;
    if (options.format === false) {
      indent = -Infinity;
    }
    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
      linebreak = _getWhitespaceSymbols.linebreak,
      space = _getWhitespaceSymbols.space;
    if (selector) indent++; // Apply fallbacks first.

    if (fallbacks) {
      // Array syntax {fallbacks: [{prop: value}]}
      if (Array.isArray(fallbacks)) {
        for (var index = 0; index < fallbacks.length; index++) {
          var fallback = fallbacks[index];
          for (var prop in fallback) {
            var value = fallback[prop];
            if (value != null) {
              if (result) result += linebreak;
              result += indentStr(prop + ":" + space + toCssValue(value) + ";", indent);
            }
          }
        }
      } else {
        // Object syntax {fallbacks: {prop: value}}
        for (var _prop in fallbacks) {
          var _value = fallbacks[_prop];
          if (_value != null) {
            if (result) result += linebreak;
            result += indentStr(_prop + ":" + space + toCssValue(_value) + ";", indent);
          }
        }
      }
    }
    for (var _prop2 in style) {
      var _value2 = style[_prop2];
      if (_value2 != null && _prop2 !== 'fallbacks') {
        if (result) result += linebreak;
        result += indentStr(_prop2 + ":" + space + toCssValue(_value2) + ";", indent);
      }
    } // Allow empty style in this case, because properties will be added dynamically.

    if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

    if (!selector) return result;
    indent--;
    if (result) result = "" + linebreak + result + linebreak;
    return indentStr("" + selector + space + "{" + result, indent) + indentStr('}', indent);
  }
  var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
  var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;
  var escape = function (str) {
    return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
  };
  var BaseStyleRule = /*#__PURE__*/
  function () {
    function BaseStyleRule(key, style, options) {
      this.type = 'style';
      this.isProcessed = false;
      var sheet = options.sheet,
        Renderer = options.Renderer;
      this.key = key;
      this.options = options;
      this.style = style;
      if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
    }
    /**
     * Get or set a style property.
     */

    var _proto = BaseStyleRule.prototype;
    _proto.prop = function prop(name, value, options) {
      // It's a getter.
      if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

      var force = options ? options.force : false;
      if (!force && this.style[name] === value) return this;
      var newValue = value;
      if (!options || options.process !== false) {
        newValue = this.options.jss.plugins.onChangeValue(value, name, this);
      }
      var isEmpty = newValue == null || newValue === false;
      var isDefined = (name in this.style); // Value is empty and wasn't defined before.

      if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

      var remove = isEmpty && isDefined;
      if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

      if (this.renderable && this.renderer) {
        if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
        return this;
      }
      var sheet = this.options.sheet;
      if (sheet && sheet.attached) {
        warning(false, '[JSS] Rule is not linked. Missing sheet option "link: true".') ;
      }
      return this;
    };
    return BaseStyleRule;
  }();
  var StyleRule = /*#__PURE__*/
  function (_BaseStyleRule) {
    _inheritsLoose(StyleRule, _BaseStyleRule);
    function StyleRule(key, style, options) {
      var _this;
      _this = _BaseStyleRule.call(this, key, style, options) || this;
      var selector = options.selector,
        scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;
      if (selector) {
        _this.selectorText = selector;
      } else if (scoped !== false) {
        _this.id = generateId(_assertThisInitialized(_assertThisInitialized(_this)), sheet);
        _this.selectorText = "." + escape(_this.id);
      }
      return _this;
    }
    /**
     * Set selector string.
     * Attention: use this with caution. Most browsers didn't implement
     * selectorText setter, so this may result in rerendering of entire Style Sheet.
     */

    var _proto2 = StyleRule.prototype;

    /**
     * Apply rule to an element inline.
     */
    _proto2.applyTo = function applyTo(renderable) {
      var renderer = this.renderer;
      if (renderer) {
        var json = this.toJSON();
        for (var prop in json) {
          renderer.setProperty(renderable, prop, json[prop]);
        }
      }
      return this;
    }
    /**
     * Returns JSON representation of the rule.
     * Fallbacks are not supported.
     * Useful for inline styles.
     */;

    _proto2.toJSON = function toJSON() {
      var json = {};
      for (var prop in this.style) {
        var value = this.style[prop];
        if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
      }
      return json;
    }
    /**
     * Generates a CSS string.
     */;

    _proto2.toString = function toString(options) {
      var sheet = this.options.sheet;
      var link = sheet ? sheet.options.link : false;
      var opts = link ? _extends({}, options, {
        allowEmpty: true
      }) : options;
      return toCss(this.selectorText, this.style, opts);
    };
    _createClass(StyleRule, [{
      key: "selector",
      set: function set(selector) {
        if (selector === this.selectorText) return;
        this.selectorText = selector;
        var renderer = this.renderer,
          renderable = this.renderable;
        if (!renderable || !renderer) return;
        var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

        if (!hasChanged) {
          renderer.replaceRule(renderable, this);
        }
      }
      /**
       * Get selector string.
       */,

      get: function get() {
        return this.selectorText;
      }
    }]);
    return StyleRule;
  }(BaseStyleRule);
  var pluginStyleRule = {
    onCreateRule: function onCreateRule(key, style, options) {
      if (key[0] === '@' || options.parent && options.parent.type === 'keyframes') {
        return null;
      }
      return new StyleRule(key, style, options);
    }
  };
  var defaultToStringOptions = {
    indent: 1,
    children: true
  };
  var atRegExp = /@([\w-]+)/;
  /**
   * Conditional rule for @media, @supports
   */

  var ConditionalRule = /*#__PURE__*/
  function () {
    function ConditionalRule(key, styles, options) {
      this.type = 'conditional';
      this.isProcessed = false;
      this.key = key;
      var atMatch = key.match(atRegExp);
      this.at = atMatch ? atMatch[1] : 'unknown'; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

      this.query = options.name || "@" + this.at;
      this.options = options;
      this.rules = new RuleList(_extends({}, options, {
        parent: this
      }));
      for (var name in styles) {
        this.rules.add(name, styles[name]);
      }
      this.rules.process();
    }
    /**
     * Get a rule.
     */

    var _proto = ConditionalRule.prototype;
    _proto.getRule = function getRule(name) {
      return this.rules.get(name);
    }
    /**
     * Get index of a rule.
     */;

    _proto.indexOf = function indexOf(rule) {
      return this.rules.indexOf(rule);
    }
    /**
     * Create and register rule, run plugins.
     */;

    _proto.addRule = function addRule(name, style, options) {
      var rule = this.rules.add(name, style, options);
      if (!rule) return null;
      this.options.jss.plugins.onProcessRule(rule);
      return rule;
    }
    /**
     * Replace rule, run plugins.
     */;

    _proto.replaceRule = function replaceRule(name, style, options) {
      var newRule = this.rules.replace(name, style, options);
      if (newRule) this.options.jss.plugins.onProcessRule(newRule);
      return newRule;
    }
    /**
     * Generates a CSS string.
     */;

    _proto.toString = function toString(options) {
      if (options === void 0) {
        options = defaultToStringOptions;
      }
      var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;
      if (options.indent == null) options.indent = defaultToStringOptions.indent;
      if (options.children == null) options.children = defaultToStringOptions.children;
      if (options.children === false) {
        return this.query + " {}";
      }
      var children = this.rules.toString(options);
      return children ? this.query + " {" + linebreak + children + linebreak + "}" : '';
    };
    return ConditionalRule;
  }();
  var keyRegExp = /@container|@media|@supports\s+/;
  var pluginConditionalRule = {
    onCreateRule: function onCreateRule(key, styles, options) {
      return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
    }
  };
  var defaultToStringOptions$1 = {
    indent: 1,
    children: true
  };
  var nameRegExp = /@keyframes\s+([\w-]+)/;
  /**
   * Rule for @keyframes
   */

  var KeyframesRule = /*#__PURE__*/
  function () {
    function KeyframesRule(key, frames, options) {
      this.type = 'keyframes';
      this.at = '@keyframes';
      this.isProcessed = false;
      var nameMatch = key.match(nameRegExp);
      if (nameMatch && nameMatch[1]) {
        this.name = nameMatch[1];
      } else {
        this.name = 'noname';
        warning(false, "[JSS] Bad keyframes name " + key) ;
      }
      this.key = this.type + "-" + this.name;
      this.options = options;
      var scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;
      this.id = scoped === false ? this.name : escape(generateId(this, sheet));
      this.rules = new RuleList(_extends({}, options, {
        parent: this
      }));
      for (var name in frames) {
        this.rules.add(name, frames[name], _extends({}, options, {
          parent: this
        }));
      }
      this.rules.process();
    }
    /**
     * Generates a CSS string.
     */

    var _proto = KeyframesRule.prototype;
    _proto.toString = function toString(options) {
      if (options === void 0) {
        options = defaultToStringOptions$1;
      }
      var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;
      if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
      if (options.children == null) options.children = defaultToStringOptions$1.children;
      if (options.children === false) {
        return this.at + " " + this.id + " {}";
      }
      var children = this.rules.toString(options);
      if (children) children = "" + linebreak + children + linebreak;
      return this.at + " " + this.id + " {" + children + "}";
    };
    return KeyframesRule;
  }();
  var keyRegExp$1 = /@keyframes\s+/;
  var refRegExp$1 = /\$([\w-]+)/g;
  var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
    if (typeof val === 'string') {
      return val.replace(refRegExp$1, function (match, name) {
        if (name in keyframes) {
          return keyframes[name];
        }
        warning(false, "[JSS] Referenced keyframes rule \"" + name + "\" is not defined.") ;
        return match;
      });
    }
    return val;
  };
  /**
   * Replace the reference for a animation name.
   */

  var replaceRef = function replaceRef(style, prop, keyframes) {
    var value = style[prop];
    var refKeyframe = findReferencedKeyframe(value, keyframes);
    if (refKeyframe !== value) {
      style[prop] = refKeyframe;
    }
  };
  var pluginKeyframesRule = {
    onCreateRule: function onCreateRule(key, frames, options) {
      return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
    },
    // Animation name ref replacer.
    onProcessStyle: function onProcessStyle(style, rule, sheet) {
      if (rule.type !== 'style' || !sheet) return style;
      if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
      if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
      return style;
    },
    onChangeValue: function onChangeValue(val, prop, rule) {
      var sheet = rule.options.sheet;
      if (!sheet) {
        return val;
      }
      switch (prop) {
        case 'animation':
          return findReferencedKeyframe(val, sheet.keyframes);
        case 'animation-name':
          return findReferencedKeyframe(val, sheet.keyframes);
        default:
          return val;
      }
    }
  };
  var KeyframeRule = /*#__PURE__*/
  function (_BaseStyleRule) {
    _inheritsLoose(KeyframeRule, _BaseStyleRule);
    function KeyframeRule() {
      return _BaseStyleRule.apply(this, arguments) || this;
    }
    var _proto = KeyframeRule.prototype;

    /**
     * Generates a CSS string.
     */
    _proto.toString = function toString(options) {
      var sheet = this.options.sheet;
      var link = sheet ? sheet.options.link : false;
      var opts = link ? _extends({}, options, {
        allowEmpty: true
      }) : options;
      return toCss(this.key, this.style, opts);
    };
    return KeyframeRule;
  }(BaseStyleRule);
  var pluginKeyframeRule = {
    onCreateRule: function onCreateRule(key, style, options) {
      if (options.parent && options.parent.type === 'keyframes') {
        return new KeyframeRule(key, style, options);
      }
      return null;
    }
  };
  var FontFaceRule = /*#__PURE__*/
  function () {
    function FontFaceRule(key, style, options) {
      this.type = 'font-face';
      this.at = '@font-face';
      this.isProcessed = false;
      this.key = key;
      this.style = style;
      this.options = options;
    }
    /**
     * Generates a CSS string.
     */

    var _proto = FontFaceRule.prototype;
    _proto.toString = function toString(options) {
      var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;
      if (Array.isArray(this.style)) {
        var str = '';
        for (var index = 0; index < this.style.length; index++) {
          str += toCss(this.at, this.style[index]);
          if (this.style[index + 1]) str += linebreak;
        }
        return str;
      }
      return toCss(this.at, this.style, options);
    };
    return FontFaceRule;
  }();
  var keyRegExp$2 = /@font-face/;
  var pluginFontFaceRule = {
    onCreateRule: function onCreateRule(key, style, options) {
      return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
    }
  };
  var ViewportRule = /*#__PURE__*/
  function () {
    function ViewportRule(key, style, options) {
      this.type = 'viewport';
      this.at = '@viewport';
      this.isProcessed = false;
      this.key = key;
      this.style = style;
      this.options = options;
    }
    /**
     * Generates a CSS string.
     */

    var _proto = ViewportRule.prototype;
    _proto.toString = function toString(options) {
      return toCss(this.key, this.style, options);
    };
    return ViewportRule;
  }();
  var pluginViewportRule = {
    onCreateRule: function onCreateRule(key, style, options) {
      return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
    }
  };
  var SimpleRule = /*#__PURE__*/
  function () {
    function SimpleRule(key, value, options) {
      this.type = 'simple';
      this.isProcessed = false;
      this.key = key;
      this.value = value;
      this.options = options;
    }
    /**
     * Generates a CSS string.
     */
    // eslint-disable-next-line no-unused-vars

    var _proto = SimpleRule.prototype;
    _proto.toString = function toString(options) {
      if (Array.isArray(this.value)) {
        var str = '';
        for (var index = 0; index < this.value.length; index++) {
          str += this.key + " " + this.value[index] + ";";
          if (this.value[index + 1]) str += '\n';
        }
        return str;
      }
      return this.key + " " + this.value + ";";
    };
    return SimpleRule;
  }();
  var keysMap = {
    '@charset': true,
    '@import': true,
    '@namespace': true
  };
  var pluginSimpleRule = {
    onCreateRule: function onCreateRule(key, value, options) {
      return key in keysMap ? new SimpleRule(key, value, options) : null;
    }
  };
  var plugins$1 = [pluginStyleRule, pluginConditionalRule, pluginKeyframesRule, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];
  var defaultUpdateOptions = {
    process: true
  };
  var forceUpdateOptions = {
    force: true,
    process: true
    /**
     * Contains rules objects and allows adding/removing etc.
     * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
     */
  };

  var RuleList = /*#__PURE__*/
  function () {
    // Rules registry for access by .get() method.
    // It contains the same rule registered by name and by selector.
    // Original styles object.
    // Used to ensure correct rules order.
    function RuleList(options) {
      this.map = {};
      this.raw = {};
      this.index = [];
      this.counter = 0;
      this.options = options;
      this.classes = options.classes;
      this.keyframes = options.keyframes;
    }
    /**
     * Create and register rule.
     *
     * Will not render after Style Sheet was rendered the first time.
     */

    var _proto = RuleList.prototype;
    _proto.add = function add(name, decl, ruleOptions) {
      var _this$options = this.options,
        parent = _this$options.parent,
        sheet = _this$options.sheet,
        jss = _this$options.jss,
        Renderer = _this$options.Renderer,
        generateId = _this$options.generateId,
        scoped = _this$options.scoped;
      var options = _extends({
        classes: this.classes,
        parent: parent,
        sheet: sheet,
        jss: jss,
        Renderer: Renderer,
        generateId: generateId,
        scoped: scoped,
        name: name,
        keyframes: this.keyframes,
        selector: undefined
      }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
      // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
      // we need to make the key unique within this RuleList instance scope.

      var key = name;
      if (name in this.raw) {
        key = name + "-d" + this.counter++;
      } // We need to save the original decl before creating the rule
      // because cache plugin needs to use it as a key to return a cached rule.

      this.raw[key] = decl;
      if (key in this.classes) {
        // E.g. rules inside of @media container
        options.selector = "." + escape(this.classes[key]);
      }
      var rule = createRule(key, decl, options);
      if (!rule) return null;
      this.register(rule);
      var index = options.index === undefined ? this.index.length : options.index;
      this.index.splice(index, 0, rule);
      return rule;
    }
    /**
     * Replace rule.
     * Create a new rule and remove old one instead of overwriting
     * because we want to invoke onCreateRule hook to make plugins work.
     */;

    _proto.replace = function replace(name, decl, ruleOptions) {
      var oldRule = this.get(name);
      var oldIndex = this.index.indexOf(oldRule);
      if (oldRule) {
        this.remove(oldRule);
      }
      var options = ruleOptions;
      if (oldIndex !== -1) options = _extends({}, ruleOptions, {
        index: oldIndex
      });
      return this.add(name, decl, options);
    }
    /**
     * Get a rule by name or selector.
     */;

    _proto.get = function get(nameOrSelector) {
      return this.map[nameOrSelector];
    }
    /**
     * Delete a rule.
     */;

    _proto.remove = function remove(rule) {
      this.unregister(rule);
      delete this.raw[rule.key];
      this.index.splice(this.index.indexOf(rule), 1);
    }
    /**
     * Get index of a rule.
     */;

    _proto.indexOf = function indexOf(rule) {
      return this.index.indexOf(rule);
    }
    /**
     * Run `onProcessRule()` plugins on every rule.
     */;

    _proto.process = function process() {
      var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
      // we end up with very hard-to-track-down side effects.

      this.index.slice(0).forEach(plugins.onProcessRule, plugins);
    }
    /**
     * Register a rule in `.map`, `.classes` and `.keyframes` maps.
     */;

    _proto.register = function register(rule) {
      this.map[rule.key] = rule;
      if (rule instanceof StyleRule) {
        this.map[rule.selector] = rule;
        if (rule.id) this.classes[rule.key] = rule.id;
      } else if (rule instanceof KeyframesRule && this.keyframes) {
        this.keyframes[rule.name] = rule.id;
      }
    }
    /**
     * Unregister a rule.
     */;

    _proto.unregister = function unregister(rule) {
      delete this.map[rule.key];
      if (rule instanceof StyleRule) {
        delete this.map[rule.selector];
        delete this.classes[rule.key];
      } else if (rule instanceof KeyframesRule) {
        delete this.keyframes[rule.name];
      }
    }
    /**
     * Update the function values with a new data.
     */;

    _proto.update = function update() {
      var name;
      var data;
      var options;
      if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
        name = arguments.length <= 0 ? undefined : arguments[0];
        data = arguments.length <= 1 ? undefined : arguments[1];
        options = arguments.length <= 2 ? undefined : arguments[2];
      } else {
        data = arguments.length <= 0 ? undefined : arguments[0];
        options = arguments.length <= 1 ? undefined : arguments[1];
        name = null;
      }
      if (name) {
        this.updateOne(this.get(name), data, options);
      } else {
        for (var index = 0; index < this.index.length; index++) {
          this.updateOne(this.index[index], data, options);
        }
      }
    }
    /**
     * Execute plugins, update rule props.
     */;

    _proto.updateOne = function updateOne(rule, data, options) {
      if (options === void 0) {
        options = defaultUpdateOptions;
      }
      var _this$options2 = this.options,
        plugins = _this$options2.jss.plugins,
        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

      if (rule.rules instanceof RuleList) {
        rule.rules.update(data, options);
        return;
      }
      var style = rule.style;
      plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

      if (options.process && style && style !== rule.style) {
        // We need to run the plugins in case new `style` relies on syntax plugins.
        plugins.onProcessStyle(rule.style, rule, sheet); // Update and add props.

        for (var prop in rule.style) {
          var nextValue = rule.style[prop];
          var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
          // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

          if (nextValue !== prevValue) {
            rule.prop(prop, nextValue, forceUpdateOptions);
          }
        } // Remove props.

        for (var _prop in style) {
          var _nextValue = rule.style[_prop];
          var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
          // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

          if (_nextValue == null && _nextValue !== _prevValue) {
            rule.prop(_prop, null, forceUpdateOptions);
          }
        }
      }
    }
    /**
     * Convert rules to a CSS string.
     */;

    _proto.toString = function toString(options) {
      var str = '';
      var sheet = this.options.sheet;
      var link = sheet ? sheet.options.link : false;
      var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;
      for (var index = 0; index < this.index.length; index++) {
        var rule = this.index[index];
        var css = rule.toString(options); // No need to render an empty rule.

        if (!css && !link) continue;
        if (str) str += linebreak;
        str += css;
      }
      return str;
    };
    return RuleList;
  }();
  var StyleSheet = /*#__PURE__*/
  function () {
    function StyleSheet(styles, options) {
      this.attached = false;
      this.deployed = false;
      this.classes = {};
      this.keyframes = {};
      this.options = _extends({}, options, {
        sheet: this,
        parent: this,
        classes: this.classes,
        keyframes: this.keyframes
      });
      if (options.Renderer) {
        this.renderer = new options.Renderer(this);
      }
      this.rules = new RuleList(this.options);
      for (var name in styles) {
        this.rules.add(name, styles[name]);
      }
      this.rules.process();
    }
    /**
     * Attach renderable to the render tree.
     */

    var _proto = StyleSheet.prototype;
    _proto.attach = function attach() {
      if (this.attached) return this;
      if (this.renderer) this.renderer.attach();
      this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

      if (!this.deployed) this.deploy();
      return this;
    }
    /**
     * Remove renderable from render tree.
     */;

    _proto.detach = function detach() {
      if (!this.attached) return this;
      if (this.renderer) this.renderer.detach();
      this.attached = false;
      return this;
    }
    /**
     * Add a rule to the current stylesheet.
     * Will insert a rule also after the stylesheet has been rendered first time.
     */;

    _proto.addRule = function addRule(name, decl, options) {
      var queue = this.queue; // Plugins can create rules.
      // In order to preserve the right order, we need to queue all `.addRule` calls,
      // which happen after the first `rules.add()` call.

      if (this.attached && !queue) this.queue = [];
      var rule = this.rules.add(name, decl, options);
      if (!rule) return null;
      this.options.jss.plugins.onProcessRule(rule);
      if (this.attached) {
        if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
        // It will be inserted all together when .attach is called.

        if (queue) queue.push(rule);else {
          this.insertRule(rule);
          if (this.queue) {
            this.queue.forEach(this.insertRule, this);
            this.queue = undefined;
          }
        }
        return rule;
      } // We can't add rules to a detached style node.
      // We will redeploy the sheet once user will attach it.

      this.deployed = false;
      return rule;
    }
    /**
     * Replace a rule in the current stylesheet.
     */;

    _proto.replaceRule = function replaceRule(nameOrSelector, decl, options) {
      var oldRule = this.rules.get(nameOrSelector);
      if (!oldRule) return this.addRule(nameOrSelector, decl, options);
      var newRule = this.rules.replace(nameOrSelector, decl, options);
      if (newRule) {
        this.options.jss.plugins.onProcessRule(newRule);
      }
      if (this.attached) {
        if (!this.deployed) return newRule; // Don't replace / delete rule directly if there is no stringified version yet.
        // It will be inserted all together when .attach is called.

        if (this.renderer) {
          if (!newRule) {
            this.renderer.deleteRule(oldRule);
          } else if (oldRule.renderable) {
            this.renderer.replaceRule(oldRule.renderable, newRule);
          }
        }
        return newRule;
      } // We can't replace rules to a detached style node.
      // We will redeploy the sheet once user will attach it.

      this.deployed = false;
      return newRule;
    }
    /**
     * Insert rule into the StyleSheet
     */;

    _proto.insertRule = function insertRule(rule) {
      if (this.renderer) {
        this.renderer.insertRule(rule);
      }
    }
    /**
     * Create and add rules.
     * Will render also after Style Sheet was rendered the first time.
     */;

    _proto.addRules = function addRules(styles, options) {
      var added = [];
      for (var name in styles) {
        var rule = this.addRule(name, styles[name], options);
        if (rule) added.push(rule);
      }
      return added;
    }
    /**
     * Get a rule by name or selector.
     */;

    _proto.getRule = function getRule(nameOrSelector) {
      return this.rules.get(nameOrSelector);
    }
    /**
     * Delete a rule by name.
     * Returns `true`: if rule has been deleted from the DOM.
     */;

    _proto.deleteRule = function deleteRule(name) {
      var rule = typeof name === 'object' ? name : this.rules.get(name);
      if (!rule ||
      // Style sheet was created without link: true and attached, in this case we
      // won't be able to remove the CSS rule from the DOM.
      this.attached && !rule.renderable) {
        return false;
      }
      this.rules.remove(rule);
      if (this.attached && rule.renderable && this.renderer) {
        return this.renderer.deleteRule(rule.renderable);
      }
      return true;
    }
    /**
     * Get index of a rule.
     */;

    _proto.indexOf = function indexOf(rule) {
      return this.rules.indexOf(rule);
    }
    /**
     * Deploy pure CSS string to a renderable.
     */;

    _proto.deploy = function deploy() {
      if (this.renderer) this.renderer.deploy();
      this.deployed = true;
      return this;
    }
    /**
     * Update the function values with a new data.
     */;

    _proto.update = function update() {
      var _this$rules;
      (_this$rules = this.rules).update.apply(_this$rules, arguments);
      return this;
    }
    /**
     * Updates a single rule.
     */;

    _proto.updateOne = function updateOne(rule, data, options) {
      this.rules.updateOne(rule, data, options);
      return this;
    }
    /**
     * Convert rules to a CSS string.
     */;

    _proto.toString = function toString(options) {
      return this.rules.toString(options);
    };
    return StyleSheet;
  }();
  var PluginsRegistry = /*#__PURE__*/
  function () {
    function PluginsRegistry() {
      this.plugins = {
        internal: [],
        external: []
      };
      this.registry = {};
    }
    var _proto = PluginsRegistry.prototype;

    /**
     * Call `onCreateRule` hooks and return an object if returned by a hook.
     */
    _proto.onCreateRule = function onCreateRule(name, decl, options) {
      for (var i = 0; i < this.registry.onCreateRule.length; i++) {
        var rule = this.registry.onCreateRule[i](name, decl, options);
        if (rule) return rule;
      }
      return null;
    }
    /**
     * Call `onProcessRule` hooks.
     */;

    _proto.onProcessRule = function onProcessRule(rule) {
      if (rule.isProcessed) return;
      var sheet = rule.options.sheet;
      for (var i = 0; i < this.registry.onProcessRule.length; i++) {
        this.registry.onProcessRule[i](rule, sheet);
      }
      if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
      rule.isProcessed = true;
    }
    /**
     * Call `onProcessStyle` hooks.
     */;

    _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
      for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
        rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
      }
    }
    /**
     * Call `onProcessSheet` hooks.
     */;

    _proto.onProcessSheet = function onProcessSheet(sheet) {
      for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
        this.registry.onProcessSheet[i](sheet);
      }
    }
    /**
     * Call `onUpdate` hooks.
     */;

    _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
      for (var i = 0; i < this.registry.onUpdate.length; i++) {
        this.registry.onUpdate[i](data, rule, sheet, options);
      }
    }
    /**
     * Call `onChangeValue` hooks.
     */;

    _proto.onChangeValue = function onChangeValue(value, prop, rule) {
      var processedValue = value;
      for (var i = 0; i < this.registry.onChangeValue.length; i++) {
        processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
      }
      return processedValue;
    }
    /**
     * Register a plugin.
     */;

    _proto.use = function use(newPlugin, options) {
      if (options === void 0) {
        options = {
          queue: 'external'
        };
      }
      var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

      if (plugins.indexOf(newPlugin) !== -1) {
        return;
      }
      plugins.push(newPlugin);
      this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
        for (var name in plugin) {
          if (name in registry) {
            registry[name].push(plugin[name]);
          } else {
            warning(false, "[JSS] Unknown hook \"" + name + "\".") ;
          }
        }
        return registry;
      }, {
        onCreateRule: [],
        onProcessRule: [],
        onProcessStyle: [],
        onProcessSheet: [],
        onChangeValue: [],
        onUpdate: []
      });
    };
    return PluginsRegistry;
  }();

  /**
   * Sheets registry to access all instances in one place.
   */

  var SheetsRegistry = /*#__PURE__*/
  function () {
    function SheetsRegistry() {
      this.registry = [];
    }
    var _proto = SheetsRegistry.prototype;

    /**
     * Register a Style Sheet.
     */
    _proto.add = function add(sheet) {
      var registry = this.registry;
      var index = sheet.options.index;
      if (registry.indexOf(sheet) !== -1) return;
      if (registry.length === 0 || index >= this.index) {
        registry.push(sheet);
        return;
      } // Find a position.

      for (var i = 0; i < registry.length; i++) {
        if (registry[i].options.index > index) {
          registry.splice(i, 0, sheet);
          return;
        }
      }
    }
    /**
     * Reset the registry.
     */;

    _proto.reset = function reset() {
      this.registry = [];
    }
    /**
     * Remove a Style Sheet.
     */;

    _proto.remove = function remove(sheet) {
      var index = this.registry.indexOf(sheet);
      this.registry.splice(index, 1);
    }
    /**
     * Convert all attached sheets to a CSS string.
     */;

    _proto.toString = function toString(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
        attached = _ref.attached,
        options = _objectWithoutPropertiesLoose(_ref, ["attached"]);
      var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;
      var css = '';
      for (var i = 0; i < this.registry.length; i++) {
        var sheet = this.registry[i];
        if (attached != null && sheet.attached !== attached) {
          continue;
        }
        if (css) css += linebreak;
        css += sheet.toString(options);
      }
      return css;
    };
    _createClass(SheetsRegistry, [{
      key: "index",
      /**
       * Current highest index number.
       */
      get: function get() {
        return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
      }
    }]);
    return SheetsRegistry;
  }();

  /**
   * This is a global sheets registry. Only DomRenderer will add sheets to it.
   * On the server one should use an own SheetsRegistry instance and add the
   * sheets to it, because you need to make sure to create a new registry for
   * each request in order to not leak sheets across requests.
   */

  var sheets = new SheetsRegistry();

  /* eslint-disable */

  /**
   * Now that `globalThis` is available on most platforms
   * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)
   * we check for `globalThis` first. `globalThis` is necessary for jss
   * to run in Agoric's secure version of JavaScript (SES). Under SES,
   * `globalThis` exists, but `window`, `self`, and `Function('return
   * this')()` are all undefined for security reasons.
   *
   * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
   */
  var globalThis$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();
  var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
  if (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
  // the current version with just one short number and use it for classes generation
  // we use a counter. Also it is more accurate, because user can manually reevaluate
  // the module.

  var moduleId = globalThis$1[ns]++;
  var maxRules = 1e10;
  /**
   * Returns a function which generates unique class names based on counters.
   * When new generator function is created, rule counter is reseted.
   * We need to reset the rule counter for SSR for each request.
   */

  var createGenerateId = function createGenerateId(options) {
    if (options === void 0) {
      options = {};
    }
    var ruleCounter = 0;
    var generateId = function generateId(rule, sheet) {
      ruleCounter += 1;
      if (ruleCounter > maxRules) {
        warning(false, "[JSS] You might have a memory leak. Rule counter is at " + ruleCounter + ".") ;
      }
      var jssId = '';
      var prefix = '';
      if (sheet) {
        if (sheet.options.classNamePrefix) {
          prefix = sheet.options.classNamePrefix;
        }
        if (sheet.options.jss.id != null) {
          jssId = String(sheet.options.jss.id);
        }
      }
      if (options.minify) {
        // Using "c" because a number can't be the first char in a class name.
        return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
      }
      return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
    };
    return generateId;
  };

  /**
   * Cache the value from the first time a function is called.
   */

  var memoize = function memoize(fn) {
    var value;
    return function () {
      if (!value) value = fn();
      return value;
    };
  };
  /**
   * Get a style property value.
   */

  var getPropertyValue = function getPropertyValue(cssRule, prop) {
    try {
      // Support CSSTOM.
      if (cssRule.attributeStyleMap) {
        return cssRule.attributeStyleMap.get(prop);
      }
      return cssRule.style.getPropertyValue(prop);
    } catch (err) {
      // IE may throw if property is unknown.
      return '';
    }
  };
  /**
   * Set a style property.
   */

  var setProperty = function setProperty(cssRule, prop, value) {
    try {
      var cssValue = value;
      if (Array.isArray(value)) {
        cssValue = toCssValue(value);
      } // Support CSSTOM.

      if (cssRule.attributeStyleMap) {
        cssRule.attributeStyleMap.set(prop, cssValue);
      } else {
        var indexOfImportantFlag = cssValue ? cssValue.indexOf('!important') : -1;
        var cssValueWithoutImportantFlag = indexOfImportantFlag > -1 ? cssValue.substr(0, indexOfImportantFlag - 1) : cssValue;
        cssRule.style.setProperty(prop, cssValueWithoutImportantFlag, indexOfImportantFlag > -1 ? 'important' : '');
      }
    } catch (err) {
      // IE may throw if property is unknown.
      return false;
    }
    return true;
  };
  /**
   * Remove a style property.
   */

  var removeProperty = function removeProperty(cssRule, prop) {
    try {
      // Support CSSTOM.
      if (cssRule.attributeStyleMap) {
        cssRule.attributeStyleMap.delete(prop);
      } else {
        cssRule.style.removeProperty(prop);
      }
    } catch (err) {
      warning(false, "[JSS] DOMException \"" + err.message + "\" was thrown. Tried to remove property \"" + prop + "\".") ;
    }
  };
  /**
   * Set the selector.
   */

  var setSelector = function setSelector(cssRule, selectorText) {
    cssRule.selectorText = selectorText; // Return false if setter was not successful.
    // Currently works in chrome only.

    return cssRule.selectorText === selectorText;
  };
  /**
   * Gets the `head` element upon the first call and caches it.
   * We assume it can't be null.
   */

  var getHead = memoize(function () {
    return document.querySelector('head');
  });
  /**
   * Find attached sheet with an index higher than the passed one.
   */

  function findHigherSheet(registry, options) {
    for (var i = 0; i < registry.length; i++) {
      var sheet = registry[i];
      if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
        return sheet;
      }
    }
    return null;
  }
  /**
   * Find attached sheet with the highest index.
   */

  function findHighestSheet(registry, options) {
    for (var i = registry.length - 1; i >= 0; i--) {
      var sheet = registry[i];
      if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
        return sheet;
      }
    }
    return null;
  }
  /**
   * Find a comment with "jss" inside.
   */

  function findCommentNode(text) {
    var head = getHead();
    for (var i = 0; i < head.childNodes.length; i++) {
      var node = head.childNodes[i];
      if (node.nodeType === 8 && node.nodeValue.trim() === text) {
        return node;
      }
    }
    return null;
  }
  /**
   * Find a node before which we can insert the sheet.
   */

  function findPrevNode(options) {
    var registry = sheets.registry;
    if (registry.length > 0) {
      // Try to insert before the next higher sheet.
      var sheet = findHigherSheet(registry, options);
      if (sheet && sheet.renderer) {
        return {
          parent: sheet.renderer.element.parentNode,
          node: sheet.renderer.element
        };
      } // Otherwise insert after the last attached.

      sheet = findHighestSheet(registry, options);
      if (sheet && sheet.renderer) {
        return {
          parent: sheet.renderer.element.parentNode,
          node: sheet.renderer.element.nextSibling
        };
      }
    } // Try to find a comment placeholder if registry is empty.

    var insertionPoint = options.insertionPoint;
    if (insertionPoint && typeof insertionPoint === 'string') {
      var comment = findCommentNode(insertionPoint);
      if (comment) {
        return {
          parent: comment.parentNode,
          node: comment.nextSibling
        };
      } // If user specifies an insertion point and it can't be found in the document -
      // bad specificity issues may appear.

      warning(false, "[JSS] Insertion point \"" + insertionPoint + "\" not found.") ;
    }
    return false;
  }
  /**
   * Insert style element into the DOM.
   */

  function insertStyle(style, options) {
    var insertionPoint = options.insertionPoint;
    var nextNode = findPrevNode(options);
    if (nextNode !== false && nextNode.parent) {
      nextNode.parent.insertBefore(style, nextNode.node);
      return;
    } // Works with iframes and any node types.

    if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
      var insertionPointElement = insertionPoint;
      var parentNode = insertionPointElement.parentNode;
      if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);else warning(false, '[JSS] Insertion point is not in the DOM.') ;
      return;
    }
    getHead().appendChild(style);
  }
  /**
   * Read jss nonce setting from the page if the user has set it.
   */

  var getNonce = memoize(function () {
    var node = document.querySelector('meta[property="csp-nonce"]');
    return node ? node.getAttribute('content') : null;
  });
  var _insertRule = function insertRule(container, rule, index) {
    try {
      if ('insertRule' in container) {
        container.insertRule(rule, index);
      } // Keyframes rule.
      else if ('appendRule' in container) {
        container.appendRule(rule);
      }
    } catch (err) {
      warning(false, "[JSS] " + err.message) ;
      return false;
    }
    return container.cssRules[index];
  };
  var getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {
    var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

    if (index === undefined || index > maxIndex) {
      // eslint-disable-next-line no-param-reassign
      return maxIndex;
    }
    return index;
  };
  var createStyle = function createStyle() {
    var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
    // insert rules after we insert the style tag.
    // It seems to kick-off the source order specificity algorithm.

    el.textContent = '\n';
    return el;
  };
  var DomRenderer = /*#__PURE__*/
  function () {
    // Will be empty if link: true option is not set, because
    // it is only for use together with insertRule API.
    function DomRenderer(sheet) {
      this.getPropertyValue = getPropertyValue;
      this.setProperty = setProperty;
      this.removeProperty = removeProperty;
      this.setSelector = setSelector;
      this.hasInsertedRules = false;
      this.cssRules = [];
      // There is no sheet when the renderer is used from a standalone StyleRule.
      if (sheet) sheets.add(sheet);
      this.sheet = sheet;
      var _ref = this.sheet ? this.sheet.options : {},
        media = _ref.media,
        meta = _ref.meta,
        element = _ref.element;
      this.element = element || createStyle();
      this.element.setAttribute('data-jss', '');
      if (media) this.element.setAttribute('media', media);
      if (meta) this.element.setAttribute('data-meta', meta);
      var nonce = getNonce();
      if (nonce) this.element.setAttribute('nonce', nonce);
    }
    /**
     * Insert style element into render tree.
     */

    var _proto = DomRenderer.prototype;
    _proto.attach = function attach() {
      // In the case the element node is external and it is already in the DOM.
      if (this.element.parentNode || !this.sheet) return;
      insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
      // most browsers create a new CSSStyleSheet, except of all IEs.

      var deployed = Boolean(this.sheet && this.sheet.deployed);
      if (this.hasInsertedRules && deployed) {
        this.hasInsertedRules = false;
        this.deploy();
      }
    }
    /**
     * Remove style element from render tree.
     */;

    _proto.detach = function detach() {
      if (!this.sheet) return;
      var parentNode = this.element.parentNode;
      if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.
      // Though IE will keep them and we need a consistent behavior.

      if (this.sheet.options.link) {
        this.cssRules = [];
        this.element.textContent = '\n';
      }
    }
    /**
     * Inject CSS string into element.
     */;

    _proto.deploy = function deploy() {
      var sheet = this.sheet;
      if (!sheet) return;
      if (sheet.options.link) {
        this.insertRules(sheet.rules);
        return;
      }
      this.element.textContent = "\n" + sheet.toString() + "\n";
    }
    /**
     * Insert RuleList into an element.
     */;

    _proto.insertRules = function insertRules(rules, nativeParent) {
      for (var i = 0; i < rules.index.length; i++) {
        this.insertRule(rules.index[i], i, nativeParent);
      }
    }
    /**
     * Insert a rule into element.
     */;

    _proto.insertRule = function insertRule(rule, index, nativeParent) {
      if (nativeParent === void 0) {
        nativeParent = this.element.sheet;
      }
      if (rule.rules) {
        var parent = rule;
        var latestNativeParent = nativeParent;
        if (rule.type === 'conditional' || rule.type === 'keyframes') {
          var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.

          latestNativeParent = _insertRule(nativeParent, parent.toString({
            children: false
          }), _insertionIndex);
          if (latestNativeParent === false) {
            return false;
          }
          this.refCssRule(rule, _insertionIndex, latestNativeParent);
        }
        this.insertRules(parent.rules, latestNativeParent);
        return latestNativeParent;
      }
      var ruleStr = rule.toString();
      if (!ruleStr) return false;
      var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);
      var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);
      if (nativeRule === false) {
        return false;
      }
      this.hasInsertedRules = true;
      this.refCssRule(rule, insertionIndex, nativeRule);
      return nativeRule;
    };
    _proto.refCssRule = function refCssRule(rule, index, cssRule) {
      rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules
      // like rules inside media queries or keyframes

      if (rule.options.parent instanceof StyleSheet) {
        this.cssRules.splice(index, 0, cssRule);
      }
    }
    /**
     * Delete a rule.
     */;

    _proto.deleteRule = function deleteRule(cssRule) {
      var sheet = this.element.sheet;
      var index = this.indexOf(cssRule);
      if (index === -1) return false;
      sheet.deleteRule(index);
      this.cssRules.splice(index, 1);
      return true;
    }
    /**
     * Get index of a CSS Rule.
     */;

    _proto.indexOf = function indexOf(cssRule) {
      return this.cssRules.indexOf(cssRule);
    }
    /**
     * Generate a new CSS rule and replace the existing one.
     */;

    _proto.replaceRule = function replaceRule(cssRule, rule) {
      var index = this.indexOf(cssRule);
      if (index === -1) return false;
      this.element.sheet.deleteRule(index);
      this.cssRules.splice(index, 1);
      return this.insertRule(rule, index);
    }
    /**
     * Get all rules elements.
     */;

    _proto.getRules = function getRules() {
      return this.element.sheet.cssRules;
    };
    return DomRenderer;
  }();
  var instanceCounter = 0;
  var Jss = /*#__PURE__*/
  function () {
    function Jss(options) {
      this.id = instanceCounter++;
      this.version = "10.10.0";
      this.plugins = new PluginsRegistry();
      this.options = {
        id: {
          minify: false
        },
        createGenerateId: createGenerateId,
        Renderer: isBrowser ? DomRenderer : null,
        plugins: []
      };
      this.generateId = createGenerateId({
        minify: false
      });
      for (var i = 0; i < plugins$1.length; i++) {
        this.plugins.use(plugins$1[i], {
          queue: 'internal'
        });
      }
      this.setup(options);
    }
    /**
     * Prepares various options, applies plugins.
     * Should not be used twice on the same instance, because there is no plugins
     * deduplication logic.
     */

    var _proto = Jss.prototype;
    _proto.setup = function setup(options) {
      if (options === void 0) {
        options = {};
      }
      if (options.createGenerateId) {
        this.options.createGenerateId = options.createGenerateId;
      }
      if (options.id) {
        this.options.id = _extends({}, this.options.id, options.id);
      }
      if (options.createGenerateId || options.id) {
        this.generateId = this.options.createGenerateId(this.options.id);
      }
      if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;
      if ('Renderer' in options) {
        this.options.Renderer = options.Renderer;
      } // eslint-disable-next-line prefer-spread

      if (options.plugins) this.use.apply(this, options.plugins);
      return this;
    }
    /**
     * Create a Style Sheet.
     */;

    _proto.createStyleSheet = function createStyleSheet(styles, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options,
        index = _options.index;
      if (typeof index !== 'number') {
        index = sheets.index === 0 ? 0 : sheets.index + 1;
      }
      var sheet = new StyleSheet(styles, _extends({}, options, {
        jss: this,
        generateId: options.generateId || this.generateId,
        insertionPoint: this.options.insertionPoint,
        Renderer: this.options.Renderer,
        index: index
      }));
      this.plugins.onProcessSheet(sheet);
      return sheet;
    }
    /**
     * Detach the Style Sheet and remove it from the registry.
     */;

    _proto.removeStyleSheet = function removeStyleSheet(sheet) {
      sheet.detach();
      sheets.remove(sheet);
      return this;
    }
    /**
     * Create a rule without a Style Sheet.
     * [Deprecated] will be removed in the next major version.
     */;

    _proto.createRule = function createRule$1(name, style, options) {
      if (style === void 0) {
        style = {};
      }
      if (options === void 0) {
        options = {};
      }

      // Enable rule without name for inline styles.
      if (typeof name === 'object') {
        return this.createRule(undefined, name, style);
      }
      var ruleOptions = _extends({}, options, {
        name: name,
        jss: this,
        Renderer: this.options.Renderer
      });
      if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
      if (!ruleOptions.classes) ruleOptions.classes = {};
      if (!ruleOptions.keyframes) ruleOptions.keyframes = {};
      var rule = createRule(name, style, ruleOptions);
      if (rule) this.plugins.onProcessRule(rule);
      return rule;
    }
    /**
     * Register plugin. Passed function will be invoked with a rule instance.
     */;

    _proto.use = function use() {
      var _this = this;
      for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
        plugins[_key] = arguments[_key];
      }
      plugins.forEach(function (plugin) {
        _this.plugins.use(plugin);
      });
      return this;
    };
    return Jss;
  }();
  var createJss = function createJss(options) {
    return new Jss(options);
  };

  /**
  * Export a constant indicating if this browser has CSSTOM support.
  * https://developers.google.com/web/updates/2018/03/cssom
  */
  var hasCSSTOMSupport = typeof CSS === 'object' && CSS != null && 'number' in CSS;

  /**
   * Extracts a styles object with only props that contain function values.
   */
  function getDynamicStyles(styles) {
    var to = null;
    for (var key in styles) {
      var value = styles[key];
      var type = typeof value;
      if (type === 'function') {
        if (!to) to = {};
        to[key] = value;
      } else if (type === 'object' && value !== null && !Array.isArray(value)) {
        var extracted = getDynamicStyles(value);
        if (extracted) {
          if (!to) to = {};
          to[key] = extracted;
        }
      }
    }
    return to;
  }

  /**
   * A better abstraction over CSS.
   *
   * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
   * @website https://github.com/cssinjs/jss
   * @license MIT
   */
  createJss();

  var now = Date.now();
  var fnValuesNs = "fnValues" + now;
  var fnRuleNs = "fnStyle" + ++now;
  var functionPlugin = function functionPlugin() {
    return {
      onCreateRule: function onCreateRule(name, decl, options) {
        if (typeof decl !== 'function') return null;
        var rule = createRule(name, {}, options);
        rule[fnRuleNs] = decl;
        return rule;
      },
      onProcessStyle: function onProcessStyle(style, rule) {
        // We need to extract function values from the declaration, so that we can keep core unaware of them.
        // We need to do that only once.
        // We don't need to extract functions on each style update, since this can happen only once.
        // We don't support function values inside of function rules.
        if (fnValuesNs in rule || fnRuleNs in rule) return style;
        var fnValues = {};
        for (var prop in style) {
          var value = style[prop];
          if (typeof value !== 'function') continue;
          delete style[prop];
          fnValues[prop] = value;
        }
        rule[fnValuesNs] = fnValues;
        return style;
      },
      onUpdate: function onUpdate(data, rule, sheet, options) {
        var styleRule = rule;
        var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object
        // will be returned from that function.

        if (fnRule) {
          // Empty object will remove all currently defined props
          // in case function rule returns a falsy value.
          styleRule.style = fnRule(data) || {};
          {
            for (var prop in styleRule.style) {
              if (typeof styleRule.style[prop] === 'function') {
                warning(false, '[JSS] Function values inside function rules are not supported.') ;
                break;
              }
            }
          }
        }
        var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.

        if (fnValues) {
          for (var _prop in fnValues) {
            styleRule.prop(_prop, fnValues[_prop](data), options);
          }
        }
      }
    };
  };
  var functions = functionPlugin;

  var at = '@global';
  var atPrefix = '@global ';
  var GlobalContainerRule = /*#__PURE__*/
  function () {
    function GlobalContainerRule(key, styles, options) {
      this.type = 'global';
      this.at = at;
      this.isProcessed = false;
      this.key = key;
      this.options = options;
      this.rules = new RuleList(_extends({}, options, {
        parent: this
      }));
      for (var selector in styles) {
        this.rules.add(selector, styles[selector]);
      }
      this.rules.process();
    }
    /**
     * Get a rule.
     */

    var _proto = GlobalContainerRule.prototype;
    _proto.getRule = function getRule(name) {
      return this.rules.get(name);
    }
    /**
     * Create and register rule, run plugins.
     */;

    _proto.addRule = function addRule(name, style, options) {
      var rule = this.rules.add(name, style, options);
      if (rule) this.options.jss.plugins.onProcessRule(rule);
      return rule;
    }
    /**
     * Replace rule, run plugins.
     */;

    _proto.replaceRule = function replaceRule(name, style, options) {
      var newRule = this.rules.replace(name, style, options);
      if (newRule) this.options.jss.plugins.onProcessRule(newRule);
      return newRule;
    }
    /**
     * Get index of a rule.
     */;

    _proto.indexOf = function indexOf(rule) {
      return this.rules.indexOf(rule);
    }
    /**
     * Generates a CSS string.
     */;

    _proto.toString = function toString(options) {
      return this.rules.toString(options);
    };
    return GlobalContainerRule;
  }();
  var GlobalPrefixedRule = /*#__PURE__*/
  function () {
    function GlobalPrefixedRule(key, style, options) {
      this.type = 'global';
      this.at = at;
      this.isProcessed = false;
      this.key = key;
      this.options = options;
      var selector = key.substr(atPrefix.length);
      this.rule = options.jss.createRule(selector, style, _extends({}, options, {
        parent: this
      }));
    }
    var _proto2 = GlobalPrefixedRule.prototype;
    _proto2.toString = function toString(options) {
      return this.rule ? this.rule.toString(options) : '';
    };
    return GlobalPrefixedRule;
  }();
  var separatorRegExp$1 = /\s*,\s*/g;
  function addScope(selector, scope) {
    var parts = selector.split(separatorRegExp$1);
    var scoped = '';
    for (var i = 0; i < parts.length; i++) {
      scoped += scope + " " + parts[i].trim();
      if (parts[i + 1]) scoped += ', ';
    }
    return scoped;
  }
  function handleNestedGlobalContainerRule(rule, sheet) {
    var options = rule.options,
      style = rule.style;
    var rules = style ? style[at] : null;
    if (!rules) return;
    for (var name in rules) {
      sheet.addRule(name, rules[name], _extends({}, options, {
        selector: addScope(name, rule.selector)
      }));
    }
    delete style[at];
  }
  function handlePrefixedGlobalRule(rule, sheet) {
    var options = rule.options,
      style = rule.style;
    for (var prop in style) {
      if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
      var selector = addScope(prop.substr(at.length), rule.selector);
      sheet.addRule(selector, style[prop], _extends({}, options, {
        selector: selector
      }));
      delete style[prop];
    }
  }
  /**
   * Convert nested rules to separate, remove them from original styles.
   */

  function jssGlobal() {
    function onCreateRule(name, styles, options) {
      if (!name) return null;
      if (name === at) {
        return new GlobalContainerRule(name, styles, options);
      }
      if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
        return new GlobalPrefixedRule(name, styles, options);
      }
      var parent = options.parent;
      if (parent) {
        if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
          options.scoped = false;
        }
      }
      if (!options.selector && options.scoped === false) {
        options.selector = name;
      }
      return null;
    }
    function onProcessRule(rule, sheet) {
      if (rule.type !== 'style' || !sheet) return;
      handleNestedGlobalContainerRule(rule, sheet);
      handlePrefixedGlobalRule(rule, sheet);
    }
    return {
      onCreateRule: onCreateRule,
      onProcessRule: onProcessRule
    };
  }

  var separatorRegExp = /\s*,\s*/g;
  var parentRegExp = /&/g;
  var refRegExp = /\$([\w-]+)/g;
  /**
   * Convert nested rules to separate, remove them from original styles.
   */

  function jssNested() {
    // Get a function to be used for $ref replacement.
    function getReplaceRef(container, sheet) {
      return function (match, key) {
        var rule = container.getRule(key) || sheet && sheet.getRule(key);
        if (rule) {
          return rule.selector;
        }
        warning(false, "[JSS] Could not find the referenced rule \"" + key + "\" in \"" + (container.options.meta || container.toString()) + "\".") ;
        return key;
      };
    }
    function replaceParentRefs(nestedProp, parentProp) {
      var parentSelectors = parentProp.split(separatorRegExp);
      var nestedSelectors = nestedProp.split(separatorRegExp);
      var result = '';
      for (var i = 0; i < parentSelectors.length; i++) {
        var parent = parentSelectors[i];
        for (var j = 0; j < nestedSelectors.length; j++) {
          var nested = nestedSelectors[j];
          if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.

          result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
        }
      }
      return result;
    }
    function getOptions(rule, container, prevOptions) {
      // Options has been already created, now we only increase index.
      if (prevOptions) return _extends({}, prevOptions, {
        index: prevOptions.index + 1
      });
      var nestingLevel = rule.options.nestingLevel;
      nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;
      var options = _extends({}, rule.options, {
        nestingLevel: nestingLevel,
        index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.
      });

      delete options.name;
      return options;
    }
    function onProcessStyle(style, rule, sheet) {
      if (rule.type !== 'style') return style;
      var styleRule = rule;
      var container = styleRule.options.parent;
      var options;
      var replaceRef;
      for (var prop in style) {
        var isNested = prop.indexOf('&') !== -1;
        var isNestedConditional = prop[0] === '@';
        if (!isNested && !isNestedConditional) continue;
        options = getOptions(styleRule, container, options);
        if (isNested) {
          var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for
          // all nested rules within the sheet.

          if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.

          selector = selector.replace(refRegExp, replaceRef);
          var name = styleRule.key + "-" + prop;
          if ('replaceRule' in container) {
            // for backward compatibility
            container.replaceRule(name, style[prop], _extends({}, options, {
              selector: selector
            }));
          } else {
            container.addRule(name, style[prop], _extends({}, options, {
              selector: selector
            }));
          }
        } else if (isNestedConditional) {
          // Place conditional right after the parent rule to ensure right ordering.
          container.addRule(prop, {}, options).addRule(styleRule.key, style[prop], {
            selector: styleRule.selector
          });
        }
        delete style[prop];
      }
      return style;
    }
    return {
      onProcessStyle: onProcessStyle
    };
  }

  /* eslint-disable no-var, prefer-template */
  var uppercasePattern = /[A-Z]/g;
  var msPattern = /^ms-/;
  var cache$2 = {};
  function toHyphenLower(match) {
    return '-' + match.toLowerCase();
  }
  function hyphenateStyleName(name) {
    if (cache$2.hasOwnProperty(name)) {
      return cache$2[name];
    }
    var hName = name.replace(uppercasePattern, toHyphenLower);
    return cache$2[name] = msPattern.test(hName) ? '-' + hName : hName;
  }

  /**
   * Convert camel cased property names to dash separated.
   */

  function convertCase(style) {
    var converted = {};
    for (var prop in style) {
      var key = prop.indexOf('--') === 0 ? prop : hyphenateStyleName(prop);
      converted[key] = style[prop];
    }
    if (style.fallbacks) {
      if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
    }
    return converted;
  }
  /**
   * Allow camel cased property names by converting them back to dasherized.
   */

  function camelCase() {
    function onProcessStyle(style) {
      if (Array.isArray(style)) {
        // Handle rules like @font-face, which can have multiple styles in an array
        for (var index = 0; index < style.length; index++) {
          style[index] = convertCase(style[index]);
        }
        return style;
      }
      return convertCase(style);
    }
    function onChangeValue(value, prop, rule) {
      if (prop.indexOf('--') === 0) {
        return value;
      }
      var hyphenatedProp = hyphenateStyleName(prop); // There was no camel case in place

      if (prop === hyphenatedProp) return value;
      rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

      return null;
    }
    return {
      onProcessStyle: onProcessStyle,
      onChangeValue: onChangeValue
    };
  }

  var px = hasCSSTOMSupport && CSS ? CSS.px : 'px';
  var ms = hasCSSTOMSupport && CSS ? CSS.ms : 'ms';
  var percent = hasCSSTOMSupport && CSS ? CSS.percent : '%';
  /**
   * Generated jss-plugin-default-unit CSS property units
   */

  var defaultUnits = {
    // Animation properties
    'animation-delay': ms,
    'animation-duration': ms,
    // Background properties
    'background-position': px,
    'background-position-x': px,
    'background-position-y': px,
    'background-size': px,
    // Border Properties
    border: px,
    'border-bottom': px,
    'border-bottom-left-radius': px,
    'border-bottom-right-radius': px,
    'border-bottom-width': px,
    'border-left': px,
    'border-left-width': px,
    'border-radius': px,
    'border-right': px,
    'border-right-width': px,
    'border-top': px,
    'border-top-left-radius': px,
    'border-top-right-radius': px,
    'border-top-width': px,
    'border-width': px,
    'border-block': px,
    'border-block-end': px,
    'border-block-end-width': px,
    'border-block-start': px,
    'border-block-start-width': px,
    'border-block-width': px,
    'border-inline': px,
    'border-inline-end': px,
    'border-inline-end-width': px,
    'border-inline-start': px,
    'border-inline-start-width': px,
    'border-inline-width': px,
    'border-start-start-radius': px,
    'border-start-end-radius': px,
    'border-end-start-radius': px,
    'border-end-end-radius': px,
    // Margin properties
    margin: px,
    'margin-bottom': px,
    'margin-left': px,
    'margin-right': px,
    'margin-top': px,
    'margin-block': px,
    'margin-block-end': px,
    'margin-block-start': px,
    'margin-inline': px,
    'margin-inline-end': px,
    'margin-inline-start': px,
    // Padding properties
    padding: px,
    'padding-bottom': px,
    'padding-left': px,
    'padding-right': px,
    'padding-top': px,
    'padding-block': px,
    'padding-block-end': px,
    'padding-block-start': px,
    'padding-inline': px,
    'padding-inline-end': px,
    'padding-inline-start': px,
    // Mask properties
    'mask-position-x': px,
    'mask-position-y': px,
    'mask-size': px,
    // Width and height properties
    height: px,
    width: px,
    'min-height': px,
    'max-height': px,
    'min-width': px,
    'max-width': px,
    // Position properties
    bottom: px,
    left: px,
    top: px,
    right: px,
    inset: px,
    'inset-block': px,
    'inset-block-end': px,
    'inset-block-start': px,
    'inset-inline': px,
    'inset-inline-end': px,
    'inset-inline-start': px,
    // Shadow properties
    'box-shadow': px,
    'text-shadow': px,
    // Column properties
    'column-gap': px,
    'column-rule': px,
    'column-rule-width': px,
    'column-width': px,
    // Font and text properties
    'font-size': px,
    'font-size-delta': px,
    'letter-spacing': px,
    'text-decoration-thickness': px,
    'text-indent': px,
    'text-stroke': px,
    'text-stroke-width': px,
    'word-spacing': px,
    // Motion properties
    motion: px,
    'motion-offset': px,
    // Outline properties
    outline: px,
    'outline-offset': px,
    'outline-width': px,
    // Perspective properties
    perspective: px,
    'perspective-origin-x': percent,
    'perspective-origin-y': percent,
    // Transform properties
    'transform-origin': percent,
    'transform-origin-x': percent,
    'transform-origin-y': percent,
    'transform-origin-z': percent,
    // Transition properties
    'transition-delay': ms,
    'transition-duration': ms,
    // Alignment properties
    'vertical-align': px,
    'flex-basis': px,
    // Some random properties
    'shape-margin': px,
    size: px,
    gap: px,
    // Grid properties
    grid: px,
    'grid-gap': px,
    'row-gap': px,
    'grid-row-gap': px,
    'grid-column-gap': px,
    'grid-template-rows': px,
    'grid-template-columns': px,
    'grid-auto-rows': px,
    'grid-auto-columns': px,
    // Not existing properties.
    // Used to avoid issues with jss-plugin-expand integration.
    'box-shadow-x': px,
    'box-shadow-y': px,
    'box-shadow-blur': px,
    'box-shadow-spread': px,
    'font-line-height': px,
    'text-shadow-x': px,
    'text-shadow-y': px,
    'text-shadow-blur': px
  };

  /**
   * Clones the object and adds a camel cased property version.
   */

  function addCamelCasedVersion(obj) {
    var regExp = /(-[a-z])/g;
    var replace = function replace(str) {
      return str[1].toUpperCase();
    };
    var newObj = {};
    for (var key in obj) {
      newObj[key] = obj[key];
      newObj[key.replace(regExp, replace)] = obj[key];
    }
    return newObj;
  }
  var units = addCamelCasedVersion(defaultUnits);
  /**
   * Recursive deep style passing function
   */

  function iterate(prop, value, options) {
    if (value == null) return value;
    if (Array.isArray(value)) {
      for (var i = 0; i < value.length; i++) {
        value[i] = iterate(prop, value[i], options);
      }
    } else if (typeof value === 'object') {
      if (prop === 'fallbacks') {
        for (var innerProp in value) {
          value[innerProp] = iterate(innerProp, value[innerProp], options);
        }
      } else {
        for (var _innerProp in value) {
          value[_innerProp] = iterate(prop + "-" + _innerProp, value[_innerProp], options);
        }
      } // eslint-disable-next-line no-restricted-globals
    } else if (typeof value === 'number' && isNaN(value) === false) {
      var unit = options[prop] || units[prop]; // Add the unit if available, except for the special case of 0px.

      if (unit && !(value === 0 && unit === px)) {
        return typeof unit === 'function' ? unit(value).toString() : "" + value + unit;
      }
      return value.toString();
    }
    return value;
  }
  /**
   * Add unit to numeric values.
   */

  function defaultUnit(options) {
    if (options === void 0) {
      options = {};
    }
    var camelCasedOptions = addCamelCasedVersion(options);
    function onProcessStyle(style, rule) {
      if (rule.type !== 'style') return style;
      for (var prop in style) {
        style[prop] = iterate(prop, style[prop], camelCasedOptions);
      }
      return style;
    }
    function onChangeValue(value, prop) {
      return iterate(prop, value, camelCasedOptions);
    }
    return {
      onProcessStyle: onProcessStyle,
      onChangeValue: onChangeValue
    };
  }

  // Export javascript style and css style vendor prefixes.
  var js = '';
  var css = '';
  var vendor = '';
  var browser = '';
  var isTouch = isBrowser && 'ontouchstart' in document.documentElement; // We should not do anything if required serverside.

  if (isBrowser) {
    // Order matters. We need to check Webkit the last one because
    // other vendors use to add Webkit prefixes to some properties
    var jsCssMap = {
      Moz: '-moz-',
      ms: '-ms-',
      O: '-o-',
      Webkit: '-webkit-'
    };
    var _document$createEleme = document.createElement('p'),
      style = _document$createEleme.style;
    var testProp = 'Transform';
    for (var key in jsCssMap) {
      if (key + testProp in style) {
        js = key;
        css = jsCssMap[key];
        break;
      }
    } // Correctly detect the Edge browser.

    if (js === 'Webkit' && 'msHyphens' in style) {
      js = 'ms';
      css = jsCssMap.ms;
      browser = 'edge';
    } // Correctly detect the Safari browser.

    if (js === 'Webkit' && '-apple-trailing-word' in style) {
      vendor = 'apple';
    }
  }
  /**
   * Vendor prefix string for the current browser.
   *
   * @type {{js: String, css: String, vendor: String, browser: String}}
   * @api public
   */

  var prefix = {
    js: js,
    css: css,
    vendor: vendor,
    browser: browser,
    isTouch: isTouch
  };

  /**
   * Test if a keyframe at-rule should be prefixed or not
   *
   * @param {String} vendor prefix string for the current browser.
   * @return {String}
   * @api public
   */

  function supportedKeyframes(key) {
    // Keyframes is already prefixed. e.g. key = '@-webkit-keyframes a'
    if (key[1] === '-') return key; // No need to prefix IE/Edge. Older browsers will ignore unsupported rules.
    // https://caniuse.com/#search=keyframes

    if (prefix.js === 'ms') return key;
    return "@" + prefix.css + "keyframes" + key.substr(10);
  }

  // https://caniuse.com/#search=appearance

  var appearence = {
    noPrefill: ['appearance'],
    supportedProperty: function supportedProperty(prop) {
      if (prop !== 'appearance') return false;
      if (prefix.js === 'ms') return "-webkit-" + prop;
      return prefix.css + prop;
    }
  };

  // https://caniuse.com/#search=color-adjust

  var colorAdjust = {
    noPrefill: ['color-adjust'],
    supportedProperty: function supportedProperty(prop) {
      if (prop !== 'color-adjust') return false;
      if (prefix.js === 'Webkit') return prefix.css + "print-" + prop;
      return prop;
    }
  };
  var regExp = /[-\s]+(.)?/g;
  /**
   * Replaces the letter with the capital letter
   *
   * @param {String} match
   * @param {String} c
   * @return {String}
   * @api private
   */

  function toUpper(match, c) {
    return c ? c.toUpperCase() : '';
  }
  /**
   * Convert dash separated strings to camel-cased.
   *
   * @param {String} str
   * @return {String}
   * @api private
   */

  function camelize(str) {
    return str.replace(regExp, toUpper);
  }

  /**
   * Convert dash separated strings to pascal cased.
   *
   * @param {String} str
   * @return {String}
   * @api private
   */

  function pascalize(str) {
    return camelize("-" + str);
  }

  // but we can use a longhand property instead.
  // https://caniuse.com/#search=mask

  var mask = {
    noPrefill: ['mask'],
    supportedProperty: function supportedProperty(prop, style) {
      if (!/^mask/.test(prop)) return false;
      if (prefix.js === 'Webkit') {
        var longhand = 'mask-image';
        if (camelize(longhand) in style) {
          return prop;
        }
        if (prefix.js + pascalize(longhand) in style) {
          return prefix.css + prop;
        }
      }
      return prop;
    }
  };

  // https://caniuse.com/#search=text-orientation

  var textOrientation = {
    noPrefill: ['text-orientation'],
    supportedProperty: function supportedProperty(prop) {
      if (prop !== 'text-orientation') return false;
      if (prefix.vendor === 'apple' && !prefix.isTouch) {
        return prefix.css + prop;
      }
      return prop;
    }
  };

  // https://caniuse.com/#search=transform

  var transform = {
    noPrefill: ['transform'],
    supportedProperty: function supportedProperty(prop, style, options) {
      if (prop !== 'transform') return false;
      if (options.transform) {
        return prop;
      }
      return prefix.css + prop;
    }
  };

  // https://caniuse.com/#search=transition

  var transition = {
    noPrefill: ['transition'],
    supportedProperty: function supportedProperty(prop, style, options) {
      if (prop !== 'transition') return false;
      if (options.transition) {
        return prop;
      }
      return prefix.css + prop;
    }
  };

  // https://caniuse.com/#search=writing-mode

  var writingMode = {
    noPrefill: ['writing-mode'],
    supportedProperty: function supportedProperty(prop) {
      if (prop !== 'writing-mode') return false;
      if (prefix.js === 'Webkit' || prefix.js === 'ms' && prefix.browser !== 'edge') {
        return prefix.css + prop;
      }
      return prop;
    }
  };

  // https://caniuse.com/#search=user-select

  var userSelect = {
    noPrefill: ['user-select'],
    supportedProperty: function supportedProperty(prop) {
      if (prop !== 'user-select') return false;
      if (prefix.js === 'Moz' || prefix.js === 'ms' || prefix.vendor === 'apple') {
        return prefix.css + prop;
      }
      return prop;
    }
  };

  // https://caniuse.com/#search=multicolumn
  // https://github.com/postcss/autoprefixer/issues/491
  // https://github.com/postcss/autoprefixer/issues/177

  var breakPropsOld = {
    supportedProperty: function supportedProperty(prop, style) {
      if (!/^break-/.test(prop)) return false;
      if (prefix.js === 'Webkit') {
        var jsProp = "WebkitColumn" + pascalize(prop);
        return jsProp in style ? prefix.css + "column-" + prop : false;
      }
      if (prefix.js === 'Moz') {
        var _jsProp = "page" + pascalize(prop);
        return _jsProp in style ? "page-" + prop : false;
      }
      return false;
    }
  };

  // See https://github.com/postcss/autoprefixer/issues/324.

  var inlineLogicalOld = {
    supportedProperty: function supportedProperty(prop, style) {
      if (!/^(border|margin|padding)-inline/.test(prop)) return false;
      if (prefix.js === 'Moz') return prop;
      var newProp = prop.replace('-inline', '');
      return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
    }
  };

  // Camelization is required because we can't test using.
  // CSS syntax for e.g. in FF.

  var unprefixed = {
    supportedProperty: function supportedProperty(prop, style) {
      return camelize(prop) in style ? prop : false;
    }
  };
  var prefixed = {
    supportedProperty: function supportedProperty(prop, style) {
      var pascalized = pascalize(prop); // Return custom CSS variable without prefixing.

      if (prop[0] === '-') return prop; // Return already prefixed value without prefixing.

      if (prop[0] === '-' && prop[1] === '-') return prop;
      if (prefix.js + pascalized in style) return prefix.css + prop; // Try webkit fallback.

      if (prefix.js !== 'Webkit' && "Webkit" + pascalized in style) return "-webkit-" + prop;
      return false;
    }
  };

  // https://caniuse.com/#search=scroll-snap

  var scrollSnap = {
    supportedProperty: function supportedProperty(prop) {
      if (prop.substring(0, 11) !== 'scroll-snap') return false;
      if (prefix.js === 'ms') {
        return "" + prefix.css + prop;
      }
      return prop;
    }
  };

  // https://caniuse.com/#search=overscroll-behavior

  var overscrollBehavior = {
    supportedProperty: function supportedProperty(prop) {
      if (prop !== 'overscroll-behavior') return false;
      if (prefix.js === 'ms') {
        return prefix.css + "scroll-chaining";
      }
      return prop;
    }
  };
  var propMap = {
    'flex-grow': 'flex-positive',
    'flex-shrink': 'flex-negative',
    'flex-basis': 'flex-preferred-size',
    'justify-content': 'flex-pack',
    order: 'flex-order',
    'align-items': 'flex-align',
    'align-content': 'flex-line-pack' // 'align-self' is handled by 'align-self' plugin.
  }; // Support old flex spec from 2012.

  var flex2012 = {
    supportedProperty: function supportedProperty(prop, style) {
      var newProp = propMap[prop];
      if (!newProp) return false;
      return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
    }
  };
  var propMap$1 = {
    flex: 'box-flex',
    'flex-grow': 'box-flex',
    'flex-direction': ['box-orient', 'box-direction'],
    order: 'box-ordinal-group',
    'align-items': 'box-align',
    'flex-flow': ['box-orient', 'box-direction'],
    'justify-content': 'box-pack'
  };
  var propKeys = Object.keys(propMap$1);
  var prefixCss = function prefixCss(p) {
    return prefix.css + p;
  }; // Support old flex spec from 2009.

  var flex2009 = {
    supportedProperty: function supportedProperty(prop, style, _ref) {
      var multiple = _ref.multiple;
      if (propKeys.indexOf(prop) > -1) {
        var newProp = propMap$1[prop];
        if (!Array.isArray(newProp)) {
          return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
        }
        if (!multiple) return false;
        for (var i = 0; i < newProp.length; i++) {
          if (!(prefix.js + pascalize(newProp[0]) in style)) {
            return false;
          }
        }
        return newProp.map(prefixCss);
      }
      return false;
    }
  };

  // plugins = [
  //   ...plugins,
  //    breakPropsOld,
  //    inlineLogicalOld,
  //    unprefixed,
  //    prefixed,
  //    scrollSnap,
  //    flex2012,
  //    flex2009
  // ]
  // Plugins without 'noPrefill' value, going last.
  // 'flex-*' plugins should be at the bottom.
  // 'flex2009' going after 'flex2012'.
  // 'prefixed' going after 'unprefixed'

  var plugins = [appearence, colorAdjust, mask, textOrientation, transform, transition, writingMode, userSelect, breakPropsOld, inlineLogicalOld, unprefixed, prefixed, scrollSnap, overscrollBehavior, flex2012, flex2009];
  var propertyDetectors = plugins.filter(function (p) {
    return p.supportedProperty;
  }).map(function (p) {
    return p.supportedProperty;
  });
  var noPrefill = plugins.filter(function (p) {
    return p.noPrefill;
  }).reduce(function (a, p) {
    a.push.apply(a, _toConsumableArray(p.noPrefill));
    return a;
  }, []);
  var el;
  var cache = {};
  if (isBrowser) {
    el = document.createElement('p'); // We test every property on vendor prefix requirement.
    // Once tested, result is cached. It gives us up to 70% perf boost.
    // http://jsperf.com/element-style-object-access-vs-plain-object
    //
    // Prefill cache with known css properties to reduce amount of
    // properties we need to feature test at runtime.
    // http://davidwalsh.name/vendor-prefix

    var computed = window.getComputedStyle(document.documentElement, '');
    for (var key$1 in computed) {
      // eslint-disable-next-line no-restricted-globals
      if (!isNaN(key$1)) cache[computed[key$1]] = computed[key$1];
    } // Properties that cannot be correctly detected using the
    // cache prefill method.

    noPrefill.forEach(function (x) {
      return delete cache[x];
    });
  }
  /**
   * Test if a property is supported, returns supported property with vendor
   * prefix if required. Returns `false` if not supported.
   *
   * @param {String} prop dash separated
   * @param {Object} [options]
   * @return {String|Boolean}
   * @api public
   */

  function supportedProperty(prop, options) {
    if (options === void 0) {
      options = {};
    }

    // For server-side rendering.
    if (!el) return prop; // Remove cache for benchmark tests or return property from the cache.

    if (cache[prop] != null) {
      return cache[prop];
    } // Check if 'transition' or 'transform' natively supported in browser.

    if (prop === 'transition' || prop === 'transform') {
      options[prop] = prop in el.style;
    } // Find a plugin for current prefix property.

    for (var i = 0; i < propertyDetectors.length; i++) {
      cache[prop] = propertyDetectors[i](prop, el.style, options); // Break loop, if value found.

      if (cache[prop]) break;
    } // Reset styles for current property.
    // Firefox can even throw an error for invalid properties, e.g., "0".

    try {
      el.style[prop] = '';
    } catch (err) {
      return false;
    }
    return cache[prop];
  }
  var cache$1 = {};
  var transitionProperties = {
    transition: 1,
    'transition-property': 1,
    '-webkit-transition': 1,
    '-webkit-transition-property': 1
  };
  var transPropsRegExp = /(^\s*[\w-]+)|, (\s*[\w-]+)(?![^()]*\))/g;
  var el$1;
  /**
   * Returns prefixed value transition/transform if needed.
   *
   * @param {String} match
   * @param {String} p1
   * @param {String} p2
   * @return {String}
   * @api private
   */

  function prefixTransitionCallback(match, p1, p2) {
    if (p1 === 'var') return 'var';
    if (p1 === 'all') return 'all';
    if (p2 === 'all') return ', all';
    var prefixedValue = p1 ? supportedProperty(p1) : ", " + supportedProperty(p2);
    if (!prefixedValue) return p1 || p2;
    return prefixedValue;
  }
  if (isBrowser) el$1 = document.createElement('p');
  /**
   * Returns prefixed value if needed. Returns `false` if value is not supported.
   *
   * @param {String} property
   * @param {String} value
   * @return {String|Boolean}
   * @api public
   */

  function supportedValue(property, value) {
    // For server-side rendering.
    var prefixedValue = value;
    if (!el$1 || property === 'content') return value; // It is a string or a number as a string like '1'.
    // We want only prefixable values here.
    // eslint-disable-next-line no-restricted-globals

    if (typeof prefixedValue !== 'string' || !isNaN(parseInt(prefixedValue, 10))) {
      return prefixedValue;
    } // Create cache key for current value.

    var cacheKey = property + prefixedValue; // Remove cache for benchmark tests or return value from cache.

    if (cache$1[cacheKey] != null) {
      return cache$1[cacheKey];
    } // IE can even throw an error in some cases, for e.g. style.content = 'bar'.

    try {
      // Test value as it is.
      el$1.style[property] = prefixedValue;
    } catch (err) {
      // Return false if value not supported.
      cache$1[cacheKey] = false;
      return false;
    } // If 'transition' or 'transition-property' property.

    if (transitionProperties[property]) {
      prefixedValue = prefixedValue.replace(transPropsRegExp, prefixTransitionCallback);
    } else if (el$1.style[property] === '') {
      // Value with a vendor prefix.
      prefixedValue = prefix.css + prefixedValue; // Hardcode test to convert "flex" to "-ms-flexbox" for IE10.

      if (prefixedValue === '-ms-flex') el$1.style[property] = '-ms-flexbox'; // Test prefixed value.

      el$1.style[property] = prefixedValue; // Return false if value not supported.

      if (el$1.style[property] === '') {
        cache$1[cacheKey] = false;
        return false;
      }
    } // Reset styles for current property.

    el$1.style[property] = ''; // Write current value to cache.

    cache$1[cacheKey] = prefixedValue;
    return cache$1[cacheKey];
  }

  /**
   * Add vendor prefix to a property name when needed.
   */

  function jssVendorPrefixer() {
    function onProcessRule(rule) {
      if (rule.type === 'keyframes') {
        var atRule = rule;
        atRule.at = supportedKeyframes(atRule.at);
      }
    }
    function prefixStyle(style) {
      for (var prop in style) {
        var value = style[prop];
        if (prop === 'fallbacks' && Array.isArray(value)) {
          style[prop] = value.map(prefixStyle);
          continue;
        }
        var changeProp = false;
        var supportedProp = supportedProperty(prop);
        if (supportedProp && supportedProp !== prop) changeProp = true;
        var changeValue = false;
        var supportedValue$1 = supportedValue(supportedProp, toCssValue(value));
        if (supportedValue$1 && supportedValue$1 !== value) changeValue = true;
        if (changeProp || changeValue) {
          if (changeProp) delete style[prop];
          style[supportedProp || prop] = supportedValue$1 || value;
        }
      }
      return style;
    }
    function onProcessStyle(style, rule) {
      if (rule.type !== 'style') return style;
      return prefixStyle(style);
    }
    function onChangeValue(value, prop) {
      return supportedValue(prop, toCssValue(value)) || value;
    }
    return {
      onProcessRule: onProcessRule,
      onProcessStyle: onProcessStyle,
      onChangeValue: onChangeValue
    };
  }

  /**
   * Sort props by length.
   */
  function jssPropsSort() {
    var sort = function sort(prop0, prop1) {
      if (prop0.length === prop1.length) {
        return prop0 > prop1 ? 1 : -1;
      }
      return prop0.length - prop1.length;
    };
    return {
      onProcessStyle: function onProcessStyle(style, rule) {
        if (rule.type !== 'style') return style;
        var newStyle = {};
        var props = Object.keys(style).sort(sort);
        for (var i = 0; i < props.length; i++) {
          newStyle[props[i]] = style[props[i]];
        }
        return newStyle;
      }
    };
  }

  function jssPreset() {
    return {
      plugins: [functions(), jssGlobal(), jssNested(), camelCase(), defaultUnit(),
      // Disable the vendor prefixer server-side, it does nothing.
      // This way, we can get a performance boost.
      // In the documentation, we are using `autoprefixer` to solve this problem.
      typeof window === 'undefined' ? null : jssVendorPrefixer(), jssPropsSort()]
    };
  }

  function mergeClasses() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var baseClasses = options.baseClasses,
      newClasses = options.newClasses,
      Component = options.Component;
    if (!newClasses) {
      return baseClasses;
    }
    var nextClasses = _extends({}, baseClasses);
    {
      if (typeof newClasses === 'string') {
        console.error(["Material-UI: The value `".concat(newClasses, "` ") + "provided to the classes prop of ".concat(getDisplayName(Component), " is incorrect."), 'You might want to use the className prop instead.'].join('\n'));
        return baseClasses;
      }
    }
    Object.keys(newClasses).forEach(function (key) {
      {
        if (!baseClasses[key] && newClasses[key]) {
          console.error(["Material-UI: The key `".concat(key, "` ") + "provided to the classes prop is not implemented in ".concat(getDisplayName(Component), "."), "You can only override one of the following: ".concat(Object.keys(baseClasses).join(','), ".")].join('\n'));
        }
        if (newClasses[key] && typeof newClasses[key] !== 'string') {
          console.error(["Material-UI: The key `".concat(key, "` ") + "provided to the classes prop is not valid for ".concat(getDisplayName(Component), "."), "You need to provide a non empty string instead of: ".concat(newClasses[key], ".")].join('\n'));
        }
      }
      if (newClasses[key]) {
        nextClasses[key] = "".concat(baseClasses[key], " ").concat(newClasses[key]);
      }
    });
    return nextClasses;
  }

  // Used https://github.com/thinkloop/multi-key-cache as inspiration
  var multiKeyStore = {
    set: function set(cache, key1, key2, value) {
      var subCache = cache.get(key1);
      if (!subCache) {
        subCache = new Map();
        cache.set(key1, subCache);
      }
      subCache.set(key2, value);
    },
    get: function get(cache, key1, key2) {
      var subCache = cache.get(key1);
      return subCache ? subCache.get(key2) : undefined;
    },
    delete: function _delete(cache, key1, key2) {
      var subCache = cache.get(key1);
      subCache.delete(key2);
    }
  };
  var multiKeyStore$1 = multiKeyStore;

  var ThemeContext = React.createContext(null);
  {
    ThemeContext.displayName = 'ThemeContext';
  }
  var ThemeContext$1 = ThemeContext;

  function useTheme$1() {
    var theme = React.useContext(ThemeContext$1);
    {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React.useDebugValue(theme);
    }
    return theme;
  }

  var jss = createJss(jssPreset()); // Use a singleton or the provided one by the context.
  //
  // The counter-based approach doesn't tolerate any mistake.
  // It's much safer to use the same counter everywhere.

  var generateClassName = createGenerateClassName(); // Exported for test purposes

  var sheetsManager = new Map();
  var defaultOptions = {
    disableGeneration: false,
    generateClassName: generateClassName,
    jss: jss,
    sheetsCache: null,
    sheetsManager: sheetsManager,
    sheetsRegistry: null
  };
  var StylesContext = React.createContext(defaultOptions);
  {
    StylesContext.displayName = 'StylesContext';
  }
  var injectFirstNode;
  function StylesProvider(props) {
    var children = props.children,
      _props$injectFirst = props.injectFirst,
      injectFirst = _props$injectFirst === void 0 ? false : _props$injectFirst,
      _props$disableGenerat = props.disableGeneration,
      disableGeneration = _props$disableGenerat === void 0 ? false : _props$disableGenerat,
      localOptions = _objectWithoutProperties(props, ["children", "injectFirst", "disableGeneration"]);
    var outerOptions = React.useContext(StylesContext);
    var context = _extends({}, outerOptions, {
      disableGeneration: disableGeneration
    }, localOptions);
    {
      if (typeof window === 'undefined' && !context.sheetsManager) {
        console.error('Material-UI: You need to use the ServerStyleSheets API when rendering on the server.');
      }
    }
    {
      if (context.jss.options.insertionPoint && injectFirst) {
        console.error('Material-UI: You cannot use a custom insertionPoint and <StylesContext injectFirst> at the same time.');
      }
    }
    {
      if (injectFirst && localOptions.jss) {
        console.error('Material-UI: You cannot use the jss and injectFirst props at the same time.');
      }
    }
    if (!context.jss.options.insertionPoint && injectFirst && typeof window !== 'undefined') {
      if (!injectFirstNode) {
        var head = document.head;
        injectFirstNode = document.createComment('mui-inject-first');
        head.insertBefore(injectFirstNode, head.firstChild);
      }
      context.jss = createJss({
        plugins: jssPreset().plugins,
        insertionPoint: injectFirstNode
      });
    }
    return /*#__PURE__*/React.createElement(StylesContext.Provider, {
      value: context
    }, children);
  }
  StylesProvider.propTypes = {
    /**
     * Your component tree.
     */
    children: PropTypes.node.isRequired,
    /**
     * You can disable the generation of the styles with this option.
     * It can be useful when traversing the React tree outside of the HTML
     * rendering step on the server.
     * Let's say you are using react-apollo to extract all
     * the queries made by the interface server-side - you can significantly speed up the traversal with this prop.
     */
    disableGeneration: PropTypes.bool,
    /**
     * JSS's class name generator.
     */
    generateClassName: PropTypes.func,
    /**
     * By default, the styles are injected last in the <head> element of the page.
     * As a result, they gain more specificity than any other style sheet.
     * If you want to override Material-UI's styles, set this prop.
     */
    injectFirst: PropTypes.bool,
    /**
     * JSS's instance.
     */
    jss: PropTypes.object,
    /**
     * @ignore
     */
    serverGenerateClassName: PropTypes.func,
    /**
     * @ignore
     *
     * Beta feature.
     *
     * Cache for the sheets.
     */
    sheetsCache: PropTypes.object,
    /**
     * @ignore
     *
     * The sheetsManager is used to deduplicate style sheet injection in the page.
     * It's deduplicating using the (theme, styles) couple.
     * On the server, you should provide a new instance for each request.
     */
    sheetsManager: PropTypes.object,
    /**
     * @ignore
     *
     * Collect the sheets.
     */
    sheetsRegistry: PropTypes.object
  } ;
  {
    StylesProvider.propTypes = exactProp(StylesProvider.propTypes) ;
  }

  /* eslint-disable import/prefer-default-export */
  // Global index counter to preserve source order.
  // We create the style sheet during the creation of the component,
  // children are handled after the parents, so the order of style elements would be parent->child.
  // It is a problem though when a parent passes a className
  // which needs to override any child's styles.
  // StyleSheet of the child has a higher specificity, because of the source order.
  // So our solution is to render sheets them in the reverse order child->sheet, so
  // that parent has a higher specificity.
  var indexCounter = -1e9;
  function increment() {
    indexCounter += 1;
    {
      if (indexCounter >= 0) {
        console.warn(['Material-UI: You might have a memory leak.', 'The indexCounter is not supposed to grow that much.'].join('\n'));
      }
    }
    return indexCounter;
  }

  // We use the same empty object to ref count the styles that don't need a theme object.
  var noopTheme = {};
  var noopTheme$1 = noopTheme;

  function getStylesCreator(stylesOrCreator) {
    var themingEnabled = typeof stylesOrCreator === 'function';
    {
      if (_typeof$1(stylesOrCreator) !== 'object' && !themingEnabled) {
        console.error(['Material-UI: The `styles` argument provided is invalid.', 'You need to provide a function generating the styles or a styles object.'].join('\n'));
      }
    }
    return {
      create: function create(theme, name) {
        var styles;
        try {
          styles = themingEnabled ? stylesOrCreator(theme) : stylesOrCreator;
        } catch (err) {
          {
            if (themingEnabled === true && theme === noopTheme$1) {
              // TODO: prepend error message/name instead
              console.error(['Material-UI: The `styles` argument provided is invalid.', 'You are providing a function without a theme in the context.', 'One of the parent elements needs to use a ThemeProvider.'].join('\n'));
            }
          }
          throw err;
        }
        if (!name || !theme.overrides || !theme.overrides[name]) {
          return styles;
        }
        var overrides = theme.overrides[name];
        var stylesWithOverrides = _extends({}, styles);
        Object.keys(overrides).forEach(function (key) {
          {
            if (!stylesWithOverrides[key]) {
              console.warn(['Material-UI: You are trying to override a style that does not exist.', "Fix the `".concat(key, "` key of `theme.overrides.").concat(name, "`.")].join('\n'));
            }
          }
          stylesWithOverrides[key] = deepmerge(stylesWithOverrides[key], overrides[key]);
        });
        return stylesWithOverrides;
      },
      options: {}
    };
  }

  function getClasses(_ref, classes, Component) {
    var state = _ref.state,
      stylesOptions = _ref.stylesOptions;
    if (stylesOptions.disableGeneration) {
      return classes || {};
    }
    if (!state.cacheClasses) {
      state.cacheClasses = {
        // Cache for the finalized classes value.
        value: null,
        // Cache for the last used classes prop pointer.
        lastProp: null,
        // Cache for the last used rendered classes pointer.
        lastJSS: {}
      };
    } // Tracks if either the rendered classes or classes prop has changed,
    // requiring the generation of a new finalized classes object.

    var generate = false;
    if (state.classes !== state.cacheClasses.lastJSS) {
      state.cacheClasses.lastJSS = state.classes;
      generate = true;
    }
    if (classes !== state.cacheClasses.lastProp) {
      state.cacheClasses.lastProp = classes;
      generate = true;
    }
    if (generate) {
      state.cacheClasses.value = mergeClasses({
        baseClasses: state.cacheClasses.lastJSS,
        newClasses: classes,
        Component: Component
      });
    }
    return state.cacheClasses.value;
  }
  function attach(_ref2, props) {
    var state = _ref2.state,
      theme = _ref2.theme,
      stylesOptions = _ref2.stylesOptions,
      stylesCreator = _ref2.stylesCreator,
      name = _ref2.name;
    if (stylesOptions.disableGeneration) {
      return;
    }
    var sheetManager = multiKeyStore$1.get(stylesOptions.sheetsManager, stylesCreator, theme);
    if (!sheetManager) {
      sheetManager = {
        refs: 0,
        staticSheet: null,
        dynamicStyles: null
      };
      multiKeyStore$1.set(stylesOptions.sheetsManager, stylesCreator, theme, sheetManager);
    }
    var options = _extends({}, stylesCreator.options, stylesOptions, {
      theme: theme,
      flip: typeof stylesOptions.flip === 'boolean' ? stylesOptions.flip : theme.direction === 'rtl'
    });
    options.generateId = options.serverGenerateClassName || options.generateClassName;
    var sheetsRegistry = stylesOptions.sheetsRegistry;
    if (sheetManager.refs === 0) {
      var staticSheet;
      if (stylesOptions.sheetsCache) {
        staticSheet = multiKeyStore$1.get(stylesOptions.sheetsCache, stylesCreator, theme);
      }
      var styles = stylesCreator.create(theme, name);
      if (!staticSheet) {
        staticSheet = stylesOptions.jss.createStyleSheet(styles, _extends({
          link: false
        }, options));
        staticSheet.attach();
        if (stylesOptions.sheetsCache) {
          multiKeyStore$1.set(stylesOptions.sheetsCache, stylesCreator, theme, staticSheet);
        }
      }
      if (sheetsRegistry) {
        sheetsRegistry.add(staticSheet);
      }
      sheetManager.staticSheet = staticSheet;
      sheetManager.dynamicStyles = getDynamicStyles(styles);
    }
    if (sheetManager.dynamicStyles) {
      var dynamicSheet = stylesOptions.jss.createStyleSheet(sheetManager.dynamicStyles, _extends({
        link: true
      }, options));
      dynamicSheet.update(props);
      dynamicSheet.attach();
      state.dynamicSheet = dynamicSheet;
      state.classes = mergeClasses({
        baseClasses: sheetManager.staticSheet.classes,
        newClasses: dynamicSheet.classes
      });
      if (sheetsRegistry) {
        sheetsRegistry.add(dynamicSheet);
      }
    } else {
      state.classes = sheetManager.staticSheet.classes;
    }
    sheetManager.refs += 1;
  }
  function update(_ref3, props) {
    var state = _ref3.state;
    if (state.dynamicSheet) {
      state.dynamicSheet.update(props);
    }
  }
  function detach(_ref4) {
    var state = _ref4.state,
      theme = _ref4.theme,
      stylesOptions = _ref4.stylesOptions,
      stylesCreator = _ref4.stylesCreator;
    if (stylesOptions.disableGeneration) {
      return;
    }
    var sheetManager = multiKeyStore$1.get(stylesOptions.sheetsManager, stylesCreator, theme);
    sheetManager.refs -= 1;
    var sheetsRegistry = stylesOptions.sheetsRegistry;
    if (sheetManager.refs === 0) {
      multiKeyStore$1.delete(stylesOptions.sheetsManager, stylesCreator, theme);
      stylesOptions.jss.removeStyleSheet(sheetManager.staticSheet);
      if (sheetsRegistry) {
        sheetsRegistry.remove(sheetManager.staticSheet);
      }
    }
    if (state.dynamicSheet) {
      stylesOptions.jss.removeStyleSheet(state.dynamicSheet);
      if (sheetsRegistry) {
        sheetsRegistry.remove(state.dynamicSheet);
      }
    }
  }
  function useSynchronousEffect(func, values) {
    var key = React.useRef([]);
    var output; // Store "generation" key. Just returns a new object every time

    var currentKey = React.useMemo(function () {
      return {};
    }, values); // eslint-disable-line react-hooks/exhaustive-deps
    // "the first render", or "memo dropped the value"

    if (key.current !== currentKey) {
      key.current = currentKey;
      output = func();
    }
    React.useEffect(function () {
      return function () {
        if (output) {
          output();
        }
      };
    }, [currentKey] // eslint-disable-line react-hooks/exhaustive-deps
    );
  }

  function makeStyles(stylesOrCreator) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var name = options.name,
      classNamePrefixOption = options.classNamePrefix,
      Component = options.Component,
      _options$defaultTheme = options.defaultTheme,
      defaultTheme = _options$defaultTheme === void 0 ? noopTheme$1 : _options$defaultTheme,
      stylesOptions2 = _objectWithoutProperties(options, ["name", "classNamePrefix", "Component", "defaultTheme"]);
    var stylesCreator = getStylesCreator(stylesOrCreator);
    var classNamePrefix = name || classNamePrefixOption || 'makeStyles';
    stylesCreator.options = {
      index: increment(),
      name: name,
      meta: classNamePrefix,
      classNamePrefix: classNamePrefix
    };
    var useStyles = function useStyles() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var theme = useTheme$1() || defaultTheme;
      var stylesOptions = _extends({}, React.useContext(StylesContext), stylesOptions2);
      var instance = React.useRef();
      var shouldUpdate = React.useRef();
      useSynchronousEffect(function () {
        var current = {
          name: name,
          state: {},
          stylesCreator: stylesCreator,
          stylesOptions: stylesOptions,
          theme: theme
        };
        attach(current, props);
        shouldUpdate.current = false;
        instance.current = current;
        return function () {
          detach(current);
        };
      }, [theme, stylesCreator]);
      React.useEffect(function () {
        if (shouldUpdate.current) {
          update(instance.current, props);
        }
        shouldUpdate.current = true;
      });
      var classes = getClasses(instance.current, props.classes, Component);
      {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        React.useDebugValue(classes);
      }
      return classes;
    };
    return useStyles;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function r$1(e) {
    var t,
      f,
      n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r$1(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r$1(e)) && (n && (n += " "), n += t);
    return n;
  }

  var reactIs = reactIsExports$1;

  /**
   * Copyright 2015, Yahoo! Inc.
   * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
   */
  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    '$$typeof': true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    '$$typeof': true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
  function getStatics(component) {
    // React v16.11 and below
    if (reactIs.isMemo(component)) {
      return MEMO_STATICS;
    } // React v16.12 and above

    return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
  }
  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;
  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
      // don't hoist over string (html) components
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf(sourceComponent);
        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
      }
      var keys = getOwnPropertyNames(sourceComponent);
      if (getOwnPropertySymbols) {
        keys = keys.concat(getOwnPropertySymbols(sourceComponent));
      }
      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
          try {
            // Avoid failures from read-only properties
            defineProperty(targetComponent, key, descriptor);
          } catch (e) {}
        }
      }
    }
    return targetComponent;
  }
  var hoistNonReactStatics_cjs = hoistNonReactStatics;
  var hoistNonReactStatics$1 = /*@__PURE__*/getDefaultExportFromCjs(hoistNonReactStatics_cjs);

  function omit(input, fields) {
    var output = {};
    Object.keys(input).forEach(function (prop) {
      if (fields.indexOf(prop) === -1) {
        output[prop] = input[prop];
      }
    });
    return output;
  } // styled-components's API removes the mapping between components and styles.
  // Using components as a low-level styling construct can be simpler.

  function styled$2(Component) {
    var componentCreator = function componentCreator(style) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var name = options.name,
        stylesOptions = _objectWithoutProperties(options, ["name"]);
      if (Component === undefined) {
        throw new Error(['You are calling styled(Component)(style) with an undefined component.', 'You may have forgotten to import it.'].join('\n'));
      }
      var classNamePrefix = name;
      {
        if (!name) {
          // Provide a better DX outside production.
          var displayName = getDisplayName(Component);
          if (displayName !== undefined) {
            classNamePrefix = displayName;
          }
        }
      }
      var stylesOrCreator = typeof style === 'function' ? function (theme) {
        return {
          root: function root(props) {
            return style(_extends({
              theme: theme
            }, props));
          }
        };
      } : {
        root: style
      };
      var useStyles = makeStyles(stylesOrCreator, _extends({
        Component: Component,
        name: name || Component.displayName,
        classNamePrefix: classNamePrefix
      }, stylesOptions));
      var filterProps;
      var propTypes = {};
      if (style.filterProps) {
        filterProps = style.filterProps;
        delete style.filterProps;
      }
      /* eslint-disable react/forbid-foreign-prop-types */

      if (style.propTypes) {
        propTypes = style.propTypes;
        delete style.propTypes;
      }
      /* eslint-enable react/forbid-foreign-prop-types */

      var StyledComponent = /*#__PURE__*/React.forwardRef(function StyledComponent(props, ref) {
        var children = props.children,
          classNameProp = props.className,
          clone = props.clone,
          ComponentProp = props.component,
          other = _objectWithoutProperties(props, ["children", "className", "clone", "component"]);
        var classes = useStyles(props);
        var className = clsx(classes.root, classNameProp);
        var spread = other;
        if (filterProps) {
          spread = omit(spread, filterProps);
        }
        if (clone) {
          return /*#__PURE__*/React.cloneElement(children, _extends({
            className: clsx(children.props.className, className)
          }, spread));
        }
        if (typeof children === 'function') {
          return children(_extends({
            className: className
          }, spread));
        }
        var FinalComponent = ComponentProp || Component;
        return /*#__PURE__*/React.createElement(FinalComponent, _extends({
          ref: ref,
          className: className
        }, spread), children);
      });
      StyledComponent.propTypes = _extends({
        /**
         * A render function or node.
         */
        children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
        /**
         * @ignore
         */
        className: PropTypes.string,
        /**
         * If `true`, the component will recycle it's children HTML element.
         * It's using `React.cloneElement` internally.
         *
         * This prop will be deprecated and removed in v5
         */
        clone: chainPropTypes(PropTypes.bool, function (props) {
          if (props.clone && props.component) {
            return new Error('You can not use the clone and component prop at the same time.');
          }
          return null;
        }),
        /**
         * The component used for the root node.
         * Either a string to use a HTML element or a component.
         */
        component: PropTypes
        /* @typescript-to-proptypes-ignore */.elementType
      }, propTypes) ;
      {
        StyledComponent.displayName = "Styled(".concat(classNamePrefix, ")");
      }
      hoistNonReactStatics$1(StyledComponent, Component);
      return StyledComponent;
    };
    return componentCreator;
  }

  function mergeOuterLocalTheme(outerTheme, localTheme) {
    if (typeof localTheme === 'function') {
      var mergedTheme = localTheme(outerTheme);
      {
        if (!mergedTheme) {
          console.error(['Material-UI: You should return an object from your theme function, i.e.', '<ThemeProvider theme={() => ({})} />'].join('\n'));
        }
      }
      return mergedTheme;
    }
    return _extends({}, outerTheme, localTheme);
  }
  /**
   * This component takes a `theme` prop.
   * It makes the `theme` available down the React tree thanks to React context.
   * This component should preferably be used at **the root of your component tree**.
   */

  function ThemeProvider(props) {
    var children = props.children,
      localTheme = props.theme;
    var outerTheme = useTheme$1();
    {
      if (outerTheme === null && typeof localTheme === 'function') {
        console.error(['Material-UI: You are providing a theme function prop to the ThemeProvider component:', '<ThemeProvider theme={outerTheme => outerTheme} />', '', 'However, no outer theme is present.', 'Make sure a theme is already injected higher in the React tree ' + 'or provide a theme object.'].join('\n'));
      }
    }
    var theme = React.useMemo(function () {
      var output = outerTheme === null ? localTheme : mergeOuterLocalTheme(outerTheme, localTheme);
      if (output != null) {
        output[nested] = outerTheme !== null;
      }
      return output;
    }, [localTheme, outerTheme]);
    return /*#__PURE__*/React.createElement(ThemeContext$1.Provider, {
      value: theme
    }, children);
  }
  ThemeProvider.propTypes = {
    /**
     * Your component tree.
     */
    children: PropTypes.node.isRequired,
    /**
     * A theme object. You can provide a function to extend the outer theme.
     */
    theme: PropTypes.oneOfType([PropTypes.object, PropTypes.func]).isRequired
  } ;
  {
    ThemeProvider.propTypes = exactProp(ThemeProvider.propTypes) ;
  }

  // It does not modify the component passed to it;
  // instead, it returns a new component, with a `classes` property.

  var withStyles$1 = function withStyles(stylesOrCreator) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function (Component) {
      var defaultTheme = options.defaultTheme,
        _options$withTheme = options.withTheme,
        withTheme = _options$withTheme === void 0 ? false : _options$withTheme,
        name = options.name,
        stylesOptions = _objectWithoutProperties(options, ["defaultTheme", "withTheme", "name"]);
      {
        if (Component === undefined) {
          throw new Error(['You are calling withStyles(styles)(Component) with an undefined component.', 'You may have forgotten to import it.'].join('\n'));
        }
      }
      var classNamePrefix = name;
      {
        if (!name) {
          // Provide a better DX outside production.
          var displayName = getDisplayName(Component);
          if (displayName !== undefined) {
            classNamePrefix = displayName;
          }
        }
      }
      var useStyles = makeStyles(stylesOrCreator, _extends({
        defaultTheme: defaultTheme,
        Component: Component,
        name: name || Component.displayName,
        classNamePrefix: classNamePrefix
      }, stylesOptions));
      var WithStyles = /*#__PURE__*/React.forwardRef(function WithStyles(props, ref) {
        props.classes;
          var innerRef = props.innerRef,
          other = _objectWithoutProperties(props, ["classes", "innerRef"]); // The wrapper receives only user supplied props, which could be a subset of
        // the actual props Component might receive due to merging with defaultProps.
        // So copying it here would give us the same result in the wrapper as well.

        var classes = useStyles(_extends({}, Component.defaultProps, props));
        var theme;
        var more = other;
        if (typeof name === 'string' || withTheme) {
          // name and withTheme are invariant in the outer scope
          // eslint-disable-next-line react-hooks/rules-of-hooks
          theme = useTheme$1() || defaultTheme;
          if (name) {
            more = getThemeProps({
              theme: theme,
              name: name,
              props: other
            });
          } // Provide the theme to the wrapped component.
          // So we don't have to use the `withTheme()` Higher-order Component.

          if (withTheme && !more.theme) {
            more.theme = theme;
          }
        }
        return /*#__PURE__*/React.createElement(Component, _extends({
          ref: innerRef || ref,
          classes: classes
        }, more));
      });
      WithStyles.propTypes = {
        /**
         * Override or extend the styles applied to the component.
         */
        classes: PropTypes.object,
        /**
         * Use that prop to pass a ref to the decorated component.
         * @deprecated
         */
        innerRef: chainPropTypes(PropTypes.oneOfType([PropTypes.func, PropTypes.object]), function (props) {
          if (props.innerRef == null) {
            return null;
          }
          return null; // return new Error(
          //   'Material-UI: The `innerRef` prop is deprecated and will be removed in v5. ' +
          //     'Refs are now automatically forwarded to the inner component.',
          // );
        })
      } ;
      {
        WithStyles.displayName = "WithStyles(".concat(getDisplayName(Component), ")");
      }
      hoistNonReactStatics$1(WithStyles, Component);
      {
        // Exposed for test purposes.
        WithStyles.Naked = Component;
        WithStyles.options = options;
        WithStyles.useStyles = useStyles;
      }
      return WithStyles;
    };
  };
  var withStylesWithoutDefault = withStyles$1;

  var defaultTheme = createTheme();
  var defaultTheme$1 = defaultTheme;

  var styled = function styled(Component) {
    var componentCreator = styled$2(Component);
    return function (style, options) {
      return componentCreator(style, _extends({
        defaultTheme: defaultTheme$1
      }, options));
    };
  };
  var styled$1 = styled;

  function useTheme() {
    var theme = useTheme$1() || defaultTheme$1;
    {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React.useDebugValue(theme);
    }
    return theme;
  }

  function withStyles(stylesOrCreator, options) {
    return withStylesWithoutDefault(stylesOrCreator, _extends({
      defaultTheme: defaultTheme$1
    }, options));
  }

  // It should to be noted that this function isn't equivalent to `text-transform: capitalize`.
  //
  // A strict capitalization should uppercase the first letter of each word a the sentence.
  // We only handle the first word.
  function capitalize(string) {
    if (typeof string !== 'string') {
      throw new Error("Material-UI: capitalize(string) expects a string argument." );
    }
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  /**
   * Safe chained function
   *
   * Will only create a new function if needed,
   * otherwise will pass back existing functions or null.
   *
   * @param {function} functions to chain
   * @returns {function|null}
   */
  function createChainedFunction() {
    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }
    return funcs.reduce(function (acc, func) {
      if (func == null) {
        return acc;
      }
      {
        if (typeof func !== 'function') {
          console.error('Material-UI: Invalid Argument Type, must only provide functions, undefined, or null.');
        }
      }
      return function chainedFunction() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        acc.apply(this, args);
        func.apply(this, args);
      };
    }, function () {});
  }

  // Corresponds to 10 frames at 60 Hz.
  // A few bytes payload overhead when lodash/debounce is ~3 kB and debounce ~300 B.
  function debounce(func) {
    var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 166;
    var timeout;
    function debounced() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // eslint-disable-next-line consistent-this
      var that = this;
      var later = function later() {
        func.apply(that, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    }
    debounced.clear = function () {
      clearTimeout(timeout);
    };
    return debounced;
  }

  function deprecatedPropType(validator, reason) {
    return function (props, propName, componentName, location, propFullName) {
      var componentNameSafe = componentName || '<<anonymous>>';
      var propFullNameSafe = propFullName || propName;
      if (typeof props[propName] !== 'undefined') {
        return new Error("The ".concat(location, " `").concat(propFullNameSafe, "` of ") + "`".concat(componentNameSafe, "` is deprecated. ").concat(reason));
      }
      return null;
    };
  }

  function isMuiElement(element, muiNames) {
    return /*#__PURE__*/reactExports.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;
  }

  function ownerDocument(node) {
    return node && node.ownerDocument || document;
  }

  function ownerWindow(node) {
    var doc = ownerDocument(node);
    return doc.defaultView || window;
  }

  // TODO v5: consider to make it private
  function setRef(ref, value) {
    if (typeof ref === 'function') {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
  }

  var useEnhancedEffect$3 = typeof window !== 'undefined' ? reactExports.useLayoutEffect : reactExports.useEffect;
  /**
   * https://github.com/facebook/react/issues/14099#issuecomment-440013892
   *
   * @param {function} fn
   */

  function useEventCallback(fn) {
    var ref = reactExports.useRef(fn);
    useEnhancedEffect$3(function () {
      ref.current = fn;
    });
    return reactExports.useCallback(function () {
      return (ref.current).apply(void 0, arguments);
    }, []);
  }

  function useForkRef(refA, refB) {
    /**
     * This will create a new function if the ref props change and are defined.
     * This means react will call the old forkRef with `null` and the new forkRef
     * with the ref. Cleanup naturally emerges from this behavior
     */
    return reactExports.useMemo(function () {
      if (refA == null && refB == null) {
        return null;
      }
      return function (refValue) {
        setRef(refA, refValue);
        setRef(refB, refValue);
      };
    }, [refA, refB]);
  }

  var reactDom = {exports: {}};

  var reactDom_development = {};

  var scheduler = {exports: {}};

  var scheduler_development = {};

  /** @license React v0.19.1
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  (function (exports) {

    {
      (function () {

        var enableSchedulerDebugging = false;
        var enableProfiling = true;
        var requestHostCallback;
        var requestHostTimeout;
        var cancelHostTimeout;
        var shouldYieldToHost;
        var requestPaint;
        if (
        // If Scheduler runs in a non-DOM environment, it falls back to a naive
        // implementation using setTimeout.
        typeof window === 'undefined' ||
        // Check if MessageChannel is supported, too.
        typeof MessageChannel !== 'function') {
          // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,
          // fallback to a naive implementation.
          var _callback = null;
          var _timeoutID = null;
          var _flushCallback = function () {
            if (_callback !== null) {
              try {
                var currentTime = exports.unstable_now();
                var hasRemainingTime = true;
                _callback(hasRemainingTime, currentTime);
                _callback = null;
              } catch (e) {
                setTimeout(_flushCallback, 0);
                throw e;
              }
            }
          };
          var initialTime = Date.now();
          exports.unstable_now = function () {
            return Date.now() - initialTime;
          };
          requestHostCallback = function (cb) {
            if (_callback !== null) {
              // Protect against re-entrancy.
              setTimeout(requestHostCallback, 0, cb);
            } else {
              _callback = cb;
              setTimeout(_flushCallback, 0);
            }
          };
          requestHostTimeout = function (cb, ms) {
            _timeoutID = setTimeout(cb, ms);
          };
          cancelHostTimeout = function () {
            clearTimeout(_timeoutID);
          };
          shouldYieldToHost = function () {
            return false;
          };
          requestPaint = exports.unstable_forceFrameRate = function () {};
        } else {
          // Capture local references to native APIs, in case a polyfill overrides them.
          var performance = window.performance;
          var _Date = window.Date;
          var _setTimeout = window.setTimeout;
          var _clearTimeout = window.clearTimeout;
          if (typeof console !== 'undefined') {
            // TODO: Scheduler no longer requires these methods to be polyfilled. But
            // maybe we want to continue warning if they don't exist, to preserve the
            // option to rely on it in the future?
            var requestAnimationFrame = window.requestAnimationFrame;
            var cancelAnimationFrame = window.cancelAnimationFrame; // TODO: Remove fb.me link

            if (typeof requestAnimationFrame !== 'function') {
              // Using console['error'] to evade Babel and ESLint
              console['error']("This browser doesn't support requestAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
            }
            if (typeof cancelAnimationFrame !== 'function') {
              // Using console['error'] to evade Babel and ESLint
              console['error']("This browser doesn't support cancelAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
            }
          }
          if (typeof performance === 'object' && typeof performance.now === 'function') {
            exports.unstable_now = function () {
              return performance.now();
            };
          } else {
            var _initialTime = _Date.now();
            exports.unstable_now = function () {
              return _Date.now() - _initialTime;
            };
          }
          var isMessageLoopRunning = false;
          var scheduledHostCallback = null;
          var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main
          // thread, like user events. By default, it yields multiple times per frame.
          // It does not attempt to align with frame boundaries, since most tasks don't
          // need to be frame aligned; for those that do, use requestAnimationFrame.

          var yieldInterval = 5;
          var deadline = 0; // TODO: Make this configurable

          {
            // `isInputPending` is not available. Since we have no way of knowing if
            // there's pending input, always yield at the end of the frame.
            shouldYieldToHost = function () {
              return exports.unstable_now() >= deadline;
            }; // Since we yield every frame regardless, `requestPaint` has no effect.

            requestPaint = function () {};
          }
          exports.unstable_forceFrameRate = function (fps) {
            if (fps < 0 || fps > 125) {
              // Using console['error'] to evade Babel and ESLint
              console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing framerates higher than 125 fps is not unsupported');
              return;
            }
            if (fps > 0) {
              yieldInterval = Math.floor(1000 / fps);
            } else {
              // reset the framerate
              yieldInterval = 5;
            }
          };
          var performWorkUntilDeadline = function () {
            if (scheduledHostCallback !== null) {
              var currentTime = exports.unstable_now(); // Yield after `yieldInterval` ms, regardless of where we are in the vsync
              // cycle. This means there's always time remaining at the beginning of
              // the message event.

              deadline = currentTime + yieldInterval;
              var hasTimeRemaining = true;
              try {
                var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
                if (!hasMoreWork) {
                  isMessageLoopRunning = false;
                  scheduledHostCallback = null;
                } else {
                  // If there's more work, schedule the next message event at the end
                  // of the preceding one.
                  port.postMessage(null);
                }
              } catch (error) {
                // If a scheduler task throws, exit the current browser task so the
                // error can be observed.
                port.postMessage(null);
                throw error;
              }
            } else {
              isMessageLoopRunning = false;
            } // Yielding to the browser will give it a chance to paint, so we can
          };

          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          requestHostCallback = function (callback) {
            scheduledHostCallback = callback;
            if (!isMessageLoopRunning) {
              isMessageLoopRunning = true;
              port.postMessage(null);
            }
          };
          requestHostTimeout = function (callback, ms) {
            taskTimeoutID = _setTimeout(function () {
              callback(exports.unstable_now());
            }, ms);
          };
          cancelHostTimeout = function () {
            _clearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
          };
        }
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          siftUp(heap, node, index);
        }
        function peek(heap) {
          var first = heap[0];
          return first === undefined ? null : first;
        }
        function pop(heap) {
          var first = heap[0];
          if (first !== undefined) {
            var last = heap.pop();
            if (last !== first) {
              heap[0] = last;
              siftDown(heap, last, 0);
            }
            return first;
          } else {
            return null;
          }
        }
        function siftUp(heap, node, i) {
          var index = i;
          while (true) {
            var parentIndex = index - 1 >>> 1;
            var parent = heap[parentIndex];
            if (parent !== undefined && compare(parent, node) > 0) {
              // The parent is larger. Swap positions.
              heap[parentIndex] = node;
              heap[index] = parent;
              index = parentIndex;
            } else {
              // The parent is smaller. Exit.
              return;
            }
          }
        }
        function siftDown(heap, node, i) {
          var index = i;
          var length = heap.length;
          while (index < length) {
            var leftIndex = (index + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.

            if (left !== undefined && compare(left, node) < 0) {
              if (right !== undefined && compare(right, left) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                heap[index] = left;
                heap[leftIndex] = node;
                index = leftIndex;
              }
            } else if (right !== undefined && compare(right, node) < 0) {
              heap[index] = right;
              heap[rightIndex] = node;
              index = rightIndex;
            } else {
              // Neither child is smaller. Exit.
              return;
            }
          }
        }
        function compare(a, b) {
          // Compare sort index first, then task id.
          var diff = a.sortIndex - b.sortIndex;
          return diff !== 0 ? diff : a.id - b.id;
        }

        // TODO: Use symbols?
        var NoPriority = 0;
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        var runIdCounter = 0;
        var mainThreadIdCounter = 0;
        var profilingStateSize = 4;
        var sharedProfilingBuffer =
        // $FlowFixMe Flow doesn't know about SharedArrayBuffer
        typeof SharedArrayBuffer === 'function' ? new SharedArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) :
        // $FlowFixMe Flow doesn't know about ArrayBuffer
        typeof ArrayBuffer === 'function' ? new ArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : null // Don't crash the init path on IE9
        ;

        var profilingState = sharedProfilingBuffer !== null ? new Int32Array(sharedProfilingBuffer) : []; // We can't read this but it helps save bytes for null checks

        var PRIORITY = 0;
        var CURRENT_TASK_ID = 1;
        var CURRENT_RUN_ID = 2;
        var QUEUE_SIZE = 3;
        {
          profilingState[PRIORITY] = NoPriority; // This is maintained with a counter, because the size of the priority queue
          // array might include canceled tasks.

          profilingState[QUEUE_SIZE] = 0;
          profilingState[CURRENT_TASK_ID] = 0;
        } // Bytes per element is 4

        var INITIAL_EVENT_LOG_SIZE = 131072;
        var MAX_EVENT_LOG_SIZE = 524288; // Equivalent to 2 megabytes

        var eventLogSize = 0;
        var eventLogBuffer = null;
        var eventLog = null;
        var eventLogIndex = 0;
        var TaskStartEvent = 1;
        var TaskCompleteEvent = 2;
        var TaskErrorEvent = 3;
        var TaskCancelEvent = 4;
        var TaskRunEvent = 5;
        var TaskYieldEvent = 6;
        var SchedulerSuspendEvent = 7;
        var SchedulerResumeEvent = 8;
        function logEvent(entries) {
          if (eventLog !== null) {
            var offset = eventLogIndex;
            eventLogIndex += entries.length;
            if (eventLogIndex + 1 > eventLogSize) {
              eventLogSize *= 2;
              if (eventLogSize > MAX_EVENT_LOG_SIZE) {
                // Using console['error'] to evade Babel and ESLint
                console['error']("Scheduler Profiling: Event log exceeded maximum size. Don't " + 'forget to call `stopLoggingProfilingEvents()`.');
                stopLoggingProfilingEvents();
                return;
              }
              var newEventLog = new Int32Array(eventLogSize * 4);
              newEventLog.set(eventLog);
              eventLogBuffer = newEventLog.buffer;
              eventLog = newEventLog;
            }
            eventLog.set(entries, offset);
          }
        }
        function startLoggingProfilingEvents() {
          eventLogSize = INITIAL_EVENT_LOG_SIZE;
          eventLogBuffer = new ArrayBuffer(eventLogSize * 4);
          eventLog = new Int32Array(eventLogBuffer);
          eventLogIndex = 0;
        }
        function stopLoggingProfilingEvents() {
          var buffer = eventLogBuffer;
          eventLogSize = 0;
          eventLogBuffer = null;
          eventLog = null;
          eventLogIndex = 0;
          return buffer;
        }
        function markTaskStart(task, ms) {
          {
            profilingState[QUEUE_SIZE]++;
            if (eventLog !== null) {
              // performance.now returns a float, representing milliseconds. When the
              // event is logged, it's coerced to an int. Convert to microseconds to
              // maintain extra degrees of precision.
              logEvent([TaskStartEvent, ms * 1000, task.id, task.priorityLevel]);
            }
          }
        }
        function markTaskCompleted(task, ms) {
          {
            profilingState[PRIORITY] = NoPriority;
            profilingState[CURRENT_TASK_ID] = 0;
            profilingState[QUEUE_SIZE]--;
            if (eventLog !== null) {
              logEvent([TaskCompleteEvent, ms * 1000, task.id]);
            }
          }
        }
        function markTaskCanceled(task, ms) {
          {
            profilingState[QUEUE_SIZE]--;
            if (eventLog !== null) {
              logEvent([TaskCancelEvent, ms * 1000, task.id]);
            }
          }
        }
        function markTaskErrored(task, ms) {
          {
            profilingState[PRIORITY] = NoPriority;
            profilingState[CURRENT_TASK_ID] = 0;
            profilingState[QUEUE_SIZE]--;
            if (eventLog !== null) {
              logEvent([TaskErrorEvent, ms * 1000, task.id]);
            }
          }
        }
        function markTaskRun(task, ms) {
          {
            runIdCounter++;
            profilingState[PRIORITY] = task.priorityLevel;
            profilingState[CURRENT_TASK_ID] = task.id;
            profilingState[CURRENT_RUN_ID] = runIdCounter;
            if (eventLog !== null) {
              logEvent([TaskRunEvent, ms * 1000, task.id, runIdCounter]);
            }
          }
        }
        function markTaskYield(task, ms) {
          {
            profilingState[PRIORITY] = NoPriority;
            profilingState[CURRENT_TASK_ID] = 0;
            profilingState[CURRENT_RUN_ID] = 0;
            if (eventLog !== null) {
              logEvent([TaskYieldEvent, ms * 1000, task.id, runIdCounter]);
            }
          }
        }
        function markSchedulerSuspended(ms) {
          {
            mainThreadIdCounter++;
            if (eventLog !== null) {
              logEvent([SchedulerSuspendEvent, ms * 1000, mainThreadIdCounter]);
            }
          }
        }
        function markSchedulerUnsuspended(ms) {
          {
            if (eventLog !== null) {
              logEvent([SchedulerResumeEvent, ms * 1000, mainThreadIdCounter]);
            }
          }
        }

        /* eslint-disable no-var */
        // Math.pow(2, 30) - 1
        // 0b111111111111111111111111111111

        var maxSigned31BitInt = 1073741823; // Times out immediately

        var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out

        var USER_BLOCKING_PRIORITY = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5000;
        var LOW_PRIORITY_TIMEOUT = 10000; // Never times out

        var IDLE_PRIORITY = maxSigned31BitInt; // Tasks are stored on a min heap

        var taskQueue = [];
        var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.

        var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.
        var currentTask = null;
        var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrancy.

        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        function advanceTimers(currentTime) {
          // Check for tasks that are no longer delayed and add them to the queue.
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              // Timer was cancelled.
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              // Timer fired. Transfer to the task queue.
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push(taskQueue, timer);
              {
                markTaskStart(timer, currentTime);
                timer.isQueued = true;
              }
            } else {
              // Remaining timers are pending.
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime) {
          {
            markSchedulerUnsuspended(initialTime);
          } // We'll need a host callback the next time work is scheduled.

          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            // We scheduled a timeout but it's no longer needed. Cancel it.
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            if (enableProfiling) {
              try {
                return workLoop(hasTimeRemaining, initialTime);
              } catch (error) {
                if (currentTask !== null) {
                  var currentTime = exports.unstable_now();
                  markTaskErrored(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                throw error;
              }
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
            {
              var _currentTime = exports.unstable_now();
              markSchedulerSuspended(_currentTime);
            }
          }
        }
        function workLoop(hasTimeRemaining, initialTime) {
          var currentTime = initialTime;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && !enableSchedulerDebugging) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              // This currentTask hasn't expired, and we've reached the deadline.
              break;
            }
            var callback = currentTask.callback;
            if (callback !== null) {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              markTaskRun(currentTask, currentTime);
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === 'function') {
                currentTask.callback = continuationCallback;
                markTaskYield(currentTask, currentTime);
              } else {
                {
                  markTaskCompleted(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                if (currentTask === peek(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek(taskQueue);
          } // Return whether there's additional work

          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              // Shift down to normal priority
              priorityLevel = NormalPriority;
              break;
            default:
              // Anything lower than normal priority should remain at the current level.
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function () {
            // This is a fork of runWithPriority, inlined for performance.
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function timeoutForPriorityLevel(priorityLevel) {
          switch (priorityLevel) {
            case ImmediatePriority:
              return IMMEDIATE_PRIORITY_TIMEOUT;
            case UserBlockingPriority:
              return USER_BLOCKING_PRIORITY;
            case IdlePriority:
              return IDLE_PRIORITY;
            case LowPriority:
              return LOW_PRIORITY_TIMEOUT;
            case NormalPriority:
            default:
              return NORMAL_PRIORITY_TIMEOUT;
          }
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          var startTime;
          var timeout;
          if (typeof options === 'object' && options !== null) {
            var delay = options.delay;
            if (typeof delay === 'number' && delay > 0) {
              startTime = currentTime + delay;
            } else {
              startTime = currentTime;
            }
            timeout = typeof options.timeout === 'number' ? options.timeout : timeoutForPriorityLevel(priorityLevel);
          } else {
            timeout = timeoutForPriorityLevel(priorityLevel);
            startTime = currentTime;
          }
          var expirationTime = startTime + timeout;
          var newTask = {
            id: taskIdCounter++,
            callback: callback,
            priorityLevel: priorityLevel,
            startTime: startTime,
            expirationTime: expirationTime,
            sortIndex: -1
          };
          {
            newTask.isQueued = false;
          }
          if (startTime > currentTime) {
            // This is a delayed task.
            newTask.sortIndex = startTime;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              // All tasks are delayed, and this is the task with the earliest delay.
              if (isHostTimeoutScheduled) {
                // Cancel an existing timeout.
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              } // Schedule a timeout.

              requestHostTimeout(handleTimeout, startTime - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            {
              markTaskStart(newTask, currentTime);
              newTask.isQueued = true;
            } // Schedule a host callback, if needed. If we're already performing work,
            // wait until the next time we yield.

            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {}
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
          {
            if (task.isQueued) {
              var currentTime = exports.unstable_now();
              markTaskCanceled(task, currentTime);
              task.isQueued = false;
            }
          } // Null out the callback to indicate the task has been canceled. (Can't
          // remove from the queue because you can't remove arbitrary nodes from an
          // array based heap, only the first one.)

          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        function unstable_shouldYield() {
          var currentTime = exports.unstable_now();
          advanceTimers(currentTime);
          var firstTask = peek(taskQueue);
          return firstTask !== currentTask && currentTask !== null && firstTask !== null && firstTask.callback !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = {
          startLoggingProfilingEvents: startLoggingProfilingEvents,
          stopLoggingProfilingEvents: stopLoggingProfilingEvents,
          sharedProfilingBuffer: sharedProfilingBuffer
        };
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_shouldYield = unstable_shouldYield;
        exports.unstable_wrapCallback = unstable_wrapCallback;
      })();
    }
  })(scheduler_development);

  {
    scheduler.exports = scheduler_development;
  }
  var schedulerExports = scheduler.exports;

  var tracing = {exports: {}};

  var schedulerTracing_development = {};

  /** @license React v0.19.1
   * scheduler-tracing.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  (function (exports) {

    {
      (function () {

        var DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.

        var interactionIDCounter = 0;
        var threadIDCounter = 0; // Set of currently traced interactions.
        // Interactions "stack"–
        // Meaning that newly traced interactions are appended to the previously active set.
        // When an interaction goes out of scope, the previous set (if any) is restored.

        exports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.

        exports.__subscriberRef = null;
        {
          exports.__interactionsRef = {
            current: new Set()
          };
          exports.__subscriberRef = {
            current: null
          };
        }
        function unstable_clear(callback) {
          var prevInteractions = exports.__interactionsRef.current;
          exports.__interactionsRef.current = new Set();
          try {
            return callback();
          } finally {
            exports.__interactionsRef.current = prevInteractions;
          }
        }
        function unstable_getCurrent() {
          {
            return exports.__interactionsRef.current;
          }
        }
        function unstable_getThreadID() {
          return ++threadIDCounter;
        }
        function unstable_trace(name, timestamp, callback) {
          var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;
          var interaction = {
            __count: 1,
            id: interactionIDCounter++,
            name: name,
            timestamp: timestamp
          };
          var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.
          // To do that, clone the current interactions.
          // The previous set will be restored upon completion.

          var interactions = new Set(prevInteractions);
          interactions.add(interaction);
          exports.__interactionsRef.current = interactions;
          var subscriber = exports.__subscriberRef.current;
          var returnValue;
          try {
            if (subscriber !== null) {
              subscriber.onInteractionTraced(interaction);
            }
          } finally {
            try {
              if (subscriber !== null) {
                subscriber.onWorkStarted(interactions, threadID);
              }
            } finally {
              try {
                returnValue = callback();
              } finally {
                exports.__interactionsRef.current = prevInteractions;
                try {
                  if (subscriber !== null) {
                    subscriber.onWorkStopped(interactions, threadID);
                  }
                } finally {
                  interaction.__count--; // If no async work was scheduled for this interaction,
                  // Notify subscribers that it's completed.

                  if (subscriber !== null && interaction.__count === 0) {
                    subscriber.onInteractionScheduledWorkCompleted(interaction);
                  }
                }
              }
            }
          }
          return returnValue;
        }
        function unstable_wrap(callback) {
          var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;
          var wrappedInteractions = exports.__interactionsRef.current;
          var subscriber = exports.__subscriberRef.current;
          if (subscriber !== null) {
            subscriber.onWorkScheduled(wrappedInteractions, threadID);
          } // Update the pending async work count for the current interactions.
          // Update after calling subscribers in case of error.

          wrappedInteractions.forEach(function (interaction) {
            interaction.__count++;
          });
          var hasRun = false;
          function wrapped() {
            var prevInteractions = exports.__interactionsRef.current;
            exports.__interactionsRef.current = wrappedInteractions;
            subscriber = exports.__subscriberRef.current;
            try {
              var returnValue;
              try {
                if (subscriber !== null) {
                  subscriber.onWorkStarted(wrappedInteractions, threadID);
                }
              } finally {
                try {
                  returnValue = callback.apply(undefined, arguments);
                } finally {
                  exports.__interactionsRef.current = prevInteractions;
                  if (subscriber !== null) {
                    subscriber.onWorkStopped(wrappedInteractions, threadID);
                  }
                }
              }
              return returnValue;
            } finally {
              if (!hasRun) {
                // We only expect a wrapped function to be executed once,
                // But in the event that it's executed more than once–
                // Only decrement the outstanding interaction counts once.
                hasRun = true; // Update pending async counts for all wrapped interactions.
                // If this was the last scheduled async work for any of them,
                // Mark them as completed.

                wrappedInteractions.forEach(function (interaction) {
                  interaction.__count--;
                  if (subscriber !== null && interaction.__count === 0) {
                    subscriber.onInteractionScheduledWorkCompleted(interaction);
                  }
                });
              }
            }
          }
          wrapped.cancel = function cancel() {
            subscriber = exports.__subscriberRef.current;
            try {
              if (subscriber !== null) {
                subscriber.onWorkCanceled(wrappedInteractions, threadID);
              }
            } finally {
              // Update pending async counts for all wrapped interactions.
              // If this was the last scheduled async work for any of them,
              // Mark them as completed.
              wrappedInteractions.forEach(function (interaction) {
                interaction.__count--;
                if (subscriber && interaction.__count === 0) {
                  subscriber.onInteractionScheduledWorkCompleted(interaction);
                }
              });
            }
          };
          return wrapped;
        }
        var subscribers = null;
        {
          subscribers = new Set();
        }
        function unstable_subscribe(subscriber) {
          {
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
              exports.__subscriberRef.current = {
                onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,
                onInteractionTraced: onInteractionTraced,
                onWorkCanceled: onWorkCanceled,
                onWorkScheduled: onWorkScheduled,
                onWorkStarted: onWorkStarted,
                onWorkStopped: onWorkStopped
              };
            }
          }
        }
        function unstable_unsubscribe(subscriber) {
          {
            subscribers.delete(subscriber);
            if (subscribers.size === 0) {
              exports.__subscriberRef.current = null;
            }
          }
        }
        function onInteractionTraced(interaction) {
          var didCatchError = false;
          var caughtError = null;
          subscribers.forEach(function (subscriber) {
            try {
              subscriber.onInteractionTraced(interaction);
            } catch (error) {
              if (!didCatchError) {
                didCatchError = true;
                caughtError = error;
              }
            }
          });
          if (didCatchError) {
            throw caughtError;
          }
        }
        function onInteractionScheduledWorkCompleted(interaction) {
          var didCatchError = false;
          var caughtError = null;
          subscribers.forEach(function (subscriber) {
            try {
              subscriber.onInteractionScheduledWorkCompleted(interaction);
            } catch (error) {
              if (!didCatchError) {
                didCatchError = true;
                caughtError = error;
              }
            }
          });
          if (didCatchError) {
            throw caughtError;
          }
        }
        function onWorkScheduled(interactions, threadID) {
          var didCatchError = false;
          var caughtError = null;
          subscribers.forEach(function (subscriber) {
            try {
              subscriber.onWorkScheduled(interactions, threadID);
            } catch (error) {
              if (!didCatchError) {
                didCatchError = true;
                caughtError = error;
              }
            }
          });
          if (didCatchError) {
            throw caughtError;
          }
        }
        function onWorkStarted(interactions, threadID) {
          var didCatchError = false;
          var caughtError = null;
          subscribers.forEach(function (subscriber) {
            try {
              subscriber.onWorkStarted(interactions, threadID);
            } catch (error) {
              if (!didCatchError) {
                didCatchError = true;
                caughtError = error;
              }
            }
          });
          if (didCatchError) {
            throw caughtError;
          }
        }
        function onWorkStopped(interactions, threadID) {
          var didCatchError = false;
          var caughtError = null;
          subscribers.forEach(function (subscriber) {
            try {
              subscriber.onWorkStopped(interactions, threadID);
            } catch (error) {
              if (!didCatchError) {
                didCatchError = true;
                caughtError = error;
              }
            }
          });
          if (didCatchError) {
            throw caughtError;
          }
        }
        function onWorkCanceled(interactions, threadID) {
          var didCatchError = false;
          var caughtError = null;
          subscribers.forEach(function (subscriber) {
            try {
              subscriber.onWorkCanceled(interactions, threadID);
            } catch (error) {
              if (!didCatchError) {
                didCatchError = true;
                caughtError = error;
              }
            }
          });
          if (didCatchError) {
            throw caughtError;
          }
        }
        exports.unstable_clear = unstable_clear;
        exports.unstable_getCurrent = unstable_getCurrent;
        exports.unstable_getThreadID = unstable_getThreadID;
        exports.unstable_subscribe = unstable_subscribe;
        exports.unstable_trace = unstable_trace;
        exports.unstable_unsubscribe = unstable_unsubscribe;
        exports.unstable_wrap = unstable_wrap;
      })();
    }
  })(schedulerTracing_development);

  {
    tracing.exports = schedulerTracing_development;
  }
  var tracingExports = tracing.exports;

  {(function(){var React=reactExports;var _assign=objectAssign;var Scheduler=schedulerExports;var checkPropTypes=checkPropTypes_1;var tracing=tracingExports;var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;// Prevent newer renderers from RTE when used with older react package versions.
  // Current owner and dispatcher used to share the same ref,
  // but PR #14548 split them out to better support the react-debug-tools package.
  if(!ReactSharedInternals.hasOwnProperty('ReactCurrentDispatcher')){ReactSharedInternals.ReactCurrentDispatcher={current:null};}if(!ReactSharedInternals.hasOwnProperty('ReactCurrentBatchConfig')){ReactSharedInternals.ReactCurrentBatchConfig={suspense:null};}// by calls to these methods by a Babel plugin.
  //
  // In PROD (or in packages without access to React internals),
  // they are left as they are instead.
  function warn(format){{for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}printWarning('warn',format,args);}}function error(format){{for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}printWarning('error',format,args);}}function printWarning(level,format,args){// When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {var hasExistingStack=args.length>0&&typeof args[args.length-1]==='string'&&args[args.length-1].indexOf('\n    in')===0;if(!hasExistingStack){var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var stack=ReactDebugCurrentFrame.getStackAddendum();if(stack!==''){format+='%s';args=args.concat([stack]);}}var argsWithFormat=args.map(function(item){return ''+item;});// Careful: RN currently depends on this prefix
  argsWithFormat.unshift('Warning: '+format);// We intentionally don't use spread (or .apply) directly because it
  // breaks IE9: https://github.com/facebook/react/issues/13610
  // eslint-disable-next-line react-internal/no-production-logging
  Function.prototype.apply.call(console[level],console,argsWithFormat);try{// --- Welcome to debugging React ---
  // This error was thrown as a convenience so that you can use this stack
  // to find the callsite that caused this warning to fire.
  var argIndex=0;var message='Warning: '+format.replace(/%s/g,function(){return args[argIndex++];});throw new Error(message);}catch(x){}}}if(!React){{throw Error("ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.");}}var invokeGuardedCallbackImpl=function(name,func,context,a,b,c,d,e,f){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){this.onError(error);}};{// In DEV mode, we swap out invokeGuardedCallback for a special version
  // that plays more nicely with the browser's DevTools. The idea is to preserve
  // "Pause on exceptions" behavior. Because React wraps all user-provided
  // functions in invokeGuardedCallback, and the production version of
  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
  // like caught exceptions, and the DevTools won't pause unless the developer
  // takes the extra step of enabling pause on caught exceptions. This is
  // unintuitive, though, because even though React has caught the error, from
  // the developer's perspective, the error is uncaught.
  //
  // To preserve the expected "Pause on exceptions" behavior, we don't use a
  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
  // DOM node, and call the user-provided callback from inside an event handler
  // for that fake event. If the callback throws, the error is "captured" using
  // a global event handler. But because the error happens in a different
  // event loop context, it does not interrupt the normal program flow.
  // Effectively, this gives us try-catch behavior without actually using
  // try-catch. Neat!
  // Check that the browser supports the APIs we need to implement our special
  // DEV version of invokeGuardedCallback
  if(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');var invokeGuardedCallbackDev=function(name,func,context,a,b,c,d,e,f){// If document doesn't exist we know for sure we will crash in this method
  // when we call document.createEvent(). However this can cause confusing
  // errors: https://github.com/facebookincubator/create-react-app/issues/3482
  // So we preemptively throw with a better message instead.
  if(!(typeof document!=='undefined')){{throw Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");}}var evt=document.createEvent('Event');// Keeps track of whether the user-provided callback threw an error. We
  // set this to true at the beginning, then set it to false right after
  // calling the function. If the function errors, `didError` will never be
  // set to false. This strategy works even if the browser is flaky and
  // fails to call our global error handler, because it doesn't rely on
  // the error event at all.
  var didError=true;// Keeps track of the value of window.event so that we can reset it
  // during the callback to let user code access window.event in the
  // browsers that support it.
  var windowEvent=window.event;// Keeps track of the descriptor of window.event to restore it after event
  // dispatching: https://github.com/facebook/react/issues/13688
  var windowEventDescriptor=Object.getOwnPropertyDescriptor(window,'event');// Create an event handler for our fake event. We will synchronously
  // dispatch our fake event using `dispatchEvent`. Inside the handler, we
  // call the user-provided callback.
  var funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){// We immediately remove the callback from event listeners so that
  // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
  // nested call would trigger the fake event handlers of any call higher
  // in the stack.
  fakeNode.removeEventListener(evtType,callCallback,false);// We check for window.hasOwnProperty('event') to prevent the
  // window.event assignment in both IE <= 10 as they throw an error
  // "Member not found" in strict mode, and in Firefox which does not
  // support window.event.
  if(typeof window.event!=='undefined'&&window.hasOwnProperty('event')){window.event=windowEvent;}func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value
  // that was thrown. It's possible that this error handler will fire more
  // than once; for example, if non-React code also calls `dispatchEvent`
  // and a handler for that event throws. We should be resilient to most of
  // those cases. Even if our error event handler fires more than once, the
  // last error event is always used. If the callback actually does error,
  // we know that the last error event is the correct one, because it's not
  // possible for anything else to have happened in between our callback
  // erroring and the code that follows the `dispatchEvent` call below. If
  // the callback doesn't error, but the error event was fired, we know to
  // ignore it because `didError` will be false, as described above.
  var error;// Use this to track whether the error event is ever called.
  var didSetError=false;var isCrossOriginError=false;function handleWindowError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}if(event.defaultPrevented){// Some other error handler has prevented default.
  // Browsers silence the error report if this happens.
  // We'll remember this to later decide whether to log it or not.
  if(error!=null&&typeof error==='object'){try{error._suppressLogging=true;}catch(inner){// Ignore.
  }}}}// Create a fake event type.
  var evtType="react-"+(name?name:'invokeguardedcallback');// Attach our event handlers
  window.addEventListener('error',handleWindowError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function
  // errors, it will trigger our global error handler.
  evt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(windowEventDescriptor){Object.defineProperty(window,'event',windowEventDescriptor);}if(didError){if(!didSetError){// The callback errored, but the error event never fired.
  error=new Error('An error was thrown inside one of your components, but React '+"doesn't know what it was. This is likely due to browser "+'flakiness. React does its best to preserve the "Pause on '+'exceptions" behavior of the DevTools, which requires some '+"DEV-mode only tricks. It's possible that these don't work in "+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){error=new Error("A cross-origin error was thrown. React doesn't have access to "+'the actual error object in development. '+'See https://fb.me/react-crossorigin-error for more information.');}this.onError(error);}// Remove our event listeners
  window.removeEventListener('error',handleWindowError);};invokeGuardedCallbackImpl=invokeGuardedCallbackDev;}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl;var hasError=false;var caughtError=null;// Used by event system to capture/rethrow the first error.
  var hasRethrowError=false;var rethrowError=null;var reporter={onError:function(error){hasError=true;caughtError=error;}};/**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don't
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){hasError=false;caughtError=null;invokeGuardedCallbackImpl$1.apply(reporter,arguments);}/**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * TODO: See if caughtError and rethrowError can be unified.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){invokeGuardedCallback.apply(this,arguments);if(hasError){var error=clearCaughtError();if(!hasRethrowError){hasRethrowError=true;rethrowError=error;}}}/**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */function rethrowCaughtError(){if(hasRethrowError){var error=rethrowError;hasRethrowError=false;rethrowError=null;throw error;}}function hasCaughtError(){return hasError;}function clearCaughtError(){if(hasError){var error=caughtError;hasError=false;caughtError=null;return error;}else {{{throw Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");}}}}var getFiberCurrentPropsFromNode=null;var getInstanceFromNode=null;var getNodeFromInstance=null;function setComponentTree(getFiberCurrentPropsFromNodeImpl,getInstanceFromNodeImpl,getNodeFromInstanceImpl){getFiberCurrentPropsFromNode=getFiberCurrentPropsFromNodeImpl;getInstanceFromNode=getInstanceFromNodeImpl;getNodeFromInstance=getNodeFromInstanceImpl;{if(!getNodeFromInstance||!getInstanceFromNode){error('EventPluginUtils.setComponentTree(...): Injected '+'module is missing getNodeFromInstance or getInstanceFromNode.');}}}var validateEventDispatches;{validateEventDispatches=function(event){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;var listenersIsArr=Array.isArray(dispatchListeners);var listenersLen=listenersIsArr?dispatchListeners.length:dispatchListeners?1:0;var instancesIsArr=Array.isArray(dispatchInstances);var instancesLen=instancesIsArr?dispatchInstances.length:dispatchInstances?1:0;if(instancesIsArr!==listenersIsArr||instancesLen!==listenersLen){error('EventPluginUtils: Invalid `event`.');}};}/**
   * Dispatch the event to the listener.
   * @param {SyntheticEvent} event SyntheticEvent to handle
   * @param {function} listener Application-level callback
   * @param {*} inst Internal component instance
   */function executeDispatch(event,listener,inst){var type=event.type||'unknown-event';event.currentTarget=getNodeFromInstance(inst);invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}/**
   * Standard/simple iteration through an event's collected dispatches.
   */function executeDispatchesInOrder(event){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;{validateEventDispatches(event);}if(Array.isArray(dispatchListeners)){for(var i=0;i<dispatchListeners.length;i++){if(event.isPropagationStopped()){break;}// Listeners and Instances are two parallel arrays that are always in sync.
  executeDispatch(event,dispatchListeners[i],dispatchInstances[i]);}}else if(dispatchListeners){executeDispatch(event,dispatchListeners,dispatchInstances);}event._dispatchListeners=null;event._dispatchInstances=null;}var FunctionComponent=0;var ClassComponent=1;var IndeterminateComponent=2;// Before we know whether it is function or class
  var HostRoot=3;// Root of a host tree. Could be nested inside another node.
  var HostPortal=4;// A subtree. Could be an entry point to a different renderer.
  var HostComponent=5;var HostText=6;var Fragment=7;var Mode=8;var ContextConsumer=9;var ContextProvider=10;var ForwardRef=11;var Profiler=12;var SuspenseComponent=13;var MemoComponent=14;var SimpleMemoComponent=15;var LazyComponent=16;var IncompleteClassComponent=17;var DehydratedFragment=18;var SuspenseListComponent=19;var FundamentalComponent=20;var ScopeComponent=21;var Block=22;/**
   * Injectable ordering of event plugins.
   */var eventPluginOrder=null;/**
   * Injectable mapping from names to event plugin modules.
   */var namesToPlugins={};/**
   * Recomputes the plugin list using the injected plugins and plugin ordering.
   *
   * @private
   */function recomputePluginOrdering(){if(!eventPluginOrder){// Wait until an `eventPluginOrder` is injected.
  return;}for(var pluginName in namesToPlugins){var pluginModule=namesToPlugins[pluginName];var pluginIndex=eventPluginOrder.indexOf(pluginName);if(!(pluginIndex>-1)){{throw Error("EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `"+pluginName+"`.");}}if(plugins[pluginIndex]){continue;}if(!pluginModule.extractEvents){{throw Error("EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `"+pluginName+"` does not.");}}plugins[pluginIndex]=pluginModule;var publishedEvents=pluginModule.eventTypes;for(var eventName in publishedEvents){if(!publishEventForPlugin(publishedEvents[eventName],pluginModule,eventName)){{throw Error("EventPluginRegistry: Failed to publish event `"+eventName+"` for plugin `"+pluginName+"`.");}}}}}/**
   * Publishes an event so that it can be dispatched by the supplied plugin.
   *
   * @param {object} dispatchConfig Dispatch configuration for the event.
   * @param {object} PluginModule Plugin publishing the event.
   * @return {boolean} True if the event was successfully published.
   * @private
   */function publishEventForPlugin(dispatchConfig,pluginModule,eventName){if(!!eventNameDispatchConfigs.hasOwnProperty(eventName)){{throw Error("EventPluginRegistry: More than one plugin attempted to publish the same event name, `"+eventName+"`.");}}eventNameDispatchConfigs[eventName]=dispatchConfig;var phasedRegistrationNames=dispatchConfig.phasedRegistrationNames;if(phasedRegistrationNames){for(var phaseName in phasedRegistrationNames){if(phasedRegistrationNames.hasOwnProperty(phaseName)){var phasedRegistrationName=phasedRegistrationNames[phaseName];publishRegistrationName(phasedRegistrationName,pluginModule,eventName);}}return true;}else if(dispatchConfig.registrationName){publishRegistrationName(dispatchConfig.registrationName,pluginModule,eventName);return true;}return false;}/**
   * Publishes a registration name that is used to identify dispatched events.
   *
   * @param {string} registrationName Registration name to add.
   * @param {object} PluginModule Plugin publishing the event.
   * @private
   */function publishRegistrationName(registrationName,pluginModule,eventName){if(!!registrationNameModules[registrationName]){{throw Error("EventPluginRegistry: More than one plugin attempted to publish the same registration name, `"+registrationName+"`.");}}registrationNameModules[registrationName]=pluginModule;registrationNameDependencies[registrationName]=pluginModule.eventTypes[eventName].dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}}/**
   * Registers plugins so that they can extract and dispatch events.
   */ /**
   * Ordered list of injected plugins.
   */var plugins=[];/**
   * Mapping from event name to dispatch config
   */var eventNameDispatchConfigs={};/**
   * Mapping from registration name to plugin module
   */var registrationNameModules={};/**
   * Mapping from registration name to event name
   */var registrationNameDependencies={};/**
   * Mapping from lowercase registration names to the properly cased version,
   * used to warn in the case of missing event handlers. Available
   * only in true.
   * @type {Object}
   */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true
  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   */function injectEventPluginOrder(injectedEventPluginOrder){if(!!eventPluginOrder){{throw Error("EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.");}}// Clone the ordering so it cannot be dynamically mutated.
  eventPluginOrder=Array.prototype.slice.call(injectedEventPluginOrder);recomputePluginOrdering();}/**
   * Injects plugins to be used by plugin event system. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   */function injectEventPluginsByName(injectedNamesToPlugins){var isOrderingDirty=false;for(var pluginName in injectedNamesToPlugins){if(!injectedNamesToPlugins.hasOwnProperty(pluginName)){continue;}var pluginModule=injectedNamesToPlugins[pluginName];if(!namesToPlugins.hasOwnProperty(pluginName)||namesToPlugins[pluginName]!==pluginModule){if(!!namesToPlugins[pluginName]){{throw Error("EventPluginRegistry: Cannot inject two different event plugins using the same name, `"+pluginName+"`.");}}namesToPlugins[pluginName]=pluginModule;isOrderingDirty=true;}}if(isOrderingDirty){recomputePluginOrdering();}}var canUseDOM=!!(typeof window!=='undefined'&&typeof window.document!=='undefined'&&typeof window.document.createElement!=='undefined');var PLUGIN_EVENT_SYSTEM=1;var IS_REPLAYED=1<<5;var IS_FIRST_ANCESTOR=1<<6;var restoreImpl=null;var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we
  // always receive the correct fiber here
  var internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted
  return;}if(!(typeof restoreImpl==='function')){{throw Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");}}var stateNode=internalInstance.stateNode;// Guard against Fiber being unmounted.
  if(stateNode){var _props=getFiberCurrentPropsFromNode(stateNode);restoreImpl(internalInstance.stateNode,internalInstance.type,_props);}}function setRestoreImplementation(impl){restoreImpl=impl;}function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else {restoreQueue=[target];}}else {restoreTarget=target;}}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null;}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}var enableProfilerTimer=true;// Trace which interactions trigger each commit.
  var enableDeprecatedFlareAPI=false;// Experimental Host Component support.
  var enableFundamentalAPI=false;// Experimental Scope support.
  var warnAboutStringRefs=false;// the renderer. Such as when we're dispatching events or if third party
  // libraries need to call batchedUpdates. Eventually, this API will go away when
  // everything is batched by default. We'll then have a similar API to opt-out of
  // scheduled work and instead do synchronous work.
  // Defaults
  var batchedUpdatesImpl=function(fn,bookkeeping){return fn(bookkeeping);};var discreteUpdatesImpl=function(fn,a,b,c,d){return fn(a,b,c,d);};var flushDiscreteUpdatesImpl=function(){};var batchedEventUpdatesImpl=batchedUpdatesImpl;var isInsideEventHandler=false;var isBatchingEventUpdates=false;function finishEventHandler(){// Here we wait until all updates have propagated, which is important
  // when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  // Then we restore state of any controlled component.
  var controlledComponentsHavePendingUpdates=needsStateRestore();if(controlledComponentsHavePendingUpdates){// If a controlled event was fired, we may need to restore the state of
  // the DOM node back to the controlled value. This is necessary when React
  // bails out of the update without touching the DOM.
  flushDiscreteUpdatesImpl();restoreStateIfNeeded();}}function batchedUpdates(fn,bookkeeping){if(isInsideEventHandler){// If we are currently inside another batch, we need to wait until it
  // fully completes before restoring state.
  return fn(bookkeeping);}isInsideEventHandler=true;try{return batchedUpdatesImpl(fn,bookkeeping);}finally{isInsideEventHandler=false;finishEventHandler();}}function batchedEventUpdates(fn,a,b){if(isBatchingEventUpdates){// If we are currently inside another batch, we need to wait until it
  // fully completes before restoring state.
  return fn(a,b);}isBatchingEventUpdates=true;try{return batchedEventUpdatesImpl(fn,a,b);}finally{isBatchingEventUpdates=false;finishEventHandler();}}// This is for the React Flare event system
  function discreteUpdates(fn,a,b,c,d){var prevIsInsideEventHandler=isInsideEventHandler;isInsideEventHandler=true;try{return discreteUpdatesImpl(fn,a,b,c,d);}finally{isInsideEventHandler=prevIsInsideEventHandler;if(!isInsideEventHandler){finishEventHandler();}}}function flushDiscreteUpdatesIfNeeded(timeStamp){// event.timeStamp isn't overly reliable due to inconsistencies in
  // how different browsers have historically provided the time stamp.
  // Some browsers provide high-resolution time stamps for all events,
  // some provide low-resolution time stamps for all events. FF < 52
  // even mixes both time stamps together. Some browsers even report
  // negative time stamps or time stamps that are 0 (iOS9) in some cases.
  // Given we are only comparing two time stamps with equality (!==),
  // we are safe from the resolution differences. If the time stamp is 0
  // we bail-out of preventing the flush, which can affect semantics,
  // such as if an earlier flush removes or adds event listeners that
  // are fired in the subsequent flush. However, this is the same
  // behaviour as we had before this change, so the risks are low.
  if(!isInsideEventHandler&&!enableDeprecatedFlareAPI){flushDiscreteUpdatesImpl();}}function setBatchingImplementation(_batchedUpdatesImpl,_discreteUpdatesImpl,_flushDiscreteUpdatesImpl,_batchedEventUpdatesImpl){batchedUpdatesImpl=_batchedUpdatesImpl;discreteUpdatesImpl=_discreteUpdatesImpl;flushDiscreteUpdatesImpl=_flushDiscreteUpdatesImpl;batchedEventUpdatesImpl=_batchedEventUpdatesImpl;}var DiscreteEvent=0;var UserBlockingEvent=1;var ContinuousEvent=2;// A reserved attribute.
  // It is handled by React separately and shouldn't be written to the DOM.
  var RESERVED=0;// A simple string attribute.
  // Attributes that aren't in the whitelist are presumed to have this type.
  var STRING=1;// A string attribute that accepts booleans in React. In HTML, these are called
  // "enumerated" attributes with "true" and "false" as possible values.
  // When true, it should be set to a "true" string.
  // When false, it should be set to a "false" string.
  var BOOLEANISH_STRING=2;// A real boolean attribute.
  // When true, it should be present (set either to an empty string or its name).
  // When false, it should be omitted.
  var BOOLEAN=3;// An attribute that can be used as a flag as well as with a value.
  // When true, it should be present (set either to an empty string or its name).
  // When false, it should be omitted.
  // For any other value, should be present with that value.
  var OVERLOADED_BOOLEAN=4;// An attribute that must be numeric or parse as a numeric.
  // When falsy, it should be removed.
  var NUMERIC=5;// An attribute that must be positive numeric or parse as a positive numeric.
  // When falsy, it should be removed.
  var POSITIVE_NUMERIC=6;/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+"\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";var ROOT_ATTRIBUTE_NAME='data-reactroot';var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty=Object.prototype.hasOwnProperty;var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(hasOwnProperty.call(validatedAttributeNameCache,attributeName)){return true;}if(hasOwnProperty.call(illegalAttributeNameCache,attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{error('Invalid attribute name: `%s`',attributeName);}return false;}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){if(propertyInfo!==null){return propertyInfo.type===RESERVED;}if(isCustomComponentTag){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return true;}return false;}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED){return false;}switch(typeof value){case'function':// $FlowIssue symbol is perfectly valid here
  case'symbol':// eslint-disable-line
  return true;case'boolean':{if(isCustomComponentTag){return false;}if(propertyInfo!==null){return !propertyInfo.acceptsBooleans;}else {var prefix=name.toLowerCase().slice(0,5);return prefix!=='data-'&&prefix!=='aria-';}}default:return false;}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value==='undefined'){return true;}if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag)){return true;}if(isCustomComponentTag){return false;}if(propertyInfo!==null){switch(propertyInfo.type){case BOOLEAN:return !value;case OVERLOADED_BOOLEAN:return value===false;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1;}}return false;}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace,sanitizeURL){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN;this.attributeName=attributeName;this.attributeNamespace=attributeNamespace;this.mustUseProperty=mustUseProperty;this.propertyName=name;this.type=type;this.sanitizeURL=sanitizeURL;}// When adding attributes to this list, be sure to also add them to
  // the `possibleStandardNames` module to ensure casing and incorrect
  // name warnings.
  var properties={};// These props are reserved by React. They shouldn't be written to the DOM.
  var reservedProps=['children','dangerouslySetInnerHTML',// TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  'defaultValue','defaultChecked','innerHTML','suppressContentEditableWarning','suppressHydrationWarning','style'];reservedProps.forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,false,// mustUseProperty
  name,// attributeName
  null,// attributeNamespace
  false);});// A few React string attributes have a different name.
  // This is a mapping from React prop names to the attribute names.
  [['acceptCharset','accept-charset'],['className','class'],['htmlFor','for'],['httpEquiv','http-equiv']].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
  attributeName,// attributeName
  null,// attributeNamespace
  false);});// These are "enumerated" HTML attributes that accept "true" and "false".
  // In React, we let users pass `true` and `false` even though technically
  // these aren't boolean attributes (they are coerced to strings).
  ['contentEditable','draggable','spellCheck','value'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty
  name.toLowerCase(),// attributeName
  null,// attributeNamespace
  false);});// These are "enumerated" SVG attributes that accept "true" and "false".
  // In React, we let users pass `true` and `false` even though technically
  // these aren't boolean attributes (they are coerced to strings).
  // Since these are SVG attributes, their attribute names are case-sensitive.
  ['autoReverse','externalResourcesRequired','focusable','preserveAlpha'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty
  name,// attributeName
  null,// attributeNamespace
  false);});// These are HTML boolean attributes.
  ['allowFullScreen','async',// Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  'autoFocus','autoPlay','controls','default','defer','disabled','disablePictureInPicture','formNoValidate','hidden','loop','noModule','noValidate','open','playsInline','readOnly','required','reversed','scoped','seamless',// Microdata
  'itemScope'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,false,// mustUseProperty
  name.toLowerCase(),// attributeName
  null,// attributeNamespace
  false);});// These are the few React props that we set as DOM properties
  // rather than attributes. These are all booleans.
  ['checked',// Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  'multiple','muted','selected'// NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
  ].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,true,// mustUseProperty
  name,// attributeName
  null,// attributeNamespace
  false);});// These are HTML attributes that are "overloaded booleans": they behave like
  // booleans, but can also accept a string value.
  ['capture','download'// NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
  ].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,false,// mustUseProperty
  name,// attributeName
  null,// attributeNamespace
  false);});// These are HTML attributes that must be positive numbers.
  ['cols','rows','size','span'// NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
  ].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,false,// mustUseProperty
  name,// attributeName
  null,// attributeNamespace
  false);});// These are HTML attributes that must be numbers.
  ['rowSpan','start'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,false,// mustUseProperty
  name.toLowerCase(),// attributeName
  null,// attributeNamespace
  false);});var CAMELIZE=/[\-\:]([a-z])/g;var capitalize=function(token){return token[1].toUpperCase();};// This is a list of all SVG attributes that need special casing, namespacing,
  // or boolean value assignment. Regular attributes that just accept strings
  // and have the same names are omitted, just like in the HTML whitelist.
  // Some of these attributes can be hard to find. This list was created by
  // scraping the MDN documentation.
  ['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','xmlns:xlink','x-height'// NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
  ].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
  attributeName,null,// attributeNamespace
  false);});// String SVG attributes with the xlink namespace.
  ['xlink:actuate','xlink:arcrole','xlink:role','xlink:show','xlink:title','xlink:type'// NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
  ].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
  attributeName,'http://www.w3.org/1999/xlink',false);});// String SVG attributes with the xml namespace.
  ['xml:base','xml:lang','xml:space'// NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
  ].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
  attributeName,'http://www.w3.org/XML/1998/namespace',false);});// These attribute exists both in HTML and SVG.
  // The attribute name is case-sensitive in SVG so we can't just use
  // the React name like we do for attributes that exist only in HTML.
  ['tabIndex','crossOrigin'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty
  attributeName.toLowerCase(),// attributeName
  null,// attributeNamespace
  false);});// These attributes accept URLs. These must not allow javascript: URLS.
  // These will also need to accept Trusted Types object in the future.
  var xlinkHref='xlinkHref';properties[xlinkHref]=new PropertyInfoRecord('xlinkHref',STRING,false,// mustUseProperty
  'xlink:href','http://www.w3.org/1999/xlink',true);['src','href','action','formAction'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty
  attributeName.toLowerCase(),// attributeName
  null,// attributeNamespace
  true);});{ReactSharedInternals.ReactDebugCurrentFrame;}// A javascript: URL can contain leading C0 control or \u0020 SPACE,
  // and any newline or tab are filtered out as if they're not part of the URL.
  // https://url.spec.whatwg.org/#url-parsing
  // Tab or newline are defined as \r\n\t:
  // https://infra.spec.whatwg.org/#ascii-tab-or-newline
  // A C0 control is a code point in the range \u0000 NULL to \u001F
  // INFORMATION SEPARATOR ONE, inclusive:
  // https://infra.spec.whatwg.org/#c0-control-or-space
  /* eslint-disable max-len */var isJavaScriptProtocol=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;var didWarn=false;function sanitizeURL(url){{if(!didWarn&&isJavaScriptProtocol.test(url)){didWarn=true;error('A future version of React will block javascript: URLs as a security precaution. '+'Use event handlers instead if you can. If you need to generate unsafe HTML try '+'using dangerouslySetInnerHTML instead. React was passed %s.',JSON.stringify(url));}}}/**
   * Get the value for a property on a node. Only used in DEV for SSR validation.
   * The "expected" argument is used as a hint of what the expected value is.
   * Some properties have multiple equivalent values.
   */function getValueForProperty(node,name,expected,propertyInfo){{if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName];}else {if(propertyInfo.sanitizeURL){// If we haven't fully disabled javascript: URLs, and if
  // the hydration is successful of a javascript: URL, we
  // still want to warn on the client.
  sanitizeURL(''+expected);}var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return value;}if(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,false)){// We had an attribute but shouldn't have had one, so read it
  // for the error message.
  return node.getAttribute(attributeName);}if(propertyInfo.type===BOOLEAN){// If this was a boolean, it doesn't matter what the value is
  // the fact that we have it is the same as the expected.
  return expected;}// Even if this property uses a namespace we use getAttribute
  // because we assume its namespaced name is the same as our config.
  // To use getAttributeNS we need the local name which we don't have
  // in our config atm.
  stringValue=node.getAttribute(attributeName);}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return stringValue===null?expected:stringValue;}else if(stringValue===''+expected){return expected;}else {return stringValue;}}}}/**
   * Get the value for a attribute on a node. Only used in DEV for SSR validation.
   * The third argument is used as a hint of what the expected value is. Some
   * attributes have multiple equivalent values.
   */function getValueForAttribute(node,name,expected){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);if(value===''+expected){return expected;}return value;}}/**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){return;}if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)){value=null;}// If the prop isn't in the special list, treat it as a simple attribute.
  if(isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;if(value===null){node.removeAttribute(_attributeName);}else {node.setAttribute(_attributeName,''+value);}}return;}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?false:'';}else {// Contrary to `setAttribute`, object properties are properly
  // `toString`ed by IE8/9.
  node[propertyName]=value;}return;}// The rest are treated as attributes with special cases.
  var attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null){node.removeAttribute(attributeName);}else {var _type=propertyInfo.type;var attributeValue;if(_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===true){// If attribute type is boolean, we know for sure it won't be an execution sink
  // and we won't require Trusted Type here.
  attributeValue='';}else {// `setAttribute` with objects becomes only `[object]` in IE8/9,
  // ('' + value) makes it output the correct toString()-value.
  {attributeValue=''+value;}if(propertyInfo.sanitizeURL){sanitizeURL(attributeValue.toString());}}if(attributeNamespace){node.setAttributeNS(attributeNamespace,attributeName,attributeValue);}else {node.setAttribute(attributeName,attributeValue);}}}var BEFORE_SLASH_RE=/^(.*)[\\\/]/;function describeComponentFrame(name,source,ownerName){var sourceInfo='';if(source){var path=source.fileName;var fileName=path.replace(BEFORE_SLASH_RE,'');{// In DEV, include code for a common special case:
  // prefer "folder/index.js" instead of just "index.js".
  if(/^index\./.test(fileName)){var match=path.match(BEFORE_SLASH_RE);if(match){var pathBeforeSlash=match[1];if(pathBeforeSlash){var folderName=pathBeforeSlash.replace(BEFORE_SLASH_RE,'');fileName=folderName+'/'+fileName;}}}}sourceInfo=' (at '+fileName+':'+source.lineNumber+')';}else if(ownerName){sourceInfo=' (created by '+ownerName+')';}return '\n    in '+(name||'Unknown')+sourceInfo;}// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
  // nor polyfill, then a plain number is used for performance.
  var hasSymbol=typeof Symbol==='function'&&Symbol.for;var REACT_ELEMENT_TYPE=hasSymbol?Symbol.for('react.element'):0xeac7;var REACT_PORTAL_TYPE=hasSymbol?Symbol.for('react.portal'):0xeaca;var REACT_FRAGMENT_TYPE=hasSymbol?Symbol.for('react.fragment'):0xeacb;var REACT_STRICT_MODE_TYPE=hasSymbol?Symbol.for('react.strict_mode'):0xeacc;var REACT_PROFILER_TYPE=hasSymbol?Symbol.for('react.profiler'):0xead2;var REACT_PROVIDER_TYPE=hasSymbol?Symbol.for('react.provider'):0xeacd;var REACT_CONTEXT_TYPE=hasSymbol?Symbol.for('react.context'):0xeace;// TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
  var REACT_CONCURRENT_MODE_TYPE=hasSymbol?Symbol.for('react.concurrent_mode'):0xeacf;var REACT_FORWARD_REF_TYPE=hasSymbol?Symbol.for('react.forward_ref'):0xead0;var REACT_SUSPENSE_TYPE=hasSymbol?Symbol.for('react.suspense'):0xead1;var REACT_SUSPENSE_LIST_TYPE=hasSymbol?Symbol.for('react.suspense_list'):0xead8;var REACT_MEMO_TYPE=hasSymbol?Symbol.for('react.memo'):0xead3;var REACT_LAZY_TYPE=hasSymbol?Symbol.for('react.lazy'):0xead4;var REACT_BLOCK_TYPE=hasSymbol?Symbol.for('react.block'):0xead9;var MAYBE_ITERATOR_SYMBOL=typeof Symbol==='function'&&Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable!=='object'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var Uninitialized=-1;var Pending=0;var Resolved=1;var Rejected=2;function refineResolvedLazyComponent(lazyComponent){return lazyComponent._status===Resolved?lazyComponent._result:null;}function initializeLazyComponentType(lazyComponent){if(lazyComponent._status===Uninitialized){lazyComponent._status=Pending;var ctor=lazyComponent._ctor;var thenable=ctor();lazyComponent._result=thenable;thenable.then(function(moduleObject){if(lazyComponent._status===Pending){var defaultExport=moduleObject.default;{if(defaultExport===undefined){error('lazy: Expected the result of a dynamic import() call. '+'Instead received: %s\n\nYour code should look like: \n  '+"const MyComponent = lazy(() => import('./MyComponent'))",moduleObject);}}lazyComponent._status=Resolved;lazyComponent._result=defaultExport;}},function(error){if(lazyComponent._status===Pending){lazyComponent._status=Rejected;lazyComponent._result=error;}});}}function getWrappedName(outerType,innerType,wrapperName){var functionName=innerType.displayName||innerType.name||'';return outerType.displayName||(functionName!==''?wrapperName+"("+functionName+")":wrapperName);}function getComponentName(type){if(type==null){// Host root, text node or just invalid type.
  return null;}{if(typeof type.tag==='number'){error('Received an unexpected object in getComponentName(). '+'This is likely a bug in React. Please file an issue.');}}if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}switch(type){case REACT_FRAGMENT_TYPE:return 'Fragment';case REACT_PORTAL_TYPE:return 'Portal';case REACT_PROFILER_TYPE:return "Profiler";case REACT_STRICT_MODE_TYPE:return 'StrictMode';case REACT_SUSPENSE_TYPE:return 'Suspense';case REACT_SUSPENSE_LIST_TYPE:return 'SuspenseList';}if(typeof type==='object'){switch(type.$$typeof){case REACT_CONTEXT_TYPE:return 'Context.Consumer';case REACT_PROVIDER_TYPE:return 'Context.Provider';case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,'ForwardRef');case REACT_MEMO_TYPE:return getComponentName(type.type);case REACT_BLOCK_TYPE:return getComponentName(type.render);case REACT_LAZY_TYPE:{var thenable=type;var resolvedThenable=refineResolvedLazyComponent(thenable);if(resolvedThenable){return getComponentName(resolvedThenable);}break;}}}return null;}var ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function describeFiber(fiber){switch(fiber.tag){case HostRoot:case HostPortal:case HostText:case Fragment:case ContextProvider:case ContextConsumer:return '';default:var owner=fiber._debugOwner;var source=fiber._debugSource;var name=getComponentName(fiber.type);var ownerName=null;if(owner){ownerName=getComponentName(owner.type);}return describeComponentFrame(name,source,ownerName);}}function getStackByFiberInDevAndProd(workInProgress){var info='';var node=workInProgress;do{info+=describeFiber(node);node=node.return;}while(node);return info;}var current=null;var isRendering=false;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null){return null;}var owner=current._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentName(owner.type);}}return null;}function getCurrentFiberStackInDev(){{if(current===null){return '';}// Safe because if current fiber exists, we are reconciling,
  // and it is guaranteed to be the work-in-progress version.
  return getStackByFiberInDevAndProd(current);}}function resetCurrentFiber(){{ReactDebugCurrentFrame$1.getCurrentStack=null;current=null;isRendering=false;}}function setCurrentFiber(fiber){{ReactDebugCurrentFrame$1.getCurrentStack=getCurrentFiberStackInDev;current=fiber;isRendering=false;}}function setIsRendering(rendering){{isRendering=rendering;}}// Flow does not allow string concatenation of most non-string types. To work
  // around this limitation, we use an opaque type that can only be obtained by
  // passing the value through getToStringValue first.
  function toString(value){return ''+value;}function getToStringValue(value){switch(typeof value){case'boolean':case'number':case'object':case'string':case'undefined':return value;default:// function, symbol are assigned as empty strings
  return '';}}var ReactDebugCurrentFrame$2=null;var ReactControlledValuePropTypes={checkPropTypes:null};{ReactDebugCurrentFrame$2=ReactSharedInternals.ReactDebugCurrentFrame;var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};var propTypes={value:function(props,propName,componentName){if(hasReadOnlyValue[props.type]||props.onChange||props.readOnly||props.disabled||props[propName]==null||enableDeprecatedFlareAPI){return null;}return new Error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');},checked:function(props,propName,componentName){if(props.onChange||props.readOnly||props.disabled||props[propName]==null||enableDeprecatedFlareAPI){return null;}return new Error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}};/**
     * Provide a linked `value` attribute for controlled forms. You should not use
     * this outside of the ReactDOM controlled form components.
     */ReactControlledValuePropTypes.checkPropTypes=function(tagName,props){checkPropTypes(propTypes,props,'prop',tagName,ReactDebugCurrentFrame$2.getStackAddendum);};}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else {value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail
  // and don't track value will cause over reporting of changes,
  // but it's better then a hard failure
  // (needed for certain tests that spyOn input values and Safari)
  if(node.hasOwnProperty(valueField)||typeof descriptor==='undefined'||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}var get=descriptor.get,set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function(){return get.call(this);},set:function(value){currentValue=''+value;set.call(this,value);}});// We could've passed this the first time
  // but it triggers a bug in IE11 and Edge 14/15.
  // Calling defineProperty() again should be equivalent.
  // https://github.com/facebook/react/issues/11768
  Object.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function(){return currentValue;},setValue:function(value){currentValue=''+value;},stopTracking:function(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState
  node._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely
  // that trying again will succeed
  if(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**
   * Implements an <input> host component that allows setting these optional
   * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
   *
   * If `checked` or `value` are not supplied (or null/undefined), user actions
   * that affect the checked state or value will trigger updates to the element.
   *
   * If they are supplied (and not null/undefined), the rendered element will not
   * trigger updates to the element. Instead, the props must change in order for
   * the rendered element to be updated.
   *
   * The rendered element will be initialized as unchecked (or `defaultChecked`)
   * with an empty value (or `defaultValue`).
   *
   * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
   */function getHostProps(element,props){var node=element;var checked=props.checked;var hostProps=_assign({},props,{defaultChecked:undefined,defaultValue:undefined,value:undefined,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{ReactControlledValuePropTypes.checkPropTypes('input',props);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){error('%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){error('%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnValueDefaultValue=true;}}var node=element;var defaultValue=props.defaultValue==null?'':props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getToStringValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked,false);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){error('A component is changing an uncontrolled input of type %s to be controlled. '+'Input elements should not switch from uncontrolled to controlled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components',props.type);didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){error('A component is changing a controlled input of type %s to be uncontrolled. '+'Input elements should not switch from controlled to uncontrolled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components',props.type);didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=getToStringValue(props.value);var type=props.type;if(value!=null){if(type==='number'){if(value===0&&node.value===''||// We explicitly want to coerce to number here if possible.
  // eslint-disable-next-line
  node.value!=value){node.value=toString(value);}}else if(node.value!==toString(value)){node.value=toString(value);}}else if(type==='submit'||type==='reset'){// Submit/reset inputs need the attribute removed completely to avoid
  // blank-text buttons.
  node.removeAttribute('value');return;}{// When syncing the value attribute, the value comes from a cascade of
  // properties:
  //  1. The value React property
  //  2. The defaultValue React property
  //  3. Otherwise there should be no change
  if(props.hasOwnProperty('value')){setDefaultValue(node,props.type,value);}else if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}{// When syncing the checked attribute, it only changes when it needs
  // to be removed, such as transitioning from a checkbox into a text input
  if(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props,isHydrating){var node=element;// Do not assign value if it is already set. This prevents user text input
  // from being lost during SSR hydration.
  if(props.hasOwnProperty('value')||props.hasOwnProperty('defaultValue')){var type=props.type;var isButton=type==='submit'||type==='reset';// Avoid setting value attribute on submit/reset inputs as it overrides the
  // default value provided by the browser. See: #12872
  if(isButton&&(props.value===undefined||props.value===null)){return;}var initialValue=toString(node._wrapperState.initialValue);// Do not assign value if it is already set. This prevents user text input
  // from being lost during SSR hydration.
  if(!isHydrating){{// When syncing the value attribute, the value property should use
  // the wrapperState._initialValue property. This uses:
  //
  //   1. The value React property when present
  //   2. The defaultValue React property when present
  //   3. An empty string
  if(initialValue!==node.value){node.value=initialValue;}}}{// Otherwise, the value attribute is synchronized to the property,
  // so we assign defaultValue to the same thing as the value property
  // assignment step above.
  node.defaultValue=initialValue;}}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.
  var name=node.name;if(name!==''){node.name='';}{// When syncing the checked attribute, both the checked property and
  // attribute are assigned at the same time using defaultChecked. This uses:
  //
  //   1. The checked React property when present
  //   2. The defaultChecked React property when present
  //   3. Otherwise, false
  node.defaultChecked=!node.defaultChecked;node.defaultChecked=!!node._wrapperState.initialChecked;}if(name!==''){node.name=name;}}function restoreControlledState(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,
  // but that sometimes behaves strangely in IE8. We could also try using
  // `form.getElementsByName`, but that will only return direct children
  // and won't include inputs that use the HTML5 `form=` attribute. Since
  // the input might not even be in a form. It might not even be in the
  // document. Let's just use the local `querySelectorAll` to ensure we don't
  // miss anything.
  var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type="radio"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React
  // and the same name are rendered into the same form (same as #1939).
  // That's probably okay; we don't support it just as we don't support
  // mixing React radio buttons with non-React ones.
  var otherProps=getFiberCurrentPropsFromNode$1(otherNode);if(!otherProps){{throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");}}// We need update the tracked value on the named cousin since the value
  // was changed but the input saw no event or value set
  updateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that
  // was previously checked to update will cause it to be come re-checked
  // as appropriate.
  updateWrapper(otherNode,otherProps);}}}// In Chrome, assigning defaultValue to certain input types triggers input validation.
  // For number inputs, the display value loses trailing decimal points. For email inputs,
  // Chrome raises "The specified value <x> is not a valid email address".
  //
  // Here we check to see if the defaultValue has actually changed, avoiding these problems
  // when the user is inputting text
  //
  // https://github.com/facebook/react/issues/7253
  function setDefaultValue(node,type,value){if(// Focused number inputs synchronize on blur. See ChangeEventPlugin.js
  type!=='number'||node.ownerDocument.activeElement!==node){if(value==null){node.defaultValue=toString(node._wrapperState.initialValue);}else if(node.defaultValue!==toString(value)){node.defaultValue=toString(value);}}}var didWarnSelectedSetOnOption=false;var didWarnInvalidChild=false;function flattenChildren(children){var content='';// Flatten children. We'll warn if they are invalid
  // during validateProps() which runs for hydration too.
  // Note that this would throw on non-element objects.
  // Elements are stringified (which is normally irrelevant
  // but matters for <fbt>).
  React.Children.forEach(children,function(child){if(child==null){return;}content+=child;// Note: we don't warn about invalid children here.
  // Instead, this is done separately below so that
  // it happens during the hydration codepath too.
  });return content;}/**
   * Implements an <option> host component that warns when `selected` is set.
   */function validateProps(element,props){{// This mirrors the codepath above, but runs for hydration too.
  // Warn about invalid children here so that client and hydration are consistent.
  // TODO: this seems like it could cause a DEV-only throw for hydration
  // if children contains a non-element object. We should try to avoid that.
  if(typeof props.children==='object'&&props.children!==null){React.Children.forEach(props.children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){return;}if(typeof child.type!=='string'){return;}if(!didWarnInvalidChild){didWarnInvalidChild=true;error('Only strings and numbers are supported as <option> children.');}});}// TODO: Remove support for `selected` in <option>.
  if(props.selected!=null&&!didWarnSelectedSetOnOption){error('Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');didWarnSelectedSetOnOption=true;}}}function postMountWrapper$1(element,props){// value="" should make a value attribute (#6219)
  if(props.value!=null){element.setAttribute('value',toString(getToStringValue(props.value)));}}function getHostProps$1(element,props){var hostProps=_assign({children:undefined},props);var content=flattenChildren(props.children);if(content){hostProps.children=content;}return hostProps;}var didWarnValueDefaultValue$1;{didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){return '\n\nCheck the render method of `'+ownerName+'`.';}return '';}var valuePropNames=['value','defaultValue'];/**
   * Validation function for `value` and `defaultValue`.
   */function checkSelectPropTypes(props){{ReactControlledValuePropTypes.checkPropTypes('select',props);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var isArray=Array.isArray(props[propName]);if(props.multiple&&!isArray){error('The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&isArray){error('The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.
  selectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else {// Do not set `select.value` as exact behavior isn't consistent across all
  // browsers for all cases.
  var _selectedValue=toString(getToStringValue(propValue));var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**
   * Implements a <select> host component that allows optionally setting the
   * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
   * stringable. If `multiple` is true, the prop must be an array of stringables.
   *
   * If `value` is not supplied (or null/undefined), user actions that change the
   * selected option will trigger updates to the rendered options.
   *
   * If it is supplied (and not null/undefined), the rendered options will not
   * update in response to user actions. Instead, the `value` prop must change in
   * order for the rendered options to update.
   *
   * If `defaultValue` is provided, any options with the supplied values will be
   * selected.
   */function getHostProps$2(element,props){return _assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}node._wrapperState={wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){error('Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.
  if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else {// Revert the select back to its default unselected state.
  updateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$1(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}var didWarnValDefaultVal=false;/**
   * Implements a <textarea> host component that allows setting `value`, and
   * `defaultValue`. This differs from the traditional DOM API because value is
   * usually set as PCDATA children.
   *
   * If `value` is not supplied (or null/undefined), user actions that affect the
   * value will trigger updates to the element.
   *
   * If `value` is supplied (and not null/undefined), the rendered element will
   * not trigger updates to the element. Instead, the `value` prop must change in
   * order for the rendered element to be updated.
   *
   * The rendered element will be initialized with an empty value, the prop
   * `defaultValue` if specified, or the children content (deprecated).
   */function getHostProps$3(element,props){var node=element;if(!(props.dangerouslySetInnerHTML==null)){{throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");}}// Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
  // solution. The value can be a boolean or object so that's why it's forced
  // to be a string.
  var hostProps=_assign({},props,{value:undefined,defaultValue:undefined,children:toString(node._wrapperState.initialValue)});return hostProps;}function initWrapperState$2(element,props){var node=element;{ReactControlledValuePropTypes.checkPropTypes('textarea',props);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){error('%s contains a textarea with both value and defaultValue props. '+'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it
  if(initialValue==null){var children=props.children,defaultValue=props.defaultValue;if(children!=null){{error('Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}{if(!(defaultValue==null)){{throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");}}if(Array.isArray(children)){if(!(children.length<=1)){{throw Error("<textarea> can only have at most one child.");}}children=children[0];}defaultValue=children;}}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:getToStringValue(initialValue)};}function updateWrapper$1(element,props){var node=element;var value=getToStringValue(props.value);var defaultValue=getToStringValue(props.defaultValue);if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While
  // browsers typically do this as necessary, jsdom doesn't.
  var newValue=toString(value);// To avoid side effects (such as losing text selection), only set value if changed
  if(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null&&node.defaultValue!==newValue){node.defaultValue=newValue;}}if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.
  var textContent=node.textContent;// Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
  if(textContent===node._wrapperState.initialValue){if(textContent!==''&&textContent!==null){node.value=textContent;}}}function restoreControlledState$2(element,props){// DOM component is still mounted; update
  updateWrapper$1(element,props);}var HTML_NAMESPACE='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';var Namespaces={html:HTML_NAMESPACE,mathml:MATH_NAMESPACE,svg:SVG_NAMESPACE};// Assumes there is no parent namespace.
  function getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE){// No (or default) parent namespace: potential entry point.
  return getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.
  return HTML_NAMESPACE;}// By default, pass namespace below.
  return parentNamespace;}/* globals MSApp */ /**
   * Create a function which has 'unsafe' privileges (required by windows8 apps)
   */var createMicrosoftUnsafeLocalFunction=function(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else {return func;}};var reusableSVGContainer;/**
   * Set the innerHTML property of a node
   *
   * @param {DOMElement} node
   * @param {string} html
   * @internal
   */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){if(node.namespaceURI===Namespaces.svg){if(!('innerHTML'in node)){// IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node
  reusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html.valueOf().toString()+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}return;}}node.innerHTML=html;});/**
   * HTML nodeType values that represent the type of the node
   */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**
   * Set the textContent property of a node. For text updates, it's faster
   * to set the `nodeValue` of the Text node directly instead of using
   * `.textContent` which will remove the existing node and create a new one.
   *
   * @param {DOMElement} node
   * @param {string} text
   * @internal
   */var setTextContent=function(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};// Do not use the below two methods directly!
  // Instead use constants exported from DOMTopLevelEventTypes in ReactDOM.
  // (It is the only module that is allowed to access these methods.)
  function unsafeCastStringToDOMTopLevelType(topLevelType){return topLevelType;}function unsafeCastDOMTopLevelTypeToString(topLevelType){return topLevelType;}/**
   * Generate a mapping of standard vendor prefixes using the defined style property and event name.
   *
   * @param {string} styleProp
   * @param {string} eventName
   * @returns {object}
   */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;return prefixes;}/**
   * A list of event names to a configurable list of vendor prefixes.
   */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**
   * Event names that have already been detected and prefixed (if applicable).
   */var prefixedEventNames={};/**
   * Element to check for prefixes on.
   */var style={};/**
   * Bootstrap if a DOM exists.
   */if(canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above
  if(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**
   * Attempts to determine the correct vendor prefixed event name.
   *
   * @param {string} eventName
   * @returns {string}
   */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return eventName;}/**
   * To identify top level events in ReactDOM, we use constants defined by this
   * module. This is the only module that uses the unsafe* methods to express
   * that the constants actually correspond to the browser event names. This lets
   * us save some bundle size by avoiding a top level type -> event name map.
   * The rest of ReactDOM code should import top level types from this file.
   */var TOP_ABORT=unsafeCastStringToDOMTopLevelType('abort');var TOP_ANIMATION_END=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationend'));var TOP_ANIMATION_ITERATION=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationiteration'));var TOP_ANIMATION_START=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationstart'));var TOP_BLUR=unsafeCastStringToDOMTopLevelType('blur');var TOP_CAN_PLAY=unsafeCastStringToDOMTopLevelType('canplay');var TOP_CAN_PLAY_THROUGH=unsafeCastStringToDOMTopLevelType('canplaythrough');var TOP_CANCEL=unsafeCastStringToDOMTopLevelType('cancel');var TOP_CHANGE=unsafeCastStringToDOMTopLevelType('change');var TOP_CLICK=unsafeCastStringToDOMTopLevelType('click');var TOP_CLOSE=unsafeCastStringToDOMTopLevelType('close');var TOP_COMPOSITION_END=unsafeCastStringToDOMTopLevelType('compositionend');var TOP_COMPOSITION_START=unsafeCastStringToDOMTopLevelType('compositionstart');var TOP_COMPOSITION_UPDATE=unsafeCastStringToDOMTopLevelType('compositionupdate');var TOP_CONTEXT_MENU=unsafeCastStringToDOMTopLevelType('contextmenu');var TOP_COPY=unsafeCastStringToDOMTopLevelType('copy');var TOP_CUT=unsafeCastStringToDOMTopLevelType('cut');var TOP_DOUBLE_CLICK=unsafeCastStringToDOMTopLevelType('dblclick');var TOP_AUX_CLICK=unsafeCastStringToDOMTopLevelType('auxclick');var TOP_DRAG=unsafeCastStringToDOMTopLevelType('drag');var TOP_DRAG_END=unsafeCastStringToDOMTopLevelType('dragend');var TOP_DRAG_ENTER=unsafeCastStringToDOMTopLevelType('dragenter');var TOP_DRAG_EXIT=unsafeCastStringToDOMTopLevelType('dragexit');var TOP_DRAG_LEAVE=unsafeCastStringToDOMTopLevelType('dragleave');var TOP_DRAG_OVER=unsafeCastStringToDOMTopLevelType('dragover');var TOP_DRAG_START=unsafeCastStringToDOMTopLevelType('dragstart');var TOP_DROP=unsafeCastStringToDOMTopLevelType('drop');var TOP_DURATION_CHANGE=unsafeCastStringToDOMTopLevelType('durationchange');var TOP_EMPTIED=unsafeCastStringToDOMTopLevelType('emptied');var TOP_ENCRYPTED=unsafeCastStringToDOMTopLevelType('encrypted');var TOP_ENDED=unsafeCastStringToDOMTopLevelType('ended');var TOP_ERROR=unsafeCastStringToDOMTopLevelType('error');var TOP_FOCUS=unsafeCastStringToDOMTopLevelType('focus');var TOP_GOT_POINTER_CAPTURE=unsafeCastStringToDOMTopLevelType('gotpointercapture');var TOP_INPUT=unsafeCastStringToDOMTopLevelType('input');var TOP_INVALID=unsafeCastStringToDOMTopLevelType('invalid');var TOP_KEY_DOWN=unsafeCastStringToDOMTopLevelType('keydown');var TOP_KEY_PRESS=unsafeCastStringToDOMTopLevelType('keypress');var TOP_KEY_UP=unsafeCastStringToDOMTopLevelType('keyup');var TOP_LOAD=unsafeCastStringToDOMTopLevelType('load');var TOP_LOAD_START=unsafeCastStringToDOMTopLevelType('loadstart');var TOP_LOADED_DATA=unsafeCastStringToDOMTopLevelType('loadeddata');var TOP_LOADED_METADATA=unsafeCastStringToDOMTopLevelType('loadedmetadata');var TOP_LOST_POINTER_CAPTURE=unsafeCastStringToDOMTopLevelType('lostpointercapture');var TOP_MOUSE_DOWN=unsafeCastStringToDOMTopLevelType('mousedown');var TOP_MOUSE_MOVE=unsafeCastStringToDOMTopLevelType('mousemove');var TOP_MOUSE_OUT=unsafeCastStringToDOMTopLevelType('mouseout');var TOP_MOUSE_OVER=unsafeCastStringToDOMTopLevelType('mouseover');var TOP_MOUSE_UP=unsafeCastStringToDOMTopLevelType('mouseup');var TOP_PASTE=unsafeCastStringToDOMTopLevelType('paste');var TOP_PAUSE=unsafeCastStringToDOMTopLevelType('pause');var TOP_PLAY=unsafeCastStringToDOMTopLevelType('play');var TOP_PLAYING=unsafeCastStringToDOMTopLevelType('playing');var TOP_POINTER_CANCEL=unsafeCastStringToDOMTopLevelType('pointercancel');var TOP_POINTER_DOWN=unsafeCastStringToDOMTopLevelType('pointerdown');var TOP_POINTER_MOVE=unsafeCastStringToDOMTopLevelType('pointermove');var TOP_POINTER_OUT=unsafeCastStringToDOMTopLevelType('pointerout');var TOP_POINTER_OVER=unsafeCastStringToDOMTopLevelType('pointerover');var TOP_POINTER_UP=unsafeCastStringToDOMTopLevelType('pointerup');var TOP_PROGRESS=unsafeCastStringToDOMTopLevelType('progress');var TOP_RATE_CHANGE=unsafeCastStringToDOMTopLevelType('ratechange');var TOP_RESET=unsafeCastStringToDOMTopLevelType('reset');var TOP_SCROLL=unsafeCastStringToDOMTopLevelType('scroll');var TOP_SEEKED=unsafeCastStringToDOMTopLevelType('seeked');var TOP_SEEKING=unsafeCastStringToDOMTopLevelType('seeking');var TOP_SELECTION_CHANGE=unsafeCastStringToDOMTopLevelType('selectionchange');var TOP_STALLED=unsafeCastStringToDOMTopLevelType('stalled');var TOP_SUBMIT=unsafeCastStringToDOMTopLevelType('submit');var TOP_SUSPEND=unsafeCastStringToDOMTopLevelType('suspend');var TOP_TEXT_INPUT=unsafeCastStringToDOMTopLevelType('textInput');var TOP_TIME_UPDATE=unsafeCastStringToDOMTopLevelType('timeupdate');var TOP_TOGGLE=unsafeCastStringToDOMTopLevelType('toggle');var TOP_TOUCH_CANCEL=unsafeCastStringToDOMTopLevelType('touchcancel');var TOP_TOUCH_END=unsafeCastStringToDOMTopLevelType('touchend');var TOP_TOUCH_MOVE=unsafeCastStringToDOMTopLevelType('touchmove');var TOP_TOUCH_START=unsafeCastStringToDOMTopLevelType('touchstart');var TOP_TRANSITION_END=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('transitionend'));var TOP_VOLUME_CHANGE=unsafeCastStringToDOMTopLevelType('volumechange');var TOP_WAITING=unsafeCastStringToDOMTopLevelType('waiting');var TOP_WHEEL=unsafeCastStringToDOMTopLevelType('wheel');// List of events that need to be individually attached to media elements.
  // Note that events in this list will *not* be listened to at the top level
  // unless they're explicitly whitelisted in `ReactBrowserEventEmitter.listenTo`.
  var mediaEventTypes=[TOP_ABORT,TOP_CAN_PLAY,TOP_CAN_PLAY_THROUGH,TOP_DURATION_CHANGE,TOP_EMPTIED,TOP_ENCRYPTED,TOP_ENDED,TOP_ERROR,TOP_LOADED_DATA,TOP_LOADED_METADATA,TOP_LOAD_START,TOP_PAUSE,TOP_PLAY,TOP_PLAYING,TOP_PROGRESS,TOP_RATE_CHANGE,TOP_SEEKED,TOP_SEEKING,TOP_STALLED,TOP_SUSPEND,TOP_TIME_UPDATE,TOP_VOLUME_CHANGE,TOP_WAITING];function getRawEventName(topLevelType){return unsafeCastDOMTopLevelTypeToString(topLevelType);}var PossiblyWeakMap=typeof WeakMap==='function'?WeakMap:Map;// prettier-ignore
  var elementListenerMap=new PossiblyWeakMap();function getListenerMapForElement(element){var listenerMap=elementListenerMap.get(element);if(listenerMap===undefined){listenerMap=new Map();elementListenerMap.set(element,listenerMap);}return listenerMap;}/**
   * `ReactInstanceMap` maintains a mapping from a public facing stateful
   * instance (key) and the internal representation (value). This allows public
   * methods to accept the user facing instance as an argument and map them back
   * to internal methods.
   *
   * Note that this module is currently shared and assumed to be stateless.
   * If this becomes an actual Map, that will break.
   */function get(key){return key._reactInternalFiber;}function has(key){return key._reactInternalFiber!==undefined;}function set(key,value){key._reactInternalFiber=value;}// Don't change these two values. They're used by React Dev Tools.
  var NoEffect=/*              */0;var PerformedWork=/*         */1;// You can change the rest (and add more).
  var Placement=/*             */2;var Update=/*                */4;var PlacementAndUpdate=/*    */6;var Deletion=/*              */8;var ContentReset=/*          */16;var Callback=/*              */32;var DidCapture=/*            */64;var Ref=/*                   */128;var Snapshot=/*              */256;var Passive=/*               */512;var Hydrating=/*             */1024;var HydratingAndUpdate=/*    */1028;// Passive & Update & Callback & Ref & Snapshot
  var LifecycleEffectMask=/*   */932;// Union of all host effects
  var HostEffectMask=/*        */2047;var Incomplete=/*            */2048;var ShouldCapture=/*         */4096;var ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;function getNearestMountedFiber(fiber){var node=fiber;var nearestMounted=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted
  // yet. If it is, then it will have a pending insertion effect on it.
  var nextNode=node;do{node=nextNode;if((node.effectTag&(Placement|Hydrating))!==NoEffect){// This is an insertion or in-progress hydration. The nearest possible
  // mounted fiber is the parent but we need to continue to figure out
  // if that one is still mounted.
  nearestMounted=node.return;}nextNode=node.return;}while(nextNode);}else {while(node.return){node=node.return;}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with
  // renderContainerIntoSubtree.
  return nearestMounted;}// If we didn't hit the root, that means that we're in an disconnected tree
  // that has been unmounted.
  return null;}function getSuspenseInstanceFromFiber(fiber){if(fiber.tag===SuspenseComponent){var suspenseState=fiber.memoizedState;if(suspenseState===null){var current=fiber.alternate;if(current!==null){suspenseState=current.memoizedState;}}if(suspenseState!==null){return suspenseState.dehydrated;}}return null;}function getContainerFromFiber(fiber){return fiber.tag===HostRoot?fiber.stateNode.containerInfo:null;}function isFiberMounted(fiber){return getNearestMountedFiber(fiber)===fiber;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;if(!instance._warnedAboutRefsInRender){error('%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(ownerFiber.type)||'A component');}instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return getNearestMountedFiber(fiber)===fiber;}function assertIsMounted(fiber){if(!(getNearestMountedFiber(fiber)===fiber)){{throw Error("Unable to find node on an unmounted component.");}}}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.
  var nearestMounted=getNearestMountedFiber(fiber);if(!(nearestMounted!==null)){{throw Error("Unable to find node on an unmounted component.");}}if(nearestMounted!==fiber){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root
  // to see what path the root points to. On the way we may hit one of the
  // special cases and we'll deal with them.
  var a=fiber;var b=alternate;while(true){var parentA=a.return;if(parentA===null){// We're at the root.
  break;}var parentB=parentA.alternate;if(parentB===null){// There is no alternate. This is an unusual case. Currently, it only
  // happens when a Suspense component is hidden. An extra fragment fiber
  // is inserted in between the Suspense fiber and its children. Skip
  // over this extra fragment fiber and proceed to the next parent.
  var nextParent=parentA.return;if(nextParent!==null){a=b=nextParent;continue;}// If there's no parent, we're at the root.
  break;}// If both copies of the parent fiber point to the same child, we can
  // assume that the child is current. This happens when we bailout on low
  // priority: the bailed out fiber's child reuses the current child.
  if(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.
  assertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.
  assertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only
  // way this could possibly happen is if this was unmounted, if at all.
  {{throw Error("Unable to find node on an unmounted component.");}}}if(a.return!==b.return){// The return pointer of A and the return pointer of B point to different
  // fibers. We assume that return pointers never criss-cross, so A must
  // belong to the child set of A.return, and B must belong to the child
  // set of B.return.
  a=parentA;b=parentB;}else {// The return pointers point to the same fiber. We'll have to use the
  // default, slow path: scan the child sets of each parent alternate to see
  // which child belongs to which set.
  //
  // Search parent A's child set
  var didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set
  _child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}if(!didFindChild){{throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");}}}}if(!(a.alternate===b)){{throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");}}}// If the root is not a host container, we're in a disconnected tree. I.e.
  // unmounted.
  if(!(a.tag===HostRoot)){{throw Error("Unable to find node on an unmounted component.");}}if(a.stateNode.current===a){// We've determined that A is the current branch.
  return fiber;}// Otherwise B has to be current branch.
  return alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
  var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child){node.child.return=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node.return||node.return===currentParent){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
  var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText||enableFundamentalAPI){return node;}else if(node.child&&node.tag!==HostPortal){node.child.return=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node.return||node.return===currentParent){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;}/**
   * Accumulates items that must not be null or undefined into the first one. This
   * is used to conserve memory by avoiding array allocations, and thus sacrifices
   * API cleanness. Since `current` can be null before being passed in and not
   * null after this function, make sure to assign it back to `current`:
   *
   * `a = accumulateInto(a, b);`
   *
   * This API should be sparingly used. Try `accumulate` for something cleaner.
   *
   * @return {*|array<*>} An accumulation of items.
   */function accumulateInto(current,next){if(!(next!=null)){{throw Error("accumulateInto(...): Accumulated items must not be null or undefined.");}}if(current==null){return next;}// Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if(Array.isArray(current)){if(Array.isArray(next)){current.push.apply(current,next);return current;}current.push(next);return current;}if(Array.isArray(next)){// A bit too dangerous to mutate `next`.
  return [current].concat(next);}return [current,next];}/**
   * @param {array} arr an "accumulation" of items which is either an Array or
   * a single item. Useful when paired with the `accumulate` module. This is a
   * simple utility that allows us to reason about a collection of items, but
   * handling the case when there is exactly one item (and we do not need to
   * allocate an array).
   * @param {function} cb Callback invoked with each element or a collection.
   * @param {?} [scope] Scope used as `this` in a callback.
   */function forEachAccumulated(arr,cb,scope){if(Array.isArray(arr)){arr.forEach(cb,scope);}else if(arr){cb.call(scope,arr);}}/**
   * Internal queue of events that have accumulated their dispatches and are
   * waiting to have their dispatches executed.
   */var eventQueue=null;/**
   * Dispatches an event and releases it back into the pool, unless persistent.
   *
   * @param {?object} event Synthetic event to be dispatched.
   * @private
   */var executeDispatchesAndRelease=function(event){if(event){executeDispatchesInOrder(event);if(!event.isPersistent()){event.constructor.release(event);}}};var executeDispatchesAndReleaseTopLevel=function(e){return executeDispatchesAndRelease(e);};function runEventsInBatch(events){if(events!==null){eventQueue=accumulateInto(eventQueue,events);}// Set `eventQueue` to null before processing it so that we can tell if more
  // events get enqueued while processing.
  var processingEventQueue=eventQueue;eventQueue=null;if(!processingEventQueue){return;}forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseTopLevel);if(!!eventQueue){{throw Error("processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.");}}// This would be a good time to rethrow if any of the event handlers threw.
  rethrowCaughtError();}/**
   * Gets the target node from a native browser event by accounting for
   * inconsistencies in browser DOM APIs.
   *
   * @param {object} nativeEvent Native browser event.
   * @return {DOMEventTarget} Target node.
   */function getEventTarget(nativeEvent){// Fallback to nativeEvent.srcElement for IE9
  // https://github.com/facebook/react/issues/12506
  var target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963
  if(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType===TEXT_NODE?target.parentNode:target;}/**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   */function isEventSupported(eventNameSuffix){if(!canUseDOM){return false;}var eventName='on'+eventNameSuffix;var isSupported=(eventName in document);if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}return isSupported;}/**
   * Summary of `DOMEventPluginSystem` event handling:
   *
   *  - Top-level delegation is used to trap most native browser events. This
   *    may only occur in the main thread and is the responsibility of
   *    ReactDOMEventListener, which is injected and can therefore support
   *    pluggable event sources. This is the only work that occurs in the main
   *    thread.
   *
   *  - We normalize and de-duplicate events to account for browser quirks. This
   *    may be done in the worker thread.
   *
   *  - Forward these native events (with the associated top-level type used to
   *    trap it) to `EventPluginRegistry`, which in turn will ask plugins if they want
   *    to extract any synthetic events.
   *
   *  - The `EventPluginRegistry` will then process each event by annotating them with
   *    "dispatches", a sequence of listeners and IDs that care about that event.
   *
   *  - The `EventPluginRegistry` then dispatches the events.
   *
   * Overview of React and the event system:
   *
   * +------------+    .
   * |    DOM     |    .
   * +------------+    .
   *       |           .
   *       v           .
   * +------------+    .
   * | ReactEvent |    .
   * |  Listener  |    .
   * +------------+    .                         +-----------+
   *       |           .               +--------+|SimpleEvent|
   *       |           .               |         |Plugin     |
   * +-----|------+    .               v         +-----------+
   * |     |      |    .    +--------------+                    +------------+
   * |     +-----------.--->|PluginRegistry|                    |    Event   |
   * |            |    .    |              |     +-----------+  | Propagators|
   * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
   * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
   * |            |    .    |              |     +-----------+  |  utilities |
   * |     +-----------.--->|              |                    +------------+
   * |     |      |    .    +--------------+
   * +-----|------+    .                ^        +-----------+
   *       |           .                |        |Enter/Leave|
   *       +           .                +-------+|Plugin     |
   * +-------------+   .                         +-----------+
   * | application |   .
   * |-------------|   .
   * |             |   .
   * |             |   .
   * +-------------+   .
   *                   .
   *    React Core     .  General Purpose Event Plugin System
   */var CALLBACK_BOOKKEEPING_POOL_SIZE=10;var callbackBookkeepingPool=[];function releaseTopLevelCallbackBookKeeping(instance){instance.topLevelType=null;instance.nativeEvent=null;instance.targetInst=null;instance.ancestors.length=0;if(callbackBookkeepingPool.length<CALLBACK_BOOKKEEPING_POOL_SIZE){callbackBookkeepingPool.push(instance);}}// Used to store ancestor hierarchy in top level callback
  function getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst,eventSystemFlags){if(callbackBookkeepingPool.length){var instance=callbackBookkeepingPool.pop();instance.topLevelType=topLevelType;instance.eventSystemFlags=eventSystemFlags;instance.nativeEvent=nativeEvent;instance.targetInst=targetInst;return instance;}return {topLevelType:topLevelType,eventSystemFlags:eventSystemFlags,nativeEvent:nativeEvent,targetInst:targetInst,ancestors:[]};}/**
   * Find the deepest React component completely containing the root of the
   * passed-in instance (for use when entire React trees are nested within each
   * other). If React trees are not nested, returns null.
   */function findRootContainerNode(inst){if(inst.tag===HostRoot){return inst.stateNode.containerInfo;}// TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while(inst.return){inst=inst.return;}if(inst.tag!==HostRoot){// This can happen if we're in a detached tree.
  return null;}return inst.stateNode.containerInfo;}/**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @return {*} An accumulation of synthetic events.
   * @internal
   */function extractPluginEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags){var events=null;for(var i=0;i<plugins.length;i++){// Not every plugin in the ordering may be loaded at runtime.
  var possiblePlugin=plugins[i];if(possiblePlugin){var extractedEvents=possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);if(extractedEvents){events=accumulateInto(events,extractedEvents);}}}return events;}function runExtractedPluginEventsInBatch(topLevelType,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags){var events=extractPluginEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);runEventsInBatch(events);}function handleTopLevel(bookKeeping){var targetInst=bookKeeping.targetInst;// Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor=targetInst;do{if(!ancestor){var ancestors=bookKeeping.ancestors;ancestors.push(ancestor);break;}var root=findRootContainerNode(ancestor);if(!root){break;}var tag=ancestor.tag;if(tag===HostComponent||tag===HostText){bookKeeping.ancestors.push(ancestor);}ancestor=getClosestInstanceFromNode(root);}while(ancestor);for(var i=0;i<bookKeeping.ancestors.length;i++){targetInst=bookKeeping.ancestors[i];var eventTarget=getEventTarget(bookKeeping.nativeEvent);var topLevelType=bookKeeping.topLevelType;var nativeEvent=bookKeeping.nativeEvent;var eventSystemFlags=bookKeeping.eventSystemFlags;// If this is the first ancestor, we mark it on the system flags
  if(i===0){eventSystemFlags|=IS_FIRST_ANCESTOR;}runExtractedPluginEventsInBatch(topLevelType,targetInst,nativeEvent,eventTarget,eventSystemFlags);}}function dispatchEventForLegacyPluginEventSystem(topLevelType,eventSystemFlags,nativeEvent,targetInst){var bookKeeping=getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst,eventSystemFlags);try{// Event queue being processed in the same cycle allows
  // `preventDefault`.
  batchedEventUpdates(handleTopLevel,bookKeeping);}finally{releaseTopLevelCallbackBookKeeping(bookKeeping);}}/**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} mountAt Container where to mount the listener
   */function legacyListenToEvent(registrationName,mountAt){var listenerMap=getListenerMapForElement(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];legacyListenToTopLevelEvent(dependency,mountAt,listenerMap);}}function legacyListenToTopLevelEvent(topLevelType,mountAt,listenerMap){if(!listenerMap.has(topLevelType)){switch(topLevelType){case TOP_SCROLL:trapCapturedEvent(TOP_SCROLL,mountAt);break;case TOP_FOCUS:case TOP_BLUR:trapCapturedEvent(TOP_FOCUS,mountAt);trapCapturedEvent(TOP_BLUR,mountAt);// We set the flag for a single dependency later in this function,
  // but this ensures we mark both as attached rather than just one.
  listenerMap.set(TOP_BLUR,null);listenerMap.set(TOP_FOCUS,null);break;case TOP_CANCEL:case TOP_CLOSE:if(isEventSupported(getRawEventName(topLevelType))){trapCapturedEvent(topLevelType,mountAt);}break;case TOP_INVALID:case TOP_SUBMIT:case TOP_RESET:// We listen to them on the target DOM elements.
  // Some of them bubble so we don't want them to fire twice.
  break;default:// By default, listen on the top level to all non-media events.
  // Media events don't bubble so adding the listener wouldn't do anything.
  var isMediaEvent=mediaEventTypes.indexOf(topLevelType)!==-1;if(!isMediaEvent){trapBubbledEvent(topLevelType,mountAt);}break;}listenerMap.set(topLevelType,null);}}function isListeningToAllDependencies(registrationName,mountAt){var listenerMap=getListenerMapForElement(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!listenerMap.has(dependency)){return false;}}return true;}var attemptUserBlockingHydration;function setAttemptUserBlockingHydration(fn){attemptUserBlockingHydration=fn;}var attemptContinuousHydration;function setAttemptContinuousHydration(fn){attemptContinuousHydration=fn;}var attemptHydrationAtCurrentPriority;function setAttemptHydrationAtCurrentPriority(fn){attemptHydrationAtCurrentPriority=fn;}// TODO: Upgrade this definition once we're on a newer version of Flow that
  var hasScheduledReplayAttempt=false;// The queue of discrete events to be replayed.
  var queuedDiscreteEvents=[];// Indicates if any continuous event targets are non-null for early bailout.
  // if the last target was dehydrated.
  var queuedFocus=null;var queuedDrag=null;var queuedMouse=null;// For pointer events there can be one latest event per pointerId.
  var queuedPointers=new Map();var queuedPointerCaptures=new Map();// We could consider replaying selectionchange and touchmoves too.
  var queuedExplicitHydrationTargets=[];function hasQueuedDiscreteEvents(){return queuedDiscreteEvents.length>0;}var discreteReplayableEvents=[TOP_MOUSE_DOWN,TOP_MOUSE_UP,TOP_TOUCH_CANCEL,TOP_TOUCH_END,TOP_TOUCH_START,TOP_AUX_CLICK,TOP_DOUBLE_CLICK,TOP_POINTER_CANCEL,TOP_POINTER_DOWN,TOP_POINTER_UP,TOP_DRAG_END,TOP_DRAG_START,TOP_DROP,TOP_COMPOSITION_END,TOP_COMPOSITION_START,TOP_KEY_DOWN,TOP_KEY_PRESS,TOP_KEY_UP,TOP_INPUT,TOP_TEXT_INPUT,TOP_CLOSE,TOP_CANCEL,TOP_COPY,TOP_CUT,TOP_PASTE,TOP_CLICK,TOP_CHANGE,TOP_CONTEXT_MENU,TOP_RESET,TOP_SUBMIT];var continuousReplayableEvents=[TOP_FOCUS,TOP_BLUR,TOP_DRAG_ENTER,TOP_DRAG_LEAVE,TOP_MOUSE_OVER,TOP_MOUSE_OUT,TOP_POINTER_OVER,TOP_POINTER_OUT,TOP_GOT_POINTER_CAPTURE,TOP_LOST_POINTER_CAPTURE];function isReplayableDiscreteEvent(eventType){return discreteReplayableEvents.indexOf(eventType)>-1;}function trapReplayableEventForDocument(topLevelType,document,listenerMap){legacyListenToTopLevelEvent(topLevelType,document,listenerMap);}function eagerlyTrapReplayableEvents(container,document){var listenerMapForDoc=getListenerMapForElement(document);// Discrete
  discreteReplayableEvents.forEach(function(topLevelType){trapReplayableEventForDocument(topLevelType,document,listenerMapForDoc);});// Continuous
  continuousReplayableEvents.forEach(function(topLevelType){trapReplayableEventForDocument(topLevelType,document,listenerMapForDoc);});}function createQueuedReplayableEvent(blockedOn,topLevelType,eventSystemFlags,container,nativeEvent){return {blockedOn:blockedOn,topLevelType:topLevelType,eventSystemFlags:eventSystemFlags|IS_REPLAYED,nativeEvent:nativeEvent,container:container};}function queueDiscreteEvent(blockedOn,topLevelType,eventSystemFlags,container,nativeEvent){var queuedEvent=createQueuedReplayableEvent(blockedOn,topLevelType,eventSystemFlags,container,nativeEvent);queuedDiscreteEvents.push(queuedEvent);}// Resets the replaying for this type of continuous event to no event.
  function clearIfContinuousEvent(topLevelType,nativeEvent){switch(topLevelType){case TOP_FOCUS:case TOP_BLUR:queuedFocus=null;break;case TOP_DRAG_ENTER:case TOP_DRAG_LEAVE:queuedDrag=null;break;case TOP_MOUSE_OVER:case TOP_MOUSE_OUT:queuedMouse=null;break;case TOP_POINTER_OVER:case TOP_POINTER_OUT:{var pointerId=nativeEvent.pointerId;queuedPointers.delete(pointerId);break;}case TOP_GOT_POINTER_CAPTURE:case TOP_LOST_POINTER_CAPTURE:{var _pointerId=nativeEvent.pointerId;queuedPointerCaptures.delete(_pointerId);break;}}}function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent,blockedOn,topLevelType,eventSystemFlags,container,nativeEvent){if(existingQueuedEvent===null||existingQueuedEvent.nativeEvent!==nativeEvent){var queuedEvent=createQueuedReplayableEvent(blockedOn,topLevelType,eventSystemFlags,container,nativeEvent);if(blockedOn!==null){var _fiber2=getInstanceFromNode$1(blockedOn);if(_fiber2!==null){// Attempt to increase the priority of this target.
  attemptContinuousHydration(_fiber2);}}return queuedEvent;}// If we have already queued this exact event, then it's because
  // the different event systems have different DOM event listeners.
  // We can accumulate the flags and store a single event to be
  // replayed.
  existingQueuedEvent.eventSystemFlags|=eventSystemFlags;return existingQueuedEvent;}function queueIfContinuousEvent(blockedOn,topLevelType,eventSystemFlags,container,nativeEvent){// These set relatedTarget to null because the replayed event will be treated as if we
  // moved from outside the window (no target) onto the target once it hydrates.
  // Instead of mutating we could clone the event.
  switch(topLevelType){case TOP_FOCUS:{var focusEvent=nativeEvent;queuedFocus=accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus,blockedOn,topLevelType,eventSystemFlags,container,focusEvent);return true;}case TOP_DRAG_ENTER:{var dragEvent=nativeEvent;queuedDrag=accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag,blockedOn,topLevelType,eventSystemFlags,container,dragEvent);return true;}case TOP_MOUSE_OVER:{var mouseEvent=nativeEvent;queuedMouse=accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse,blockedOn,topLevelType,eventSystemFlags,container,mouseEvent);return true;}case TOP_POINTER_OVER:{var pointerEvent=nativeEvent;var pointerId=pointerEvent.pointerId;queuedPointers.set(pointerId,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId)||null,blockedOn,topLevelType,eventSystemFlags,container,pointerEvent));return true;}case TOP_GOT_POINTER_CAPTURE:{var _pointerEvent=nativeEvent;var _pointerId2=_pointerEvent.pointerId;queuedPointerCaptures.set(_pointerId2,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2)||null,blockedOn,topLevelType,eventSystemFlags,container,_pointerEvent));return true;}}return false;}// Check if this target is unblocked. Returns true if it's unblocked.
  function attemptExplicitHydrationTarget(queuedTarget){// TODO: This function shares a lot of logic with attemptToDispatchEvent.
  // Try to unify them. It's a bit tricky since it would require two return
  // values.
  var targetInst=getClosestInstanceFromNode(queuedTarget.target);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted!==null){var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// We're blocked on hydrating this boundary.
  // Increase its priority.
  queuedTarget.blockedOn=instance;Scheduler.unstable_runWithPriority(queuedTarget.priority,function(){attemptHydrationAtCurrentPriority(nearestMounted);});return;}}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(root.hydrate){queuedTarget.blockedOn=getContainerFromFiber(nearestMounted);// We don't currently have a way to increase the priority of
  // a root other than sync.
  return;}}}}queuedTarget.blockedOn=null;}function attemptReplayContinuousQueuedEvent(queuedEvent){if(queuedEvent.blockedOn!==null){return false;}var nextBlockedOn=attemptToDispatchEvent(queuedEvent.topLevelType,queuedEvent.eventSystemFlags,queuedEvent.container,queuedEvent.nativeEvent);if(nextBlockedOn!==null){// We're still blocked. Try again later.
  var _fiber3=getInstanceFromNode$1(nextBlockedOn);if(_fiber3!==null){attemptContinuousHydration(_fiber3);}queuedEvent.blockedOn=nextBlockedOn;return false;}return true;}function attemptReplayContinuousQueuedEventInMap(queuedEvent,key,map){if(attemptReplayContinuousQueuedEvent(queuedEvent)){map.delete(key);}}function replayUnblockedEvents(){hasScheduledReplayAttempt=false;// First replay discrete events.
  while(queuedDiscreteEvents.length>0){var nextDiscreteEvent=queuedDiscreteEvents[0];if(nextDiscreteEvent.blockedOn!==null){// We're still blocked.
  // Increase the priority of this boundary to unblock
  // the next discrete event.
  var _fiber4=getInstanceFromNode$1(nextDiscreteEvent.blockedOn);if(_fiber4!==null){attemptUserBlockingHydration(_fiber4);}break;}var nextBlockedOn=attemptToDispatchEvent(nextDiscreteEvent.topLevelType,nextDiscreteEvent.eventSystemFlags,nextDiscreteEvent.container,nextDiscreteEvent.nativeEvent);if(nextBlockedOn!==null){// We're still blocked. Try again later.
  nextDiscreteEvent.blockedOn=nextBlockedOn;}else {// We've successfully replayed the first event. Let's try the next one.
  queuedDiscreteEvents.shift();}}// Next replay any continuous events.
  if(queuedFocus!==null&&attemptReplayContinuousQueuedEvent(queuedFocus)){queuedFocus=null;}if(queuedDrag!==null&&attemptReplayContinuousQueuedEvent(queuedDrag)){queuedDrag=null;}if(queuedMouse!==null&&attemptReplayContinuousQueuedEvent(queuedMouse)){queuedMouse=null;}queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);}function scheduleCallbackIfUnblocked(queuedEvent,unblocked){if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;if(!hasScheduledReplayAttempt){hasScheduledReplayAttempt=true;// Schedule a callback to attempt replaying as many events as are
  // now unblocked. This first might not actually be unblocked yet.
  // We could check it early to avoid scheduling an unnecessary callback.
  Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority,replayUnblockedEvents);}}}function retryIfBlockedOn(unblocked){// Mark anything that was blocked on this as no longer blocked
  // and eligible for a replay.
  if(queuedDiscreteEvents.length>0){scheduleCallbackIfUnblocked(queuedDiscreteEvents[0],unblocked);// This is a exponential search for each boundary that commits. I think it's
  // worth it because we expect very few discrete events to queue up and once
  // we are actually fully unblocked it will be fast to replay them.
  for(var i=1;i<queuedDiscreteEvents.length;i++){var queuedEvent=queuedDiscreteEvents[i];if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;}}}if(queuedFocus!==null){scheduleCallbackIfUnblocked(queuedFocus,unblocked);}if(queuedDrag!==null){scheduleCallbackIfUnblocked(queuedDrag,unblocked);}if(queuedMouse!==null){scheduleCallbackIfUnblocked(queuedMouse,unblocked);}var unblock=function(queuedEvent){return scheduleCallbackIfUnblocked(queuedEvent,unblocked);};queuedPointers.forEach(unblock);queuedPointerCaptures.forEach(unblock);for(var _i=0;_i<queuedExplicitHydrationTargets.length;_i++){var queuedTarget=queuedExplicitHydrationTargets[_i];if(queuedTarget.blockedOn===unblocked){queuedTarget.blockedOn=null;}}while(queuedExplicitHydrationTargets.length>0){var nextExplicitTarget=queuedExplicitHydrationTargets[0];if(nextExplicitTarget.blockedOn!==null){// We're still blocked.
  break;}else {attemptExplicitHydrationTarget(nextExplicitTarget);if(nextExplicitTarget.blockedOn===null){// We're unblocked.
  queuedExplicitHydrationTargets.shift();}}}}function addEventBubbleListener(element,eventType,listener){element.addEventListener(eventType,listener,false);}function addEventCaptureListener(element,eventType,listener){element.addEventListener(eventType,listener,true);}// do it in two places, which duplicates logic
  // and increases the bundle size, we do it all
  // here once. If we remove or refactor the
  // SimpleEventPlugin, we should also remove or
  // update the below line.
  var simpleEventPluginEventTypes={};var topLevelEventsToDispatchConfig=new Map();var eventPriorities=new Map();// We store most of the events in this module in pairs of two strings so we can re-use
  // the code required to apply the same logic for event prioritization and that of the
  // SimpleEventPlugin. This complicates things slightly, but the aim is to reduce code
  // duplication (for which there would be quite a bit). For the events that are not needed
  // for the SimpleEventPlugin (otherDiscreteEvents) we process them separately as an
  // array of top level events.
  // Lastly, we ignore prettier so we can keep the formatting sane.
  // prettier-ignore
  var discreteEventPairsForSimpleEventPlugin=[TOP_BLUR,'blur',TOP_CANCEL,'cancel',TOP_CLICK,'click',TOP_CLOSE,'close',TOP_CONTEXT_MENU,'contextMenu',TOP_COPY,'copy',TOP_CUT,'cut',TOP_AUX_CLICK,'auxClick',TOP_DOUBLE_CLICK,'doubleClick',TOP_DRAG_END,'dragEnd',TOP_DRAG_START,'dragStart',TOP_DROP,'drop',TOP_FOCUS,'focus',TOP_INPUT,'input',TOP_INVALID,'invalid',TOP_KEY_DOWN,'keyDown',TOP_KEY_PRESS,'keyPress',TOP_KEY_UP,'keyUp',TOP_MOUSE_DOWN,'mouseDown',TOP_MOUSE_UP,'mouseUp',TOP_PASTE,'paste',TOP_PAUSE,'pause',TOP_PLAY,'play',TOP_POINTER_CANCEL,'pointerCancel',TOP_POINTER_DOWN,'pointerDown',TOP_POINTER_UP,'pointerUp',TOP_RATE_CHANGE,'rateChange',TOP_RESET,'reset',TOP_SEEKED,'seeked',TOP_SUBMIT,'submit',TOP_TOUCH_CANCEL,'touchCancel',TOP_TOUCH_END,'touchEnd',TOP_TOUCH_START,'touchStart',TOP_VOLUME_CHANGE,'volumeChange'];var otherDiscreteEvents=[TOP_CHANGE,TOP_SELECTION_CHANGE,TOP_TEXT_INPUT,TOP_COMPOSITION_START,TOP_COMPOSITION_END,TOP_COMPOSITION_UPDATE];// prettier-ignore
  var userBlockingPairsForSimpleEventPlugin=[TOP_DRAG,'drag',TOP_DRAG_ENTER,'dragEnter',TOP_DRAG_EXIT,'dragExit',TOP_DRAG_LEAVE,'dragLeave',TOP_DRAG_OVER,'dragOver',TOP_MOUSE_MOVE,'mouseMove',TOP_MOUSE_OUT,'mouseOut',TOP_MOUSE_OVER,'mouseOver',TOP_POINTER_MOVE,'pointerMove',TOP_POINTER_OUT,'pointerOut',TOP_POINTER_OVER,'pointerOver',TOP_SCROLL,'scroll',TOP_TOGGLE,'toggle',TOP_TOUCH_MOVE,'touchMove',TOP_WHEEL,'wheel'];// prettier-ignore
  var continuousPairsForSimpleEventPlugin=[TOP_ABORT,'abort',TOP_ANIMATION_END,'animationEnd',TOP_ANIMATION_ITERATION,'animationIteration',TOP_ANIMATION_START,'animationStart',TOP_CAN_PLAY,'canPlay',TOP_CAN_PLAY_THROUGH,'canPlayThrough',TOP_DURATION_CHANGE,'durationChange',TOP_EMPTIED,'emptied',TOP_ENCRYPTED,'encrypted',TOP_ENDED,'ended',TOP_ERROR,'error',TOP_GOT_POINTER_CAPTURE,'gotPointerCapture',TOP_LOAD,'load',TOP_LOADED_DATA,'loadedData',TOP_LOADED_METADATA,'loadedMetadata',TOP_LOAD_START,'loadStart',TOP_LOST_POINTER_CAPTURE,'lostPointerCapture',TOP_PLAYING,'playing',TOP_PROGRESS,'progress',TOP_SEEKING,'seeking',TOP_STALLED,'stalled',TOP_SUSPEND,'suspend',TOP_TIME_UPDATE,'timeUpdate',TOP_TRANSITION_END,'transitionEnd',TOP_WAITING,'waiting'];/**
   * Turns
   * ['abort', ...]
   * into
   * eventTypes = {
   *   'abort': {
   *     phasedRegistrationNames: {
   *       bubbled: 'onAbort',
   *       captured: 'onAbortCapture',
   *     },
   *     dependencies: [TOP_ABORT],
   *   },
   *   ...
   * };
   * topLevelEventsToDispatchConfig = new Map([
   *   [TOP_ABORT, { sameConfig }],
   * ]);
   */function processSimpleEventPluginPairsByPriority(eventTypes,priority){// As the event types are in pairs of two, we need to iterate
  // through in twos. The events are in pairs of two to save code
  // and improve init perf of processing this array, as it will
  // result in far fewer object allocations and property accesses
  // if we only use three arrays to process all the categories of
  // instead of tuples.
  for(var i=0;i<eventTypes.length;i+=2){var topEvent=eventTypes[i];var event=eventTypes[i+1];var capitalizedEvent=event[0].toUpperCase()+event.slice(1);var onEvent='on'+capitalizedEvent;var config={phasedRegistrationNames:{bubbled:onEvent,captured:onEvent+'Capture'},dependencies:[topEvent],eventPriority:priority};eventPriorities.set(topEvent,priority);topLevelEventsToDispatchConfig.set(topEvent,config);simpleEventPluginEventTypes[event]=config;}}function processTopEventPairsByPriority(eventTypes,priority){for(var i=0;i<eventTypes.length;i++){eventPriorities.set(eventTypes[i],priority);}}// SimpleEventPlugin
  processSimpleEventPluginPairsByPriority(discreteEventPairsForSimpleEventPlugin,DiscreteEvent);processSimpleEventPluginPairsByPriority(userBlockingPairsForSimpleEventPlugin,UserBlockingEvent);processSimpleEventPluginPairsByPriority(continuousPairsForSimpleEventPlugin,ContinuousEvent);// Not used by SimpleEventPlugin
  processTopEventPairsByPriority(otherDiscreteEvents,DiscreteEvent);function getEventPriorityForPluginSystem(topLevelType){var priority=eventPriorities.get(topLevelType);// Default to a ContinuousEvent. Note: we might
  // want to warn if we can't detect the priority
  // for the event.
  return priority===undefined?ContinuousEvent:priority;}// Intentionally not named imports because Rollup would use dynamic dispatch for
  var UserBlockingPriority=Scheduler.unstable_UserBlockingPriority,runWithPriority=Scheduler.unstable_runWithPriority;// TODO: can we stop exporting these?
  var _enabled=true;function setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}function trapBubbledEvent(topLevelType,element){trapEventForPluginEventSystem(element,topLevelType,false);}function trapCapturedEvent(topLevelType,element){trapEventForPluginEventSystem(element,topLevelType,true);}function trapEventForPluginEventSystem(container,topLevelType,capture){var listener;switch(getEventPriorityForPluginSystem(topLevelType)){case DiscreteEvent:listener=dispatchDiscreteEvent.bind(null,topLevelType,PLUGIN_EVENT_SYSTEM,container);break;case UserBlockingEvent:listener=dispatchUserBlockingUpdate.bind(null,topLevelType,PLUGIN_EVENT_SYSTEM,container);break;case ContinuousEvent:default:listener=dispatchEvent.bind(null,topLevelType,PLUGIN_EVENT_SYSTEM,container);break;}var rawEventName=getRawEventName(topLevelType);if(capture){addEventCaptureListener(container,rawEventName,listener);}else {addEventBubbleListener(container,rawEventName,listener);}}function dispatchDiscreteEvent(topLevelType,eventSystemFlags,container,nativeEvent){flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);discreteUpdates(dispatchEvent,topLevelType,eventSystemFlags,container,nativeEvent);}function dispatchUserBlockingUpdate(topLevelType,eventSystemFlags,container,nativeEvent){runWithPriority(UserBlockingPriority,dispatchEvent.bind(null,topLevelType,eventSystemFlags,container,nativeEvent));}function dispatchEvent(topLevelType,eventSystemFlags,container,nativeEvent){if(!_enabled){return;}if(hasQueuedDiscreteEvents()&&isReplayableDiscreteEvent(topLevelType)){// If we already have a queue of discrete events, and this is another discrete
  // event, then we can't dispatch it regardless of its target, since they
  // need to dispatch in order.
  queueDiscreteEvent(null,// Flags that we're not actually blocked on anything as far as we know.
  topLevelType,eventSystemFlags,container,nativeEvent);return;}var blockedOn=attemptToDispatchEvent(topLevelType,eventSystemFlags,container,nativeEvent);if(blockedOn===null){// We successfully dispatched this event.
  clearIfContinuousEvent(topLevelType,nativeEvent);return;}if(isReplayableDiscreteEvent(topLevelType)){// This this to be replayed later once the target is available.
  queueDiscreteEvent(blockedOn,topLevelType,eventSystemFlags,container,nativeEvent);return;}if(queueIfContinuousEvent(blockedOn,topLevelType,eventSystemFlags,container,nativeEvent)){return;}// We need to clear only if we didn't queue because
  // queueing is accummulative.
  clearIfContinuousEvent(topLevelType,nativeEvent);// This is not replayable so we'll invoke it but without a target,
  // in case the event system needs to trace it.
  {dispatchEventForLegacyPluginEventSystem(topLevelType,eventSystemFlags,nativeEvent,null);}}// Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.
  function attemptToDispatchEvent(topLevelType,eventSystemFlags,container,nativeEvent){// TODO: Warn if _enabled is false.
  var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted===null){// This tree has been unmounted already. Dispatch without a target.
  targetInst=null;}else {var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// Queue the event to be replayed later. Abort dispatching since we
  // don't want this event dispatched twice through the event system.
  // TODO: If this is the first discrete event in the queue. Schedule an increased
  // priority for this boundary.
  return instance;}// This shouldn't happen, something went wrong but to avoid blocking
  // the whole system, dispatch the event without a target.
  // TODO: Warn.
  targetInst=null;}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(root.hydrate){// If this happens during a replay something went wrong and it might block
  // the whole system.
  return getContainerFromFiber(nearestMounted);}targetInst=null;}else if(nearestMounted!==targetInst){// If we get an event (ex: img onload) before committing that
  // component's mount, ignore it for now (that is, treat it as if it was an
  // event on a non-React tree). We might also consider queueing events and
  // dispatching them after the mount.
  targetInst=null;}}}{dispatchEventForLegacyPluginEventSystem(topLevelType,eventSystemFlags,nativeEvent,targetInst);}// We're not blocked on anything.
  return null;}// List derived from Gecko source code:
  // https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js
  var shorthandToLonghand={animation:['animationDelay','animationDirection','animationDuration','animationFillMode','animationIterationCount','animationName','animationPlayState','animationTimingFunction'],background:['backgroundAttachment','backgroundClip','backgroundColor','backgroundImage','backgroundOrigin','backgroundPositionX','backgroundPositionY','backgroundRepeat','backgroundSize'],backgroundPosition:['backgroundPositionX','backgroundPositionY'],border:['borderBottomColor','borderBottomStyle','borderBottomWidth','borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth','borderLeftColor','borderLeftStyle','borderLeftWidth','borderRightColor','borderRightStyle','borderRightWidth','borderTopColor','borderTopStyle','borderTopWidth'],borderBlockEnd:['borderBlockEndColor','borderBlockEndStyle','borderBlockEndWidth'],borderBlockStart:['borderBlockStartColor','borderBlockStartStyle','borderBlockStartWidth'],borderBottom:['borderBottomColor','borderBottomStyle','borderBottomWidth'],borderColor:['borderBottomColor','borderLeftColor','borderRightColor','borderTopColor'],borderImage:['borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth'],borderInlineEnd:['borderInlineEndColor','borderInlineEndStyle','borderInlineEndWidth'],borderInlineStart:['borderInlineStartColor','borderInlineStartStyle','borderInlineStartWidth'],borderLeft:['borderLeftColor','borderLeftStyle','borderLeftWidth'],borderRadius:['borderBottomLeftRadius','borderBottomRightRadius','borderTopLeftRadius','borderTopRightRadius'],borderRight:['borderRightColor','borderRightStyle','borderRightWidth'],borderStyle:['borderBottomStyle','borderLeftStyle','borderRightStyle','borderTopStyle'],borderTop:['borderTopColor','borderTopStyle','borderTopWidth'],borderWidth:['borderBottomWidth','borderLeftWidth','borderRightWidth','borderTopWidth'],columnRule:['columnRuleColor','columnRuleStyle','columnRuleWidth'],columns:['columnCount','columnWidth'],flex:['flexBasis','flexGrow','flexShrink'],flexFlow:['flexDirection','flexWrap'],font:['fontFamily','fontFeatureSettings','fontKerning','fontLanguageOverride','fontSize','fontSizeAdjust','fontStretch','fontStyle','fontVariant','fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition','fontWeight','lineHeight'],fontVariant:['fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition'],gap:['columnGap','rowGap'],grid:['gridAutoColumns','gridAutoFlow','gridAutoRows','gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],gridArea:['gridColumnEnd','gridColumnStart','gridRowEnd','gridRowStart'],gridColumn:['gridColumnEnd','gridColumnStart'],gridColumnGap:['columnGap'],gridGap:['columnGap','rowGap'],gridRow:['gridRowEnd','gridRowStart'],gridRowGap:['rowGap'],gridTemplate:['gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],listStyle:['listStyleImage','listStylePosition','listStyleType'],margin:['marginBottom','marginLeft','marginRight','marginTop'],marker:['markerEnd','markerMid','markerStart'],mask:['maskClip','maskComposite','maskImage','maskMode','maskOrigin','maskPositionX','maskPositionY','maskRepeat','maskSize'],maskPosition:['maskPositionX','maskPositionY'],outline:['outlineColor','outlineStyle','outlineWidth'],overflow:['overflowX','overflowY'],padding:['paddingBottom','paddingLeft','paddingRight','paddingTop'],placeContent:['alignContent','justifyContent'],placeItems:['alignItems','justifyItems'],placeSelf:['alignSelf','justifySelf'],textDecoration:['textDecorationColor','textDecorationLine','textDecorationStyle'],textEmphasis:['textEmphasisColor','textEmphasisStyle'],transition:['transitionDelay','transitionDuration','transitionProperty','transitionTimingFunction'],wordWrap:['overflowWrap']};/**
   * CSS properties which accept numbers but are not in units of "px".
   */var isUnitlessNumber={animationIterationCount:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties
  fillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**
   * @param {string} prefix vendor-specific prefix, eg: Webkit
   * @param {string} key style name, eg: transitionDuration
   * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
   * WebkitTransitionDuration
   */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**
   * Support style names that may come passed in prefixed by adding permutations
   * of vendor prefixes.
   */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
  // infinite loop, because it iterates over the newly added props too.
  Object.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**
   * Convert a value into the proper css writable value. The style name `name`
   * should be logical (no hyphens), as specified
   * in `CSSProperty.isUnitlessNumber`.
   *
   * @param {string} name CSS property name such as `topMargin`.
   * @param {*} value CSS property value such as `10px`.
   * @return {string} Normalized style value with dimensions applied.
   */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901
  var isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return '';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers
  }return (''+value).trim();}var uppercasePattern=/([A-Z])/g;var msPattern=/^ms-/;/**
   * Hyphenates a camelcased CSS property name, for example:
   *
   *   > hyphenateStyleName('backgroundColor')
   *   < "background-color"
   *   > hyphenateStyleName('MozTransition')
   *   < "-moz-transition"
   *   > hyphenateStyleName('msTransition')
   *   < "-ms-transition"
   *
   * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
   * is converted to `-ms-`.
   */function hyphenateStyleName(name){return name.replace(uppercasePattern,'-$1').toLowerCase().replace(msPattern,'-ms-');}var warnValidStyle=function(){};{// 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;var msPattern$1=/^-ms-/;var hyphenPattern=/-(.)/g;// style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern=/;\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var camelize=function(string){return string.replace(hyphenPattern,function(_,character){return character.toUpperCase();});};var warnHyphenatedStyleName=function(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported style property %s. Did you mean %s?',name,// As Andi Smith suggests
  // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
  // is converted to lowercase `ms`.
  camelize(name.replace(msPattern$1,'ms-')));};var warnBadVendoredStyleName=function(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported vendor-prefixed style property %s. Did you mean %s?',name,name.charAt(0).toUpperCase()+name.slice(1));};var warnStyleValueWithSemicolon=function(name,value){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;error("Style property values shouldn't contain a semicolon. "+'Try "%s: %s" instead.',name,value.replace(badStyleValueWithSemicolonPattern,''));};var warnStyleValueIsNaN=function(name,value){if(warnedForNaNValue){return;}warnedForNaNValue=true;error('`NaN` is an invalid value for the `%s` css style property.',name);};var warnStyleValueIsInfinity=function(name,value){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;error('`Infinity` is an invalid value for the `%s` css style property.',name);};warnValidStyle=function(name,value){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value);}}};}var warnValidStyle$1=warnValidStyle;/**
   * Operations for dealing with CSS properties.
   */ /**
   * This creates a string that is expected to be equivalent to the style
   * attribute generated by server-side rendering. It by-passes warnings and
   * security checks so it's not safe to use this value for anything other than
   * comparison. It is only used in DEV for SSR validation.
   */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+(isCustomProperty?styleName:hyphenateStyleName(styleName))+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   */function setValueForStyles(node,styles){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName]);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else {style[styleName]=styleValue;}}}function isValueEmpty(value){return value==null||typeof value==='boolean'||value==='';}/**
   * Given {color: 'red', overflow: 'hidden'} returns {
   *   color: 'color',
   *   overflowX: 'overflow',
   *   overflowY: 'overflow',
   * }. This can be read as "the overflowY property was set by the overflow
   * shorthand". That is, the values are the property that each was derived from.
   */function expandShorthandMap(styles){var expanded={};for(var key in styles){var longhands=shorthandToLonghand[key]||[key];for(var i=0;i<longhands.length;i++){expanded[longhands[i]]=key;}}return expanded;}/**
   * When mixing shorthand and longhand property names, we warn during updates if
   * we expect an incorrect result to occur. In particular, we warn for:
   *
   * Updating a shorthand property (longhand gets overwritten):
   *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
   *   becomes .style.font = 'baz'
   * Removing a shorthand property (longhand gets lost too):
   *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
   *   becomes .style.font = ''
   * Removing a longhand property (should revert to shorthand; doesn't):
   *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
   *   becomes .style.fontVariant = ''
   */function validateShorthandPropertyCollisionInDev(styleUpdates,nextStyles){{if(!nextStyles){return;}var expandedUpdates=expandShorthandMap(styleUpdates);var expandedStyles=expandShorthandMap(nextStyles);var warnedAbout={};for(var key in expandedUpdates){var originalKey=expandedUpdates[key];var correctOriginalKey=expandedStyles[key];if(correctOriginalKey&&originalKey!==correctOriginalKey){var warningKey=originalKey+','+correctOriginalKey;if(warnedAbout[warningKey]){continue;}warnedAbout[warningKey]=true;error('%s a style property during rerender (%s) when a '+'conflicting property is set (%s) can lead to styling bugs. To '+"avoid this, don't mix shorthand and non-shorthand properties "+'for the same value; instead, replace the shorthand with '+'separate values.',isValueEmpty(styleUpdates[originalKey])?'Removing':'Updating',originalKey,correctOriginalKey);}}}}// For HTML, certain tags should omit their close tag. We keep a whitelist for
  // those special-case tags.
  var omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true// NOTE: menuitem's close tag should be omitted, but that causes problems.
  };// `omittedCloseTags` except that `menuitem` should still have its closing tag.
  var voidElementTags=_assign({menuitem:true},omittedCloseTags);var HTML='__html';var ReactDebugCurrentFrame$3=null;{ReactDebugCurrentFrame$3=ReactSharedInternals.ReactDebugCurrentFrame;}function assertValidProps(tag,props){if(!props){return;}// Note the use of `==` which checks for null or undefined.
  if(voidElementTags[tag]){if(!(props.children==null&&props.dangerouslySetInnerHTML==null)){{throw Error(tag+" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."+ReactDebugCurrentFrame$3.getStackAddendum());}}}if(props.dangerouslySetInnerHTML!=null){if(!(props.children==null)){{throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");}}if(!(typeof props.dangerouslySetInnerHTML==='object'&&HTML in props.dangerouslySetInnerHTML)){{throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.");}}}{if(!props.suppressContentEditableWarning&&props.contentEditable&&props.children!=null){error('A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.');}}if(!(props.style==null||typeof props.style==='object')){{throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."+ReactDebugCurrentFrame$3.getStackAddendum());}}}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.
  // We don't mind this whitelist too much because we expect it to never grow.
  // The alternative is to track the namespace in a few places which is convoluted.
  // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
  case'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}// When adding attributes to the HTML or SVG whitelist, be sure to
  // also add them to this module to ensure casing and incorrect name
  // warnings.
  var possibleStandardNames={// HTML
  accept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite',class:'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime',default:'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',disablepictureinpicture:'disablePictureInPicture',download:'download',draggable:'draggable',enctype:'encType',for:'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nomodule:'noModule',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG
  about:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2',in:'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform',typeof:'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};var ariaProperties={'aria-current':0,// state
  'aria-details':0,'aria-disabled':0,// state
  'aria-hidden':0,// state
  'aria-invalid':0,// state
  'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes
  'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes
  'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes
  'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes
  'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty$1=Object.prototype.hasOwnProperty;function validateProperty(tagName,name){{if(hasOwnProperty$1.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM
  // DOM properties, then it is an invalid aria-* attribute.
  if(correctName==null){error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',name);warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.
  if(name!==correctName){error('Invalid ARIA attribute `%s`. Did you mean `%s`?',name,correctName);warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM
  // DOM properties, then it is an invalid aria-* attribute.
  if(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.
  if(name!==standardName){error('Unknown ARIA attribute `%s`. Did you mean `%s`?',name,standardName);warnedProperties[name]=true;return true;}}}return true;}function warnInvalidARIAProps(type,props){{var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return '`'+prop+'`';}).join(', ');if(invalidProps.length===1){error('Invalid aria prop %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop',unknownPropString,type);}else if(invalidProps.length>1){error('Invalid aria props %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop',unknownPropString,type);}}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function validateProperties$1(type,props){{if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){error('`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.',type);}else {error('`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.',type);}}}}var validateProperty$1=function(){};{var warnedProperties$1={};var _hasOwnProperty=Object.prototype.hasOwnProperty;var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');validateProperty$1=function(tagName,name,value,canUseEventSystem){if(_hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.
  if(canUseEventSystem){if(registrationNameModules.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){error('Invalid event handler property `%s`. Did you mean `%s`?',name,registrationName);warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){error('Unknown event handler property `%s`. It will be ignored.',name);warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.
  // So we can't tell if the event name is correct for sure, but we can filter
  // out known bad ones like `onclick`. We can't suggest a specific replacement though.
  if(INVALID_EVENT_NAME_REGEX.test(name)){error('Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.',name);}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes
  if(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){error('Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){error('The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){error('Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.',typeof value);warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){error('Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.',name);warnedProperties$1[name]=true;return true;}var propertyInfo=getPropertyInfo(name);var isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;// Known attributes should match the casing specified in the property config.
  if(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){error('Invalid DOM property `%s`. Did you mean `%s`?',name,standardName);warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they
  // will be cased anyway with server rendering.
  error('React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.',name,lowerCasedName);warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){if(value){error('Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.',value,name,name,value,name);}else {error('Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',value,name,name,value,name,name,name);}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate
  // data types for reserved props
  if(isReserved){return true;}// Warn when a known attribute is a bad type
  if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){warnedProperties$1[name]=true;return false;}// Warn when passing the strings 'false' or 'true' into a boolean prop
  if((value==='false'||value==='true')&&propertyInfo!==null&&propertyInfo.type===BOOLEAN){error('Received the string `%s` for the boolean attribute `%s`. '+'%s '+'Did you mean %s={%s}?',value,name,value==='false'?'The browser will interpret it as a truthy value.':'Although this works, it will not work as expected if you pass the string "false".',name,value);warnedProperties$1[name]=true;return true;}return true;};}var warnUnknownProperties=function(type,props,canUseEventSystem){{var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],canUseEventSystem);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return '`'+prop+'`';}).join(', ');if(unknownProps.length===1){error('Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://fb.me/react-attribute-behavior',unknownPropString,type);}else if(unknownProps.length>1){error('Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://fb.me/react-attribute-behavior',unknownPropString,type);}}};function validateProperties$2(type,props,canUseEventSystem){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,canUseEventSystem);}var didWarnInvalidHydration=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML$1='__html';var HTML_NAMESPACE$1=Namespaces.html;var warnedUnknownTags;var suppressHydrationWarning;var validatePropertiesInDevelopment;var warnForTextDifference;var warnForPropDifference;var warnForExtraAttributes;var warnForInvalidEventListener;var canDiffStyleForHydrationWarning;var normalizeMarkupForTextOrAttribute;var normalizeHTML;{warnedUnknownTags={// Chrome is the only major browser not shipping <time>. But as of July
  // 2017 it intends to ship it due to widespread usage. We intentionally
  // *don't* warn for <time> even if it's unrecognized by Chrome because
  // it soon will be, and many apps have been using it anyway.
  time:true,// There are working polyfills for <dialog>. Let people use it.
  dialog:true,// Electron ships a custom <webview> tag to display external web content in
  // an isolated frame and process.
  // This tag is not present in non Electron environments such as JSDom which
  // is often used for testing purposes.
  // @see https://electronjs.org/docs/api/webview-tag
  webview:true};validatePropertiesInDevelopment=function(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,/* canUseEventSystem */true);};// IE 11 parses & normalizes the style attribute as opposed to other
  // browsers. It adds spaces and sorts the properties in some
  // non-alphabetical order. Handling that would require sorting CSS
  // properties in the client & server versions or applying
  // `expectedStyle` to a temporary DOM node to read its `style` attribute
  // normalized. Since it only affects IE, we're skipping style warnings
  // in that browser completely in favor of doing all that work.
  // See https://github.com/facebook/react/issues/11807
  canDiffStyleForHydrationWarning=canUseDOM&&!document.documentMode;// HTML parsing normalizes CR and CRLF to LF.
  // It also can turn \u0000 into \uFFFD inside attributes.
  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
  // If we have a mismatch, it might be caused by that.
  // We will still patch up in this case but not fire the warning.
  var NORMALIZE_NEWLINES_REGEX=/\r\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\u0000|\uFFFD/g;normalizeMarkupForTextOrAttribute=function(markup){var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');};warnForTextDifference=function(serverText,clientText){if(didWarnInvalidHydration){return;}var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}didWarnInvalidHydration=true;error('Text content did not match. Server: "%s" Client: "%s"',normalizedServerText,normalizedClientText);};warnForPropDifference=function(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;error('Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};warnForExtraAttributes=function(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});error('Extra attributes from the server: %s',names);};warnForInvalidEventListener=function(registrationName,listener){if(listener===false){error('Expected `%s` listener to be a function, instead got `false`.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',registrationName,registrationName,registrationName);}else {error('Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener);}};// Parse the HTML and read it back to normalize the HTML string so that it
  // can be used for comparison.
  normalizeHTML=function(parent,html){// We could have created a separate document here to avoid
  // re-initializing custom elements if they exist. But this breaks
  // how <noscript> is being handled. So we use the same document.
  // See the discussion in https://github.com/facebook/react/pull/11157.
  var testElement=parent.namespaceURI===HTML_NAMESPACE$1?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}function ensureListeningTo(rootContainerElement,registrationName){var isDocumentOrFragment=rootContainerElement.nodeType===DOCUMENT_NODE||rootContainerElement.nodeType===DOCUMENT_FRAGMENT_NODE;var doc=isDocumentOrFragment?rootContainerElement:rootContainerElement.ownerDocument;legacyListenToEvent(registrationName,doc);}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}function noop(){}function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  // Just set it using the onclick property so that we don't have to manage any
  // bookkeeping for it. Not sure if we need to clear it when the listener is
  // removed.
  // TODO: Only do this for the relevant Safaris maybe?
  node.onclick=noop;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
  // mutated. We have already warned for this in the past.
  Object.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.
  setValueForStyles(domElement,nextProp);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting
  // textContent on a <textarea> will cause the placeholder to not
  // show within the <textarea> until it has been focused and blurred again.
  // https://github.com/facebook/react/issues/6731#issuecomment-254874553
  var canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else if(nextProp!=null){setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag
  for(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else {setValueForProperty(domElement,propKey,propValue,isCustomComponentTag);}}}function createElement(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag;// We create tags in the namespace of their parent container, except HTML
  // tags get no namespace.
  var ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE$1){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE$1){{isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to
  // allow <SVG> or <mATH>.
  if(!isCustomComponentTag&&type!==type.toLowerCase()){error('<%s /> is using incorrect casing. '+'Use PascalCase for React components, '+'or lowercase for HTML elements.',type);}}if(type==='script'){// Create the script via .innerHTML so its "parser-inserted" flag is
  // set to true and it does not execute
  var div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line
  // This is guaranteed to yield a script element.
  var firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components
  domElement=ownerDocument.createElement(type,{is:props.is});}else {// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
  // See discussion in https://github.com/facebook/react/pull/6896
  // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
  domElement=ownerDocument.createElement(type);// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`
  // attributes on `select`s needs to be added before `option`s are inserted.
  // This prevents:
  // - a bug where the `select` does not scroll to the correct option because singular
  //  `select` elements automatically pick the first item #13222
  // - a bug where the `select` set the first item as selected despite the `size` attribute #14239
  // See https://github.com/facebook/react/issues/13222
  // and https://github.com/facebook/react/issues/14239
  if(type==='select'){var node=domElement;if(props.multiple){node.multiple=true;}else if(props.size){// Setting a size greater than 1 causes a select to behave like `multiple=true`, where
  // it is possible that no option is selected.
  //
  // This is only necessary when a select in "single selection mode".
  node.size=props.size;}}}}else {domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE$1){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!Object.prototype.hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;error('The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.
  var props;switch(tag){case'iframe':case'object':case'embed':trapBubbledEvent(TOP_LOAD,domElement);props=rawProps;break;case'video':case'audio':// Create listener for each media event
  for(var i=0;i<mediaEventTypes.length;i++){trapBubbledEvent(mediaEventTypes[i],domElement);}props=rawProps;break;case'source':trapBubbledEvent(TOP_ERROR,domElement);props=rawProps;break;case'img':case'image':case'link':trapBubbledEvent(TOP_ERROR,domElement);trapBubbledEvent(TOP_LOAD,domElement);props=rawProps;break;case'form':trapBubbledEvent(TOP_RESET,domElement);trapBubbledEvent(TOP_SUBMIT,domElement);props=rawProps;break;case'details':trapBubbledEvent(TOP_TOGGLE,domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
  // to onChange. Even if there is no listener.
  ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);props=getHostProps$1(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$2(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
  // to onChange. Even if there is no listener.
  ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$3(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
  // to onChange. Even if there is no listener.
  ensureListeningTo(rootContainerElement,'onChange');break;default:props=rawProps;}assertValidProps(tag,props);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
  // up necessary since we never stop tracking anymore.
  track(domElement);postMountWrapper(domElement,rawProps,false);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
  // up necessary since we never stop tracking anymore.
  track(domElement);postMountWrapper$3(domElement);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
  trapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.
  function diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'option':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$3(domElement,lastRawProps);nextProps=getHostProps$3(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
  trapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameModules.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure
  // that the "current" fiber pointer gets updated so we need a commit
  // to update this element.
  if(!updatePayload){updatePayload=[];}}else {// For all other deleted properties we add it to the queue. We use
  // the whitelist in the commit phase instead.
  (updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
  // mutated. We have already warned for this in the past.
  Object.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.
  for(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.
  for(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else {// Relies on `updateStylesByID` not mutating `styleUpdates`.
  if(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;var lastHtml=lastProp?lastProp[HTML$1]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,nextHtml);}}}else if(propKey===CHILDREN){if(lastProp!==nextProp&&(typeof nextProp==='string'||typeof nextProp==='number')){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.
  if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure
  // that the "current" props pointer gets updated so we need a commit
  // to update this element.
  updatePayload=[];}}else {// For any other property we always add it to the queue and then we
  // filter it out using the whitelist during the commit.
  (updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){{validateShorthandPropertyCollisionInDev(styleUpdates,nextProps[STYLE]);}(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.
  function updateProperties(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.
  // In the middle of an update, it is possible to have multiple checked.
  // When a checked radio tries to change name, browser makes another radio's checked false.
  if(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.
  updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props
  // changed.
  switch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to
  // happen after `updateDOMProperties`. Otherwise HTML5 input validations
  // raise warnings and prevent the new value from being assigned.
  updateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children
  // reconciliation
  postUpdateWrapper(domElement,nextRawProps);break;}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();if(!possibleStandardNames.hasOwnProperty(lowerCasedName)){return null;}return possibleStandardNames[lowerCasedName]||null;}}function diffHydratedProperties(domElement,tag,rawProps,parentNamespace,rootContainerElement){var isCustomComponentTag;var extraAttributeNames;{suppressHydrationWarning=rawProps[SUPPRESS_HYDRATION_WARNING]===true;isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.
  switch(tag){case'iframe':case'object':case'embed':trapBubbledEvent(TOP_LOAD,domElement);break;case'video':case'audio':// Create listener for each media event
  for(var i=0;i<mediaEventTypes.length;i++){trapBubbledEvent(mediaEventTypes[i],domElement);}break;case'source':trapBubbledEvent(TOP_ERROR,domElement);break;case'img':case'image':case'link':trapBubbledEvent(TOP_ERROR,domElement);trapBubbledEvent(TOP_LOAD,domElement);break;case'form':trapBubbledEvent(TOP_RESET,domElement);trapBubbledEvent(TOP_SUBMIT,domElement);break;case'details':trapBubbledEvent(TOP_TOGGLE,domElement);break;case'input':initWrapperState(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
  // to onChange. Even if there is no listener.
  ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
  // to onChange. Even if there is no listener.
  ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
  // to onChange. Even if there is no listener.
  ensureListeningTo(rootContainerElement,'onChange');break;}assertValidProps(tag,rawProps);{extraAttributeNames=new Set();var attributes=domElement.attributes;for(var _i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){// Built-in SSR attribute is whitelisted
  case'data-reactroot':break;// Controlled attributes are not validated
  // TODO: Only ignore them on controlled tags.
  case'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.
  // See discussion in https://github.com/facebook/react/pull/10676.
  extraAttributeNames.add(attributes[_i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This
  // might match additional HTML that is hidden when we read it using
  // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
  // satisfies our requirement. Our requirement is not to produce perfect
  // HTML and attributes. Ideally we should preserve structure but it's
  // ok not to if the visible content is still enough to indicate what
  // even listeners these nodes might be wired up to.
  // TODO: Warn if there is more than a single textNode as a child.
  // TODO: Should we use domElement.firstChild.nodeValue to compare?
  if(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else if(// Convince Flow we've calculated it (it's DEV-only in this method.)
  typeof isCustomComponentTag==='boolean'){// Validate that the properties correspond to their expected values.
  var serverValue=void 0;var propertyInfo=getPropertyInfo(propKey);if(suppressHydrationWarning);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||// Controlled attributes are not validated
  // TODO: Only ignore them on controlled tags.
  propKey==='value'||propKey==='checked'||propKey==='selected');else if(propKey===DANGEROUSLY_SET_INNER_HTML){var serverHTML=domElement.innerHTML;var nextHtml=nextProp?nextProp[HTML$1]:undefined;var expectedHTML=normalizeHTML(domElement,nextHtml!=null?nextHtml:'');if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.
  extraAttributeNames.delete(propKey);if(canDiffStyleForHydrationWarning){var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}}else if(isCustomComponentTag){// $FlowFixMe - Should be inferred as not undefined.
  extraAttributeNames.delete(propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=false;if(propertyInfo!==null){// $FlowFixMe - Should be inferred as not undefined.
  extraAttributeNames.delete(propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);}else {var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE$1){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE$1){// $FlowFixMe - Should be inferred as not undefined.
  extraAttributeNames.delete(propKey.toLowerCase());}else {var standardName=getPossibleStandardName(propKey);if(standardName!==null&&standardName!==propKey){// If an SVG prop is supplied with bad casing, it will
  // be successfully parsed from HTML, but will produce a mismatch
  // (and would be incorrectly rendered on the client).
  // However, we already warn about bad casing elsewhere.
  // So we'll skip the misleading extra mismatch warning in this case.
  isMismatchDueToBadCasing=true;// $FlowFixMe - Should be inferred as not undefined.
  extraAttributeNames.delete(standardName);}// $FlowFixMe - Should be inferred as not undefined.
  extraAttributeNames.delete(propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}if(nextProp!==serverValue&&!isMismatchDueToBadCasing){warnForPropDifference(propKey,serverValue,nextProp);}}}}{// $FlowFixMe - Should be inferred as not undefined.
  if(extraAttributeNames.size>0&&!suppressHydrationWarning){// $FlowFixMe - Should be inferred as not undefined.
  warnForExtraAttributes(extraAttributeNames);}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
  // up necessary since we never stop tracking anymore.
  track(domElement);postMountWrapper(domElement,rawProps,true);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
  // up necessary since we never stop tracking anymore.
  track(domElement);postMountWrapper$3(domElement);break;case'select':case'option':// For input and textarea we current always set the value property at
  // post mount to force it to diverge from attributes. However, for
  // option and select we don't quite do the same thing and select
  // is not resilient to the DOM state changing so we don't do that here.
  // TODO: Consider not doing this for input and textarea.
  break;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
  trapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText(textNode,text){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForUnmatchedText(textNode,text){{warnForTextDifference(textNode.nodeValue,text);}}function warnForDeletedHydratableElement(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain the text node "%s" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in
  // the HTML.
  // TODO: Remove this special case if we can just avoid inserting empty
  // text nodes.
  return;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching text node for "%s" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState$3(domElement,tag,props){switch(tag){case'input':restoreControlledState(domElement,props);return;case'textarea':restoreControlledState$2(domElement,props);return;case'select':restoreControlledState$1(domElement,props);return;}}function getActiveElement(doc){doc=doc||(typeof document!=='undefined'?document:undefined);if(typeof doc==='undefined'){return null;}try{return doc.activeElement||doc.body;}catch(e){return doc.body;}}/**
   * Given any node return the first leaf node without children.
   *
   * @param {DOMElement|DOMTextNode} node
   * @return {DOMElement|DOMTextNode}
   */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**
   * Get the next sibling within a container. This will walk up the
   * DOM if a node's siblings have been exhausted.
   *
   * @param {DOMElement|DOMTextNode} node
   * @return {?DOMElement|DOMTextNode}
   */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**
   * Get object describing the nodes which contain characters at offset.
   *
   * @param {DOMElement|DOMTextNode} root
   * @param {number} offset
   * @return {?object}
   */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return {node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**
   * @param {DOMElement} outerNode
   * @return {?object}
   */function getOffsets(outerNode){var ownerDocument=outerNode.ownerDocument;var win=ownerDocument&&ownerDocument.defaultView||window;var selection=win.getSelection&&win.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
  // up/down buttons on an <input type="number">. Anonymous divs do not seem to
  // expose properties, triggering a "Permission denied error" if any of its
  // properties are accessed. The only seemingly possible way to avoid erroring
  // is to access a property that typically works for non-anonymous divs and
  // catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset);}/**
   * Returns {start, end} where `start` is the character/codepoint index of
   * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
   * `end` is the index of (focusNode, focusOffset).
   *
   * Returns null if you pass in garbage input but we should probably just crash.
   *
   * Exported only for testing.
   */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.
  parentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting
  // it. If it has no children, this is still the first loop, and the only
  // valid selection is anchorNode and focusNode both equal to this node
  // and both offsets 0, in which case we will have handled above.
  break outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.
  node=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't
  // actually inside the passed-in node.)
  return null;}return {start:start,end:end};}/**
   * In modern non-IE browsers, we can support both forward and backward
   * selections.
   *
   * Note: IE10+ supports the Selection object, but it does not support
   * the `extend` method, which means that even in modern IE, it's not possible
   * to programmatically create a backward selection. Thus, for all IE
   * versions, we use the old IE API to create our selections.
   *
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */function setOffsets(node,offsets){var doc=node.ownerDocument||document;var win=doc&&doc.defaultView||window;// Edge fails with "Object expected" in some scenarios.
  // (For instance: TinyMCE editor used in a list component that supports pasting to add more,
  // fails when pasting 100+ items)
  if(!win.getSelection){return;}var selection=win.getSelection();var length=node.textContent.length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else {range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isTextNode(node){return node&&node.nodeType===TEXT_NODE;}function containsNode(outerNode,innerNode){if(!outerNode||!innerNode){return false;}else if(outerNode===innerNode){return true;}else if(isTextNode(outerNode)){return false;}else if(isTextNode(innerNode)){return containsNode(outerNode,innerNode.parentNode);}else if('contains'in outerNode){return outerNode.contains(innerNode);}else if(outerNode.compareDocumentPosition){return !!(outerNode.compareDocumentPosition(innerNode)&16);}else {return false;}}function isInDocument(node){return node&&node.ownerDocument&&containsNode(node.ownerDocument.documentElement,node);}function isSameOriginFrame(iframe){try{// Accessing the contentDocument of a HTMLIframeElement can cause the browser
  // to throw, e.g. if it has a cross-origin src attribute.
  // Safari will show an error in the console when the access results in "Blocked a frame with origin". e.g:
  // iframe.contentDocument.defaultView;
  // A safety way is to access one of the cross origin properties: Window or Location
  // Which might result in "SecurityError" DOM Exception and it is compatible to Safari.
  // https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl
  return typeof iframe.contentWindow.location.href==='string';}catch(err){return false;}}function getActiveElementDeep(){var win=window;var element=getActiveElement();while(element instanceof win.HTMLIFrameElement){if(isSameOriginFrame(element)){win=element.contentWindow;}else {return element;}element=getActiveElement(win.document);}return element;}/**
   * @ReactInputSelection: React input selection module. Based on Selection.js,
   * but modified to be suitable for react and has a couple of bug fixes (doesn't
   * assume buttons have range selections allowed).
   * Input selection module for React.
   */ /**
   * @hasSelectionCapabilities: we get the element types that support selection
   * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
   * and `selectionEnd` rows.
   */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&(elem.type==='text'||elem.type==='search'||elem.type==='tel'||elem.type==='url'||elem.type==='password')||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElementDeep();return {// Used by Flare
  activeElementDetached:null,focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection(focusedElem):null};}/**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElementDeep();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable
  var ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}if(typeof priorFocusedElem.focus==='function'){priorFocusedElem.focus();}for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */function getSelection(input){var selection;if('selectionStart'in input){// Modern browser with input or textarea.
  selection={start:input.selectionStart,end:input.selectionEnd};}else {// Content editable or old IE textarea.
  selection=getOffsets(input);}return selection||{start:0,end:0};}/**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */function setSelection(input,offsets){var start=offsets.start,end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else {setOffsets(input,offsets);}}var validateDOMNesting=function(){};var updatedAncestorInfo=function(){};{// This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.
  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};updatedAncestorInfo=function(oldInfo,tag){var ancestorInfo=_assign({},oldInfo||emptyAncestorInfo);var info={tag:tag};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
  if(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**
     * Returns whether
     */var isTagValidWithParent=function(tag,parentTag){// First, let's check if we're in an unusual parsing mode...
  switch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
  case'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>
  // but
  case'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
  // No special behavior since these rules fall back to "in body" mode for
  // all except special table nodes which cause bad parsing behavior anyway.
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
  case'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
  case'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
  case'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
  case'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
  case'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
  case'html':return tag==='head'||tag==='body'||tag==='frameset';case'frameset':return tag==='frame';case'#document':return tag==='html';}// Probably in the "in body" parsing mode, so we outlaw only tag combos
  // where the parsing rules cause implicit opens or closes to be added.
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
  switch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frameset':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child
  // parsing rules -- if we're down here, then none of those matched and
  // so we allow it only if we don't know what the parent is, as all other
  // cases are invalid.
  return parentTag==null;}return true;};/**
     * Returns whether
     */var findInvalidAncestorForTag=function(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds
  // equivalent to this check.
  return ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn$1={};validateDOMNesting=function(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){if(childTag!=null){error('validateDOMNesting: when childText is passed, childTag should be null');}childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var addendum=getCurrentFiberStackInDev();var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag+'|'+addendum;if(didWarn$1[warnKey]){return;}didWarn$1[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\S/.test(childText)){tagDisplayName='Text nodes';}else {tagDisplayName='Whitespace text nodes';whitespaceInfo=" Make sure you don't have any extra whitespace between tags on "+'each line of your source code.';}}else {tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by '+'the browser.';}error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info);}else {error('validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.',tagDisplayName,ancestorTag);}};}var SUPPRESS_HYDRATION_WARNING$1;{SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';}var SUSPENSE_START_DATA='$';var SUSPENSE_END_DATA='/$';var SUSPENSE_PENDING_START_DATA='$?';var SUSPENSE_FALLBACK_START_DATA='$!';var STYLE$1='style';var eventsEnabled=null;var selectionInformation=null;function shouldAutoFocusHostComponent(type,props){switch(type){case'button':case'input':case'select':case'textarea':return !!props.autoFocus;}return false;}function getRootHostContext(rootContainerInstance){var type;var namespace;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var ancestorInfo=updatedAncestorInfo(null,validatedTag);return {namespace:namespace,ancestorInfo:ancestorInfo};}}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext;var namespace=getChildNamespace(parentHostContextDev.namespace,type);var ancestorInfo=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type);return {namespace:namespace,ancestorInfo:ancestorInfo};}}function getPublicInstance(instance){return instance;}function prepareForCommit(containerInfo){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();setEnabled(false);}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation);setEnabled(eventsEnabled);eventsEnabled=null;selectionInformation=null;}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace;{// TODO: take namespace into account when validating.
  var hostContextDev=hostContext;validateDOMNesting(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){setInitialProperties(domElement,type,props,rootContainerInstance);return shouldAutoFocusHostComponent(type,props);}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(typeof newProps.children!==typeof oldProps.children&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps,rootContainerInstance);}function shouldSetTextContent(type,props){return type==='textarea'||type==='option'||type==='noscript'||typeof props.children==='string'||typeof props.children==='number'||typeof props.dangerouslySetInnerHTML==='object'&&props.dangerouslySetInnerHTML!==null&&props.dangerouslySetInnerHTML.__html!=null;}function shouldDeprioritizeSubtree(type,props){return !!props.hidden;}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;}// if a component just imports ReactDOM (e.g. for findDOMNode).
  // Some environments might not have setTimeout or clearTimeout.
  var scheduleTimeout=typeof setTimeout==='function'?setTimeout:undefined;var cancelTimeout=typeof clearTimeout==='function'?clearTimeout:undefined;var noTimeout=-1;// -------------------
  function commitMount(domElement,type,newProps,internalInstanceHandle){// Despite the naming that might imply otherwise, this method only
  // fires if there is an `Update` effect scheduled during mounting.
  // This happens if `finalizeInitialChildren` returns `true` (which it
  // does to implement the `autoFocus` attribute on the client). But
  // there are also other cases when this might happen (such as patching
  // up text content during hydration mismatch). So we'll check this again.
  if(shouldAutoFocusHostComponent(type,newProps)){domElement.focus();}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Update the props handle so that we know which props are the ones with
  // with current event handlers.
  updateFiberProps(domElement,newProps);// Apply the diff to the DOM node.
  updateProperties(domElement,updatePayload,type,oldProps,newProps);}function resetTextContent(domElement){setTextContent(domElement,'');}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;}function appendChild(parentInstance,child){parentInstance.appendChild(child);}function appendChildToContainer(container,child){var parentNode;if(container.nodeType===COMMENT_NODE){parentNode=container.parentNode;parentNode.insertBefore(child,container);}else {parentNode=container;parentNode.appendChild(child);}// This container might be used for a portal.
  // If something inside a portal is clicked, that click should bubble
  // through the React tree. However, on Mobile Safari the click would
  // never bubble through the *DOM* tree unless an ancestor with onclick
  // event exists. So we wouldn't see it and dispatch it.
  // This is why we ensure that non React root containers have inline onclick
  // defined.
  // https://github.com/facebook/react/issues/11918
  var reactRootContainer=container._reactRootContainer;if((reactRootContainer===null||reactRootContainer===undefined)&&parentNode.onclick===null){// TODO: This cast may not be sound for SVG, MathML or custom elements.
  trapClickOnNonInteractiveElement(parentNode);}}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);}function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else {container.insertBefore(child,beforeChild);}}function removeChild(parentInstance,child){parentInstance.removeChild(child);}function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else {container.removeChild(child);}}function hideInstance(instance){// pass host context to this method?
  instance=instance;var style=instance.style;if(typeof style.setProperty==='function'){style.setProperty('display','none','important');}else {style.display='none';}}function hideTextInstance(textInstance){textInstance.nodeValue='';}function unhideInstance(instance,props){instance=instance;var styleProp=props[STYLE$1];var display=styleProp!==undefined&&styleProp!==null&&styleProp.hasOwnProperty('display')?styleProp.display:null;instance.style.display=dangerousStyleValue('display',display);}function unhideTextInstance(textInstance,text){textInstance.nodeValue=text;}// -------------------
  function canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.
  return instance;}function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.
  return null;}// This has now been refined to a text node.
  return instance;}function isSuspenseInstancePending(instance){return instance.data===SUSPENSE_PENDING_START_DATA;}function isSuspenseInstanceFallback(instance){return instance.data===SUSPENSE_FALLBACK_START_DATA;}function getNextHydratable(node){// Skip non-hydratable nodes.
  for(;node!=null;node=node.nextSibling){var nodeType=node.nodeType;if(nodeType===ELEMENT_NODE||nodeType===TEXT_NODE){break;}}return node;}function getNextHydratableSibling(instance){return getNextHydratable(instance.nextSibling);}function getFirstHydratableChild(parentInstance){return getNextHydratable(parentInstance.firstChild);}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events
  // get attached.
  updateFiberProps(instance,props);var parentNamespace;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance);}function hydrateTextInstance(textInstance,text,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,textInstance);return diffHydratedText(textInstance,text);}function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance){var node=suspenseInstance.nextSibling;// Skip past all nodes within this suspense boundary.
  // There might be nested nodes so we need to keep track of how
  // deep we are and only break out when we're back on top.
  var depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_END_DATA){if(depth===0){return getNextHydratableSibling(node);}else {depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){depth++;}}node=node.nextSibling;}// TODO: Warn, we didn't find the end comment boundary.
  return null;}// Returns the SuspenseInstance if this node is a direct child of a
  // SuspenseInstance. I.e. if its previous sibling is a Comment with
  // SUSPENSE_x_START_DATA. Otherwise, null.
  function getParentSuspenseInstance(targetInstance){var node=targetInstance.previousSibling;// Skip past all nodes within this suspense boundary.
  // There might be nested nodes so we need to keep track of how
  // deep we are and only break out when we're back on top.
  var depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){if(depth===0){return node;}else {depth--;}}else if(data===SUSPENSE_END_DATA){depth++;}}node=node.previousSibling;}return null;}function commitHydratedContainer(container){// Retry if any event replaying was blocked on this.
  retryIfBlockedOn(container);}function commitHydratedSuspenseInstance(suspenseInstance){// Retry if any event replaying was blocked on this.
  retryIfBlockedOn(suspenseInstance);}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text){{warnForUnmatchedText(textInstance,text);}}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForUnmatchedText(textInstance,text);}}function didNotHydrateContainerInstance(parentContainer,instance){{if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentContainer,instance);}else if(instance.nodeType===COMMENT_NODE);else {warnForDeletedHydratableText(parentContainer,instance);}}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentInstance,instance);}else if(instance.nodeType===COMMENT_NODE);else {warnForDeletedHydratableText(parentInstance,instance);}}}function didNotFindHydratableContainerInstance(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type);}}function didNotFindHydratableContainerTextInstance(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedElement(parentInstance,type);}}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedText(parentInstance,text);}}function didNotFindHydratableSuspenseInstance(parentType,parentProps,parentInstance){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true);}var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactInternalInstance$'+randomKey;var internalEventHandlersKey='__reactEventHandlers$'+randomKey;var internalContainerInstanceKey='__reactContainere$'+randomKey;function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst;}function markContainerAsRoot(hostRoot,node){node[internalContainerInstanceKey]=hostRoot;}function unmarkContainerAsRoot(node){node[internalContainerInstanceKey]=null;}function isContainerMarkedAsRoot(node){return !!node[internalContainerInstanceKey];}// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.
  // If the target node is part of a hydrated or not yet rendered subtree, then
  // this may also return a SuspenseComponent or HostRoot to indicate that.
  // Conceptually the HostRoot fiber is a child of the Container node. So if you
  // pass the Container node as the targetNode, you will not actually get the
  // HostRoot back. To get to the HostRoot, you need to pass a child of it.
  // The same thing applies to Suspense boundaries.
  function getClosestInstanceFromNode(targetNode){var targetInst=targetNode[internalInstanceKey];if(targetInst){// Don't return HostRoot or SuspenseComponent here.
  return targetInst;}// If the direct event target isn't a React owned DOM node, we need to look
  // to see if one of its parents is a React owned DOM node.
  var parentNode=targetNode.parentNode;while(parentNode){// We'll check if this is a container root that could include
  // React nodes in the future. We need to check this first because
  // if we're a child of a dehydrated container, we need to first
  // find that inner container before moving on to finding the parent
  // instance. Note that we don't check this field on  the targetNode
  // itself because the fibers are conceptually between the container
  // node and the first child. It isn't surrounding the container node.
  // If it's not a container, we check if it's an instance.
  targetInst=parentNode[internalContainerInstanceKey]||parentNode[internalInstanceKey];if(targetInst){// Since this wasn't the direct target of the event, we might have
  // stepped past dehydrated DOM nodes to get here. However they could
  // also have been non-React nodes. We need to answer which one.
  // If we the instance doesn't have any children, then there can't be
  // a nested suspense boundary within it. So we can use this as a fast
  // bailout. Most of the time, when people add non-React children to
  // the tree, it is using a ref to a child-less DOM node.
  // Normally we'd only need to check one of the fibers because if it
  // has ever gone from having children to deleting them or vice versa
  // it would have deleted the dehydrated boundary nested inside already.
  // However, since the HostRoot starts out with an alternate it might
  // have one on the alternate so we need to check in case this was a
  // root.
  var alternate=targetInst.alternate;if(targetInst.child!==null||alternate!==null&&alternate.child!==null){// Next we need to figure out if the node that skipped past is
  // nested within a dehydrated boundary and if so, which one.
  var suspenseInstance=getParentSuspenseInstance(targetNode);while(suspenseInstance!==null){// We found a suspense instance. That means that we haven't
  // hydrated it yet. Even though we leave the comments in the
  // DOM after hydrating, and there are boundaries in the DOM
  // that could already be hydrated, we wouldn't have found them
  // through this pass since if the target is hydrated it would
  // have had an internalInstanceKey on it.
  // Let's get the fiber associated with the SuspenseComponent
  // as the deepest instance.
  var targetSuspenseInst=suspenseInstance[internalInstanceKey];if(targetSuspenseInst){return targetSuspenseInst;}// If we don't find a Fiber on the comment, it might be because
  // we haven't gotten to hydrate it yet. There might still be a
  // parent boundary that hasn't above this one so we need to find
  // the outer most that is known.
  suspenseInstance=getParentSuspenseInstance(suspenseInstance);// If we don't find one, then that should mean that the parent
  // host component also hasn't hydrated yet. We can return it
  // below since it will bail out on the isMounted check later.
  }}return targetInst;}targetNode=parentNode;parentNode=targetNode.parentNode;}return null;}/**
   * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
   * instance, or null if the node was not rendered by this React.
   */function getInstanceFromNode$1(node){var inst=node[internalInstanceKey]||node[internalContainerInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText||inst.tag===SuspenseComponent||inst.tag===HostRoot){return inst;}else {return null;}}return null;}/**
   * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
   * DOM node.
   */function getNodeFromInstance$1(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be
  // a host component or host text.
  return inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  {{throw Error("getNodeFromInstance: Invalid argument.");}}}function getFiberCurrentPropsFromNode$1(node){return node[internalEventHandlersKey]||null;}function updateFiberProps(node,props){node[internalEventHandlersKey]=props;}function getParent(inst){do{inst=inst.return;// TODO: If this is a HostRoot we might want to bail out.
  // That is depending on if we want nested subtrees (layers) to bubble
  // events to their parent. We could also go through parentNode on the
  // host node but that wouldn't work for React Native and doesn't let us
  // do the portal feature.
  }while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**
   * Return the lowest common ancestor of A and B, or null if they are in
   * different trees.
   */function getLowestCommonAncestor(instA,instB){var depthA=0;for(var tempA=instA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=instB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.
  while(depthA-depthB>0){instA=getParent(instA);depthA--;}// If B is deeper, crawl up.
  while(depthB-depthA>0){instB=getParent(instB);depthB--;}// Walk in lockstep until we find a match.
  var depth=depthA;while(depth--){if(instA===instB||instA===instB.alternate){return instA;}instA=getParent(instA);instB=getParent(instB);}return null;}/**
   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
   */function traverseTwoPhase(inst,fn,arg){var path=[];while(inst){path.push(inst);inst=getParent(inst);}var i;for(i=path.length;i-->0;){fn(path[i],'captured',arg);}for(i=0;i<path.length;i++){fn(path[i],'bubbled',arg);}}/**
   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
   * should would receive a `mouseEnter` or `mouseLeave` event.
   *
   * Does not invoke the callback on the nearest common ancestor because nothing
   * "entered" or "left" that element.
   */function traverseEnterLeave(from,to,fn,argFrom,argTo){var common=from&&to?getLowestCommonAncestor(from,to):null;var pathFrom=[];while(true){if(!from){break;}if(from===common){break;}var alternate=from.alternate;if(alternate!==null&&alternate===common){break;}pathFrom.push(from);from=getParent(from);}var pathTo=[];while(true){if(!to){break;}if(to===common){break;}var _alternate=to.alternate;if(_alternate!==null&&_alternate===common){break;}pathTo.push(to);to=getParent(to);}for(var i=0;i<pathFrom.length;i++){fn(pathFrom[i],'bubbled',argFrom);}for(var _i=pathTo.length;_i-->0;){fn(pathTo[_i],'captured',argTo);}}function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':case'onMouseEnter':return !!(props.disabled&&isInteractive(type));default:return false;}}/**
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */function getListener(inst,registrationName){var listener;// TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
  // live here; needs to be moved to a better place soon
  var stateNode=inst.stateNode;if(!stateNode){// Work in progress (ex: onload events in incremental mode).
  return null;}var props=getFiberCurrentPropsFromNode(stateNode);if(!props){// Work in progress.
  return null;}listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}if(!(!listener||typeof listener==='function')){{throw Error("Expected `"+registrationName+"` listener to be a function, instead got a value of `"+typeof listener+"` type.");}}return listener;}/**
   * Some event types have a notion of different registration names for different
   * "phases" of propagation. This finds listeners by a given phase.
   */function listenerAtPhase(inst,event,propagationPhase){var registrationName=event.dispatchConfig.phasedRegistrationNames[propagationPhase];return getListener(inst,registrationName);}/**
   * A small set of propagation patterns, each of which will accept a small amount
   * of information, and generate a set of "dispatch ready event objects" - which
   * are sets of events that have already been annotated with a set of dispatched
   * listener functions/ids. The API is designed this way to discourage these
   * propagation strategies from actually executing the dispatches, since we
   * always want to collect the entire set of dispatches before executing even a
   * single one.
   */ /**
   * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
   * here, allows us to not have to bind or create functions for each event.
   * Mutating the event's members allows us to not have to create a wrapping
   * "dispatch" object that pairs the event with the listener.
   */function accumulateDirectionalDispatches(inst,phase,event){{if(!inst){error('Dispatching inst must not be null');}}var listener=listenerAtPhase(inst,event,phase);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}/**
   * Collect dispatches (must be entirely collected before dispatching - see unit
   * tests). Lazily allocate the array to conserve memory.  We must loop through
   * each event and perform the traversal for each one. We cannot perform a
   * single traversal for the entire collection of events because each event may
   * have a different target.
   */function accumulateTwoPhaseDispatchesSingle(event){if(event&&event.dispatchConfig.phasedRegistrationNames){traverseTwoPhase(event._targetInst,accumulateDirectionalDispatches,event);}}/**
   * Accumulates without regard to direction, does not look for phased
   * registration names. Same as `accumulateDirectDispatchesSingle` but without
   * requiring that the `dispatchMarker` be the same as the dispatched ID.
   */function accumulateDispatches(inst,ignoredDirection,event){if(inst&&event&&event.dispatchConfig.registrationName){var registrationName=event.dispatchConfig.registrationName;var listener=getListener(inst,registrationName);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}}/**
   * Accumulates dispatches on an `SyntheticEvent`, but only for the
   * `dispatchMarker`.
   * @param {SyntheticEvent} event
   */function accumulateDirectDispatchesSingle(event){if(event&&event.dispatchConfig.registrationName){accumulateDispatches(event._targetInst,null,event);}}function accumulateTwoPhaseDispatches(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingle);}function accumulateEnterLeaveDispatches(leave,enter,from,to){traverseEnterLeave(from,to,accumulateDispatches,leave,enter);}function accumulateDirectDispatches(events){forEachAccumulated(events,accumulateDirectDispatchesSingle);}/**
   * These variables store information about text content of a target node,
   * allowing comparison of content before and after a given event.
   *
   * Identify the node where selection currently begins, then observe
   * both its text content and its current position in the DOM. Since the
   * browser may natively replace the target node during composition, we can
   * use its position to find its replacement.
   *
   *
   */var root=null;var startText=null;var fallbackText=null;function initialize(nativeEventTarget){root=nativeEventTarget;startText=getText();return true;}function reset(){root=null;startText=null;fallbackText=null;}function getData(){if(fallbackText){return fallbackText;}var start;var startValue=startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;fallbackText=endValue.slice(start,sliceTail);return fallbackText;}function getText(){if('value'in root){return root.value;}return root.textContent;}var EVENT_POOL_SIZE=10;/**
   * @interface Event
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */var EventInterface={type:null,target:null,// currentTarget is set when dispatching; no use in copying it here
  currentTarget:function(){return null;},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(event){return event.timeStamp||Date.now();},defaultPrevented:null,isTrusted:null};function functionThatReturnsTrue(){return true;}function functionThatReturnsFalse(){return false;}/**
   * Synthetic events are dispatched by event plugins, typically in response to a
   * top-level event delegation handler.
   *
   * These systems should generally use pooling to reduce the frequency of garbage
   * collection. The system should check `isPersistent` to determine whether the
   * event should be released into the pool after being dispatched. Users that
   * need a persisted event should invoke `persist`.
   *
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
   * normalizing browser quirks. Subclasses do not necessarily have to implement a
   * DOM interface; custom application-specific events can also subclass this.
   *
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {*} targetInst Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @param {DOMEventTarget} nativeEventTarget Target node.
   */function SyntheticEvent(dispatchConfig,targetInst,nativeEvent,nativeEventTarget){{// these have a getter/setter for warnings
  delete this.nativeEvent;delete this.preventDefault;delete this.stopPropagation;delete this.isDefaultPrevented;delete this.isPropagationStopped;}this.dispatchConfig=dispatchConfig;this._targetInst=targetInst;this.nativeEvent=nativeEvent;var Interface=this.constructor.Interface;for(var propName in Interface){if(!Interface.hasOwnProperty(propName)){continue;}{delete this[propName];// this has a getter/setter for warnings
  }var normalize=Interface[propName];if(normalize){this[propName]=normalize(nativeEvent);}else {if(propName==='target'){this.target=nativeEventTarget;}else {this[propName]=nativeEvent[propName];}}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=functionThatReturnsTrue;}else {this.isDefaultPrevented=functionThatReturnsFalse;}this.isPropagationStopped=functionThatReturnsFalse;return this;}_assign(SyntheticEvent.prototype,{preventDefault:function(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=functionThatReturnsTrue;},stopPropagation:function(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a "propertychange" event for
  // IE. This event does not support bubbling or cancelling, and
  // any references to cancelBubble throw "Member not found".  A
  // typeof check of "unknown" circumvents this issue (and is also
  // IE specific).
  event.cancelBubble=true;}this.isPropagationStopped=functionThatReturnsTrue;},/**
     * We release all dispatched `SyntheticEvent`s after each event loop, adding
     * them back into the pool. This allows a way to hold onto a reference that
     * won't be added back into the pool.
     */persist:function(){this.isPersistent=functionThatReturnsTrue;},/**
     * Checks if this event should be released back into the pool.
     *
     * @return {boolean} True if this should not be released, false otherwise.
     */isPersistent:functionThatReturnsFalse,/**
     * `PooledClass` looks for `destructor` on each instance it releases.
     */destructor:function(){var Interface=this.constructor.Interface;for(var propName in Interface){{Object.defineProperty(this,propName,getPooledWarningPropertyDefinition(propName,Interface[propName]));}}this.dispatchConfig=null;this._targetInst=null;this.nativeEvent=null;this.isDefaultPrevented=functionThatReturnsFalse;this.isPropagationStopped=functionThatReturnsFalse;this._dispatchListeners=null;this._dispatchInstances=null;{Object.defineProperty(this,'nativeEvent',getPooledWarningPropertyDefinition('nativeEvent',null));Object.defineProperty(this,'isDefaultPrevented',getPooledWarningPropertyDefinition('isDefaultPrevented',functionThatReturnsFalse));Object.defineProperty(this,'isPropagationStopped',getPooledWarningPropertyDefinition('isPropagationStopped',functionThatReturnsFalse));Object.defineProperty(this,'preventDefault',getPooledWarningPropertyDefinition('preventDefault',function(){}));Object.defineProperty(this,'stopPropagation',getPooledWarningPropertyDefinition('stopPropagation',function(){}));}}});SyntheticEvent.Interface=EventInterface;/**
   * Helper to reduce boilerplate when creating subclasses.
   */SyntheticEvent.extend=function(Interface){var Super=this;var E=function(){};E.prototype=Super.prototype;var prototype=new E();function Class(){return Super.apply(this,arguments);}_assign(prototype,Class.prototype);Class.prototype=prototype;Class.prototype.constructor=Class;Class.Interface=_assign({},Super.Interface,Interface);Class.extend=Super.extend;addEventPoolingTo(Class);return Class;};addEventPoolingTo(SyntheticEvent);/**
   * Helper to nullify syntheticEvent instance properties when destructing
   *
   * @param {String} propName
   * @param {?object} getVal
   * @return {object} defineProperty object
   */function getPooledWarningPropertyDefinition(propName,getVal){var isFunction=typeof getVal==='function';return {configurable:true,set:set,get:get};function set(val){var action=isFunction?'setting the method':'setting the property';warn(action,'This is effectively a no-op');return val;}function get(){var action=isFunction?'accessing the method':'accessing the property';var result=isFunction?'This is a no-op function':'This is set to null';warn(action,result);return getVal;}function warn(action,result){{error("This synthetic event is reused for performance reasons. If you're seeing this, "+"you're %s `%s` on a released/nullified synthetic event. %s. "+'If you must keep the original synthetic event around, use event.persist(). '+'See https://fb.me/react-event-pooling for more information.',action,propName,result);}}}function getPooledEvent(dispatchConfig,targetInst,nativeEvent,nativeInst){var EventConstructor=this;if(EventConstructor.eventPool.length){var instance=EventConstructor.eventPool.pop();EventConstructor.call(instance,dispatchConfig,targetInst,nativeEvent,nativeInst);return instance;}return new EventConstructor(dispatchConfig,targetInst,nativeEvent,nativeInst);}function releasePooledEvent(event){var EventConstructor=this;if(!(event instanceof EventConstructor)){{throw Error("Trying to release an event instance into a pool of a different type.");}}event.destructor();if(EventConstructor.eventPool.length<EVENT_POOL_SIZE){EventConstructor.eventPool.push(event);}}function addEventPoolingTo(EventConstructor){EventConstructor.eventPool=[];EventConstructor.getPooled=getPooledEvent;EventConstructor.release=releasePooledEvent;}/**
   * @interface Event
   * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
   */var SyntheticCompositionEvent=SyntheticEvent.extend({data:null});/**
   * @interface Event
   * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
   *      /#events-inputevents
   */var SyntheticInputEvent=SyntheticEvent.extend({data:null});var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space
  var START_KEYCODE=229;var canUseCompositionEvent=canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to
  // directly represent `beforeInput`. The IE `textinput` event is not as
  // useful, so we don't use it.
  var canUseTextInputEvent=canUseDOM&&'TextEvent'in window&&!documentMode;// In IE9+, we have access to composition events, but the data supplied
  // by the native compositionend event may be incorrect. Japanese ideographic
  // spaces, for instance (\u3000) are not recorded correctly.
  var useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);// Events and their corresponding property names.
  var eventTypes={beforeInput:{phasedRegistrationNames:{bubbled:'onBeforeInput',captured:'onBeforeInputCapture'},dependencies:[TOP_COMPOSITION_END,TOP_KEY_PRESS,TOP_TEXT_INPUT,TOP_PASTE]},compositionEnd:{phasedRegistrationNames:{bubbled:'onCompositionEnd',captured:'onCompositionEndCapture'},dependencies:[TOP_BLUR,TOP_COMPOSITION_END,TOP_KEY_DOWN,TOP_KEY_PRESS,TOP_KEY_UP,TOP_MOUSE_DOWN]},compositionStart:{phasedRegistrationNames:{bubbled:'onCompositionStart',captured:'onCompositionStartCapture'},dependencies:[TOP_BLUR,TOP_COMPOSITION_START,TOP_KEY_DOWN,TOP_KEY_PRESS,TOP_KEY_UP,TOP_MOUSE_DOWN]},compositionUpdate:{phasedRegistrationNames:{bubbled:'onCompositionUpdate',captured:'onCompositionUpdateCapture'},dependencies:[TOP_BLUR,TOP_COMPOSITION_UPDATE,TOP_KEY_DOWN,TOP_KEY_PRESS,TOP_KEY_UP,TOP_MOUSE_DOWN]}};// Track whether we've ever handled a keypress on the space key.
  var hasSpaceKeypress=false;/**
   * Return whether a native keypress event is assumed to be a command.
   * This is required because Firefox fires `keypress` events for key commands
   * (cut, copy, select-all, etc.) even though no character is inserted.
   */function isKeypressCommand(nativeEvent){return (nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**
   * Translate native top level events into event types.
   *
   * @param {string} topLevelType
   * @return {object}
   */function getCompositionEventType(topLevelType){switch(topLevelType){case TOP_COMPOSITION_START:return eventTypes.compositionStart;case TOP_COMPOSITION_END:return eventTypes.compositionEnd;case TOP_COMPOSITION_UPDATE:return eventTypes.compositionUpdate;}}/**
   * Does our fallback best-guess model think this event signifies that
   * composition has begun?
   *
   * @param {string} topLevelType
   * @param {object} nativeEvent
   * @return {boolean}
   */function isFallbackCompositionStart(topLevelType,nativeEvent){return topLevelType===TOP_KEY_DOWN&&nativeEvent.keyCode===START_KEYCODE;}/**
   * Does our fallback mode think that this event is the end of composition?
   *
   * @param {string} topLevelType
   * @param {object} nativeEvent
   * @return {boolean}
   */function isFallbackCompositionEnd(topLevelType,nativeEvent){switch(topLevelType){case TOP_KEY_UP:// Command keys insert or clear IME input.
  return END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case TOP_KEY_DOWN:// Expect IME keyCode on each keydown. If we get any other
  // code we must have exited earlier.
  return nativeEvent.keyCode!==START_KEYCODE;case TOP_KEY_PRESS:case TOP_MOUSE_DOWN:case TOP_BLUR:// Events are not possible without cancelling IME.
  return true;default:return false;}}/**
   * Google Input Tools provides composition data via a CustomEvent,
   * with the `data` property populated in the `detail` object. If this
   * is available on the event object, use it. If not, this is a plain
   * composition event and we have nothing special to extract.
   *
   * @param {object} nativeEvent
   * @return {?string}
   */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if(typeof detail==='object'&&'data'in detail){return detail.data;}return null;}/**
   * Check if a composition event was triggered by Korean IME.
   * Our fallback mode does not work well with IE's Korean IME,
   * so just use native composition events when Korean IME is used.
   * Although CompositionEvent.locale property is deprecated,
   * it is available in IE, where our fallback mode is enabled.
   *
   * @param {object} nativeEvent
   * @return {boolean}
   */function isUsingKoreanIME(nativeEvent){return nativeEvent.locale==='ko';}// Track the current IME composition status, if any.
  var isComposing=false;/**
   * @return {?object} A SyntheticCompositionEvent.
   */function extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(topLevelType);}else if(!isComposing){if(isFallbackCompositionStart(topLevelType,nativeEvent)){eventType=eventTypes.compositionStart;}}else if(isFallbackCompositionEnd(topLevelType,nativeEvent)){eventType=eventTypes.compositionEnd;}if(!eventType){return null;}if(useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)){// The current composition is stored statically and must not be
  // overwritten while composition continues.
  if(!isComposing&&eventType===eventTypes.compositionStart){isComposing=initialize(nativeEventTarget);}else if(eventType===eventTypes.compositionEnd){if(isComposing){fallbackData=getData();}}}var event=SyntheticCompositionEvent.getPooled(eventType,targetInst,nativeEvent,nativeEventTarget);if(fallbackData){// Inject data generated from fallback path into the synthetic event.
  // This matches the property of native CompositionEventInterface.
  event.data=fallbackData;}else {var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}accumulateTwoPhaseDispatches(event);return event;}/**
   * @param {TopLevelType} topLevelType Number from `TopLevelType`.
   * @param {object} nativeEvent Native browser event.
   * @return {?string} The string corresponding to this `beforeInput` event.
   */function getNativeBeforeInputChars(topLevelType,nativeEvent){switch(topLevelType){case TOP_COMPOSITION_END:return getDataFromCustomEvent(nativeEvent);case TOP_KEY_PRESS:/**
         * If native `textInput` events are available, our goal is to make
         * use of them. However, there is a special case: the spacebar key.
         * In Webkit, preventing default on a spacebar `textInput` event
         * cancels character insertion, but it *also* causes the browser
         * to fall back to its default spacebar behavior of scrolling the
         * page.
         *
         * Tracking at:
         * https://code.google.com/p/chromium/issues/detail?id=355103
         *
         * To avoid this issue, use the keypress event as if no `textInput`
         * event is available.
         */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case TOP_TEXT_INPUT:// Record the characters to be added to the DOM.
  var chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled
  // it at the keypress level and bail immediately. Android Chrome
  // doesn't give us keycodes, so we need to ignore it.
  if(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.
  return null;}}/**
   * For browsers that do not provide the `textInput` event, extract the
   * appropriate string to use for SyntheticInputEvent.
   *
   * @param {number} topLevelType Number from `TopLevelEventTypes`.
   * @param {object} nativeEvent Native browser event.
   * @return {?string} The fallback string for this `beforeInput` event.
   */function getFallbackBeforeInputChars(topLevelType,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if(isComposing){if(topLevelType===TOP_COMPOSITION_END||!canUseCompositionEvent&&isFallbackCompositionEnd(topLevelType,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(topLevelType){case TOP_PASTE:// If a paste event occurs after a keypress, throw out the input
  // chars. Paste events should not lead to BeforeInput events.
  return null;case TOP_KEY_PRESS:/**
         * As of v27, Firefox may fire keypress events even when no character
         * will be inserted. A few possibilities:
         *
         * - `which` is `0`. Arrow keys, Esc key, etc.
         *
         * - `which` is the pressed key code, but no char is available.
         *   Ex: 'AltGr + d` in Polish. There is no modified character for
         *   this key combination and no character is inserted into the
         *   document, but FF fires the keypress for char code `100` anyway.
         *   No `input` event will occur.
         *
         * - `which` is the pressed key code, but a command combination is
         *   being used. Ex: `Cmd+C`. No character is inserted, and no
         *   `input` event will occur.
         */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via
  // Touch keyboard of Windows.  In such a case, the `char` property
  // holds an emoji character like `\uD83D\uDE0A`.  Because its length
  // is 2, the property `which` does not represent an emoji correctly.
  // In such a case, we directly return the `char` property instead of
  // using `which`.
  if(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case TOP_COMPOSITION_END:return useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)?null:nativeEvent.data;default:return null;}}/**
   * Extract a SyntheticInputEvent for `beforeInput`, based on either native
   * `textInput` or fallback behavior.
   *
   * @return {?object} A SyntheticInputEvent.
   */function extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(topLevelType,nativeEvent);}else {chars=getFallbackBeforeInputChars(topLevelType,nativeEvent);}// If no characters are being inserted, no BeforeInput event should
  // be fired.
  if(!chars){return null;}var event=SyntheticInputEvent.getPooled(eventTypes.beforeInput,targetInst,nativeEvent,nativeEventTarget);event.data=chars;accumulateTwoPhaseDispatches(event);return event;}/**
   * Create an `onBeforeInput` event to match
   * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
   *
   * This event plugin is based on the native `textInput` event
   * available in Chrome, Safari, Opera, and IE. This event fires after
   * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
   *
   * `beforeInput` is spec'd but not implemented in any browsers, and
   * the `input` event does not provide any useful information about what has
   * actually been added, contrary to the spec. Thus, `textInput` is the best
   * available event to identify the characters that have actually been inserted
   * into the target node.
   *
   * This plugin is also responsible for emitting `composition` events, thus
   * allowing us to share composition fallback code for both `beforeInput` and
   * `composition` event types.
   */var BeforeInputEventPlugin={eventTypes:eventTypes,extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags){var composition=extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget);var beforeInput=extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget);if(composition===null){return beforeInput;}if(beforeInput===null){return composition;}return [composition,beforeInput];}};/**
   * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
   */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return !!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}var eventTypes$1={change:{phasedRegistrationNames:{bubbled:'onChange',captured:'onChangeCapture'},dependencies:[TOP_BLUR,TOP_CHANGE,TOP_CLICK,TOP_FOCUS,TOP_INPUT,TOP_KEY_DOWN,TOP_KEY_UP,TOP_SELECTION_CHANGE]}};function createAndAccumulateChangeEvent(inst,nativeEvent,target){var event=SyntheticEvent.getPooled(eventTypes$1.change,inst,nativeEvent,target);event.type='change';// Flag this event loop as needing state restore.
  enqueueStateRestore(target);accumulateTwoPhaseDispatches(event);return event;}/**
   * For IE shims
   */var activeElement=null;var activeElementInst=null;/**
   * SECTION: handle `change` event
   */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var event=createAndAccumulateChangeEvent(activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  batchedUpdates(runEventInBatch,event);}function runEventInBatch(event){runEventsInBatch(event);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance$1(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(topLevelType,targetInst){if(topLevelType===TOP_CHANGE){return targetInst;}}/**
   * SECTION: handle `input` event
   */var isInputEventSupported=false;if(canUseDOM){// IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  isInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**
   * (For IE <=9) Starts tracking propertychange events on the passed-in element
   * and override the value property so that we can distinguish user events from
   * value changes in JS.
   */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**
   * (For IE <=9) Removes the event listeners from the currently-tracked element,
   * if any exists.
   */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**
   * (For IE <=9) Handles a propertychange event, sending a `change` event if
   * the value of the active element has changed.
   */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(topLevelType,target,targetInst){if(topLevelType===TOP_FOCUS){// In IE9, propertychange fires for most input events but is buggy and
  // doesn't fire when text is deleted, but conveniently, selectionchange
  // appears to fire in all of the remaining cases so we catch those and
  // forward the event if the value has changed
  // In either case, we don't want to call the event handler if the value
  // is changed from JS so we redefine a setter for `.value` that updates
  // our activeElementValue variable, allowing us to ignore those changes
  //
  // stopWatching() should be a noop here but we call it just in case we
  // missed a blur event somehow.
  stopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(topLevelType===TOP_BLUR){stopWatchingForValueChange();}}// For IE8 and IE9.
  function getTargetInstForInputEventPolyfill(topLevelType,targetInst){if(topLevelType===TOP_SELECTION_CHANGE||topLevelType===TOP_KEY_UP||topLevelType===TOP_KEY_DOWN){// On the selectionchange event, the target is just document which isn't
  // helpful for us so just check activeElement instead.
  //
  // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
  // propertychange on the first input event after setting `value` from a
  // script and fires only keydown, keypress, keyup. Catching keyup usually
  // gets it and catching keydown lets us fire an event for the first
  // keystroke if user does a key repeat (it'll be a little delayed: right
  // before the second keystroke). Other input methods (e.g., paste) seem to
  // fire selectionchange normally.
  return getInstIfValueChanged(activeElementInst);}}/**
   * SECTION: handle `click` event
   */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(topLevelType,targetInst){if(topLevelType===TOP_CLICK){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(topLevelType,targetInst){if(topLevelType===TOP_INPUT||topLevelType===TOP_CHANGE){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(node){var state=node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}{// If controlled, assign the value attribute to the current value on blur
  setDefaultValue(node,'number',node.value);}}/**
   * This plugin creates an `onChange` event that normalizes change events
   * across form elements. This event fires at a time when it's possible to
   * change the element's value without seeing a flicker.
   *
   * Supported elements are:
   * - input (see `isTextInputElement`)
   * - textarea
   * - select
   */var ChangeEventPlugin={eventTypes:eventTypes$1,_isInputEventSupported:isInputEventSupported,extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags){var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else {getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(topLevelType,targetInst);if(inst){var event=createAndAccumulateChangeEvent(inst,nativeEvent,nativeEventTarget);return event;}}if(handleEventFunc){handleEventFunc(topLevelType,targetNode,targetInst);}// When blurring, set the value attribute for number inputs
  if(topLevelType===TOP_BLUR){handleControlledInputBlur(targetNode);}}};var SyntheticUIEvent=SyntheticEvent.extend({view:null,detail:null});/**
   * Translation from modifier key to the associated property in the event.
   * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
   */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
  // getModifierState. If getModifierState is not supported, we map it to a set of
  // modifier keys exposed by the event. In this case, Lock-keys are not supported.
  function modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}var previousScreenX=0;var previousScreenY=0;// Use flags to signal movementX/Y has already been set
  var isMovementXSet=false;var isMovementYSet=false;/**
   * @interface MouseEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */var SyntheticMouseEvent=SyntheticUIEvent.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:getEventModifierState,button:null,buttons:null,relatedTarget:function(event){return event.relatedTarget||(event.fromElement===event.srcElement?event.toElement:event.fromElement);},movementX:function(event){if('movementX'in event){return event.movementX;}var screenX=previousScreenX;previousScreenX=event.screenX;if(!isMovementXSet){isMovementXSet=true;return 0;}return event.type==='mousemove'?event.screenX-screenX:0;},movementY:function(event){if('movementY'in event){return event.movementY;}var screenY=previousScreenY;previousScreenY=event.screenY;if(!isMovementYSet){isMovementYSet=true;return 0;}return event.type==='mousemove'?event.screenY-screenY:0;}});/**
   * @interface PointerEvent
   * @see http://www.w3.org/TR/pointerevents/
   */var SyntheticPointerEvent=SyntheticMouseEvent.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null});var eventTypes$2={mouseEnter:{registrationName:'onMouseEnter',dependencies:[TOP_MOUSE_OUT,TOP_MOUSE_OVER]},mouseLeave:{registrationName:'onMouseLeave',dependencies:[TOP_MOUSE_OUT,TOP_MOUSE_OVER]},pointerEnter:{registrationName:'onPointerEnter',dependencies:[TOP_POINTER_OUT,TOP_POINTER_OVER]},pointerLeave:{registrationName:'onPointerLeave',dependencies:[TOP_POINTER_OUT,TOP_POINTER_OVER]}};var EnterLeaveEventPlugin={eventTypes:eventTypes$2,/**
     * For almost every interaction we care about, there will be both a top-level
     * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
     * we do not extract duplicate events. However, moving the mouse into the
     * browser from outside will not fire a `mouseout` event. In this case, we use
     * the `mouseover` top-level event.
     */extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags){var isOverEvent=topLevelType===TOP_MOUSE_OVER||topLevelType===TOP_POINTER_OVER;var isOutEvent=topLevelType===TOP_MOUSE_OUT||topLevelType===TOP_POINTER_OUT;if(isOverEvent&&(eventSystemFlags&IS_REPLAYED)===0&&(nativeEvent.relatedTarget||nativeEvent.fromElement)){// If this is an over event with a target, then we've already dispatched
  // the event in the out event of the other target. If this is replayed,
  // then it's because we couldn't dispatch against this target previously
  // so we have to do it now instead.
  return null;}if(!isOutEvent&&!isOverEvent){// Must not be a mouse or pointer in or out - ignoring.
  return null;}var win;if(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.
  win=nativeEventTarget;}else {// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
  var doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else {win=window;}}var from;var to;if(isOutEvent){from=targetInst;var related=nativeEvent.relatedTarget||nativeEvent.toElement;to=related?getClosestInstanceFromNode(related):null;if(to!==null){var nearestMounted=getNearestMountedFiber(to);if(to!==nearestMounted||to.tag!==HostComponent&&to.tag!==HostText){to=null;}}}else {// Moving to a node from outside the window.
  from=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.
  return null;}var eventInterface,leaveEventType,enterEventType,eventTypePrefix;if(topLevelType===TOP_MOUSE_OUT||topLevelType===TOP_MOUSE_OVER){eventInterface=SyntheticMouseEvent;leaveEventType=eventTypes$2.mouseLeave;enterEventType=eventTypes$2.mouseEnter;eventTypePrefix='mouse';}else if(topLevelType===TOP_POINTER_OUT||topLevelType===TOP_POINTER_OVER){eventInterface=SyntheticPointerEvent;leaveEventType=eventTypes$2.pointerLeave;enterEventType=eventTypes$2.pointerEnter;eventTypePrefix='pointer';}var fromNode=from==null?win:getNodeFromInstance$1(from);var toNode=to==null?win:getNodeFromInstance$1(to);var leave=eventInterface.getPooled(leaveEventType,from,nativeEvent,nativeEventTarget);leave.type=eventTypePrefix+'leave';leave.target=fromNode;leave.relatedTarget=toNode;var enter=eventInterface.getPooled(enterEventType,to,nativeEvent,nativeEventTarget);enter.type=eventTypePrefix+'enter';enter.target=toNode;enter.relatedTarget=fromNode;accumulateEnterLeaveDispatches(leave,enter,from,to);// If we are not processing the first ancestor, then we
  // should not process the same nativeEvent again, as we
  // will have already processed it in the first ancestor.
  if((eventSystemFlags&IS_FIRST_ANCESTOR)===0){return [leave];}return [leave,enter];}};/**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */function is(x,y){return x===y&&(x!==0||1/x===1/y)||x!==x&&y!==y// eslint-disable-line no-self-compare
  ;}var objectIs=typeof Object.is==='function'?Object.is:is;var hasOwnProperty$2=Object.prototype.hasOwnProperty;/**
   * Performs equality by iterating through keys on an object and returning false
   * when any key has values which are not strictly equal between the arguments.
   * Returns true when the values of all keys are strictly equal.
   */function shallowEqual(objA,objB){if(objectIs(objA,objB)){return true;}if(typeof objA!=='object'||objA===null||typeof objB!=='object'||objB===null){return false;}var keysA=Object.keys(objA);var keysB=Object.keys(objB);if(keysA.length!==keysB.length){return false;}// Test for A's keys different from B.
  for(var i=0;i<keysA.length;i++){if(!hasOwnProperty$2.call(objB,keysA[i])||!objectIs(objA[keysA[i]],objB[keysA[i]])){return false;}}return true;}var skipSelectionChangeEvent=canUseDOM&&'documentMode'in document&&document.documentMode<=11;var eventTypes$3={select:{phasedRegistrationNames:{bubbled:'onSelect',captured:'onSelectCapture'},dependencies:[TOP_BLUR,TOP_CONTEXT_MENU,TOP_DRAG_END,TOP_FOCUS,TOP_KEY_DOWN,TOP_KEY_UP,TOP_MOUSE_DOWN,TOP_MOUSE_UP,TOP_SELECTION_CHANGE]}};var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**
   * Get an object which is a unique representation of the current selection.
   *
   * The return value will not be consistent across nodes or browsers, but
   * two identical selections on the same node will return identical objects.
   *
   * @param {DOMElement} node
   * @return {object}
   */function getSelection$1(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return {start:node.selectionStart,end:node.selectionEnd};}else {var win=node.ownerDocument&&node.ownerDocument.defaultView||window;var selection=win.getSelection();return {anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**
   * Get document associated with the event target.
   *
   * @param {object} nativeEventTarget
   * @return {Document}
   */function getEventTargetDocument(eventTarget){return eventTarget.window===eventTarget?eventTarget.document:eventTarget.nodeType===DOCUMENT_NODE?eventTarget:eventTarget.ownerDocument;}/**
   * Poll selection to see whether it's changed.
   *
   * @param {object} nativeEvent
   * @param {object} nativeEventTarget
   * @return {?SyntheticEvent}
   */function constructSelectEvent(nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  var doc=getEventTargetDocument(nativeEventTarget);if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement(doc)){return null;}// Only fire when selection has actually changed.
  var currentSelection=getSelection$1(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var syntheticEvent=SyntheticEvent.getPooled(eventTypes$3.select,activeElementInst$1,nativeEvent,nativeEventTarget);syntheticEvent.type='select';syntheticEvent.target=activeElement$1;accumulateTwoPhaseDispatches(syntheticEvent);return syntheticEvent;}return null;}/**
   * This plugin creates an `onSelect` event that normalizes select events
   * across form elements.
   *
   * Supported elements are:
   * - input (see `isTextInputElement`)
   * - textarea
   * - contentEditable
   *
   * This differs from native browser implementations in the following ways:
   * - Fires on contentEditable fields as well as inputs.
   * - Fires for collapsed selection.
   * - Fires after user input.
   */var SelectEventPlugin={eventTypes:eventTypes$3,extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,container){var containerOrDoc=container||getEventTargetDocument(nativeEventTarget);// Track whether all listeners exists for this plugin. If none exist, we do
  // not extract events. See #3639.
  if(!containerOrDoc||!isListeningToAllDependencies('onSelect',containerOrDoc)){return null;}var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;switch(topLevelType){// Track the input node that has focus.
  case TOP_FOCUS:if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case TOP_BLUR:activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the
  // semantics of the native select event.
  case TOP_MOUSE_DOWN:mouseDown=true;break;case TOP_CONTEXT_MENU:case TOP_MOUSE_UP:case TOP_DRAG_END:mouseDown=false;return constructSelectEvent(nativeEvent,nativeEventTarget);// Chrome and IE fire non-standard event when selection is changed (and
  // sometimes when it hasn't). IE's event fires out of order with respect
  // to key and input events on deletion, so we discard it.
  //
  // Firefox doesn't support selectionchange, so check selection status
  // after each key entry. The selection changes after keydown and before
  // keyup, but we check on keydown as well in the case of holding down a
  // key, when multiple keydown events are fired but only one keyup is.
  // This is also our approach for IE handling, for the reason above.
  case TOP_SELECTION_CHANGE:if(skipSelectionChangeEvent){break;}// falls through
  case TOP_KEY_DOWN:case TOP_KEY_UP:return constructSelectEvent(nativeEvent,nativeEventTarget);}return null;}};/**
   * @interface Event
   * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
   * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
   */var SyntheticAnimationEvent=SyntheticEvent.extend({animationName:null,elapsedTime:null,pseudoElement:null});/**
   * @interface Event
   * @see http://www.w3.org/TR/clipboard-apis/
   */var SyntheticClipboardEvent=SyntheticEvent.extend({clipboardData:function(event){return 'clipboardData'in event?event.clipboardData:window.clipboardData;}});/**
   * @interface FocusEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */var SyntheticFocusEvent=SyntheticUIEvent.extend({relatedTarget:null});/**
   * `charCode` represents the actual "character code" and is safe to use with
   * `String.fromCharCode`. As such, only keys that correspond to printable
   * characters produce a valid `charCode`, the only exception to this is Enter.
   * The Tab-key is considered non-printable and does not have a `charCode`,
   * presumably because it does not produce a tab-character in browsers.
   *
   * @param {object} nativeEvent Native browser event.
   * @return {number} Normalized `charCode` property.
   */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.
  if(charCode===0&&keyCode===13){charCode=13;}}else {// IE8 does not implement `charCode`, but `keyCode` has the correct value.
  charCode=keyCode;}// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
  // report Enter as charCode 10 when ctrl is pressed.
  if(charCode===10){charCode=13;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if(charCode>=32||charCode===13){return charCode;}return 0;}/**
   * Normalization of deprecated HTML5 `key` values
   * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
   */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**
   * Translation from legacy `keyCode` to HTML5 `key`
   * Only special keys supported, all others depend on keyboard layout or browser
   * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
   */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**
   * @param {object} nativeEvent Native browser event.
   * @return {string} Normalized `key` property.
   */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to
  // implementations of a working draft specification.
  // FireFox implements `key` but returns `MozPrintableKey` for all
  // printable characters (normalized to `Unidentified`), ignore it.
  var key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.
  if(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can
  // thus be captured by `keypress`, no other non-printable key should.
  return charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each
  // `keyCode` value, almost all function keys have a universal value.
  return translateToKey[nativeEvent.keyCode]||'Unidentified';}return '';}/**
   * @interface KeyboardEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */var SyntheticKeyboardEvent=SyntheticUIEvent.extend({key:getEventKey,location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:getEventModifierState,// Legacy Interface
  charCode:function(event){// `charCode` is the result of a KeyPress event and represents the value of
  // the actual printable character.
  // KeyPress is deprecated, but its replacement is not yet final and not
  // implemented in any major browser. Only KeyPress has charCode.
  if(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of
  // physical keyboard key.
  // The actual meaning of the value depends on the users' keyboard layout
  // which cannot be detected. Assuming that it is a US keyboard layout
  // provides a surprisingly accurate mapping for US and European users.
  // Due to this, it is left to the user to implement at this time.
  if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function(event){// `which` is an alias for either `keyCode` or `charCode` depending on the
  // type of the event.
  if(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}});/**
   * @interface DragEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */var SyntheticDragEvent=SyntheticMouseEvent.extend({dataTransfer:null});/**
   * @interface TouchEvent
   * @see http://www.w3.org/TR/touch-events/
   */var SyntheticTouchEvent=SyntheticUIEvent.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:getEventModifierState});/**
   * @interface Event
   * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
   * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
   */var SyntheticTransitionEvent=SyntheticEvent.extend({propertyName:null,elapsedTime:null,pseudoElement:null});/**
   * @interface WheelEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */var SyntheticWheelEvent=SyntheticMouseEvent.extend({deltaX:function(event){return 'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
  'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function(event){return 'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
  'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
  'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:null,// Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode:null});var knownHTMLTopLevelTypes=[TOP_ABORT,TOP_CANCEL,TOP_CAN_PLAY,TOP_CAN_PLAY_THROUGH,TOP_CLOSE,TOP_DURATION_CHANGE,TOP_EMPTIED,TOP_ENCRYPTED,TOP_ENDED,TOP_ERROR,TOP_INPUT,TOP_INVALID,TOP_LOAD,TOP_LOADED_DATA,TOP_LOADED_METADATA,TOP_LOAD_START,TOP_PAUSE,TOP_PLAY,TOP_PLAYING,TOP_PROGRESS,TOP_RATE_CHANGE,TOP_RESET,TOP_SEEKED,TOP_SEEKING,TOP_STALLED,TOP_SUBMIT,TOP_SUSPEND,TOP_TIME_UPDATE,TOP_TOGGLE,TOP_VOLUME_CHANGE,TOP_WAITING];var SimpleEventPlugin={// simpleEventPluginEventTypes gets populated from
  // the DOMEventProperties module.
  eventTypes:simpleEventPluginEventTypes,extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags){var dispatchConfig=topLevelEventsToDispatchConfig.get(topLevelType);if(!dispatchConfig){return null;}var EventConstructor;switch(topLevelType){case TOP_KEY_PRESS:// Firefox creates a keypress event for function keys too. This removes
  // the unwanted keypress events. Enter is however both printable and
  // non-printable. One would expect Tab to be as well (but it isn't).
  if(getEventCharCode(nativeEvent)===0){return null;}/* falls through */case TOP_KEY_DOWN:case TOP_KEY_UP:EventConstructor=SyntheticKeyboardEvent;break;case TOP_BLUR:case TOP_FOCUS:EventConstructor=SyntheticFocusEvent;break;case TOP_CLICK:// Firefox creates a click event on right mouse clicks. This removes the
  // unwanted click events.
  if(nativeEvent.button===2){return null;}/* falls through */case TOP_AUX_CLICK:case TOP_DOUBLE_CLICK:case TOP_MOUSE_DOWN:case TOP_MOUSE_MOVE:case TOP_MOUSE_UP:// TODO: Disabled elements should not respond to mouse events
  /* falls through */case TOP_MOUSE_OUT:case TOP_MOUSE_OVER:case TOP_CONTEXT_MENU:EventConstructor=SyntheticMouseEvent;break;case TOP_DRAG:case TOP_DRAG_END:case TOP_DRAG_ENTER:case TOP_DRAG_EXIT:case TOP_DRAG_LEAVE:case TOP_DRAG_OVER:case TOP_DRAG_START:case TOP_DROP:EventConstructor=SyntheticDragEvent;break;case TOP_TOUCH_CANCEL:case TOP_TOUCH_END:case TOP_TOUCH_MOVE:case TOP_TOUCH_START:EventConstructor=SyntheticTouchEvent;break;case TOP_ANIMATION_END:case TOP_ANIMATION_ITERATION:case TOP_ANIMATION_START:EventConstructor=SyntheticAnimationEvent;break;case TOP_TRANSITION_END:EventConstructor=SyntheticTransitionEvent;break;case TOP_SCROLL:EventConstructor=SyntheticUIEvent;break;case TOP_WHEEL:EventConstructor=SyntheticWheelEvent;break;case TOP_COPY:case TOP_CUT:case TOP_PASTE:EventConstructor=SyntheticClipboardEvent;break;case TOP_GOT_POINTER_CAPTURE:case TOP_LOST_POINTER_CAPTURE:case TOP_POINTER_CANCEL:case TOP_POINTER_DOWN:case TOP_POINTER_MOVE:case TOP_POINTER_OUT:case TOP_POINTER_OVER:case TOP_POINTER_UP:EventConstructor=SyntheticPointerEvent;break;default:{if(knownHTMLTopLevelTypes.indexOf(topLevelType)===-1){error('SimpleEventPlugin: Unhandled event type, `%s`. This warning '+'is likely caused by a bug in React. Please file an issue.',topLevelType);}}// HTML Events
  // @see http://www.w3.org/TR/html5/index.html#events-0
  EventConstructor=SyntheticEvent;break;}var event=EventConstructor.getPooled(dispatchConfig,targetInst,nativeEvent,nativeEventTarget);accumulateTwoPhaseDispatches(event);return event;}};/**
   * Specifies a deterministic ordering of `EventPlugin`s. A convenient way to
   * reason about plugins, without having to package every one of them. This
   * is better than having plugins be ordered in the same order that they
   * are injected because that ordering would be influenced by the packaging order.
   * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
   * preventing default on events is convenient in `SimpleEventPlugin` handlers.
   */var DOMEventPluginOrder=['ResponderEventPlugin','SimpleEventPlugin','EnterLeaveEventPlugin','ChangeEventPlugin','SelectEventPlugin','BeforeInputEventPlugin'];/**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */injectEventPluginOrder(DOMEventPluginOrder);setComponentTree(getFiberCurrentPropsFromNode$1,getInstanceFromNode$1,getNodeFromInstance$1);/**
   * Some important event plugins included by default (without having to require
   * them).
   */injectEventPluginsByName({SimpleEventPlugin:SimpleEventPlugin,EnterLeaveEventPlugin:EnterLeaveEventPlugin,ChangeEventPlugin:ChangeEventPlugin,SelectEventPlugin:SelectEventPlugin,BeforeInputEventPlugin:BeforeInputEventPlugin});// Prefix measurements so that it's possible to filter them.
  // Longer prefixes are hard to read in DevTools.
  var reactEmoji="\u269B";var warningEmoji="\u26D4";var supportsUserTiming=typeof performance!=='undefined'&&typeof performance.mark==='function'&&typeof performance.clearMarks==='function'&&typeof performance.measure==='function'&&typeof performance.clearMeasures==='function';// Keep track of current fiber so that we know the path to unwind on pause.
  // TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
  var currentFiber=null;// If we're in the middle of user code, which fiber and method is it?
  // Reusing `currentFiber` would be confusing for this because user code fiber
  // can change during commit phase too, but we don't need to unwind it (since
  // lifecycles in the commit phase don't resemble a tree).
  var currentPhase=null;var currentPhaseFiber=null;// Did lifecycle hook schedule an update? This is often a performance problem,
  // so we will keep track of it, and include it in the report.
  // Track commits caused by cascading updates.
  var isCommitting=false;var hasScheduledUpdateInCurrentCommit=false;var hasScheduledUpdateInCurrentPhase=false;var commitCountInCurrentWorkLoop=0;var effectCountInCurrentCommit=0;// to avoid stretch the commit phase with measurement overhead.
  var labelsInCurrentCommit=new Set();var formatMarkName=function(markName){return reactEmoji+" "+markName;};var formatLabel=function(label,warning){var prefix=warning?warningEmoji+" ":reactEmoji+" ";var suffix=warning?" Warning: "+warning:'';return ""+prefix+label+suffix;};var beginMark=function(markName){performance.mark(formatMarkName(markName));};var clearMark=function(markName){performance.clearMarks(formatMarkName(markName));};var endMark=function(label,markName,warning){var formattedMarkName=formatMarkName(markName);var formattedLabel=formatLabel(label,warning);try{performance.measure(formattedLabel,formattedMarkName);}catch(err){}// If previous mark was missing for some reason, this will throw.
  // This could only happen if React crashed in an unexpected place earlier.
  // Don't pile on with more errors.
  // Clear marks immediately to avoid growing buffer.
  performance.clearMarks(formattedMarkName);performance.clearMeasures(formattedLabel);};var getFiberMarkName=function(label,debugID){return label+" (#"+debugID+")";};var getFiberLabel=function(componentName,isMounted,phase){if(phase===null){// These are composite component total time measurements.
  return componentName+" ["+(isMounted?'update':'mount')+"]";}else {// Composite component methods.
  return componentName+"."+phase;}};var beginFiberMark=function(fiber,phase){var componentName=getComponentName(fiber.type)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);if(isCommitting&&labelsInCurrentCommit.has(label)){// During the commit phase, we don't show duplicate labels because
  // there is a fixed overhead for every measurement, and we don't
  // want to stretch the commit phase beyond necessary.
  return false;}labelsInCurrentCommit.add(label);var markName=getFiberMarkName(label,debugID);beginMark(markName);return true;};var clearFiberMark=function(fiber,phase){var componentName=getComponentName(fiber.type)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);clearMark(markName);};var endFiberMark=function(fiber,phase,warning){var componentName=getComponentName(fiber.type)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);endMark(label,markName,warning);};var shouldIgnoreFiber=function(fiber){// Host components should be skipped in the timeline.
  // We could check typeof fiber.type, but does this work with RN?
  switch(fiber.tag){case HostRoot:case HostComponent:case HostText:case HostPortal:case Fragment:case ContextProvider:case ContextConsumer:case Mode:return true;default:return false;}};var clearPendingPhaseMeasurement=function(){if(currentPhase!==null&&currentPhaseFiber!==null){clearFiberMark(currentPhaseFiber,currentPhase);}currentPhaseFiber=null;currentPhase=null;hasScheduledUpdateInCurrentPhase=false;};var pauseTimers=function(){// Stops all currently active measurements so that they can be resumed
  // if we continue in a later deferred loop from the same unit of work.
  var fiber=currentFiber;while(fiber){if(fiber._debugIsCurrentlyTiming){endFiberMark(fiber,null,null);}fiber=fiber.return;}};var resumeTimersRecursively=function(fiber){if(fiber.return!==null){resumeTimersRecursively(fiber.return);}if(fiber._debugIsCurrentlyTiming){beginFiberMark(fiber,null);}};var resumeTimers=function(){// Resumes all measurements that were active during the last deferred loop.
  if(currentFiber!==null){resumeTimersRecursively(currentFiber);}};function recordEffect(){{effectCountInCurrentCommit++;}}function recordScheduleUpdate(){{if(isCommitting){hasScheduledUpdateInCurrentCommit=true;}if(currentPhase!==null&&currentPhase!=='componentWillMount'&&currentPhase!=='componentWillReceiveProps'){hasScheduledUpdateInCurrentPhase=true;}}}function startWorkTimer(fiber){{if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, this is the fiber to unwind from.
  currentFiber=fiber;if(!beginFiberMark(fiber,null)){return;}fiber._debugIsCurrentlyTiming=true;}}function cancelWorkTimer(fiber){{if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// Remember we shouldn't complete measurement for this fiber.
  // Otherwise flamechart will be deep even for small updates.
  fiber._debugIsCurrentlyTiming=false;clearFiberMark(fiber,null);}}function stopWorkTimer(fiber){{if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
  currentFiber=fiber.return;if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;endFiberMark(fiber,null,null);}}function stopFailedWorkTimer(fiber){{if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
  currentFiber=fiber.return;if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;var warning=fiber.tag===SuspenseComponent?'Rendering was suspended':'An error was thrown inside this error boundary';endFiberMark(fiber,null,warning);}}function startPhaseTimer(fiber,phase){{if(!supportsUserTiming){return;}clearPendingPhaseMeasurement();if(!beginFiberMark(fiber,phase)){return;}currentPhaseFiber=fiber;currentPhase=phase;}}function stopPhaseTimer(){{if(!supportsUserTiming){return;}if(currentPhase!==null&&currentPhaseFiber!==null){var warning=hasScheduledUpdateInCurrentPhase?'Scheduled a cascading update':null;endFiberMark(currentPhaseFiber,currentPhase,warning);}currentPhase=null;currentPhaseFiber=null;}}function startWorkLoopTimer(nextUnitOfWork){{currentFiber=nextUnitOfWork;if(!supportsUserTiming){return;}commitCountInCurrentWorkLoop=0;// This is top level call.
  // Any other measurements are performed within.
  beginMark('(React Tree Reconciliation)');// Resume any measurements that were in progress during the last loop.
  resumeTimers();}}function stopWorkLoopTimer(interruptedBy,didCompleteRoot){{if(!supportsUserTiming){return;}var warning=null;if(interruptedBy!==null){if(interruptedBy.tag===HostRoot){warning='A top-level update interrupted the previous render';}else {var componentName=getComponentName(interruptedBy.type)||'Unknown';warning="An update to "+componentName+" interrupted the previous render";}}else if(commitCountInCurrentWorkLoop>1){warning='There were cascading updates';}commitCountInCurrentWorkLoop=0;var label=didCompleteRoot?'(React Tree Reconciliation: Completed Root)':'(React Tree Reconciliation: Yielded)';// Pause any measurements until the next loop.
  pauseTimers();endMark(label,'(React Tree Reconciliation)',warning);}}function startCommitTimer(){{if(!supportsUserTiming){return;}isCommitting=true;hasScheduledUpdateInCurrentCommit=false;labelsInCurrentCommit.clear();beginMark('(Committing Changes)');}}function stopCommitTimer(){{if(!supportsUserTiming){return;}var warning=null;if(hasScheduledUpdateInCurrentCommit){warning='Lifecycle hook scheduled a cascading update';}else if(commitCountInCurrentWorkLoop>0){warning='Caused by a cascading update in earlier commit';}hasScheduledUpdateInCurrentCommit=false;commitCountInCurrentWorkLoop++;isCommitting=false;labelsInCurrentCommit.clear();endMark('(Committing Changes)','(Committing Changes)',warning);}}function startCommitSnapshotEffectsTimer(){{if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Committing Snapshot Effects)');}}function stopCommitSnapshotEffectsTimer(){{if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark("(Committing Snapshot Effects: "+count+" Total)",'(Committing Snapshot Effects)',null);}}function startCommitHostEffectsTimer(){{if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Committing Host Effects)');}}function stopCommitHostEffectsTimer(){{if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark("(Committing Host Effects: "+count+" Total)",'(Committing Host Effects)',null);}}function startCommitLifeCyclesTimer(){{if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Calling Lifecycle Methods)');}}function stopCommitLifeCyclesTimer(){{if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark("(Calling Lifecycle Methods: "+count+" Total)",'(Calling Lifecycle Methods)',null);}}var valueStack=[];var fiberStack;{fiberStack=[];}var index=-1;function createCursor(defaultValue){return {current:defaultValue};}function pop(cursor,fiber){if(index<0){{error('Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){error('Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}var warnedAboutMissingGetChildContext;{warnedAboutMissingGetChildContext={};}var emptyContextObject={};{Object.freeze(emptyContextObject);}// A cursor to the current merged context object on the stack.
  var contextStackCursor=createCursor(emptyContextObject);// A cursor to a boolean indicating whether the context has changed.
  var didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.
  // We use this to get access to the parent context after we have already
  // pushed the next context provider, and now need to merge their contexts.
  var previousContext=emptyContextObject;function getUnmaskedContext(workInProgress,Component,didPushOwnContextIfProvider){{if(didPushOwnContextIfProvider&&isContextProvider(Component)){// If the fiber is a context provider itself, when we read its context
  // we may have already pushed its own child context on the stack. A context
  // provider should not "see" its own child context. Therefore we read the
  // previous (parent) context instead for a context provider.
  return previousContext;}return contextStackCursor.current;}}function cacheContext(workInProgress,unmaskedContext,maskedContext){{var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}}function getMaskedContext(workInProgress,unmaskedContext){{var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyContextObject;}// Avoid recreating masked context unless unmasked context has changed.
  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
  // This may trigger infinite loops if componentWillReceiveProps calls setState.
  var instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentName(type)||'Unknown';checkPropTypes(contextTypes,context,'context',name,getCurrentFiberStackInDev);}// Cache unmasked context so we can avoid recreating masked context unless necessary.
  // Context is created before the class component is instantiated so check for instance.
  if(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}}function hasContextChanged(){{return didPerformWorkStackCursor.current;}}function isContextProvider(type){{var childContextTypes=type.childContextTypes;return childContextTypes!==null&&childContextTypes!==undefined;}}function popContext(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function popTopLevelContextObject(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function pushTopLevelContextObject(fiber,context,didChange){{if(!(contextStackCursor.current===emptyContextObject)){{throw Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");}}push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}}function processChildContext(fiber,type,parentContext){{var instance=fiber.stateNode;var childContextTypes=type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.
  // It has only been added in Fiber to match the (unintentional) behavior in Stack.
  if(typeof instance.getChildContext!=='function'){{var componentName=getComponentName(type)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;error('%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext;startPhaseTimer(fiber,'getChildContext');childContext=instance.getChildContext();stopPhaseTimer();for(var contextKey in childContext){if(!(contextKey in childContextTypes)){{throw Error((getComponentName(type)||'Unknown')+".getChildContext(): key \""+contextKey+"\" is not defined in childContextTypes.");}}}{var name=getComponentName(type)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name,// In practice, there is one case in which we won't get a stack. It's when
  // somebody calls unstable_renderSubtreeIntoContainer() and we process
  // context from the parent component instance. The stack will be missing
  // because it's outside of the reconciliation, and so the pointer has not
  // been set. This is rare and doesn't matter. We'll also remove that API.
  getCurrentFiberStackInDev);}return _assign({},parentContext,{},childContext);}}function pushContextProvider(workInProgress){{var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.
  // If the instance does not exist yet, we will push null at first,
  // and replace it on the stack later when invalidating the context.
  var memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;// Remember the parent context so we can merge with it later.
  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
  previousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}}function invalidateContextProvider(workInProgress,type,didChange){{var instance=workInProgress.stateNode;if(!instance){{throw Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");}}if(didChange){// Merge parent and own context.
  // Skip this if we're not updating due to sCU.
  // This avoids unnecessarily recomputing memoized values.
  var mergedContext=processChildContext(workInProgress,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.
  // It is important to unwind the context in the reverse order.
  pop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.
  push(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else {pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}}function findCurrentUnmaskedContext(fiber){{// Currently this is only used with renderSubtreeIntoContainer; not sure if it
  // makes sense elsewhere
  if(!(isFiberMounted(fiber)&&fiber.tag===ClassComponent)){{throw Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");}}var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}break;}}node=node.return;}while(node!==null);{{throw Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");}}}}var LegacyRoot=0;var BlockingRoot=1;var ConcurrentRoot=2;var Scheduler_runWithPriority=Scheduler.unstable_runWithPriority,Scheduler_scheduleCallback=Scheduler.unstable_scheduleCallback,Scheduler_cancelCallback=Scheduler.unstable_cancelCallback,Scheduler_shouldYield=Scheduler.unstable_shouldYield,Scheduler_requestPaint=Scheduler.unstable_requestPaint,Scheduler_now=Scheduler.unstable_now,Scheduler_getCurrentPriorityLevel=Scheduler.unstable_getCurrentPriorityLevel,Scheduler_ImmediatePriority=Scheduler.unstable_ImmediatePriority,Scheduler_UserBlockingPriority=Scheduler.unstable_UserBlockingPriority,Scheduler_NormalPriority=Scheduler.unstable_NormalPriority,Scheduler_LowPriority=Scheduler.unstable_LowPriority,Scheduler_IdlePriority=Scheduler.unstable_IdlePriority;{// Provide explicit error message when production+profiling bundle of e.g.
  // react-dom is used with production (non-profiling) bundle of
  // scheduler/tracing
  if(!(tracing.__interactionsRef!=null&&tracing.__interactionsRef.current!=null)){{throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling");}}}var fakeCallbackNode={};// Except for NoPriority, these correspond to Scheduler priorities. We use
  // ascending numbers so we can compare them like numbers. They start at 90 to
  // avoid clashing with Scheduler's priorities.
  var ImmediatePriority=99;var UserBlockingPriority$1=98;var NormalPriority=97;var LowPriority=96;var IdlePriority=95;// NoPriority is the absence of priority. Also React-only.
  var NoPriority=90;var shouldYield=Scheduler_shouldYield;var requestPaint=// Fall back gracefully if we're running an older version of Scheduler.
  Scheduler_requestPaint!==undefined?Scheduler_requestPaint:function(){};var syncQueue=null;var immediateQueueCallbackNode=null;var isFlushingSyncQueue=false;var initialTimeMs=Scheduler_now();// If the initial timestamp is reasonably small, use Scheduler's `now` directly.
  // This will be the case for modern browsers that support `performance.now`. In
  // older browsers, Scheduler falls back to `Date.now`, which returns a Unix
  // timestamp. In that case, subtract the module initialization time to simulate
  // the behavior of performance.now and keep our times small enough to fit
  // within 32 bits.
  // TODO: Consider lifting this into Scheduler.
  var now=initialTimeMs<10000?Scheduler_now:function(){return Scheduler_now()-initialTimeMs;};function getCurrentPriorityLevel(){switch(Scheduler_getCurrentPriorityLevel()){case Scheduler_ImmediatePriority:return ImmediatePriority;case Scheduler_UserBlockingPriority:return UserBlockingPriority$1;case Scheduler_NormalPriority:return NormalPriority;case Scheduler_LowPriority:return LowPriority;case Scheduler_IdlePriority:return IdlePriority;default:{{throw Error("Unknown priority level.");}}}}function reactPriorityToSchedulerPriority(reactPriorityLevel){switch(reactPriorityLevel){case ImmediatePriority:return Scheduler_ImmediatePriority;case UserBlockingPriority$1:return Scheduler_UserBlockingPriority;case NormalPriority:return Scheduler_NormalPriority;case LowPriority:return Scheduler_LowPriority;case IdlePriority:return Scheduler_IdlePriority;default:{{throw Error("Unknown priority level.");}}}}function runWithPriority$1(reactPriorityLevel,fn){var priorityLevel=reactPriorityToSchedulerPriority(reactPriorityLevel);return Scheduler_runWithPriority(priorityLevel,fn);}function scheduleCallback(reactPriorityLevel,callback,options){var priorityLevel=reactPriorityToSchedulerPriority(reactPriorityLevel);return Scheduler_scheduleCallback(priorityLevel,callback,options);}function scheduleSyncCallback(callback){// Push this callback into an internal queue. We'll flush these either in
  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.
  if(syncQueue===null){syncQueue=[callback];// Flush the queue in the next tick, at the earliest.
  immediateQueueCallbackNode=Scheduler_scheduleCallback(Scheduler_ImmediatePriority,flushSyncCallbackQueueImpl);}else {// Push onto existing queue. Don't need to schedule a callback because
  // we already scheduled one when we created the queue.
  syncQueue.push(callback);}return fakeCallbackNode;}function cancelCallback(callbackNode){if(callbackNode!==fakeCallbackNode){Scheduler_cancelCallback(callbackNode);}}function flushSyncCallbackQueue(){if(immediateQueueCallbackNode!==null){var node=immediateQueueCallbackNode;immediateQueueCallbackNode=null;Scheduler_cancelCallback(node);}flushSyncCallbackQueueImpl();}function flushSyncCallbackQueueImpl(){if(!isFlushingSyncQueue&&syncQueue!==null){// Prevent re-entrancy.
  isFlushingSyncQueue=true;var i=0;try{var _isSync=true;var queue=syncQueue;runWithPriority$1(ImmediatePriority,function(){for(;i<queue.length;i++){var callback=queue[i];do{callback=callback(_isSync);}while(callback!==null);}});syncQueue=null;}catch(error){// If something throws, leave the remaining callbacks on the queue.
  if(syncQueue!==null){syncQueue=syncQueue.slice(i+1);}// Resume flushing in the next tick
  Scheduler_scheduleCallback(Scheduler_ImmediatePriority,flushSyncCallbackQueue);throw error;}finally{isFlushingSyncQueue=false;}}}var NoMode=0;var StrictMode=1;// TODO: Remove BlockingMode and ConcurrentMode by reading from the root
  // tag instead
  var BlockingMode=2;var ConcurrentMode=4;var ProfileMode=8;// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
  // Math.pow(2, 30) - 1
  // 0b111111111111111111111111111111
  var MAX_SIGNED_31_BIT_INT=1073741823;var NoWork=0;// TODO: Think of a better name for Never. The key difference with Idle is that
  // Never work can be committed in an inconsistent state without tearing the UI.
  // The main example is offscreen content, like a hidden subtree. So one possible
  // name is Offscreen. However, it also includes dehydrated Suspense boundaries,
  // which are inconsistent in the sense that they haven't finished yet, but
  // aren't visibly inconsistent because the server rendered HTML matches what the
  // hydrated tree would look like.
  var Never=1;// Idle is slightly higher priority than Never. It must completely finish in
  // order to be consistent.
  var Idle=2;// Continuous Hydration is slightly higher than Idle and is used to increase
  // priority of hover targets.
  var ContinuousHydration=3;var Sync=MAX_SIGNED_31_BIT_INT;var Batched=Sync-1;var UNIT_SIZE=10;var MAGIC_NUMBER_OFFSET=Batched-1;// 1 unit of expiration time represents 10ms.
  function msToExpirationTime(ms){// Always subtract from the offset so that we don't clash with the magic number for NoWork.
  return MAGIC_NUMBER_OFFSET-(ms/UNIT_SIZE|0);}function expirationTimeToMs(expirationTime){return (MAGIC_NUMBER_OFFSET-expirationTime)*UNIT_SIZE;}function ceiling(num,precision){return ((num/precision|0)+1)*precision;}function computeExpirationBucket(currentTime,expirationInMs,bucketSizeMs){return MAGIC_NUMBER_OFFSET-ceiling(MAGIC_NUMBER_OFFSET-currentTime+expirationInMs/UNIT_SIZE,bucketSizeMs/UNIT_SIZE);}// TODO: This corresponds to Scheduler's NormalPriority, not LowPriority. Update
  // the names to reflect.
  var LOW_PRIORITY_EXPIRATION=5000;var LOW_PRIORITY_BATCH_SIZE=250;function computeAsyncExpiration(currentTime){return computeExpirationBucket(currentTime,LOW_PRIORITY_EXPIRATION,LOW_PRIORITY_BATCH_SIZE);}function computeSuspenseExpiration(currentTime,timeoutMs){// TODO: Should we warn if timeoutMs is lower than the normal pri expiration time?
  return computeExpirationBucket(currentTime,timeoutMs,LOW_PRIORITY_BATCH_SIZE);}// We intentionally set a higher expiration time for interactive updates in
  // dev than in production.
  //
  // If the main thread is being blocked so long that you hit the expiration,
  // it's a problem that could be solved with better scheduling.
  //
  // People will be more likely to notice this and fix it with the long
  // expiration time in development.
  //
  // In production we opt for better UX at the risk of masking scheduling
  // problems, by expiring fast.
  var HIGH_PRIORITY_EXPIRATION=500;var HIGH_PRIORITY_BATCH_SIZE=100;function computeInteractiveExpiration(currentTime){return computeExpirationBucket(currentTime,HIGH_PRIORITY_EXPIRATION,HIGH_PRIORITY_BATCH_SIZE);}function inferPriorityFromExpirationTime(currentTime,expirationTime){if(expirationTime===Sync){return ImmediatePriority;}if(expirationTime===Never||expirationTime===Idle){return IdlePriority;}var msUntil=expirationTimeToMs(expirationTime)-expirationTimeToMs(currentTime);if(msUntil<=0){return ImmediatePriority;}if(msUntil<=HIGH_PRIORITY_EXPIRATION+HIGH_PRIORITY_BATCH_SIZE){return UserBlockingPriority$1;}if(msUntil<=LOW_PRIORITY_EXPIRATION+LOW_PRIORITY_BATCH_SIZE){return NormalPriority;}// TODO: Handle LowPriority
  // Assume anything lower has idle priority
  return IdlePriority;}var ReactStrictModeWarnings={recordUnsafeLifecycleWarnings:function(fiber,instance){},flushPendingUnsafeLifecycleWarnings:function(){},recordLegacyContextWarning:function(fiber,instance){},flushLegacyContextWarning:function(){},discardPendingWarnings:function(){}};{var findStrictRoot=function(fiber){var maybeStrictRoot=null;var node=fiber;while(node!==null){if(node.mode&StrictMode){maybeStrictRoot=node;}node=node.return;}return maybeStrictRoot;};var setToSortedString=function(set){var array=[];set.forEach(function(value){array.push(value);});return array.sort().join(', ');};var pendingComponentWillMountWarnings=[];var pendingUNSAFE_ComponentWillMountWarnings=[];var pendingComponentWillReceivePropsWarnings=[];var pendingUNSAFE_ComponentWillReceivePropsWarnings=[];var pendingComponentWillUpdateWarnings=[];var pendingUNSAFE_ComponentWillUpdateWarnings=[];// Tracks components we have already warned about.
  var didWarnAboutUnsafeLifecycles=new Set();ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){// Dedup strategy: Warn once per component.
  if(didWarnAboutUnsafeLifecycles.has(fiber.type)){return;}if(typeof instance.componentWillMount==='function'&&// Don't warn about react-lifecycles-compat polyfilled components.
  instance.componentWillMount.__suppressDeprecationWarning!==true){pendingComponentWillMountWarnings.push(fiber);}if(fiber.mode&StrictMode&&typeof instance.UNSAFE_componentWillMount==='function'){pendingUNSAFE_ComponentWillMountWarnings.push(fiber);}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){pendingComponentWillReceivePropsWarnings.push(fiber);}if(fiber.mode&StrictMode&&typeof instance.UNSAFE_componentWillReceiveProps==='function'){pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){pendingComponentWillUpdateWarnings.push(fiber);}if(fiber.mode&StrictMode&&typeof instance.UNSAFE_componentWillUpdate==='function'){pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);}};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){// We do an initial pass to gather component names
  var componentWillMountUniqueNames=new Set();if(pendingComponentWillMountWarnings.length>0){pendingComponentWillMountWarnings.forEach(function(fiber){componentWillMountUniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillMountWarnings=[];}var UNSAFE_componentWillMountUniqueNames=new Set();if(pendingUNSAFE_ComponentWillMountWarnings.length>0){pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber){UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillMountWarnings=[];}var componentWillReceivePropsUniqueNames=new Set();if(pendingComponentWillReceivePropsWarnings.length>0){pendingComponentWillReceivePropsWarnings.forEach(function(fiber){componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillReceivePropsWarnings=[];}var UNSAFE_componentWillReceivePropsUniqueNames=new Set();if(pendingUNSAFE_ComponentWillReceivePropsWarnings.length>0){pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber){UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillReceivePropsWarnings=[];}var componentWillUpdateUniqueNames=new Set();if(pendingComponentWillUpdateWarnings.length>0){pendingComponentWillUpdateWarnings.forEach(function(fiber){componentWillUpdateUniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillUpdateWarnings=[];}var UNSAFE_componentWillUpdateUniqueNames=new Set();if(pendingUNSAFE_ComponentWillUpdateWarnings.length>0){pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber){UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillUpdateWarnings=[];}// Finally, we flush all the warnings
  // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'
  if(UNSAFE_componentWillMountUniqueNames.size>0){var sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. '+'See https://fb.me/react-unsafe-component-lifecycles for details.\n\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\n'+'\nPlease update the following components: %s',sortedNames);}if(UNSAFE_componentWillReceivePropsUniqueNames.size>0){var _sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://fb.me/react-unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+"* If you're updating state whenever props change, "+'refactor your code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state\n'+'\nPlease update the following components: %s',_sortedNames);}if(UNSAFE_componentWillUpdateUniqueNames.size>0){var _sortedNames2=setToSortedString(UNSAFE_componentWillUpdateUniqueNames);error('Using UNSAFE_componentWillUpdate in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://fb.me/react-unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+'\nPlease update the following components: %s',_sortedNames2);}if(componentWillMountUniqueNames.size>0){var _sortedNames3=setToSortedString(componentWillMountUniqueNames);warn('componentWillMount has been renamed, and is not recommended for use. '+'See https://fb.me/react-unsafe-component-lifecycles for details.\n\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\n'+'* Rename componentWillMount to UNSAFE_componentWillMount to suppress '+'this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n'+'\nPlease update the following components: %s',_sortedNames3);}if(componentWillReceivePropsUniqueNames.size>0){var _sortedNames4=setToSortedString(componentWillReceivePropsUniqueNames);warn('componentWillReceiveProps has been renamed, and is not recommended for use. '+'See https://fb.me/react-unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+"* If you're updating state whenever props change, refactor your "+'code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state\n'+'* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress '+'this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n'+'\nPlease update the following components: %s',_sortedNames4);}if(componentWillUpdateUniqueNames.size>0){var _sortedNames5=setToSortedString(componentWillUpdateUniqueNames);warn('componentWillUpdate has been renamed, and is not recommended for use. '+'See https://fb.me/react-unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+'* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress '+'this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n'+'\nPlease update the following components: %s',_sortedNames5);}};var pendingLegacyContextWarning=new Map();// Tracks components we have already warned about.
  var didWarnAboutLegacyContext=new Set();ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){error('Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.
  if(didWarnAboutLegacyContext.has(fiber.type)){return;}var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);if(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext==='function'){if(warningsForRoot===undefined){warningsForRoot=[];pendingLegacyContextWarning.set(strictRoot,warningsForRoot);}warningsForRoot.push(fiber);}};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){if(fiberArray.length===0){return;}var firstFiber=fiberArray[0];var uniqueNames=new Set();fiberArray.forEach(function(fiber){uniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutLegacyContext.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);var firstComponentStack=getStackByFiberInDevAndProd(firstFiber);error('Legacy context API has been detected within a strict-mode tree.'+'\n\nThe old API will be supported in all 16.x releases, but applications '+'using it should migrate to the new version.'+'\n\nPlease update the following components: %s'+'\n\nLearn more about this warning here: https://fb.me/react-legacy-context'+'%s',sortedNames,firstComponentStack);});};ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[];pendingUNSAFE_ComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingUNSAFE_ComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUNSAFE_ComponentWillUpdateWarnings=[];pendingLegacyContextWarning=new Map();};}var resolveFamily=null;// $FlowFixMe Flow gets confused by a WeakSet feature check below.
  var failedBoundaries=null;var setRefreshHandler=function(handler){{resolveFamily=handler;}};function resolveFunctionForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.
  return type;}var family=resolveFamily(type);if(family===undefined){return type;}// Use the latest known implementation.
  return family.current;}}function resolveClassForHotReloading(type){// No implementation differences.
  return resolveFunctionForHotReloading(type);}function resolveForwardRefForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.
  return type;}var family=resolveFamily(type);if(family===undefined){// Check if we're dealing with a real forwardRef. Don't want to crash early.
  if(type!==null&&type!==undefined&&typeof type.render==='function'){// ForwardRef is special because its resolved .type is an object,
  // but it's possible that we only have its inner render function in the map.
  // If that inner render function is different, we'll build a new forwardRef type.
  var currentRender=resolveFunctionForHotReloading(type.render);if(type.render!==currentRender){var syntheticType={$$typeof:REACT_FORWARD_REF_TYPE,render:currentRender};if(type.displayName!==undefined){syntheticType.displayName=type.displayName;}return syntheticType;}}return type;}// Use the latest known implementation.
  return family.current;}}function isCompatibleFamilyForHotReloading(fiber,element){{if(resolveFamily===null){// Hot reloading is disabled.
  return false;}var prevType=fiber.elementType;var nextType=element.type;// If we got here, we know types aren't === equal.
  var needsCompareFamilies=false;var $$typeofNextType=typeof nextType==='object'&&nextType!==null?nextType.$$typeof:null;switch(fiber.tag){case ClassComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}break;}case FunctionComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){// We don't know the inner type yet.
  // We're going to assume that the lazy inner type is stable,
  // and so it is sufficient to avoid reconciling it away.
  // We're not going to unwrap or actually use the new lazy type.
  needsCompareFamilies=true;}break;}case ForwardRef:{if($$typeofNextType===REACT_FORWARD_REF_TYPE){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}case MemoComponent:case SimpleMemoComponent:{if($$typeofNextType===REACT_MEMO_TYPE){// TODO: if it was but can no longer be simple,
  // we shouldn't set this.
  needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}default:return false;}// Check if both types have a family and it's the same one.
  if(needsCompareFamilies){// Note: memo() and forwardRef() we'll compare outer rather than inner type.
  // This means both of them need to be registered to preserve state.
  // If we unwrapped and compared the inner types for wrappers instead,
  // then we would risk falsely saying two separate memo(Foo)
  // calls are equivalent because they wrap the same Foo function.
  var prevFamily=resolveFamily(prevType);if(prevFamily!==undefined&&prevFamily===resolveFamily(nextType)){return true;}}return false;}}function markFailedErrorBoundaryForHotReloading(fiber){{if(resolveFamily===null){// Hot reloading is disabled.
  return;}if(typeof WeakSet!=='function'){return;}if(failedBoundaries===null){failedBoundaries=new WeakSet();}failedBoundaries.add(fiber);}}var scheduleRefresh=function(root,update){{if(resolveFamily===null){// Hot reloading is disabled.
  return;}var staleFamilies=update.staleFamilies,updatedFamilies=update.updatedFamilies;flushPassiveEffects();flushSync(function(){scheduleFibersWithFamiliesRecursively(root.current,updatedFamilies,staleFamilies);});}};var scheduleRoot=function(root,element){{if(root.context!==emptyContextObject){// Super edge case: root has a legacy _renderSubtree context
  // but we don't know the parentComponent so we can't pass it.
  // Just ignore. We'll delete this with _renderSubtree code path later.
  return;}flushPassiveEffects();syncUpdates(function(){updateContainer(element,root,null,null);});}};function scheduleFibersWithFamiliesRecursively(fiber,updatedFamilies,staleFamilies){{var alternate=fiber.alternate,child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}if(resolveFamily===null){throw new Error('Expected resolveFamily to be set during hot reload.');}var needsRender=false;var needsRemount=false;if(candidateType!==null){var family=resolveFamily(candidateType);if(family!==undefined){if(staleFamilies.has(family)){needsRemount=true;}else if(updatedFamilies.has(family)){if(tag===ClassComponent){needsRemount=true;}else {needsRender=true;}}}}if(failedBoundaries!==null){if(failedBoundaries.has(fiber)||alternate!==null&&failedBoundaries.has(alternate)){needsRemount=true;}}if(needsRemount){fiber._debugNeedsRemount=true;}if(needsRemount||needsRender){scheduleWork(fiber,Sync);}if(child!==null&&!needsRemount){scheduleFibersWithFamiliesRecursively(child,updatedFamilies,staleFamilies);}if(sibling!==null){scheduleFibersWithFamiliesRecursively(sibling,updatedFamilies,staleFamilies);}}}var findHostInstancesForRefresh=function(root,families){{var hostInstances=new Set();var types=new Set(families.map(function(family){return family.current;}));findHostInstancesForMatchingFibersRecursively(root.current,types,hostInstances);return hostInstances;}};function findHostInstancesForMatchingFibersRecursively(fiber,types,hostInstances){{var child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}var didMatch=false;if(candidateType!==null){if(types.has(candidateType)){didMatch=true;}}if(didMatch){// We have a match. This only drills down to the closest host components.
  // There's no need to search deeper because for the purpose of giving
  // visual feedback, "flashing" outermost parent rectangles is sufficient.
  findHostInstancesForFiberShallowly(fiber,hostInstances);}else {// If there's no match, maybe there will be one further down in the child tree.
  if(child!==null){findHostInstancesForMatchingFibersRecursively(child,types,hostInstances);}}if(sibling!==null){findHostInstancesForMatchingFibersRecursively(sibling,types,hostInstances);}}}function findHostInstancesForFiberShallowly(fiber,hostInstances){{var foundHostInstances=findChildHostInstancesForFiberShallowly(fiber,hostInstances);if(foundHostInstances){return;}// If we didn't find any host children, fallback to closest host parent.
  var node=fiber;while(true){switch(node.tag){case HostComponent:hostInstances.add(node.stateNode);return;case HostPortal:hostInstances.add(node.stateNode.containerInfo);return;case HostRoot:hostInstances.add(node.stateNode.containerInfo);return;}if(node.return===null){throw new Error('Expected to reach root first.');}node=node.return;}}}function findChildHostInstancesForFiberShallowly(fiber,hostInstances){{var node=fiber;var foundHostInstances=false;while(true){if(node.tag===HostComponent){// We got a match.
  foundHostInstances=true;hostInstances.add(node.stateNode);// There may still be more, so keep searching.
  }else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===fiber){return foundHostInstances;}while(node.sibling===null){if(node.return===null||node.return===fiber){return foundHostInstances;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}return false;}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){// Resolve default props. Taken from ReactElement
  var props=_assign({},baseProps);var defaultProps=Component.defaultProps;for(var propName in defaultProps){if(props[propName]===undefined){props[propName]=defaultProps[propName];}}return props;}return baseProps;}function readLazyComponentType(lazyComponent){initializeLazyComponentType(lazyComponent);if(lazyComponent._status!==Resolved){throw lazyComponent._result;}return lazyComponent._result;}var valueCursor=createCursor(null);var rendererSigil;{// Use this to detect multiple renderers using the same context
  rendererSigil={};}var currentlyRenderingFiber=null;var lastContextDependency=null;var lastContextWithAllBitsObserved=null;var isDisallowedContextReadInDEV=false;function resetContextDependencies(){// This is called right before React yields execution, to ensure `readContext`
  // cannot be called outside the render phase.
  currentlyRenderingFiber=null;lastContextDependency=null;lastContextWithAllBitsObserved=null;{isDisallowedContextReadInDEV=false;}}function enterDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=true;}}function exitDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=false;}}function pushProvider(providerFiber,nextValue){var context=providerFiber.type._context;{push(valueCursor,context._currentValue,providerFiber);context._currentValue=nextValue;{if(context._currentRenderer!==undefined&&context._currentRenderer!==null&&context._currentRenderer!==rendererSigil){error('Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.');}context._currentRenderer=rendererSigil;}}}function popProvider(providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber);var context=providerFiber.type._context;{context._currentValue=currentValue;}}function calculateChangedBits(context,newValue,oldValue){if(objectIs(oldValue,newValue)){// No change
  return 0;}else {var changedBits=typeof context._calculateChangedBits==='function'?context._calculateChangedBits(oldValue,newValue):MAX_SIGNED_31_BIT_INT;{if((changedBits&MAX_SIGNED_31_BIT_INT)!==changedBits){error('calculateChangedBits: Expected the return value to be a '+'31-bit integer. Instead received: %s',changedBits);}}return changedBits|0;}}function scheduleWorkOnParentPath(parent,renderExpirationTime){// Update the child expiration time of all the ancestors, including
  // the alternates.
  var node=parent;while(node!==null){var alternate=node.alternate;if(node.childExpirationTime<renderExpirationTime){node.childExpirationTime=renderExpirationTime;if(alternate!==null&&alternate.childExpirationTime<renderExpirationTime){alternate.childExpirationTime=renderExpirationTime;}}else if(alternate!==null&&alternate.childExpirationTime<renderExpirationTime){alternate.childExpirationTime=renderExpirationTime;}else {// Neither alternate was updated, which means the rest of the
  // ancestor path already has sufficient priority.
  break;}node=node.return;}}function propagateContextChange(workInProgress,context,changedBits,renderExpirationTime){var fiber=workInProgress.child;if(fiber!==null){// Set the return pointer of the child to the work-in-progress fiber.
  fiber.return=workInProgress;}while(fiber!==null){var nextFiber=void 0;// Visit this fiber.
  var list=fiber.dependencies;if(list!==null){nextFiber=fiber.child;var dependency=list.firstContext;while(dependency!==null){// Check if the context matches.
  if(dependency.context===context&&(dependency.observedBits&changedBits)!==0){// Match! Schedule an update on this fiber.
  if(fiber.tag===ClassComponent){// Schedule a force update on the work-in-progress.
  var update=createUpdate(renderExpirationTime,null);update.tag=ForceUpdate;// TODO: Because we don't have a work-in-progress, this will add the
  // update to the current fiber, too, which means it will persist even if
  // this render is thrown away. Since it's a race condition, not sure it's
  // worth fixing.
  enqueueUpdate(fiber,update);}if(fiber.expirationTime<renderExpirationTime){fiber.expirationTime=renderExpirationTime;}var alternate=fiber.alternate;if(alternate!==null&&alternate.expirationTime<renderExpirationTime){alternate.expirationTime=renderExpirationTime;}scheduleWorkOnParentPath(fiber.return,renderExpirationTime);// Mark the expiration time on the list, too.
  if(list.expirationTime<renderExpirationTime){list.expirationTime=renderExpirationTime;}// Since we already found a match, we can stop traversing the
  // dependency list.
  break;}dependency=dependency.next;}}else if(fiber.tag===ContextProvider){// Don't scan deeper if this is a matching provider
  nextFiber=fiber.type===workInProgress.type?null:fiber.child;}else {// Traverse down.
  nextFiber=fiber.child;}if(nextFiber!==null){// Set the return pointer of the child to the work-in-progress fiber.
  nextFiber.return=fiber;}else {// No child. Traverse to next sibling.
  nextFiber=fiber;while(nextFiber!==null){if(nextFiber===workInProgress){// We're back to the root of this subtree. Exit.
  nextFiber=null;break;}var sibling=nextFiber.sibling;if(sibling!==null){// Set the return pointer of the sibling to the work-in-progress fiber.
  sibling.return=nextFiber.return;nextFiber=sibling;break;}// No more siblings. Traverse up.
  nextFiber=nextFiber.return;}}fiber=nextFiber;}}function prepareToReadContext(workInProgress,renderExpirationTime){currentlyRenderingFiber=workInProgress;lastContextDependency=null;lastContextWithAllBitsObserved=null;var dependencies=workInProgress.dependencies;if(dependencies!==null){var firstContext=dependencies.firstContext;if(firstContext!==null){if(dependencies.expirationTime>=renderExpirationTime){// Context list has a pending update. Mark that this fiber performed work.
  markWorkInProgressReceivedUpdate();}// Reset the work-in-progress list
  dependencies.firstContext=null;}}}function readContext(context,observedBits){{// This warning would fire if you read context inside a Hook like useMemo.
  // Unlike the class check below, it's not enforced in production for perf.
  if(isDisallowedContextReadInDEV){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}}if(lastContextWithAllBitsObserved===context);else if(observedBits===false||observedBits===0);else {var resolvedObservedBits;// Avoid deopting on observable arguments or heterogeneous types.
  if(typeof observedBits!=='number'||observedBits===MAX_SIGNED_31_BIT_INT){// Observe all updates.
  lastContextWithAllBitsObserved=context;resolvedObservedBits=MAX_SIGNED_31_BIT_INT;}else {resolvedObservedBits=observedBits;}var contextItem={context:context,observedBits:resolvedObservedBits,next:null};if(lastContextDependency===null){if(!(currentlyRenderingFiber!==null)){{throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");}}// This is the first dependency for this component. Create a new list.
  lastContextDependency=contextItem;currentlyRenderingFiber.dependencies={expirationTime:NoWork,firstContext:contextItem,responders:null};}else {// Append a new context item.
  lastContextDependency=lastContextDependency.next=contextItem;}}return context._currentValue;}var UpdateState=0;var ReplaceState=1;var ForceUpdate=2;var CaptureUpdate=3;// Global state that is reset at the beginning of calling `processUpdateQueue`.
  // It should only be read right after calling `processUpdateQueue`, via
  // `checkHasForceUpdateAfterProcessing`.
  var hasForceUpdate=false;var didWarnUpdateInsideUpdate;var currentlyProcessingQueue;{didWarnUpdateInsideUpdate=false;currentlyProcessingQueue=null;}function initializeUpdateQueue(fiber){var queue={baseState:fiber.memoizedState,baseQueue:null,shared:{pending:null},effects:null};fiber.updateQueue=queue;}function cloneUpdateQueue(current,workInProgress){// Clone the update queue from current. Unless it's already a clone.
  var queue=workInProgress.updateQueue;var currentQueue=current.updateQueue;if(queue===currentQueue){var clone={baseState:currentQueue.baseState,baseQueue:currentQueue.baseQueue,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=clone;}}function createUpdate(expirationTime,suspenseConfig){var update={expirationTime:expirationTime,suspenseConfig:suspenseConfig,tag:UpdateState,payload:null,callback:null,next:null};update.next=update;{update.priority=getCurrentPriorityLevel();}return update;}function enqueueUpdate(fiber,update){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.
  return;}var sharedQueue=updateQueue.shared;var pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.
  update.next=update;}else {update.next=pending.next;pending.next=update;}sharedQueue.pending=update;{if(currentlyProcessingQueue===sharedQueue&&!didWarnUpdateInsideUpdate){error('An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}}function enqueueCapturedUpdate(workInProgress,update){var current=workInProgress.alternate;if(current!==null){// Ensure the work-in-progress queue is a clone
  cloneUpdateQueue(current,workInProgress);}// Captured updates go only on the work-in-progress queue.
  var queue=workInProgress.updateQueue;// Append the update to the end of the list.
  var last=queue.baseQueue;if(last===null){queue.baseQueue=update.next=update;update.next=update;}else {update.next=last.next;last.next=update;}}function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var payload=update.payload;if(typeof payload==='function'){// Updater function
  {enterDisallowedContextReadInDEV();if(workInProgress.mode&StrictMode){payload.call(instance,prevState,nextProps);}}var nextState=payload.call(instance,prevState,nextProps);{exitDisallowedContextReadInDEV();}return nextState;}// State object
  return payload;}case CaptureUpdate:{workInProgress.effectTag=workInProgress.effectTag&~ShouldCapture|DidCapture;}// Intentional fallthrough
  case UpdateState:{var _payload=update.payload;var partialState;if(typeof _payload==='function'){// Updater function
  {enterDisallowedContextReadInDEV();if(workInProgress.mode&StrictMode){_payload.call(instance,prevState,nextProps);}}partialState=_payload.call(instance,prevState,nextProps);{exitDisallowedContextReadInDEV();}}else {// Partial state object
  partialState=_payload;}if(partialState===null||partialState===undefined){// Null and undefined are treated as no-ops.
  return prevState;}// Merge the partial state and the previous state.
  return _assign({},prevState,partialState);}case ForceUpdate:{hasForceUpdate=true;return prevState;}}return prevState;}function processUpdateQueue(workInProgress,props,instance,renderExpirationTime){// This is always non-null on a ClassComponent or HostRoot
  var queue=workInProgress.updateQueue;hasForceUpdate=false;{currentlyProcessingQueue=queue.shared;}// The last rebase update that is NOT part of the base state.
  var baseQueue=queue.baseQueue;// The last pending update that hasn't been processed yet.
  var pendingQueue=queue.shared.pending;if(pendingQueue!==null){// We have new updates that haven't been processed yet.
  // We'll add them to the base queue.
  if(baseQueue!==null){// Merge the pending queue and the base queue.
  var baseFirst=baseQueue.next;var pendingFirst=pendingQueue.next;baseQueue.next=pendingFirst;pendingQueue.next=baseFirst;}baseQueue=pendingQueue;queue.shared.pending=null;// TODO: Pass `current` as argument
  var current=workInProgress.alternate;if(current!==null){var currentQueue=current.updateQueue;if(currentQueue!==null){currentQueue.baseQueue=pendingQueue;}}}// These values may change as we process the queue.
  if(baseQueue!==null){var first=baseQueue.next;// Iterate through the list of updates to compute the result.
  var newState=queue.baseState;var newExpirationTime=NoWork;var newBaseState=null;var newBaseQueueFirst=null;var newBaseQueueLast=null;if(first!==null){var update=first;do{var updateExpirationTime=update.expirationTime;if(updateExpirationTime<renderExpirationTime){// Priority is insufficient. Skip this update. If this is the first
  // skipped update, the previous update/state is the new base
  // update/state.
  var clone={expirationTime:update.expirationTime,suspenseConfig:update.suspenseConfig,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newBaseQueueLast===null){newBaseQueueFirst=newBaseQueueLast=clone;newBaseState=newState;}else {newBaseQueueLast=newBaseQueueLast.next=clone;}// Update the remaining priority in the queue.
  if(updateExpirationTime>newExpirationTime){newExpirationTime=updateExpirationTime;}}else {// This update does have sufficient priority.
  if(newBaseQueueLast!==null){var _clone={expirationTime:Sync,// This update is going to be committed so we never want uncommit it.
  suspenseConfig:update.suspenseConfig,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newBaseQueueLast=newBaseQueueLast.next=_clone;}// Mark the event time of this update as relevant to this render pass.
  // TODO: This should ideally use the true event time of this update rather than
  // its priority which is a derived and not reverseable value.
  // TODO: We should skip this update if it was already committed but currently
  // we have no way of detecting the difference between a committed and suspended
  // update here.
  markRenderEventTimeAndConfig(updateExpirationTime,update.suspenseConfig);// Process this update.
  newState=getStateFromUpdate(workInProgress,queue,update,newState,props,instance);var callback=update.callback;if(callback!==null){workInProgress.effectTag|=Callback;var effects=queue.effects;if(effects===null){queue.effects=[update];}else {effects.push(update);}}}update=update.next;if(update===null||update===first){pendingQueue=queue.shared.pending;if(pendingQueue===null){break;}else {// An update was scheduled from inside a reducer. Add the new
  // pending updates to the end of the list and keep processing.
  update=baseQueue.next=pendingQueue.next;pendingQueue.next=first;queue.baseQueue=baseQueue=pendingQueue;queue.shared.pending=null;}}}while(true);}if(newBaseQueueLast===null){newBaseState=newState;}else {newBaseQueueLast.next=newBaseQueueFirst;}queue.baseState=newBaseState;queue.baseQueue=newBaseQueueLast;// Set the remaining expiration time to be whatever is remaining in the queue.
  // This should be fine because the only two other things that contribute to
  // expiration time are props and context. We're already in the middle of the
  // begin phase by the time we start processing the queue, so we've already
  // dealt with the props. Context in components that specify
  // shouldComponentUpdate is tricky; but we'll have to account for
  // that regardless.
  markUnprocessedUpdateTime(newExpirationTime);workInProgress.expirationTime=newExpirationTime;workInProgress.memoizedState=newState;}{currentlyProcessingQueue=null;}}function callCallback(callback,context){if(!(typeof callback==='function')){{throw Error("Invalid argument passed as callback. Expected a function. Instead received: "+callback);}}callback.call(context);}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=false;}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate;}function commitUpdateQueue(finishedWork,finishedQueue,instance){// Commit the effects
  var effects=finishedQueue.effects;finishedQueue.effects=null;if(effects!==null){for(var i=0;i<effects.length;i++){var effect=effects[i];var callback=effect.callback;if(callback!==null){effect.callback=null;callCallback(callback,instance);}}}}var ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig;function requestCurrentSuspenseConfig(){return ReactCurrentBatchConfig.suspense;}var fakeInternalInstance={};var isArray=Array.isArray;// React.Component uses a shared frozen object by default.
  // We'll use it to determine whether we need to initialize legacy refs.
  var emptyRefsObject=new React.Component().refs;var didWarnAboutStateAssignmentForComponent;var didWarnAboutUninitializedState;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;var didWarnAboutLegacyLifecyclesAndDerivedState;var didWarnAboutUndefinedDerivedState;var warnOnUndefinedDerivedState;var warnOnInvalidCallback;var didWarnAboutDirectlyAssigningPropsToState;var didWarnAboutContextTypeAndContextTypes;var didWarnAboutInvalidateContextType;{didWarnAboutStateAssignmentForComponent=new Set();didWarnAboutUninitializedState=new Set();didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set();didWarnAboutLegacyLifecyclesAndDerivedState=new Set();didWarnAboutDirectlyAssigningPropsToState=new Set();didWarnAboutUndefinedDerivedState=new Set();didWarnAboutContextTypeAndContextTypes=new Set();didWarnAboutInvalidateContextType=new Set();var didWarnOnInvalidCallback=new Set();warnOnInvalidCallback=function(callback,callerName){if(callback===null||typeof callback==='function'){return;}var key=callerName+"_"+callback;if(!didWarnOnInvalidCallback.has(key)){didWarnOnInvalidCallback.add(key);error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}};warnOnUndefinedDerivedState=function(type,partialState){if(partialState===undefined){var componentName=getComponentName(type)||'Component';if(!didWarnAboutUndefinedDerivedState.has(componentName)){didWarnAboutUndefinedDerivedState.add(componentName);error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '+'You have returned undefined.',componentName);}}};// This is so gross but it's at least non-critical and can be removed if
  // it causes problems. This is meant to give a nicer error message for
  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
  // ...)) which otherwise throws a "_processChildContext is not a function"
  // exception.
  Object.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function(){{{throw Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");}}}});Object.freeze(fakeInternalInstance);}function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState;{if(workInProgress.mode&StrictMode){// Invoke the function an extra time to help detect side-effects.
  getDerivedStateFromProps(nextProps,prevState);}}var partialState=getDerivedStateFromProps(nextProps,prevState);{warnOnUndefinedDerivedState(ctor,partialState);}// Merge the partial state and the previous state.
  var memoizedState=partialState===null||partialState===undefined?prevState:_assign({},prevState,partialState);workInProgress.memoizedState=memoizedState;// Once the update queue is empty, persist the derived state onto the
  // base state.
  if(workInProgress.expirationTime===NoWork){// Queue is always non-null for classes
  var updateQueue=workInProgress.updateQueue;updateQueue.baseState=memoizedState;}}var classComponentUpdater={isMounted:isMounted,enqueueSetState:function(inst,payload,callback){var fiber=get(inst);var currentTime=requestCurrentTimeForUpdate();var suspenseConfig=requestCurrentSuspenseConfig();var expirationTime=computeExpirationForFiber(currentTime,fiber,suspenseConfig);var update=createUpdate(expirationTime,suspenseConfig);update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'setState');}update.callback=callback;}enqueueUpdate(fiber,update);scheduleWork(fiber,expirationTime);},enqueueReplaceState:function(inst,payload,callback){var fiber=get(inst);var currentTime=requestCurrentTimeForUpdate();var suspenseConfig=requestCurrentSuspenseConfig();var expirationTime=computeExpirationForFiber(currentTime,fiber,suspenseConfig);var update=createUpdate(expirationTime,suspenseConfig);update.tag=ReplaceState;update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'replaceState');}update.callback=callback;}enqueueUpdate(fiber,update);scheduleWork(fiber,expirationTime);},enqueueForceUpdate:function(inst,callback){var fiber=get(inst);var currentTime=requestCurrentTimeForUpdate();var suspenseConfig=requestCurrentSuspenseConfig();var expirationTime=computeExpirationForFiber(currentTime,fiber,suspenseConfig);var update=createUpdate(expirationTime,suspenseConfig);update.tag=ForceUpdate;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'forceUpdate');}update.callback=callback;}enqueueUpdate(fiber,update);scheduleWork(fiber,expirationTime);}};function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress.stateNode;if(typeof instance.shouldComponentUpdate==='function'){{if(workInProgress.mode&StrictMode){// Invoke the function an extra time to help detect side-effects.
  instance.shouldComponentUpdate(newProps,newState,nextContext);}}startPhaseTimer(workInProgress,'shouldComponentUpdate');var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);stopPhaseTimer();{if(shouldUpdate===undefined){error('%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentName(ctor)||'Component');}}return shouldUpdate;}if(ctor.prototype&&ctor.prototype.isPureReactComponent){return !shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress,ctor,newProps){var instance=workInProgress.stateNode;{var name=getComponentName(ctor)||'Component';var renderPresent=instance.render;if(!renderPresent){if(ctor.prototype&&typeof ctor.prototype.render==='function'){error('%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else {error('%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}if(instance.getInitialState&&!instance.getInitialState.isReactClassApproved&&!instance.state){error('getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);}if(instance.getDefaultProps&&!instance.getDefaultProps.isReactClassApproved){error('getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);}if(instance.propTypes){error('propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);}if(instance.contextType){error('contextType was defined as an instance property on %s. Use a static '+'property to define contextType instead.',name);}{if(instance.contextTypes){error('contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);}if(ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)){didWarnAboutContextTypeAndContextTypes.add(ctor);error('%s declares both contextTypes and contextType static properties. '+'The legacy contextTypes property will be ignored.',name);}}if(typeof instance.componentShouldUpdate==='function'){error('%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);}if(ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){error('%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentName(ctor)||'A pure component');}if(typeof instance.componentDidUnmount==='function'){error('%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);}if(typeof instance.componentDidReceiveProps==='function'){error('%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);}if(typeof instance.componentWillRecieveProps==='function'){error('%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);}if(typeof instance.UNSAFE_componentWillRecieveProps==='function'){error('%s has a method called '+'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',name);}var hasMutatedProps=instance.props!==newProps;if(instance.props!==undefined&&hasMutatedProps){error('%s(...): When calling super() in `%s`, make sure to pass '+"up the same props that your component's constructor was passed.",name,name);}if(instance.defaultProps){error('Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}if(typeof instance.getSnapshotBeforeUpdate==='function'&&typeof instance.componentDidUpdate!=='function'&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)){didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '+'This component defines getSnapshotBeforeUpdate() only.',getComponentName(ctor));}if(typeof instance.getDerivedStateFromProps==='function'){error('%s: getDerivedStateFromProps() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof instance.getDerivedStateFromError==='function'){error('%s: getDerivedStateFromError() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof ctor.getSnapshotBeforeUpdate==='function'){error('%s: getSnapshotBeforeUpdate() is defined as a static method '+'and will be ignored. Instead, declare it as an instance method.',name);}var _state=instance.state;if(_state&&(typeof _state!=='object'||isArray(_state))){error('%s.state: must be set to an object or null',name);}if(typeof instance.getChildContext==='function'&&typeof ctor.childContextTypes!=='object'){error('%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',name);}}}function adoptClassInstance(workInProgress,instance){instance.updater=classComponentUpdater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates
  set(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,ctor,props){var isLegacyContextConsumer=false;var unmaskedContext=emptyContextObject;var context=emptyContextObject;var contextType=ctor.contextType;{if('contextType'in ctor){var isValid=// Allow null for conditional declaration
  contextType===null||contextType!==undefined&&contextType.$$typeof===REACT_CONTEXT_TYPE&&contextType._context===undefined;// Not a <Context.Consumer>
  if(!isValid&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum='';if(contextType===undefined){addendum=' However, it is set to undefined. '+'This can be caused by a typo or by mixing up named and default imports. '+'This can also happen due to a circular dependency, so '+'try moving the createContext() call to a separate file.';}else if(typeof contextType!=='object'){addendum=' However, it is set to a '+typeof contextType+'.';}else if(contextType.$$typeof===REACT_PROVIDER_TYPE){addendum=' Did you accidentally pass the Context.Provider instead?';}else if(contextType._context!==undefined){// <Context.Consumer>
  addendum=' Did you accidentally pass the Context.Consumer instead?';}else {addendum=' However, it is set to an object with keys {'+Object.keys(contextType).join(', ')+'}.';}error('%s defines an invalid contextType. '+'contextType should point to the Context object returned by React.createContext().%s',getComponentName(ctor)||'Component',addendum);}}}if(typeof contextType==='object'&&contextType!==null){context=readContext(contextType);}else {unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var contextTypes=ctor.contextTypes;isLegacyContextConsumer=contextTypes!==null&&contextTypes!==undefined;context=isLegacyContextConsumer?getMaskedContext(workInProgress,unmaskedContext):emptyContextObject;}// Instantiate twice to help detect side-effects.
  {if(workInProgress.mode&StrictMode){new ctor(props,context);// eslint-disable-line no-new
  }}var instance=new ctor(props,context);var state=workInProgress.memoizedState=instance.state!==null&&instance.state!==undefined?instance.state:null;adoptClassInstance(workInProgress,instance);{if(typeof ctor.getDerivedStateFromProps==='function'&&state===null){var componentName=getComponentName(ctor)||'Component';if(!didWarnAboutUninitializedState.has(componentName)){didWarnAboutUninitializedState.add(componentName);error('`%s` uses `getDerivedStateFromProps` but its initial state is '+'%s. This is not recommended. Instead, define the initial state by '+'assigning an object to `this.state` in the constructor of `%s`. '+'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',componentName,instance.state===null?'null':'undefined',componentName);}}// If new component APIs are defined, "unsafe" lifecycles won't be called.
  // Warn about these lifecycles if they are present.
  // Don't warn about react-lifecycles-compat polyfilled methods though.
  if(typeof ctor.getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function'){var foundWillMountName=null;var foundWillReceivePropsName=null;var foundWillUpdateName=null;if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){foundWillMountName='componentWillMount';}else if(typeof instance.UNSAFE_componentWillMount==='function'){foundWillMountName='UNSAFE_componentWillMount';}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){foundWillReceivePropsName='componentWillReceiveProps';}else if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){foundWillReceivePropsName='UNSAFE_componentWillReceiveProps';}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){foundWillUpdateName='componentWillUpdate';}else if(typeof instance.UNSAFE_componentWillUpdate==='function'){foundWillUpdateName='UNSAFE_componentWillUpdate';}if(foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentName(ctor)||'Component';var newApiName=typeof ctor.getDerivedStateFromProps==='function'?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';if(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)){didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n'+'%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n'+'The above lifecycles should be removed. Learn more about this warning here:\n'+'https://fb.me/react-unsafe-component-lifecycles',_componentName,newApiName,foundWillMountName!==null?"\n  "+foundWillMountName:'',foundWillReceivePropsName!==null?"\n  "+foundWillReceivePropsName:'',foundWillUpdateName!==null?"\n  "+foundWillUpdateName:'');}}}}// Cache unmasked context so we can avoid recreating masked context unless necessary.
  // ReactFiberContext usually updates this cache but can't for newly-created instances.
  if(isLegacyContextConsumer){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){startPhaseTimer(workInProgress,'componentWillMount');var oldState=instance.state;if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}stopPhaseTimer();if(oldState!==instance.state){{error('%s.componentWillMount(): Assigning directly to this.state is '+"deprecated (except inside a component's "+'constructor). Use setState instead.',getComponentName(workInProgress.type)||'Component');}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext){var oldState=instance.state;startPhaseTimer(workInProgress,'componentWillReceiveProps');if(typeof instance.componentWillReceiveProps==='function'){instance.componentWillReceiveProps(newProps,nextContext);}if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){instance.UNSAFE_componentWillReceiveProps(newProps,nextContext);}stopPhaseTimer();if(instance.state!==oldState){{var componentName=getComponentName(workInProgress.type)||'Component';if(!didWarnAboutStateAssignmentForComponent.has(componentName)){didWarnAboutStateAssignmentForComponent.add(componentName);error('%s.componentWillReceiveProps(): Assigning directly to '+"this.state is deprecated (except inside a component's "+'constructor). Use setState instead.',componentName);}}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.
  function mountClassInstance(workInProgress,ctor,newProps,renderExpirationTime){{checkClassInstance(workInProgress,ctor,newProps);}var instance=workInProgress.stateNode;instance.props=newProps;instance.state=workInProgress.memoizedState;instance.refs=emptyRefsObject;initializeUpdateQueue(workInProgress);var contextType=ctor.contextType;if(typeof contextType==='object'&&contextType!==null){instance.context=readContext(contextType);}else {var unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);instance.context=getMaskedContext(workInProgress,unmaskedContext);}{if(instance.state===newProps){var componentName=getComponentName(ctor)||'Component';if(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)){didWarnAboutDirectlyAssigningPropsToState.add(componentName);error('%s: It is not recommended to assign props directly to state '+"because updates to props won't be reflected in state. "+'In most cases, it is better to use props directly.',componentName);}}if(workInProgress.mode&StrictMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);}{ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);}}processUpdateQueue(workInProgress,newProps,instance,renderExpirationTime);instance.state=workInProgress.memoizedState;var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);instance.state=workInProgress.memoizedState;}// In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.
  if(typeof ctor.getDerivedStateFromProps!=='function'&&typeof instance.getSnapshotBeforeUpdate!=='function'&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's
  // process them now.
  processUpdateQueue(workInProgress,newProps,instance,renderExpirationTime);instance.state=workInProgress.memoizedState;}if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}}function resumeMountClassInstance(workInProgress,ctor,newProps,renderExpirationTime){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=oldProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(typeof contextType==='object'&&contextType!==null){nextContext=readContext(contextType);}else {var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what
  // ever the previously attempted to render - not the "current". However,
  // during componentDidUpdate we pass the "current" props.
  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.
  if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderExpirationTime);newState=workInProgress.memoizedState;if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update
  // effect even though we're bailing out, so that cWU/cDU are called.
  if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.
  if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){startPhaseTimer(workInProgress,'componentWillMount');if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}stopPhaseTimer();}if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}}else {// If an update was already in progress, we should schedule an Update
  // effect even though we're bailing out, so that cWU/cDU are called.
  if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}// If shouldComponentUpdate returned false, we should still update the
  // memoized state to indicate that this work can be reused.
  workInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even
  // if shouldComponentUpdate returns false.
  instance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}// Invokes the update life-cycles and returns false if it shouldn't rerender.
  function updateClassInstance(current,workInProgress,ctor,newProps,renderExpirationTime){var instance=workInProgress.stateNode;cloneUpdateQueue(current,workInProgress);var oldProps=workInProgress.memoizedProps;instance.props=workInProgress.type===workInProgress.elementType?oldProps:resolveDefaultProps(workInProgress.type,oldProps);var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(typeof contextType==='object'&&contextType!==null){nextContext=readContext(contextType);}else {var nextUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what
  // ever the previously attempted to render - not the "current". However,
  // during componentDidUpdate we pass the "current" props.
  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.
  if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderExpirationTime);newState=workInProgress.memoizedState;if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update
  // effect even though we're bailing out, so that cWU/cDU are called.
  if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Snapshot;}}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.
  if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate==='function'||typeof instance.componentWillUpdate==='function')){startPhaseTimer(workInProgress,'componentWillUpdate');if(typeof instance.componentWillUpdate==='function'){instance.componentWillUpdate(newProps,newState,nextContext);}if(typeof instance.UNSAFE_componentWillUpdate==='function'){instance.UNSAFE_componentWillUpdate(newProps,newState,nextContext);}stopPhaseTimer();}if(typeof instance.componentDidUpdate==='function'){workInProgress.effectTag|=Update;}if(typeof instance.getSnapshotBeforeUpdate==='function'){workInProgress.effectTag|=Snapshot;}}else {// If an update was already in progress, we should schedule an Update
  // effect even though we're bailing out, so that cWU/cDU are called.
  if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Snapshot;}}// If shouldComponentUpdate returned false, we should still update the
  // memoized props/state to indicate that this work can be reused.
  workInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even
  // if shouldComponentUpdate returns false.
  instance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}var didWarnAboutMaps;var didWarnAboutGenerators;var didWarnAboutStringRefs;var ownerHasKeyUseWarning;var ownerHasFunctionTypeWarning;var warnForMissingKey=function(child){};{didWarnAboutMaps=false;didWarnAboutGenerators=false;didWarnAboutStringRefs={};/**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */ownerHasKeyUseWarning={};ownerHasFunctionTypeWarning={};warnForMissingKey=function(child){if(child===null||typeof child!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}if(!(typeof child._store==='object')){{throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");}}child._store.validated=true;var currentComponentErrorInfo='Each child in a list should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.'+getCurrentFiberStackInDev();if(ownerHasKeyUseWarning[currentComponentErrorInfo]){return;}ownerHasKeyUseWarning[currentComponentErrorInfo]=true;error('Each child in a list should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.');};}var isArray$1=Array.isArray;function coerceRef(returnFiber,current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'&&typeof mixedRef!=='object'){{// TODO: Clean this up once we turn on the string ref warning for
  // everyone, because the strict mode case will no longer be relevant
  if((returnFiber.mode&StrictMode||warnAboutStringRefs)&&// We warn in ReactElement.js if owner and self are equal for string refs
  // because these cannot be automatically converted to an arrow function
  // using a codemod. Therefore, we don't have to warn about string refs again.
  !(element._owner&&element._self&&element._owner.stateNode!==element._self)){var componentName=getComponentName(returnFiber.type)||'Component';if(!didWarnAboutStringRefs[componentName]){{error('A string ref, "%s", has been found within a strict mode tree. '+'String refs are a source of potential bugs and should be avoided. '+'We recommend using useRef() or createRef() instead. '+'Learn more about using refs safely here: '+'https://fb.me/react-strict-mode-string-ref%s',mixedRef,getStackByFiberInDevAndProd(returnFiber));}didWarnAboutStringRefs[componentName]=true;}}}if(element._owner){var owner=element._owner;var inst;if(owner){var ownerFiber=owner;if(!(ownerFiber.tag===ClassComponent)){{throw Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://fb.me/react-strict-mode-string-ref");}}inst=ownerFiber.stateNode;}if(!inst){{throw Error("Missing owner for string ref "+mixedRef+". This error is likely caused by a bug in React. Please file an issue.");}}var stringRef=''+mixedRef;// Check if previous string ref matches new string ref
  if(current!==null&&current.ref!==null&&typeof current.ref==='function'&&current.ref._stringRef===stringRef){return current.ref;}var ref=function(value){var refs=inst.refs;if(refs===emptyRefsObject){// This is a lazy pooled frozen object, so we need to initialize.
  refs=inst.refs={};}if(value===null){delete refs[stringRef];}else {refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else {if(!(typeof mixedRef==='string')){{throw Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");}}if(!element._owner){{throw Error("Element ref was specified as a string ("+mixedRef+") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://fb.me/react-refs-must-have-owner for more information.");}}}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){if(returnFiber.type!=='textarea'){var addendum='';{addendum=' If you meant to render a collection of children, use an array '+'instead.'+getCurrentFiberStackInDev();}{{throw Error("Objects are not valid as a React child (found: "+(Object.prototype.toString.call(newChild)==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':newChild)+")."+addendum);}}}}function warnOnFunctionType(){{var currentComponentErrorInfo='Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.'+getCurrentFiberStackInDev();if(ownerHasFunctionTypeWarning[currentComponentErrorInfo]){return;}ownerHasFunctionTypeWarning[currentComponentErrorInfo]=true;error('Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.');}}// This wrapper function exists because I expect to clone the code in each path
  // to be able to optimize each path individually by branching early. This needs
  // a compiler or we can do it manually. Helpers that don't need this branching
  // live outside of this function.
  function ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.
  return;}// Deletions are added in reversed order so we add it to the front.
  // At this point, the return fiber's effect list is empty except for
  // deletions, so we can just append the deletion to the list. The remaining
  // effects aren't added until the complete phase. Once we implement
  // resuming, this may not be true.
  var last=returnFiber.lastEffect;if(last!==null){last.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else {returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}childToDelete.nextEffect=null;childToDelete.effectTag=Deletion;}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.
  return null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by
  // assuming that after the first child we've already added everything.
  var childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by
  // keys quickly. Implicit (null) keys get added to this set with their index
  // instead.
  var existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else {existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps){// We currently set sibling to null and index to 0 here because it is easy
  // to forget to do before returning it. E.g. for the single child case.
  var clone=createWorkInProgress(fiber,pendingProps);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// Noop.
  return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.
  newFiber.effectTag=Placement;return lastPlacedIndex;}else {// This item can stay in place.
  return oldIndex;}}else {// This is an insertion.
  newFiber.effectTag=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a
  // placement for inserting new children.
  if(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.effectTag=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,expirationTime){if(current===null||current.tag!==HostText){// Insert
  var created=createFiberFromText(textContent,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}else {// Update
  var existing=useFiber(current,textContent);existing.return=returnFiber;return existing;}}function updateElement(returnFiber,current,element,expirationTime){if(current!==null){if(current.elementType===element.type||// Keep this check inline so it only runs on the false path:
  isCompatibleFamilyForHotReloading(current,element)){// Move based on index
  var existing=useFiber(current,element.props);existing.ref=coerceRef(returnFiber,current,element);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}// Insert
  var created=createFiberFromElement(element,returnFiber.mode,expirationTime);created.ref=coerceRef(returnFiber,current,element);created.return=returnFiber;return created;}function updatePortal(returnFiber,current,portal,expirationTime){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert
  var created=createFiberFromPortal(portal,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}else {// Update
  var existing=useFiber(current,portal.children||[]);existing.return=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,expirationTime,key){if(current===null||current.tag!==Fragment){// Insert
  var created=createFiberFromFragment(fragment,returnFiber.mode,expirationTime,key);created.return=returnFiber;return created;}else {// Update
  var existing=useFiber(current,fragment);existing.return=returnFiber;return existing;}}function createChild(returnFiber,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
  // we can continue to replace it without aborting even if it is not a text
  // node.
  var created=createFiberFromText(''+newChild,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,expirationTime);_created.ref=coerceRef(returnFiber,null,newChild);_created.return=returnFiber;return _created;}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,expirationTime);_created2.return=returnFiber;return _created2;}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,expirationTime,null);_created3.return=returnFiber;return _created3;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateSlot(returnFiber,oldFiber,newChild,expirationTime){// Update the fiber if the keys match, otherwise return null.
  var key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
  // we can continue to replace it without aborting even if it is not a text
  // node.
  if(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,expirationTime);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,oldFiber,newChild.props.children,expirationTime,key);}return updateElement(returnFiber,oldFiber,newChild,expirationTime);}else {return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,expirationTime);}else {return null;}}}if(isArray$1(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor
  // new node for the key. If both are text nodes, they match.
  var matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,expirationTime);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,_matchedFiber,newChild.props.children,expirationTime,newChild.key);}return updateElement(returnFiber,_matchedFiber,newChild,expirationTime);}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,expirationTime);}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber3,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}/**
     * Warns if there is a duplicate or missing key
     */function warnOnInvalidKey(child,knownKeys){{if(typeof child!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}error('Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.',key);break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,expirationTime){// This algorithm can't optimize by searching from both ends since we
  // don't have backpointers on fibers. I'm trying to see how far we can get
  // with that model. If it ends up not being worth the tradeoffs, we can
  // add it later.
  // Even with a two ended optimization, we'd want to optimize for the case
  // where there are few changes and brute force the comparison instead of
  // going for the Map. It'd like to explore hitting that path first in
  // forward-only mode and only go for the Map once we notice that we need
  // lots of look ahead. This doesn't handle reversal as well as two ended
  // search but that's unusual. Besides, for the two ended optimization to
  // work on Iterables, we'd need to copy the whole set.
  // In this first iteration, we'll just live with hitting the bad case
  // (adding everything to a Map) in for every insert/move.
  // If you change this code, also update reconcileChildrenIterator() which
  // uses the same algorithm.
  {// First, validate keys.
  var knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else {nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
  // unfortunate because it triggers the slow path all the time. We need
  // a better way to communicate whether this was a miss or null,
  // boolean, undefined, etc.
  if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
  // need to delete the existing child.
  deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
  resultingFirstChild=newFiber;}else {// TODO: Defer siblings if we're not at the right index for this slot.
  // I.e. if we had null values before, then we want to defer this
  // for each null value. However, we also don't want to call updateSlot
  // with the previous one.
  previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.
  deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
  // since the rest will all be insertions.
  for(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],expirationTime);if(_newFiber===null){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
  resultingFirstChild=_newFiber;}else {previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
  var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
  for(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],expirationTime);if(_newFiber2!==null){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a
  // current, that means that we reused the fiber. We need to delete
  // it from the child list so that we don't add it to the deletion
  // list.
  existingChildren.delete(_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else {previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
  // to add them to the deletion list.
  existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,expirationTime){// This is the same implementation as reconcileChildrenArray(),
  // but using the iterator instead.
  var iteratorFn=getIteratorFn(newChildrenIterable);if(!(typeof iteratorFn==='function')){{throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");}}{// We don't support rendering Generators because it's a mutation.
  // See https://github.com/facebook/react/issues/12995
  if(typeof Symbol==='function'&&// $FlowFixMe Flow doesn't know about toStringTag
  newChildrenIterable[Symbol.toStringTag]==='Generator'){if(!didWarnAboutGenerators){error('Using Generators as children is unsupported and will likely yield '+'unexpected results because enumerating a generator mutates it. '+'You may convert it to an array with `Array.from()` or the '+'`[...spread]` operator before rendering. Keep in mind '+'you might need to polyfill these features for older browsers.');}didWarnAboutGenerators=true;}// Warn about using Maps as children
  if(newChildrenIterable.entries===iteratorFn){if(!didWarnAboutMaps){error('Using Maps as children is unsupported and will likely yield '+'unexpected results. Convert it to a sequence/iterable of keyed '+'ReactElements instead.');}didWarnAboutMaps=true;}// First, validate keys.
  // We'll get a different iterator later for the main pass.
  var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys);}}}var newChildren=iteratorFn.call(newChildrenIterable);if(!(newChildren!=null)){{throw Error("An iterable object provided no iterator.");}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else {nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
  // unfortunate because it triggers the slow path all the time. We need
  // a better way to communicate whether this was a miss or null,
  // boolean, undefined, etc.
  if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
  // need to delete the existing child.
  deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
  resultingFirstChild=newFiber;}else {// TODO: Defer siblings if we're not at the right index for this slot.
  // I.e. if we had null values before, then we want to defer this
  // for each null value. However, we also don't want to call updateSlot
  // with the previous one.
  previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.
  deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
  // since the rest will all be insertions.
  for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,expirationTime);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
  resultingFirstChild=_newFiber3;}else {previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
  var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
  for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,expirationTime);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a
  // current, that means that we reused the fiber. We need to delete
  // it from the child list so that we don't add it to the deletion
  // list.
  existingChildren.delete(_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else {previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
  // to add them to the deletion list.
  existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,expirationTime){// There's no need to check for keys on text nodes since we don't have a
  // way to define them.
  if(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete
  // the rest.
  deleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent);existing.return=returnFiber;return existing;}// The existing first child is not a text node so we need to create one
  // and delete the existing ones.
  deleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,expirationTime){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
  // the first item in the list.
  if(child.key===key){switch(child.tag){case Fragment:{if(element.type===REACT_FRAGMENT_TYPE){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.props.children);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}break;}case Block:// We intentionally fallthrough here if enableBlocksAPI is not on.
  // eslint-disable-next-lined no-fallthrough
  default:{if(child.elementType===element.type||// Keep this check inline so it only runs on the false path:
  isCompatibleFamilyForHotReloading(child,element)){deleteRemainingChildren(returnFiber,child.sibling);var _existing3=useFiber(child,element.props);_existing3.ref=coerceRef(returnFiber,child,element);_existing3.return=returnFiber;{_existing3._debugSource=element._source;_existing3._debugOwner=element._owner;}return _existing3;}break;}}// Didn't match.
  deleteRemainingChildren(returnFiber,child);break;}else {deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,expirationTime,element.key);created.return=returnFiber;return created;}else {var _created4=createFiberFromElement(element,returnFiber.mode,expirationTime);_created4.ref=coerceRef(returnFiber,currentFirstChild,element);_created4.return=returnFiber;return _created4;}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,expirationTime){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
  // the first item in the list.
  if(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[]);existing.return=returnFiber;return existing;}else {deleteRemainingChildren(returnFiber,child);break;}}else {deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation
  // itself. They will be added to the side-effect list as we pass through the
  // children and the parent.
  function reconcileChildFibers(returnFiber,currentFirstChild,newChild,expirationTime){// This function is not recursive.
  // If the top level item is an array, we treat it as a set of children,
  // not as a fragment. Nested arrays on the other hand will be treated as
  // fragment nodes. Recursion happens at the normal flow.
  // Handle top level unkeyed fragments as if they were arrays.
  // This leads to an ambiguity between <>{[...]}</> and <>...</>.
  // We treat the ambiguous cases above the same.
  var isUnkeyedTopLevelFragment=typeof newChild==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment){newChild=newChild.props.children;}// Handle object types
  var isObject=typeof newChild==='object'&&newChild!==null;if(isObject){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,expirationTime));}}if(typeof newChild==='string'||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,expirationTime));}if(isArray$1(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,expirationTime);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,expirationTime);}if(isObject){throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}if(typeof newChild==='undefined'&&!isUnkeyedTopLevelFragment){// If the new child is undefined, and the return fiber is a composite
  // component, throw an error. If Fiber return types are disabled,
  // we already threw above.
  switch(returnFiber.tag){case ClassComponent:{{var instance=returnFiber.stateNode;if(instance.render._isMockFunction){// We allow auto-mocks to proceed as if they're returning null.
  break;}}}// Intentionally fall through to the next case, which handles both
  // functions and classes
  // eslint-disable-next-lined no-fallthrough
  case FunctionComponent:{var Component=returnFiber.type;{{throw Error((Component.displayName||Component.name||'Component')+"(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");}}}}}// Remaining cases are all treated as empty.
  return deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){if(!(current===null||workInProgress.child===current.child)){{throw Error("Resuming work not yet implemented.");}}if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps);workInProgress.child=newChild;newChild.return=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps);newChild.return=workInProgress;}newChild.sibling=null;}// Reset a workInProgress child set to prepare it for a second pass.
  function resetChildFibers(workInProgress,renderExpirationTime){var child=workInProgress.child;while(child!==null){resetWorkInProgress(child,renderExpirationTime);child=child.sibling;}}var NO_CONTEXT={};var contextStackCursor$1=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){if(!(c!==NO_CONTEXT)){{throw Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");}}return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;
  // This allows us to reset root when portals are popped.
  push(rootInstanceStackCursor,nextRootInstance,fiber);// Track the context and the Fiber that provided it.
  // This enables us to pop only Fibers that provide unique contexts.
  push(contextFiberStackCursor,fiber,fiber);// Finally, we need to push the host context to the stack.
  // However, we can't just call getRootHostContext() and push it because
  // we'd have a different number of entries on the stack depending on
  // whether getRootHostContext() throws somewhere in renderer code or not.
  // So we push an empty value first. This lets us safely unwind on errors.
  push(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Now that we know this function doesn't throw, replace it.
  pop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor$1.current);return context;}function pushHostContext(fiber){requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor$1.current);var nextContext=getChildHostContext(context,fiber.type);// Don't push this Fiber's context unless it's unique.
  if(context===nextContext){return;}// Track the context and the Fiber that provided it.
  // This enables us to pop only Fibers that provide unique contexts.
  push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.
  // pushHostContext() only pushes Fibers that provide unique contexts.
  if(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);}var DefaultSuspenseContext=0;// The Suspense Context is split into two parts. The lower bits is
  // inherited deeply down the subtree. The upper bits only affect
  // this immediate suspense boundary and gets reset each new
  // boundary or suspense list.
  var SubtreeSuspenseContextMask=1;// Subtree Flags:
  // InvisibleParentSuspenseContext indicates that one of our parent Suspense
  // boundaries is not currently showing visible main content.
  // Either because it is already showing a fallback or is not mounted at all.
  // We can use this to determine if it is desirable to trigger a fallback at
  // the parent. If not, then we might need to trigger undesirable boundaries
  // and/or suspend the commit to avoid hiding the parent content.
  var InvisibleParentSuspenseContext=1;// Shallow Flags:
  // ForceSuspenseFallback can be used by SuspenseList to force newly added
  // items into their fallback state during one of the render passes.
  var ForceSuspenseFallback=2;var suspenseStackCursor=createCursor(DefaultSuspenseContext);function hasSuspenseContext(parentContext,flag){return (parentContext&flag)!==0;}function setDefaultShallowSuspenseContext(parentContext){return parentContext&SubtreeSuspenseContextMask;}function setShallowSuspenseContext(parentContext,shallowContext){return parentContext&SubtreeSuspenseContextMask|shallowContext;}function addSubtreeSuspenseContext(parentContext,subtreeContext){return parentContext|subtreeContext;}function pushSuspenseContext(fiber,newContext){push(suspenseStackCursor,newContext,fiber);}function popSuspenseContext(fiber){pop(suspenseStackCursor,fiber);}function shouldCaptureSuspense(workInProgress,hasInvisibleParent){// If it was the primary children that just suspended, capture and render the
  // fallback. Otherwise, don't capture and bubble to the next boundary.
  var nextState=workInProgress.memoizedState;if(nextState!==null){if(nextState.dehydrated!==null){// A dehydrated boundary always captures.
  return true;}return false;}var props=workInProgress.memoizedProps;// In order to capture, the Suspense component must have a fallback prop.
  if(props.fallback===undefined){return false;}// Regular boundaries always capture.
  if(props.unstable_avoidThisFallback!==true){return true;}// If it's a boundary we should avoid, then we prefer to bubble up to the
  // parent boundary if it is currently invisible.
  if(hasInvisibleParent){return false;}// If the parent is not able to handle it, we must handle it.
  return true;}function findFirstSuspended(row){var node=row;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){var dehydrated=state.dehydrated;if(dehydrated===null||isSuspenseInstancePending(dehydrated)||isSuspenseInstanceFallback(dehydrated)){return node;}}}else if(node.tag===SuspenseListComponent&&// revealOrder undefined can't be trusted because it don't
  // keep track of whether it suspended or not.
  node.memoizedProps.revealOrder!==undefined){var didSuspend=(node.effectTag&DidCapture)!==NoEffect;if(didSuspend){return node;}}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===row){return null;}while(node.sibling===null){if(node.return===null||node.return===row){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}return null;}function createDeprecatedResponderListener(responder,props){var eventResponderListener={responder:responder,props:props};{Object.freeze(eventResponderListener);}return eventResponderListener;}var HasEffect=/* */1;// Represents the phase in which the effect (not the clean-up) fires.
  var Layout=/*    */2;var Passive$1=/*   */4;var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentBatchConfig$1=ReactSharedInternals.ReactCurrentBatchConfig;var didWarnAboutMismatchedHooksForComponent;{didWarnAboutMismatchedHooksForComponent=new Set();}// These are set right before calling the component.
  var renderExpirationTime=NoWork;// The work-in-progress fiber. I've named it differently to distinguish it from
  // the work-in-progress hook.
  var currentlyRenderingFiber$1=null;// Hooks are stored as a linked list on the fiber's memoizedState field. The
  // current hook list is the list that belongs to the current fiber. The
  // work-in-progress hook list is a new list that will be added to the
  // work-in-progress fiber.
  var currentHook=null;var workInProgressHook=null;// Whether an update was scheduled at any point during the render phase. This
  // does not get reset if we do another render pass; only when we're completely
  // finished evaluating this component. This is an optimization so we know
  // whether we need to clear render phase updates after a throw.
  var didScheduleRenderPhaseUpdate=false;var RE_RENDER_LIMIT=25;// In DEV, this is the name of the currently executing primitive hook
  var currentHookNameInDev=null;// In DEV, this list ensures that hooks are called in the same order between renders.
  // The list stores the order of hooks used during the initial render (mount).
  // Subsequent renders (updates) reference this list.
  var hookTypesDev=null;var hookTypesUpdateIndexDev=-1;// In DEV, this tracks whether currently rendering component needs to ignore
  // the dependencies for Hooks that need them (e.g. useEffect or useMemo).
  // When true, such Hooks will always be "remounted". Only used during hot reload.
  var ignorePreviousDependencies=false;function mountHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev===null){hookTypesDev=[hookName];}else {hookTypesDev.push(hookName);}}}function updateHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev!==null){hookTypesUpdateIndexDev++;if(hookTypesDev[hookTypesUpdateIndexDev]!==hookName){warnOnHookMismatchInDev(hookName);}}}}function checkDepsAreArrayDev(deps){{if(deps!==undefined&&deps!==null&&!Array.isArray(deps)){// Verify deps, but only on mount to avoid extra checks.
  // It's unlikely their type would change as usually you define them inline.
  error('%s received a final argument that is not an array (instead, received `%s`). When '+'specified, the final argument must be an array.',currentHookNameInDev,typeof deps);}}}function warnOnHookMismatchInDev(currentHookName){{var componentName=getComponentName(currentlyRenderingFiber$1.type);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)){didWarnAboutMismatchedHooksForComponent.add(componentName);if(hookTypesDev!==null){var table='';var secondColumnStart=30;for(var i=0;i<=hookTypesUpdateIndexDev;i++){var oldHookName=hookTypesDev[i];var newHookName=i===hookTypesUpdateIndexDev?currentHookName:oldHookName;var row=i+1+". "+oldHookName;// Extra space so second column lines up
  // lol @ IE not supporting String#repeat
  while(row.length<secondColumnStart){row+=' ';}row+=newHookName+'\n';table+=row;}error('React has detected a change in the order of Hooks called by %s. '+'This will lead to bugs and errors if not fixed. '+'For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\n\n'+'   Previous render            Next render\n'+'   ------------------------------------------------------\n'+'%s'+'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n',componentName,table);}}}}function throwInvalidHookError(){{{throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.");}}}function areHookInputsEqual(nextDeps,prevDeps){{if(ignorePreviousDependencies){// Only true when this component is being hot reloaded.
  return false;}}if(prevDeps===null){{error('%s received a final argument during this render, but not during '+'the previous render. Even though the final argument is optional, '+'its type cannot change between renders.',currentHookNameInDev);}return false;}{// Don't bother comparing lengths in prod because these arrays should be
  // passed inline.
  if(nextDeps.length!==prevDeps.length){error('The final argument passed to %s changed size between renders. The '+'order and size of this array must remain constant.\n\n'+'Previous: %s\n'+'Incoming: %s',currentHookNameInDev,"["+prevDeps.join(', ')+"]","["+nextDeps.join(', ')+"]");}}for(var i=0;i<prevDeps.length&&i<nextDeps.length;i++){if(objectIs(nextDeps[i],prevDeps[i])){continue;}return false;}return true;}function renderWithHooks(current,workInProgress,Component,props,secondArg,nextRenderExpirationTime){renderExpirationTime=nextRenderExpirationTime;currentlyRenderingFiber$1=workInProgress;{hookTypesDev=current!==null?current._debugHookTypes:null;hookTypesUpdateIndexDev=-1;// Used for hot reloading:
  ignorePreviousDependencies=current!==null&&current.type!==workInProgress.type;}workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.expirationTime=NoWork;// The following should have already been reset
  // currentHook = null;
  // workInProgressHook = null;
  // didScheduleRenderPhaseUpdate = false;
  // TODO Warn if no hooks are used at all during mount, then some are used during update.
  // Currently we will identify the update render as a mount because memoizedState === null.
  // This is tricky because it's valid for certain types of components (e.g. React.lazy)
  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.
  // Non-stateful hooks (e.g. context) don't get added to memoizedState,
  // so memoizedState would be null during updates and mounts.
  {if(current!==null&&current.memoizedState!==null){ReactCurrentDispatcher.current=HooksDispatcherOnUpdateInDEV;}else if(hookTypesDev!==null){// This dispatcher handles an edge case where a component is updating,
  // but no stateful hooks have been used.
  // We want to match the production code behavior (which will use HooksDispatcherOnMount),
  // but with the extra DEV validation to ensure hooks ordering hasn't changed.
  // This dispatcher does that.
  ReactCurrentDispatcher.current=HooksDispatcherOnMountWithHookTypesInDEV;}else {ReactCurrentDispatcher.current=HooksDispatcherOnMountInDEV;}}var children=Component(props,secondArg);// Check if there was a render phase update
  if(workInProgress.expirationTime===renderExpirationTime){// Keep rendering in a loop for as long as render phase updates continue to
  // be scheduled. Use a counter to prevent infinite loops.
  var numberOfReRenders=0;do{workInProgress.expirationTime=NoWork;if(!(numberOfReRenders<RE_RENDER_LIMIT)){{throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");}}numberOfReRenders+=1;{// Even when hot reloading, allow dependencies to stabilize
  // after first render to prevent infinite render phase updates.
  ignorePreviousDependencies=false;}// Start over from the beginning of the list
  currentHook=null;workInProgressHook=null;workInProgress.updateQueue=null;{// Also validate hook order for cascading updates.
  hookTypesUpdateIndexDev=-1;}ReactCurrentDispatcher.current=HooksDispatcherOnRerenderInDEV;children=Component(props,secondArg);}while(workInProgress.expirationTime===renderExpirationTime);}// We can assume the previous dispatcher is always this one, since we set it
  // at the beginning of the render phase and there's no re-entrancy.
  ReactCurrentDispatcher.current=ContextOnlyDispatcher;{workInProgress._debugHookTypes=hookTypesDev;}// This check uses currentHook so that it works the same in DEV and prod bundles.
  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.
  var didRenderTooFewHooks=currentHook!==null&&currentHook.next!==null;renderExpirationTime=NoWork;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{currentHookNameInDev=null;hookTypesDev=null;hookTypesUpdateIndexDev=-1;}didScheduleRenderPhaseUpdate=false;if(!!didRenderTooFewHooks){{throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");}}return children;}function bailoutHooks(current,workInProgress,expirationTime){workInProgress.updateQueue=current.updateQueue;workInProgress.effectTag&=~(Passive|Update);if(current.expirationTime<=expirationTime){current.expirationTime=NoWork;}}function resetHooksAfterThrow(){// We can assume the previous dispatcher is always this one, since we set it
  // at the beginning of the render phase and there's no re-entrancy.
  ReactCurrentDispatcher.current=ContextOnlyDispatcher;if(didScheduleRenderPhaseUpdate){// There were render phase updates. These are only valid for this render
  // phase, which we are now aborting. Remove the updates from the queues so
  // they do not persist to the next render. Do not remove updates from hooks
  // that weren't processed.
  //
  // Only reset the updates from the queue if it has a clone. If it does
  // not have a clone, that means it wasn't processed, and the updates were
  // scheduled before we entered the render phase.
  var hook=currentlyRenderingFiber$1.memoizedState;while(hook!==null){var queue=hook.queue;if(queue!==null){queue.pending=null;}hook=hook.next;}}renderExpirationTime=NoWork;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{hookTypesDev=null;hookTypesUpdateIndexDev=-1;currentHookNameInDev=null;}didScheduleRenderPhaseUpdate=false;}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};if(workInProgressHook===null){// This is the first hook in the list
  currentlyRenderingFiber$1.memoizedState=workInProgressHook=hook;}else {// Append to the end of the list
  workInProgressHook=workInProgressHook.next=hook;}return workInProgressHook;}function updateWorkInProgressHook(){// This function is used both for updates and for re-renders triggered by a
  // render phase update. It assumes there is either a current hook we can
  // clone, or a work-in-progress hook from a previous render pass that we can
  // use as a base. When we reach the end of the base list, we must switch to
  // the dispatcher used for mounts.
  var nextCurrentHook;if(currentHook===null){var current=currentlyRenderingFiber$1.alternate;if(current!==null){nextCurrentHook=current.memoizedState;}else {nextCurrentHook=null;}}else {nextCurrentHook=currentHook.next;}var nextWorkInProgressHook;if(workInProgressHook===null){nextWorkInProgressHook=currentlyRenderingFiber$1.memoizedState;}else {nextWorkInProgressHook=workInProgressHook.next;}if(nextWorkInProgressHook!==null){// There's already a work-in-progress. Reuse it.
  workInProgressHook=nextWorkInProgressHook;nextWorkInProgressHook=workInProgressHook.next;currentHook=nextCurrentHook;}else {// Clone from the current hook.
  if(!(nextCurrentHook!==null)){{throw Error("Rendered more hooks than during the previous render.");}}currentHook=nextCurrentHook;var newHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};if(workInProgressHook===null){// This is the first hook in the list.
  currentlyRenderingFiber$1.memoizedState=workInProgressHook=newHook;}else {// Append to the end of the list.
  workInProgressHook=workInProgressHook.next=newHook;}}return workInProgressHook;}function createFunctionComponentUpdateQueue(){return {lastEffect:null};}function basicStateReducer(state,action){// $FlowFixMe: Flow doesn't like mixed types
  return typeof action==='function'?action(state):action;}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook();var initialState;if(init!==undefined){initialState=init(initialArg);}else {initialState=initialArg;}hook.memoizedState=hook.baseState=initialState;var queue=hook.queue={pending:null,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};var dispatch=queue.dispatch=dispatchAction.bind(null,currentlyRenderingFiber$1,queue);return [hook.memoizedState,dispatch];}function updateReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(!(queue!==null)){{throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");}}queue.lastRenderedReducer=reducer;var current=currentHook;// The last rebase update that is NOT part of the base state.
  var baseQueue=current.baseQueue;// The last pending update that hasn't been processed yet.
  var pendingQueue=queue.pending;if(pendingQueue!==null){// We have new updates that haven't been processed yet.
  // We'll add them to the base queue.
  if(baseQueue!==null){// Merge the pending queue and the base queue.
  var baseFirst=baseQueue.next;var pendingFirst=pendingQueue.next;baseQueue.next=pendingFirst;pendingQueue.next=baseFirst;}current.baseQueue=baseQueue=pendingQueue;queue.pending=null;}if(baseQueue!==null){// We have a queue to process.
  var first=baseQueue.next;var newState=current.baseState;var newBaseState=null;var newBaseQueueFirst=null;var newBaseQueueLast=null;var update=first;do{var updateExpirationTime=update.expirationTime;if(updateExpirationTime<renderExpirationTime){// Priority is insufficient. Skip this update. If this is the first
  // skipped update, the previous update/state is the new base
  // update/state.
  var clone={expirationTime:update.expirationTime,suspenseConfig:update.suspenseConfig,action:update.action,eagerReducer:update.eagerReducer,eagerState:update.eagerState,next:null};if(newBaseQueueLast===null){newBaseQueueFirst=newBaseQueueLast=clone;newBaseState=newState;}else {newBaseQueueLast=newBaseQueueLast.next=clone;}// Update the remaining priority in the queue.
  if(updateExpirationTime>currentlyRenderingFiber$1.expirationTime){currentlyRenderingFiber$1.expirationTime=updateExpirationTime;markUnprocessedUpdateTime(updateExpirationTime);}}else {// This update does have sufficient priority.
  if(newBaseQueueLast!==null){var _clone={expirationTime:Sync,// This update is going to be committed so we never want uncommit it.
  suspenseConfig:update.suspenseConfig,action:update.action,eagerReducer:update.eagerReducer,eagerState:update.eagerState,next:null};newBaseQueueLast=newBaseQueueLast.next=_clone;}// Mark the event time of this update as relevant to this render pass.
  // TODO: This should ideally use the true event time of this update rather than
  // its priority which is a derived and not reverseable value.
  // TODO: We should skip this update if it was already committed but currently
  // we have no way of detecting the difference between a committed and suspended
  // update here.
  markRenderEventTimeAndConfig(updateExpirationTime,update.suspenseConfig);// Process this update.
  if(update.eagerReducer===reducer){// If this update was processed eagerly, and its reducer matches the
  // current reducer, we can use the eagerly computed state.
  newState=update.eagerState;}else {var action=update.action;newState=reducer(newState,action);}}update=update.next;}while(update!==null&&update!==first);if(newBaseQueueLast===null){newBaseState=newState;}else {newBaseQueueLast.next=newBaseQueueFirst;}// Mark that the fiber performed work, but only if the new state is
  // different from the current state.
  if(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;hook.baseState=newBaseState;hook.baseQueue=newBaseQueueLast;queue.lastRenderedState=newState;}var dispatch=queue.dispatch;return [hook.memoizedState,dispatch];}function rerenderReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(!(queue!==null)){{throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");}}queue.lastRenderedReducer=reducer;// This is a re-render. Apply the new render phase updates to the previous
  // work-in-progress hook.
  var dispatch=queue.dispatch;var lastRenderPhaseUpdate=queue.pending;var newState=hook.memoizedState;if(lastRenderPhaseUpdate!==null){// The queue doesn't persist past this render pass.
  queue.pending=null;var firstRenderPhaseUpdate=lastRenderPhaseUpdate.next;var update=firstRenderPhaseUpdate;do{// Process this render phase update. We don't have to check the
  // priority because it will always be the same as the current
  // render's.
  var action=update.action;newState=reducer(newState,action);update=update.next;}while(update!==firstRenderPhaseUpdate);// Mark that the fiber performed work, but only if the new state is
  // different from the current state.
  if(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;// Don't persist the state accumulated from the render phase updates to
  // the base state unless the queue is empty.
  // TODO: Not sure if this is the desired semantics, but it's what we
  // do for gDSFP. I can't remember why.
  if(hook.baseQueue===null){hook.baseState=newState;}queue.lastRenderedState=newState;}return [newState,dispatch];}function mountState(initialState){var hook=mountWorkInProgressHook();if(typeof initialState==='function'){// $FlowFixMe: Flow doesn't like mixed types
  initialState=initialState();}hook.memoizedState=hook.baseState=initialState;var queue=hook.queue={pending:null,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};var dispatch=queue.dispatch=dispatchAction.bind(null,currentlyRenderingFiber$1,queue);return [hook.memoizedState,dispatch];}function updateState(initialState){return updateReducer(basicStateReducer);}function rerenderState(initialState){return rerenderReducer(basicStateReducer);}function pushEffect(tag,create,destroy,deps){var effect={tag:tag,create:create,destroy:destroy,deps:deps,// Circular
  next:null};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.lastEffect=effect.next=effect;}else {var lastEffect=componentUpdateQueue.lastEffect;if(lastEffect===null){componentUpdateQueue.lastEffect=effect.next=effect;}else {var firstEffect=lastEffect.next;lastEffect.next=effect;effect.next=firstEffect;componentUpdateQueue.lastEffect=effect;}}return effect;}function mountRef(initialValue){var hook=mountWorkInProgressHook();var ref={current:initialValue};{Object.seal(ref);}hook.memoizedState=ref;return ref;}function updateRef(initialValue){var hook=updateWorkInProgressHook();return hook.memoizedState;}function mountEffectImpl(fiberEffectTag,hookEffectTag,create,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;currentlyRenderingFiber$1.effectTag|=fiberEffectTag;hook.memoizedState=pushEffect(HasEffect|hookEffectTag,create,undefined,nextDeps);}function updateEffectImpl(fiberEffectTag,hookEffectTag,create,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var destroy=undefined;if(currentHook!==null){var prevEffect=currentHook.memoizedState;destroy=prevEffect.destroy;if(nextDeps!==null){var prevDeps=prevEffect.deps;if(areHookInputsEqual(nextDeps,prevDeps)){pushEffect(hookEffectTag,create,destroy,nextDeps);return;}}}currentlyRenderingFiber$1.effectTag|=fiberEffectTag;hook.memoizedState=pushEffect(HasEffect|hookEffectTag,create,destroy,nextDeps);}function mountEffect(create,deps){{// $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
  if('undefined'!==typeof jest){warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);}}return mountEffectImpl(Update|Passive,Passive$1,create,deps);}function updateEffect(create,deps){{// $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
  if('undefined'!==typeof jest){warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);}}return updateEffectImpl(Update|Passive,Passive$1,create,deps);}function mountLayoutEffect(create,deps){return mountEffectImpl(Update,Layout,create,deps);}function updateLayoutEffect(create,deps){return updateEffectImpl(Update,Layout,create,deps);}function imperativeHandleEffect(create,ref){if(typeof ref==='function'){var refCallback=ref;var _inst=create();refCallback(_inst);return function(){refCallback(null);};}else if(ref!==null&&ref!==undefined){var refObject=ref;{if(!refObject.hasOwnProperty('current')){error('Expected useImperativeHandle() first argument to either be a '+'ref callback or React.createRef() object. Instead received: %s.','an object with keys {'+Object.keys(refObject).join(', ')+'}');}}var _inst2=create();refObject.current=_inst2;return function(){refObject.current=null;};}}function mountImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create:'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?
  var effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return mountEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function updateImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create:'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?
  var effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return updateEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function mountDebugValue(value,formatterFn){// This hook is normally a no-op.
  // The react-debug-hooks package injects its own implementation
  // so that e.g. DevTools can display custom hook values.
  }var updateDebugValue=mountDebugValue;function mountCallback(callback,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;hook.memoizedState=[callback,nextDeps];return callback;}function updateCallback(callback,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}hook.memoizedState=[callback,nextDeps];return callback;}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){// Assume these are defined. If they're not, areHookInputsEqual will warn.
  if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function mountDeferredValue(value,config){var _mountState=mountState(value),prevValue=_mountState[0],setValue=_mountState[1];mountEffect(function(){var previousConfig=ReactCurrentBatchConfig$1.suspense;ReactCurrentBatchConfig$1.suspense=config===undefined?null:config;try{setValue(value);}finally{ReactCurrentBatchConfig$1.suspense=previousConfig;}},[value,config]);return prevValue;}function updateDeferredValue(value,config){var _updateState=updateState(),prevValue=_updateState[0],setValue=_updateState[1];updateEffect(function(){var previousConfig=ReactCurrentBatchConfig$1.suspense;ReactCurrentBatchConfig$1.suspense=config===undefined?null:config;try{setValue(value);}finally{ReactCurrentBatchConfig$1.suspense=previousConfig;}},[value,config]);return prevValue;}function rerenderDeferredValue(value,config){var _rerenderState=rerenderState(),prevValue=_rerenderState[0],setValue=_rerenderState[1];updateEffect(function(){var previousConfig=ReactCurrentBatchConfig$1.suspense;ReactCurrentBatchConfig$1.suspense=config===undefined?null:config;try{setValue(value);}finally{ReactCurrentBatchConfig$1.suspense=previousConfig;}},[value,config]);return prevValue;}function startTransition(setPending,config,callback){var priorityLevel=getCurrentPriorityLevel();runWithPriority$1(priorityLevel<UserBlockingPriority$1?UserBlockingPriority$1:priorityLevel,function(){setPending(true);});runWithPriority$1(priorityLevel>NormalPriority?NormalPriority:priorityLevel,function(){var previousConfig=ReactCurrentBatchConfig$1.suspense;ReactCurrentBatchConfig$1.suspense=config===undefined?null:config;try{setPending(false);callback();}finally{ReactCurrentBatchConfig$1.suspense=previousConfig;}});}function mountTransition(config){var _mountState2=mountState(false),isPending=_mountState2[0],setPending=_mountState2[1];var start=mountCallback(startTransition.bind(null,setPending,config),[setPending,config]);return [start,isPending];}function updateTransition(config){var _updateState2=updateState(),isPending=_updateState2[0],setPending=_updateState2[1];var start=updateCallback(startTransition.bind(null,setPending,config),[setPending,config]);return [start,isPending];}function rerenderTransition(config){var _rerenderState2=rerenderState(),isPending=_rerenderState2[0],setPending=_rerenderState2[1];var start=updateCallback(startTransition.bind(null,setPending,config),[setPending,config]);return [start,isPending];}function dispatchAction(fiber,queue,action){{if(typeof arguments[3]==='function'){error("State updates from the useState() and useReducer() Hooks don't support the "+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var currentTime=requestCurrentTimeForUpdate();var suspenseConfig=requestCurrentSuspenseConfig();var expirationTime=computeExpirationForFiber(currentTime,fiber,suspenseConfig);var update={expirationTime:expirationTime,suspenseConfig:suspenseConfig,action:action,eagerReducer:null,eagerState:null,next:null};{update.priority=getCurrentPriorityLevel();}// Append the update to the end of the list.
  var pending=queue.pending;if(pending===null){// This is the first update. Create a circular list.
  update.next=update;}else {update.next=pending.next;pending.next=update;}queue.pending=update;var alternate=fiber.alternate;if(fiber===currentlyRenderingFiber$1||alternate!==null&&alternate===currentlyRenderingFiber$1){// This is a render phase update. Stash it in a lazily-created map of
  // queue -> linked list of updates. After this render pass, we'll restart
  // and apply the stashed updates on top of the work-in-progress hook.
  didScheduleRenderPhaseUpdate=true;update.expirationTime=renderExpirationTime;currentlyRenderingFiber$1.expirationTime=renderExpirationTime;}else {if(fiber.expirationTime===NoWork&&(alternate===null||alternate.expirationTime===NoWork)){// The queue is currently empty, which means we can eagerly compute the
  // next state before entering the render phase. If the new state is the
  // same as the current state, we may be able to bail out entirely.
  var lastRenderedReducer=queue.lastRenderedReducer;if(lastRenderedReducer!==null){var prevDispatcher;{prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;}try{var currentState=queue.lastRenderedState;var eagerState=lastRenderedReducer(currentState,action);// Stash the eagerly computed state, and the reducer used to compute
  // it, on the update object. If the reducer hasn't changed by the
  // time we enter the render phase, then the eager state can be used
  // without calling the reducer again.
  update.eagerReducer=lastRenderedReducer;update.eagerState=eagerState;if(objectIs(eagerState,currentState)){// Fast path. We can bail out without scheduling React to re-render.
  // It's still possible that we'll need to rebase this update later,
  // if the component re-renders for a different reason and by that
  // time the reducer has changed.
  return;}}catch(error){// Suppress the error. It will throw again in the render phase.
  }finally{{ReactCurrentDispatcher.current=prevDispatcher;}}}}{// $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
  if('undefined'!==typeof jest){warnIfNotScopedWithMatchingAct(fiber);warnIfNotCurrentlyActingUpdatesInDev(fiber);}}scheduleWork(fiber,expirationTime);}}var ContextOnlyDispatcher={readContext:readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useResponder:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError};var HooksDispatcherOnMountInDEV=null;var HooksDispatcherOnMountWithHookTypesInDEV=null;var HooksDispatcherOnUpdateInDEV=null;var HooksDispatcherOnRerenderInDEV=null;var InvalidNestedHooksDispatcherOnMountInDEV=null;var InvalidNestedHooksDispatcherOnUpdateInDEV=null;var InvalidNestedHooksDispatcherOnRerenderInDEV=null;{var warnInvalidContextAccess=function(){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');};var warnInvalidHookAccess=function(){error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. '+'You can only call Hooks at the top level of your React function. '+'For more information, see '+'https://fb.me/rules-of-hooks');};HooksDispatcherOnMountInDEV={readContext:function(context,observedBits){return readContext(context,observedBits);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountCallback(callback,deps);},useContext:function(context,observedBits){currentHookNameInDev='useContext';mountHookTypesDev();return readContext(context,observedBits);},useEffect:function(create,deps){currentHookNameInDev='useEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountImperativeHandle(ref,create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';mountHookTypesDev();checkDepsAreArrayDev(deps);var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';mountHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';mountHookTypesDev();return mountDebugValue();},useResponder:function(responder,props){currentHookNameInDev='useResponder';mountHookTypesDev();return createDeprecatedResponderListener(responder,props);},useDeferredValue:function(value,config){currentHookNameInDev='useDeferredValue';mountHookTypesDev();return mountDeferredValue(value,config);},useTransition:function(config){currentHookNameInDev='useTransition';mountHookTypesDev();return mountTransition(config);}};HooksDispatcherOnMountWithHookTypesInDEV={readContext:function(context,observedBits){return readContext(context,observedBits);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return mountCallback(callback,deps);},useContext:function(context,observedBits){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context,observedBits);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return mountImperativeHandle(ref,create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return mountDebugValue();},useResponder:function(responder,props){currentHookNameInDev='useResponder';updateHookTypesDev();return createDeprecatedResponderListener(responder,props);},useDeferredValue:function(value,config){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return mountDeferredValue(value,config);},useTransition:function(config){currentHookNameInDev='useTransition';updateHookTypesDev();return mountTransition(config);}};HooksDispatcherOnUpdateInDEV={readContext:function(context,observedBits){return readContext(context,observedBits);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context,observedBits){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context,observedBits);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useResponder:function(responder,props){currentHookNameInDev='useResponder';updateHookTypesDev();return createDeprecatedResponderListener(responder,props);},useDeferredValue:function(value,config){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return updateDeferredValue(value,config);},useTransition:function(config){currentHookNameInDev='useTransition';updateHookTypesDev();return updateTransition(config);}};HooksDispatcherOnRerenderInDEV={readContext:function(context,observedBits){return readContext(context,observedBits);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context,observedBits){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context,observedBits);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useResponder:function(responder,props){currentHookNameInDev='useResponder';updateHookTypesDev();return createDeprecatedResponderListener(responder,props);},useDeferredValue:function(value,config){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return rerenderDeferredValue(value,config);},useTransition:function(config){currentHookNameInDev='useTransition';updateHookTypesDev();return rerenderTransition(config);}};InvalidNestedHooksDispatcherOnMountInDEV={readContext:function(context,observedBits){warnInvalidContextAccess();return readContext(context,observedBits);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();mountHookTypesDev();return mountCallback(callback,deps);},useContext:function(context,observedBits){currentHookNameInDev='useContext';warnInvalidHookAccess();mountHookTypesDev();return readContext(context,observedBits);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();mountHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();mountHookTypesDev();return mountImperativeHandle(ref,create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();mountHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();mountHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();mountHookTypesDev();return mountDebugValue();},useResponder:function(responder,props){currentHookNameInDev='useResponder';warnInvalidHookAccess();mountHookTypesDev();return createDeprecatedResponderListener(responder,props);},useDeferredValue:function(value,config){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();mountHookTypesDev();return mountDeferredValue(value,config);},useTransition:function(config){currentHookNameInDev='useTransition';warnInvalidHookAccess();mountHookTypesDev();return mountTransition(config);}};InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function(context,observedBits){warnInvalidContextAccess();return readContext(context,observedBits);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context,observedBits){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return readContext(context,observedBits);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useResponder:function(responder,props){currentHookNameInDev='useResponder';warnInvalidHookAccess();updateHookTypesDev();return createDeprecatedResponderListener(responder,props);},useDeferredValue:function(value,config){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return updateDeferredValue(value,config);},useTransition:function(config){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return updateTransition(config);}};InvalidNestedHooksDispatcherOnRerenderInDEV={readContext:function(context,observedBits){warnInvalidContextAccess();return readContext(context,observedBits);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context,observedBits){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return readContext(context,observedBits);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useResponder:function(responder,props){currentHookNameInDev='useResponder';warnInvalidHookAccess();updateHookTypesDev();return createDeprecatedResponderListener(responder,props);},useDeferredValue:function(value,config){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return rerenderDeferredValue(value,config);},useTransition:function(config){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return rerenderTransition(config);}};}var now$1=Scheduler.unstable_now;var commitTime=0;var profilerStartTime=-1;function getCommitTime(){return commitTime;}function recordCommitTime(){commitTime=now$1();}function startProfilerTimer(fiber){profilerStartTime=now$1();if(fiber.actualStartTime<0){fiber.actualStartTime=now$1();}}function stopProfilerTimerIfRunning(fiber){profilerStartTime=-1;}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(profilerStartTime>=0){var elapsedTime=now$1()-profilerStartTime;fiber.actualDuration+=elapsedTime;if(overrideBaseTime){fiber.selfBaseDuration=elapsedTime;}profilerStartTime=-1;}}// This may have been an insertion or a hydration.
  var hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChild(parentInstance);hydrationParentFiber=fiber;isHydrating=true;return true;}function deleteHydratableInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo,instance);break;case HostComponent:didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance);break;}}var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete.return=returnFiber;childToDelete.effectTag=Deletion;// This might seem like it belongs on progressedFirstDeletion. However,
  // these children are not part of the reconciliation list of children.
  // Even if we abort and rereconcile the children, that will try to hydrate
  // again and the nodes are still in the host tree so these will be
  // recreated.
  if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else {returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}}function insertNonHydratedInstance(returnFiber,fiber){fiber.effectTag=fiber.effectTag&~Hydrating|Placement;{switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;fiber.pendingProps;didNotFindHydratableContainerInstance(parentContainer,type);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableContainerTextInstance(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:var _type=fiber.type;fiber.pendingProps;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type);break;case HostText:var _text=fiber.pendingProps;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text);break;case SuspenseComponent:didNotFindHydratableSuspenseInstance(parentType,parentProps);break;}break;}default:return;}}}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type);if(instance!==null){fiber.stateNode=instance;return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;return true;}return false;}case SuspenseComponent:{return false;}default:return false;}}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){// Nothing to hydrate. Make it an insertion.
  insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){// If we can't hydrate this instance let's try the next one.
  // We use this as a heuristic. It's based on intuition and not data so it
  // might be flawed or unnecessary.
  nextInstance=getNextHydratableSibling(firstAttemptedInstance);if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.
  insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was
  // superfluous and we'll delete it. Since we can't eagerly delete it
  // we'll have to schedule a deletion. To do that, this node needs a dummy
  // fiber associated with it.
  deleteHydratableInstance(hydrationParentFiber,firstAttemptedInstance);}hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(nextInstance);}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber);// TODO: Type this specific to this type of component.
  fiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
  // is a new ref we mark this as an update.
  if(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);{if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the
  // hydration parent is the parent host component of this host text.
  var returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent);break;}}}}}return shouldUpdate;}function skipPastDehydratedSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){{throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");}}return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);}function popToNextHostParent(fiber){var parent=fiber.return;while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot&&parent.tag!==SuspenseComponent){parent=parent.return;}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted
  // tree.
  return false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then
  // we were an insertion and now need to pop up reenter hydration of our
  // siblings.
  popToNextHostParent(fiber);isHydrating=true;return false;}var type=fiber.type;// If we have any remaining hydratable nodes, we need to delete them now.
  // We only do this deeper than head and body since they tend to have random
  // other nodes in them. We also ignore components with pure text content in
  // side of them.
  // TODO: Better heuristic.
  if(fiber.tag!==HostComponent||type!=='head'&&type!=='body'&&!shouldSetTextContent(type,fiber.memoizedProps)){var nextInstance=nextHydratableInstance;while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}popToNextHostParent(fiber);if(fiber.tag===SuspenseComponent){nextHydratableInstance=skipPastDehydratedSuspenseInstance(fiber);}else {nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;}return true;}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner;var didReceiveUpdate=false;var didWarnAboutBadClass;var didWarnAboutModulePatternComponent;var didWarnAboutContextTypeOnFunctionComponent;var didWarnAboutGetDerivedStateOnFunctionComponent;var didWarnAboutFunctionRefs;var didWarnAboutReassigningProps;var didWarnAboutRevealOrder;var didWarnAboutTailOptions;{didWarnAboutBadClass={};didWarnAboutModulePatternComponent={};didWarnAboutContextTypeOnFunctionComponent={};didWarnAboutGetDerivedStateOnFunctionComponent={};didWarnAboutFunctionRefs={};didWarnAboutReassigningProps=false;didWarnAboutRevealOrder={};didWarnAboutTailOptions={};}function reconcileChildren(current,workInProgress,nextChildren,renderExpirationTime){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we
  // won't update its child set by applying minimal side-effects. Instead,
  // we will add them all to the child before it gets rendered. That means
  // we can optimize this reconciliation pass by not tracking side-effects.
  workInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}else {// If the current child is the same as the work in progress, it means that
  // we haven't yet started any work on these children. Therefore, we use
  // the clone algorithm to create a copy of all the current children.
  // If we had any progressed work already, that is invalid at this point so
  // let's throw it out.
  workInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderExpirationTime);}}function forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderExpirationTime){// This function is fork of reconcileChildren. It's used in cases where we
  // want to reconcile without matching against the existing set. This has the
  // effect of all current children being unmounted; even if the type and key
  // are the same, the old child is unmounted and a new child is created.
  //
  // To do this, we're going to go through the reconcile algorithm twice. In
  // the first pass, we schedule a deletion for all the current children by
  // passing null.
  workInProgress.child=reconcileChildFibers(workInProgress,current.child,null,renderExpirationTime);// In the second pass, we mount the new children. The trick here is that we
  // pass null in place of where we usually pass the current child set. This has
  // the effect of remounting all children regardless of whether their
  // identities match.
  workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}function updateForwardRef(current,workInProgress,Component,nextProps,renderExpirationTime){// TODO: current can be non-null here even if the component
  // hasn't yet mounted. This happens after the first render suspends.
  // We'll need to figure out if this is fine or can cause issues.
  {if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
  // because they're only guaranteed to be resolved here.
  var innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props
  'prop',getComponentName(Component),getCurrentFiberStackInDev);}}}var render=Component.render;var ref=workInProgress.ref;// The rest is a fork of updateFunctionComponent
  var nextChildren;prepareToReadContext(workInProgress,renderExpirationTime);{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderExpirationTime);if(workInProgress.mode&StrictMode){// Only double-render components with Hooks
  if(workInProgress.memoizedState!==null){nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderExpirationTime);}}setIsRendering(false);}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderExpirationTime);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderExpirationTime);}// React DevTools reads this flag.
  workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderExpirationTime);return workInProgress.child;}function updateMemoComponent(current,workInProgress,Component,nextProps,updateExpirationTime,renderExpirationTime){if(current===null){var type=Component.type;if(isSimpleFunctionComponent(type)&&Component.compare===null&&// SimpleMemoComponent codepath doesn't resolve outer props either.
  Component.defaultProps===undefined){var resolvedType=type;{resolvedType=resolveFunctionForHotReloading(type);}// If this is a plain function component without default props,
  // and with only the default shallow comparison, we upgrade it
  // to a SimpleMemoComponent to allow fast path updates.
  workInProgress.tag=SimpleMemoComponent;workInProgress.type=resolvedType;{validateFunctionComponentInDev(workInProgress,type);}return updateSimpleMemoComponent(current,workInProgress,resolvedType,nextProps,updateExpirationTime,renderExpirationTime);}{var innerPropTypes=type.propTypes;if(innerPropTypes){// Inner memo component props aren't currently validated in createElement.
  // We could move it there, but we'd still need this for lazy code path.
  checkPropTypes(innerPropTypes,nextProps,// Resolved props
  'prop',getComponentName(type),getCurrentFiberStackInDev);}}var child=createFiberFromTypeAndProps(Component.type,null,nextProps,null,workInProgress.mode,renderExpirationTime);child.ref=workInProgress.ref;child.return=workInProgress;workInProgress.child=child;return child;}{var _type=Component.type;var _innerPropTypes=_type.propTypes;if(_innerPropTypes){// Inner memo component props aren't currently validated in createElement.
  // We could move it there, but we'd still need this for lazy code path.
  checkPropTypes(_innerPropTypes,nextProps,// Resolved props
  'prop',getComponentName(_type),getCurrentFiberStackInDev);}}var currentChild=current.child;// This is always exactly one child
  if(updateExpirationTime<renderExpirationTime){// This will be the props with resolved defaultProps,
  // unlike current.memoizedProps which will be the unresolved ones.
  var prevProps=currentChild.memoizedProps;// Default to shallow comparison
  var compare=Component.compare;compare=compare!==null?compare:shallowEqual;if(compare(prevProps,nextProps)&&current.ref===workInProgress.ref){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderExpirationTime);}}// React DevTools reads this flag.
  workInProgress.effectTag|=PerformedWork;var newChild=createWorkInProgress(currentChild,nextProps);newChild.ref=workInProgress.ref;newChild.return=workInProgress;workInProgress.child=newChild;return newChild;}function updateSimpleMemoComponent(current,workInProgress,Component,nextProps,updateExpirationTime,renderExpirationTime){// TODO: current can be non-null here even if the component
  // hasn't yet mounted. This happens when the inner render suspends.
  // We'll need to figure out if this is fine or can cause issues.
  {if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
  // because they're only guaranteed to be resolved here.
  var outerMemoType=workInProgress.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){// We warn when you define propTypes on lazy()
  // so let's just skip over it to find memo() outer wrapper.
  // Inner props for memo are validated later.
  outerMemoType=refineResolvedLazyComponent(outerMemoType);}var outerPropTypes=outerMemoType&&outerMemoType.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,nextProps,// Resolved (SimpleMemoComponent has no defaultProps)
  'prop',getComponentName(outerMemoType),getCurrentFiberStackInDev);}// Inner propTypes will be validated in the function component path.
  }}if(current!==null){var prevProps=current.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current.ref===workInProgress.ref&&// Prevent bailout if the implementation changed due to hot reload.
  workInProgress.type===current.type){didReceiveUpdate=false;if(updateExpirationTime<renderExpirationTime){// The pending update priority was cleared at the beginning of
  // beginWork. We're about to bail out, but there might be additional
  // updates at a lower priority. Usually, the priority level of the
  // remaining updates is accumlated during the evaluation of the
  // component (i.e. when processing the update queue). But since since
  // we're bailing out early *without* evaluating the component, we need
  // to account for it here, too. Reset to the value of the current fiber.
  // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,
  // because a MemoComponent fiber does not have hooks or an update queue;
  // rather, it wraps around an inner component, which may or may not
  // contains hooks.
  // TODO: Move the reset at in beginWork out of the common path so that
  // this is no longer necessary.
  workInProgress.expirationTime=current.expirationTime;return bailoutOnAlreadyFinishedWork(current,workInProgress,renderExpirationTime);}}}return updateFunctionComponent(current,workInProgress,Component,nextProps,renderExpirationTime);}function updateFragment(current,workInProgress,renderExpirationTime){var nextChildren=workInProgress.pendingProps;reconcileChildren(current,workInProgress,nextChildren,renderExpirationTime);return workInProgress.child;}function updateMode(current,workInProgress,renderExpirationTime){var nextChildren=workInProgress.pendingProps.children;reconcileChildren(current,workInProgress,nextChildren,renderExpirationTime);return workInProgress.child;}function updateProfiler(current,workInProgress,renderExpirationTime){{workInProgress.effectTag|=Update;}var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;reconcileChildren(current,workInProgress,nextChildren,renderExpirationTime);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(current===null&&ref!==null||current!==null&&current.ref!==ref){// Schedule a Ref effect
  workInProgress.effectTag|=Ref;}}function updateFunctionComponent(current,workInProgress,Component,nextProps,renderExpirationTime){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
  // because they're only guaranteed to be resolved here.
  var innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props
  'prop',getComponentName(Component),getCurrentFiberStackInDev);}}}var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,true);context=getMaskedContext(workInProgress,unmaskedContext);}var nextChildren;prepareToReadContext(workInProgress,renderExpirationTime);{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderExpirationTime);if(workInProgress.mode&StrictMode){// Only double-render components with Hooks
  if(workInProgress.memoizedState!==null){nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderExpirationTime);}}setIsRendering(false);}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderExpirationTime);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderExpirationTime);}// React DevTools reads this flag.
  workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderExpirationTime);return workInProgress.child;}function updateClassComponent(current,workInProgress,Component,nextProps,renderExpirationTime){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
  // because they're only guaranteed to be resolved here.
  var innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props
  'prop',getComponentName(Component),getCurrentFiberStackInDev);}}}// Push context providers early to prevent context stack mismatches.
  // During mounting we don't know the child context yet as the instance doesn't exist.
  // We will invalidate the child context in finishClassComponent() right after rendering.
  var hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else {hasContext=false;}prepareToReadContext(workInProgress,renderExpirationTime);var instance=workInProgress.stateNode;var shouldUpdate;if(instance===null){if(current!==null){// A class component without an instance only mounts if it suspended
  // inside a non-concurrent tree, in an inconsistent state. We want to
  // treat it like a new mount, even though an empty version of it already
  // committed. Disconnect the alternate pointers.
  current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
  workInProgress.effectTag|=Placement;}// In the initial pass we might need to construct the instance.
  constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderExpirationTime);shouldUpdate=true;}else if(current===null){// In a resume, we'll already have an instance we can reuse.
  shouldUpdate=resumeMountClassInstance(workInProgress,Component,nextProps,renderExpirationTime);}else {shouldUpdate=updateClassInstance(current,workInProgress,Component,nextProps,renderExpirationTime);}var nextUnitOfWork=finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderExpirationTime);{var inst=workInProgress.stateNode;if(inst.props!==nextProps){if(!didWarnAboutReassigningProps){error('It looks like %s is reassigning its own `this.props` while rendering. '+'This is not supported and can lead to confusing bugs.',getComponentName(workInProgress.type)||'a component');}didWarnAboutReassigningProps=true;}}return nextUnitOfWork;}function finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderExpirationTime){// Refs should update even if shouldComponentUpdate returns false
  markRef(current,workInProgress);var didCaptureError=(workInProgress.effectTag&DidCapture)!==NoEffect;if(!shouldUpdate&&!didCaptureError){// Context providers should defer to sCU for rendering
  if(hasContext){invalidateContextProvider(workInProgress,Component,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderExpirationTime);}var instance=workInProgress.stateNode;// Rerender
  ReactCurrentOwner$1.current=workInProgress;var nextChildren;if(didCaptureError&&typeof Component.getDerivedStateFromError!=='function'){// If we captured an error, but getDerivedStateFromError is not defined,
  // unmount all the children. componentDidCatch will schedule an update to
  // re-render a fallback. This is temporary until we migrate everyone to
  // the new API.
  // TODO: Warn in a future release.
  nextChildren=null;{stopProfilerTimerIfRunning();}}else {{setIsRendering(true);nextChildren=instance.render();if(workInProgress.mode&StrictMode){instance.render();}setIsRendering(false);}}// React DevTools reads this flag.
  workInProgress.effectTag|=PerformedWork;if(current!==null&&didCaptureError){// If we're recovering from an error, reconcile without reusing any of
  // the existing children. Conceptually, the normal children and the children
  // that are shown on error are two different sets, so we shouldn't reuse
  // normal children even if their identities match.
  forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderExpirationTime);}else {reconcileChildren(current,workInProgress,nextChildren,renderExpirationTime);}// Memoize state using the values we just used to render.
  // TODO: Restructure so we never read values from the instance.
  workInProgress.memoizedState=instance.state;// The context might have changed so we need to recalculate it.
  if(hasContext){invalidateContextProvider(workInProgress,Component,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set
  pushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderExpirationTime){pushHostRootContext(workInProgress);var updateQueue=workInProgress.updateQueue;if(!(current!==null&&updateQueue!==null)){{throw Error("If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.");}}var nextProps=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;var prevChildren=prevState!==null?prevState.element:null;cloneUpdateQueue(current,workInProgress);processUpdateQueue(workInProgress,nextProps,null,renderExpirationTime);var nextState=workInProgress.memoizedState;// Caution: React DevTools currently depends on this property
  // being called "element".
  var nextChildren=nextState.element;if(nextChildren===prevChildren){// If the state is the same as before, that's a bailout because we had
  // no work that expires at this time.
  resetHydrationState();return bailoutOnAlreadyFinishedWork(current,workInProgress,renderExpirationTime);}var root=workInProgress.stateNode;if(root.hydrate&&enterHydrationState(workInProgress)){// If we don't have any current children this might be the first pass.
  // We always try to hydrate. If this isn't a hydration pass there won't
  // be any children to hydrate which is effectively the same thing as
  // not hydrating.
  var child=mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime);workInProgress.child=child;var node=child;while(node){// Mark each child as hydrating. This is a fast path to know whether this
  // tree is part of a hydrating tree. This is used to determine if a child
  // node has fully mounted yet, and for scheduling event replaying.
  // Conceptually this is similar to Placement in that a new subtree is
  // inserted into the React tree here. It just happens to not need DOM
  // mutations because it already exists.
  node.effectTag=node.effectTag&~Placement|Hydrating;node=node.sibling;}}else {// Otherwise reset hydration state in case we aborted and resumed another
  // root.
  reconcileChildren(current,workInProgress,nextChildren,renderExpirationTime);resetHydrationState();}return workInProgress.child;}function updateHostComponent(current,workInProgress,renderExpirationTime){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var nextProps=workInProgress.pendingProps;var prevProps=current!==null?current.memoizedProps:null;var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common
  // case. We won't handle it as a reified child. We will instead handle
  // this in the host environment that also has access to this prop. That
  // avoids allocating another HostText fiber and traversing it.
  nextChildren=null;}else if(prevProps!==null&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to
  // empty, we need to schedule the text content to be reset.
  workInProgress.effectTag|=ContentReset;}markRef(current,workInProgress);// Check the host config to see if the children are offscreen/hidden.
  if(workInProgress.mode&ConcurrentMode&&renderExpirationTime!==Never&&shouldDeprioritizeSubtree(type,nextProps)){{markSpawnedWork(Never);}// Schedule this fiber to re-render at offscreen priority. Then bailout.
  workInProgress.expirationTime=workInProgress.childExpirationTime=Never;return null;}reconcileChildren(current,workInProgress,nextChildren,renderExpirationTime);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}// Nothing to do here. This is terminal. We'll do the completion step
  // immediately after.
  return null;}function mountLazyComponent(_current,workInProgress,elementType,updateExpirationTime,renderExpirationTime){if(_current!==null){// A lazy component only mounts if it suspended inside a non-
  // concurrent tree, in an inconsistent state. We want to treat it like
  // a new mount, even though an empty version of it already committed.
  // Disconnect the alternate pointers.
  _current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
  workInProgress.effectTag|=Placement;}var props=workInProgress.pendingProps;// We can't start a User Timing measurement with correct label yet.
  // Cancel and resume right after we know the tag.
  cancelWorkTimer(workInProgress);var Component=readLazyComponentType(elementType);// Store the unwrapped component in the type.
  workInProgress.type=Component;var resolvedTag=workInProgress.tag=resolveLazyComponentTag(Component);startWorkTimer(workInProgress);var resolvedProps=resolveDefaultProps(Component,props);var child;switch(resolvedTag){case FunctionComponent:{{validateFunctionComponentInDev(workInProgress,Component);workInProgress.type=Component=resolveFunctionForHotReloading(Component);}child=updateFunctionComponent(null,workInProgress,Component,resolvedProps,renderExpirationTime);return child;}case ClassComponent:{{workInProgress.type=Component=resolveClassForHotReloading(Component);}child=updateClassComponent(null,workInProgress,Component,resolvedProps,renderExpirationTime);return child;}case ForwardRef:{{workInProgress.type=Component=resolveForwardRefForHotReloading(Component);}child=updateForwardRef(null,workInProgress,Component,resolvedProps,renderExpirationTime);return child;}case MemoComponent:{{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=Component.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,resolvedProps,// Resolved for outer only
  'prop',getComponentName(Component),getCurrentFiberStackInDev);}}}child=updateMemoComponent(null,workInProgress,Component,resolveDefaultProps(Component.type,resolvedProps),// The inner type can have defaults too
  updateExpirationTime,renderExpirationTime);return child;}}var hint='';{if(Component!==null&&typeof Component==='object'&&Component.$$typeof===REACT_LAZY_TYPE){hint=' Did you wrap a component in React.lazy() more than once?';}}// This message intentionally doesn't mention ForwardRef or MemoComponent
  // because the fact that it's a separate type of work is an
  // implementation detail.
  {{throw Error("Element type is invalid. Received a promise that resolves to: "+Component+". Lazy element type must resolve to a class or function."+hint);}}}function mountIncompleteClassComponent(_current,workInProgress,Component,nextProps,renderExpirationTime){if(_current!==null){// An incomplete component only mounts if it suspended inside a non-
  // concurrent tree, in an inconsistent state. We want to treat it like
  // a new mount, even though an empty version of it already committed.
  // Disconnect the alternate pointers.
  _current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
  workInProgress.effectTag|=Placement;}// Promote the fiber to a class and try rendering again.
  workInProgress.tag=ClassComponent;// The rest of this function is a fork of `updateClassComponent`
  // Push context providers early to prevent context stack mismatches.
  // During mounting we don't know the child context yet as the instance doesn't exist.
  // We will invalidate the child context in finishClassComponent() right after rendering.
  var hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else {hasContext=false;}prepareToReadContext(workInProgress,renderExpirationTime);constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderExpirationTime);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderExpirationTime);}function mountIndeterminateComponent(_current,workInProgress,Component,renderExpirationTime){if(_current!==null){// An indeterminate component only mounts if it suspended inside a non-
  // concurrent tree, in an inconsistent state. We want to treat it like
  // a new mount, even though an empty version of it already committed.
  // Disconnect the alternate pointers.
  _current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
  workInProgress.effectTag|=Placement;}var props=workInProgress.pendingProps;var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,false);context=getMaskedContext(workInProgress,unmaskedContext);}prepareToReadContext(workInProgress,renderExpirationTime);var value;{if(Component.prototype&&typeof Component.prototype.render==='function'){var componentName=getComponentName(Component)||'Unknown';if(!didWarnAboutBadClass[componentName]){error("The <%s /> component appears to have a render method, but doesn't extend React.Component. "+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);didWarnAboutBadClass[componentName]=true;}}if(workInProgress.mode&StrictMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);}setIsRendering(true);ReactCurrentOwner$1.current=workInProgress;value=renderWithHooks(null,workInProgress,Component,props,context,renderExpirationTime);setIsRendering(false);}// React DevTools reads this flag.
  workInProgress.effectTag|=PerformedWork;if(typeof value==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){{var _componentName=getComponentName(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+"If you can't use a class try assigning the prototype on the function as a workaround. "+"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it "+'cannot be called with `new` by React.',_componentName,_componentName,_componentName);didWarnAboutModulePatternComponent[_componentName]=true;}}// Proceed under the assumption that this is a class instance
  workInProgress.tag=ClassComponent;// Throw out any hooks that were used.
  workInProgress.memoizedState=null;workInProgress.updateQueue=null;// Push context providers early to prevent context stack mismatches.
  // During mounting we don't know the child context yet as the instance doesn't exist.
  // We will invalidate the child context in finishClassComponent() right after rendering.
  var hasContext=false;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else {hasContext=false;}workInProgress.memoizedState=value.state!==null&&value.state!==undefined?value.state:null;initializeUpdateQueue(workInProgress);var getDerivedStateFromProps=Component.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,Component,getDerivedStateFromProps,props);}adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,Component,props,renderExpirationTime);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderExpirationTime);}else {// Proceed under the assumption that this is a function component
  workInProgress.tag=FunctionComponent;{if(workInProgress.mode&StrictMode){// Only double-render components with Hooks
  if(workInProgress.memoizedState!==null){value=renderWithHooks(null,workInProgress,Component,props,context,renderExpirationTime);}}}reconcileChildren(null,workInProgress,value,renderExpirationTime);{validateFunctionComponentInDev(workInProgress,Component);}return workInProgress.child;}}function validateFunctionComponentInDev(workInProgress,Component){{if(Component){if(Component.childContextTypes){error('%s(...): childContextTypes cannot be defined on a function component.',Component.displayName||Component.name||'Component');}}if(workInProgress.ref!==null){var info='';var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||workInProgress._debugID||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!didWarnAboutFunctionRefs[warningKey]){didWarnAboutFunctionRefs[warningKey]=true;error('Function components cannot be given refs. '+'Attempts to access this ref will fail. '+'Did you mean to use React.forwardRef()?%s',info);}}if(typeof Component.getDerivedStateFromProps==='function'){var _componentName2=getComponentName(Component)||'Unknown';if(!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2]){error('%s: Function components do not support getDerivedStateFromProps.',_componentName2);didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2]=true;}}if(typeof Component.contextType==='object'&&Component.contextType!==null){var _componentName3=getComponentName(Component)||'Unknown';if(!didWarnAboutContextTypeOnFunctionComponent[_componentName3]){error('%s: Function components do not support contextType.',_componentName3);didWarnAboutContextTypeOnFunctionComponent[_componentName3]=true;}}}}var SUSPENDED_MARKER={dehydrated:null,retryTime:NoWork};function shouldRemainOnFallback(suspenseContext,current,workInProgress){// If the context is telling us that we should show a fallback, and we're not
  // already showing content, then we should show the fallback instead.
  return hasSuspenseContext(suspenseContext,ForceSuspenseFallback)&&(current===null||current.memoizedState!==null);}function updateSuspenseComponent(current,workInProgress,renderExpirationTime){var mode=workInProgress.mode;var nextProps=workInProgress.pendingProps;// This is used by DevTools to force a boundary to suspend.
  {if(shouldSuspend(workInProgress)){workInProgress.effectTag|=DidCapture;}}var suspenseContext=suspenseStackCursor.current;var nextDidTimeout=false;var didSuspend=(workInProgress.effectTag&DidCapture)!==NoEffect;if(didSuspend||shouldRemainOnFallback(suspenseContext,current)){// Something in this boundary's subtree already suspended. Switch to
  // rendering the fallback children.
  nextDidTimeout=true;workInProgress.effectTag&=~DidCapture;}else {// Attempting the main content
  if(current===null||current.memoizedState!==null){// This is a new mount or this boundary is already showing a fallback state.
  // Mark this subtree context as having at least one invisible parent that could
  // handle the fallback state.
  // Boundaries without fallbacks or should be avoided are not considered since
  // they cannot handle preferred fallback states.
  if(nextProps.fallback!==undefined&&nextProps.unstable_avoidThisFallback!==true){suspenseContext=addSubtreeSuspenseContext(suspenseContext,InvisibleParentSuspenseContext);}}}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);pushSuspenseContext(workInProgress,suspenseContext);// This next part is a bit confusing. If the children timeout, we switch to
  // showing the fallback children in place of the "primary" children.
  // However, we don't want to delete the primary children because then their
  // state will be lost (both the React state and the host state, e.g.
  // uncontrolled form inputs). Instead we keep them mounted and hide them.
  // Both the fallback children AND the primary children are rendered at the
  // same time. Once the primary children are un-suspended, we can delete
  // the fallback children — don't need to preserve their state.
  //
  // The two sets of children are siblings in the host environment, but
  // semantically, for purposes of reconciliation, they are two separate sets.
  // So we store them using two fragment fibers.
  //
  // However, we want to avoid allocating extra fibers for every placeholder.
  // They're only necessary when the children time out, because that's the
  // only time when both sets are mounted.
  //
  // So, the extra fragment fibers are only used if the children time out.
  // Otherwise, we render the primary children directly. This requires some
  // custom reconciliation logic to preserve the state of the primary
  // children. It's essentially a very basic form of re-parenting.
  if(current===null){// If we're currently hydrating, try to hydrate this boundary.
  // But only if this has a fallback.
  if(nextProps.fallback!==undefined){tryToClaimNextHydratableInstance(workInProgress);// This could've been a dehydrated suspense component.
  }// This is the initial mount. This branch is pretty simple because there's
  // no previous state that needs to be preserved.
  if(nextDidTimeout){// Mount separate fragments for primary and fallback children.
  var nextFallbackChildren=nextProps.fallback;var primaryChildFragment=createFiberFromFragment(null,mode,NoWork,null);primaryChildFragment.return=workInProgress;if((workInProgress.mode&BlockingMode)===NoMode){// Outside of blocking mode, we commit the effects from the
  // partially completed, timed-out tree, too.
  var progressedState=workInProgress.memoizedState;var progressedPrimaryChild=progressedState!==null?workInProgress.child.child:workInProgress.child;primaryChildFragment.child=progressedPrimaryChild;var progressedChild=progressedPrimaryChild;while(progressedChild!==null){progressedChild.return=primaryChildFragment;progressedChild=progressedChild.sibling;}}var fallbackChildFragment=createFiberFromFragment(nextFallbackChildren,mode,renderExpirationTime,null);fallbackChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;// Skip the primary children, and continue working on the
  // fallback children.
  workInProgress.memoizedState=SUSPENDED_MARKER;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}else {// Mount the primary children without an intermediate fragment fiber.
  var nextPrimaryChildren=nextProps.children;workInProgress.memoizedState=null;return workInProgress.child=mountChildFibers(workInProgress,null,nextPrimaryChildren,renderExpirationTime);}}else {// This is an update. This branch is more complicated because we need to
  // ensure the state of the primary children is preserved.
  var prevState=current.memoizedState;if(prevState!==null){// wrapped in a fragment fiber.
  var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;if(nextDidTimeout){// Still timed out. Reuse the current primary children by cloning
  // its fragment. We're going to skip over these entirely.
  var _nextFallbackChildren2=nextProps.fallback;var _primaryChildFragment2=createWorkInProgress(currentPrimaryChildFragment,currentPrimaryChildFragment.pendingProps);_primaryChildFragment2.return=workInProgress;if((workInProgress.mode&BlockingMode)===NoMode){// Outside of blocking mode, we commit the effects from the
  // partially completed, timed-out tree, too.
  var _progressedState=workInProgress.memoizedState;var _progressedPrimaryChild=_progressedState!==null?workInProgress.child.child:workInProgress.child;if(_progressedPrimaryChild!==currentPrimaryChildFragment.child){_primaryChildFragment2.child=_progressedPrimaryChild;var _progressedChild2=_progressedPrimaryChild;while(_progressedChild2!==null){_progressedChild2.return=_primaryChildFragment2;_progressedChild2=_progressedChild2.sibling;}}}// Because primaryChildFragment is a new fiber that we're inserting as the
  // parent of a new tree, we need to set its treeBaseDuration.
  if(workInProgress.mode&ProfileMode){// treeBaseDuration is the sum of all the child tree base durations.
  var _treeBaseDuration=0;var _hiddenChild=_primaryChildFragment2.child;while(_hiddenChild!==null){_treeBaseDuration+=_hiddenChild.treeBaseDuration;_hiddenChild=_hiddenChild.sibling;}_primaryChildFragment2.treeBaseDuration=_treeBaseDuration;}// Clone the fallback child fragment, too. These we'll continue
  // working on.
  var _fallbackChildFragment2=createWorkInProgress(currentFallbackChildFragment,_nextFallbackChildren2);_fallbackChildFragment2.return=workInProgress;_primaryChildFragment2.sibling=_fallbackChildFragment2;_primaryChildFragment2.childExpirationTime=NoWork;// Skip the primary children, and continue working on the
  // fallback children.
  workInProgress.memoizedState=SUSPENDED_MARKER;workInProgress.child=_primaryChildFragment2;return _fallbackChildFragment2;}else {// No longer suspended. Switch back to showing the primary children,
  // and remove the intermediate fragment fiber.
  var _nextPrimaryChildren=nextProps.children;var currentPrimaryChild=currentPrimaryChildFragment.child;var primaryChild=reconcileChildFibers(workInProgress,currentPrimaryChild,_nextPrimaryChildren,renderExpirationTime);// If this render doesn't suspend, we need to delete the fallback
  // children. Wait until the complete phase, after we've confirmed the
  // fallback is no longer needed.
  // TODO: Would it be better to store the fallback fragment on
  // the stateNode?
  // Continue rendering the children, like we normally do.
  workInProgress.memoizedState=null;return workInProgress.child=primaryChild;}}else {// The current tree has not already timed out. That means the primary
  // children are not wrapped in a fragment fiber.
  var _currentPrimaryChild=current.child;if(nextDidTimeout){// Timed out. Wrap the children in a fragment fiber to keep them
  // separate from the fallback children.
  var _nextFallbackChildren3=nextProps.fallback;var _primaryChildFragment3=createFiberFromFragment(// It shouldn't matter what the pending props are because we aren't
  // going to render this fragment.
  null,mode,NoWork,null);_primaryChildFragment3.return=workInProgress;_primaryChildFragment3.child=_currentPrimaryChild;if(_currentPrimaryChild!==null){_currentPrimaryChild.return=_primaryChildFragment3;}// Even though we're creating a new fiber, there are no new children,
  // because we're reusing an already mounted tree. So we don't need to
  // schedule a placement.
  // primaryChildFragment.effectTag |= Placement;
  if((workInProgress.mode&BlockingMode)===NoMode){// Outside of blocking mode, we commit the effects from the
  // partially completed, timed-out tree, too.
  var _progressedState2=workInProgress.memoizedState;var _progressedPrimaryChild2=_progressedState2!==null?workInProgress.child.child:workInProgress.child;_primaryChildFragment3.child=_progressedPrimaryChild2;var _progressedChild3=_progressedPrimaryChild2;while(_progressedChild3!==null){_progressedChild3.return=_primaryChildFragment3;_progressedChild3=_progressedChild3.sibling;}}// Because primaryChildFragment is a new fiber that we're inserting as the
  // parent of a new tree, we need to set its treeBaseDuration.
  if(workInProgress.mode&ProfileMode){// treeBaseDuration is the sum of all the child tree base durations.
  var _treeBaseDuration2=0;var _hiddenChild2=_primaryChildFragment3.child;while(_hiddenChild2!==null){_treeBaseDuration2+=_hiddenChild2.treeBaseDuration;_hiddenChild2=_hiddenChild2.sibling;}_primaryChildFragment3.treeBaseDuration=_treeBaseDuration2;}// Create a fragment from the fallback children, too.
  var _fallbackChildFragment3=createFiberFromFragment(_nextFallbackChildren3,mode,renderExpirationTime,null);_fallbackChildFragment3.return=workInProgress;_primaryChildFragment3.sibling=_fallbackChildFragment3;_fallbackChildFragment3.effectTag|=Placement;_primaryChildFragment3.childExpirationTime=NoWork;// Skip the primary children, and continue working on the
  // fallback children.
  workInProgress.memoizedState=SUSPENDED_MARKER;workInProgress.child=_primaryChildFragment3;return _fallbackChildFragment3;}else {// Still haven't timed out. Continue rendering the children, like we
  // normally do.
  workInProgress.memoizedState=null;var _nextPrimaryChildren2=nextProps.children;return workInProgress.child=reconcileChildFibers(workInProgress,_currentPrimaryChild,_nextPrimaryChildren2,renderExpirationTime);}}}}function scheduleWorkOnFiber(fiber,renderExpirationTime){if(fiber.expirationTime<renderExpirationTime){fiber.expirationTime=renderExpirationTime;}var alternate=fiber.alternate;if(alternate!==null&&alternate.expirationTime<renderExpirationTime){alternate.expirationTime=renderExpirationTime;}scheduleWorkOnParentPath(fiber.return,renderExpirationTime);}function propagateSuspenseContextChange(workInProgress,firstChild,renderExpirationTime){// Mark any Suspense boundaries with fallbacks as having work to do.
  // If they were previously forced into fallbacks, they may now be able
  // to unblock.
  var node=firstChild;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){scheduleWorkOnFiber(node,renderExpirationTime);}}else if(node.tag===SuspenseListComponent){// If the tail is hidden there might not be an Suspense boundaries
  // to schedule work on. In this case we have to schedule it on the
  // list itself.
  // We don't have to traverse to the children of the list since
  // the list will propagate the change when it rerenders.
  scheduleWorkOnFiber(node,renderExpirationTime);}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function findLastContentRow(firstChild){// This is going to find the last row among these children that is already
  // showing content on the screen, as opposed to being in fallback state or
  // new. If a row has multiple Suspense boundaries, any of them being in the
  // fallback state, counts as the whole row being in a fallback state.
  // Note that the "rows" will be workInProgress, but any nested children
  // will still be current since we haven't rendered them yet. The mounted
  // order may not be the same as the new order. We use the new order.
  var row=firstChild;var lastContentRow=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.
  if(currentRow!==null&&findFirstSuspended(currentRow)===null){lastContentRow=row;}row=row.sibling;}return lastContentRow;}function validateRevealOrder(revealOrder){{if(revealOrder!==undefined&&revealOrder!=='forwards'&&revealOrder!=='backwards'&&revealOrder!=='together'&&!didWarnAboutRevealOrder[revealOrder]){didWarnAboutRevealOrder[revealOrder]=true;if(typeof revealOrder==='string'){switch(revealOrder.toLowerCase()){case'together':case'forwards':case'backwards':{error('"%s" is not a valid value for revealOrder on <SuspenseList />. '+'Use lowercase "%s" instead.',revealOrder,revealOrder.toLowerCase());break;}case'forward':case'backward':{error('"%s" is not a valid value for revealOrder on <SuspenseList />. '+'React uses the -s suffix in the spelling. Use "%ss" instead.',revealOrder,revealOrder.toLowerCase());break;}default:error('"%s" is not a supported revealOrder on <SuspenseList />. '+'Did you mean "together", "forwards" or "backwards"?',revealOrder);break;}}else {error('%s is not a supported value for revealOrder on <SuspenseList />. '+'Did you mean "together", "forwards" or "backwards"?',revealOrder);}}}}function validateTailOptions(tailMode,revealOrder){{if(tailMode!==undefined&&!didWarnAboutTailOptions[tailMode]){if(tailMode!=='collapsed'&&tailMode!=='hidden'){didWarnAboutTailOptions[tailMode]=true;error('"%s" is not a supported value for tail on <SuspenseList />. '+'Did you mean "collapsed" or "hidden"?',tailMode);}else if(revealOrder!=='forwards'&&revealOrder!=='backwards'){didWarnAboutTailOptions[tailMode]=true;error('<SuspenseList tail="%s" /> is only valid if revealOrder is '+'"forwards" or "backwards". '+'Did you mean to specify revealOrder="forwards"?',tailMode);}}}}function validateSuspenseListNestedChild(childSlot,index){{var isArray=Array.isArray(childSlot);var isIterable=!isArray&&typeof getIteratorFn(childSlot)==='function';if(isArray||isIterable){var type=isArray?'array':'iterable';error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in '+'an additional SuspenseList to configure its revealOrder: '+'<SuspenseList revealOrder=...> ... '+'<SuspenseList revealOrder=...>{%s}</SuspenseList> ... '+'</SuspenseList>',type,index,type);return false;}}return true;}function validateSuspenseListChildren(children,revealOrder){{if((revealOrder==='forwards'||revealOrder==='backwards')&&children!==undefined&&children!==null&&children!==false){if(Array.isArray(children)){for(var i=0;i<children.length;i++){if(!validateSuspenseListNestedChild(children[i],i)){return;}}}else {var iteratorFn=getIteratorFn(children);if(typeof iteratorFn==='function'){var childrenIterator=iteratorFn.call(children);if(childrenIterator){var step=childrenIterator.next();var _i=0;for(;!step.done;step=childrenIterator.next()){if(!validateSuspenseListNestedChild(step.value,_i)){return;}_i++;}}}else {error('A single row was passed to a <SuspenseList revealOrder="%s" />. '+'This is not useful since it needs multiple rows. '+'Did you mean to pass multiple children or an array?',revealOrder);}}}}}function initSuspenseListRenderState(workInProgress,isBackwards,tail,lastContentRow,tailMode,lastEffectBeforeRendering){var renderState=workInProgress.memoizedState;if(renderState===null){workInProgress.memoizedState={isBackwards:isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail:tail,tailExpiration:0,tailMode:tailMode,lastEffect:lastEffectBeforeRendering};}else {// We can reuse the existing object from previous renders.
  renderState.isBackwards=isBackwards;renderState.rendering=null;renderState.renderingStartTime=0;renderState.last=lastContentRow;renderState.tail=tail;renderState.tailExpiration=0;renderState.tailMode=tailMode;renderState.lastEffect=lastEffectBeforeRendering;}}// This can end up rendering this component multiple passes.
  // The first pass splits the children fibers into two sets. A head and tail.
  // We first render the head. If anything is in fallback state, we do another
  // pass through beginWork to rerender all children (including the tail) with
  // the force suspend context. If the first render didn't have anything in
  // in fallback state. Then we render each row in the tail one-by-one.
  // That happens in the completeWork phase without going back to beginWork.
  function updateSuspenseListComponent(current,workInProgress,renderExpirationTime){var nextProps=workInProgress.pendingProps;var revealOrder=nextProps.revealOrder;var tailMode=nextProps.tail;var newChildren=nextProps.children;validateRevealOrder(revealOrder);validateTailOptions(tailMode,revealOrder);validateSuspenseListChildren(newChildren,revealOrder);reconcileChildren(current,workInProgress,newChildren,renderExpirationTime);var suspenseContext=suspenseStackCursor.current;var shouldForceFallback=hasSuspenseContext(suspenseContext,ForceSuspenseFallback);if(shouldForceFallback){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);workInProgress.effectTag|=DidCapture;}else {var didSuspendBefore=current!==null&&(current.effectTag&DidCapture)!==NoEffect;if(didSuspendBefore){// If we previously forced a fallback, we need to schedule work
  // on any nested boundaries to let them know to try to render
  // again. This is the same as context updating.
  propagateSuspenseContextChange(workInProgress,workInProgress.child,renderExpirationTime);}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);if((workInProgress.mode&BlockingMode)===NoMode){// Outside of blocking mode, SuspenseList doesn't work so we just
  // use make it a noop by treating it as the default revealOrder.
  workInProgress.memoizedState=null;}else {switch(revealOrder){case'forwards':{var lastContentRow=findLastContentRow(workInProgress.child);var tail;if(lastContentRow===null){// The whole list is part of the tail.
  // TODO: We could fast path by just rendering the tail now.
  tail=workInProgress.child;workInProgress.child=null;}else {// Disconnect the tail rows after the content row.
  // We're going to render them separately later.
  tail=lastContentRow.sibling;lastContentRow.sibling=null;}initSuspenseListRenderState(workInProgress,false,// isBackwards
  tail,lastContentRow,tailMode,workInProgress.lastEffect);break;}case'backwards':{// We're going to find the first row that has existing content.
  // At the same time we're going to reverse the list of everything
  // we pass in the meantime. That's going to be our tail in reverse
  // order.
  var _tail=null;var row=workInProgress.child;workInProgress.child=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.
  if(currentRow!==null&&findFirstSuspended(currentRow)===null){// This is the beginning of the main content.
  workInProgress.child=row;break;}var nextRow=row.sibling;row.sibling=_tail;_tail=row;row=nextRow;}// TODO: If workInProgress.child is null, we can continue on the tail immediately.
  initSuspenseListRenderState(workInProgress,true,// isBackwards
  _tail,null,// last
  tailMode,workInProgress.lastEffect);break;}case'together':{initSuspenseListRenderState(workInProgress,false,// isBackwards
  null,// tail
  null,// last
  undefined,workInProgress.lastEffect);break;}default:{// The default reveal order is the same as not having
  // a boundary.
  workInProgress.memoizedState=null;}}}return workInProgress.child;}function updatePortalComponent(current,workInProgress,renderExpirationTime){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(current===null){// Portals are special because we don't append the children during mount
  // but at commit. Therefore we need to track insertions which the normal
  // flow doesn't do during mount. This doesn't happen at the root because
  // the root always starts with a "current" with a null child.
  // TODO: Consider unifying this with how the root works.
  workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}else {reconcileChildren(current,workInProgress,nextChildren,renderExpirationTime);}return workInProgress.child;}function updateContextProvider(current,workInProgress,renderExpirationTime){var providerType=workInProgress.type;var context=providerType._context;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var newValue=newProps.value;{var providerPropTypes=workInProgress.type.propTypes;if(providerPropTypes){checkPropTypes(providerPropTypes,newProps,'prop','Context.Provider',getCurrentFiberStackInDev);}}pushProvider(workInProgress,newValue);if(oldProps!==null){var oldValue=oldProps.value;var changedBits=calculateChangedBits(context,newValue,oldValue);if(changedBits===0){// No change. Bailout early if children are the same.
  if(oldProps.children===newProps.children&&!hasContextChanged()){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderExpirationTime);}}else {// The context value changed. Search for matching consumers and schedule
  // them to update.
  propagateContextChange(workInProgress,context,changedBits,renderExpirationTime);}}var newChildren=newProps.children;reconcileChildren(current,workInProgress,newChildren,renderExpirationTime);return workInProgress.child;}var hasWarnedAboutUsingContextAsConsumer=false;function updateContextConsumer(current,workInProgress,renderExpirationTime){var context=workInProgress.type;// The logic below for Context differs depending on PROD or DEV mode. In
  // DEV mode, we create a separate object for Context.Consumer that acts
  // like a proxy to Context. This proxy object adds unnecessary code in PROD
  // so we use the old behaviour (Context.Consumer references Context) to
  // reduce size and overhead. The separate object references context via
  // a property called "_context", which also gives us the ability to check
  // in DEV mode if this property exists or not and warn if it does not.
  {if(context._context===undefined){// This may be because it's a Context (rather than a Consumer).
  // Or it may be because it's older React where they're the same thing.
  // We only want to warn if we're sure it's a new React.
  if(context!==context.Consumer){if(!hasWarnedAboutUsingContextAsConsumer){hasWarnedAboutUsingContextAsConsumer=true;error('Rendering <Context> directly is not supported and will be removed in '+'a future major release. Did you mean to render <Context.Consumer> instead?');}}}else {context=context._context;}}var newProps=workInProgress.pendingProps;var render=newProps.children;{if(typeof render!=='function'){error('A context consumer was rendered with multiple children, or a child '+"that isn't a function. A context consumer expects a single child "+'that is a function. If you did pass a function, make sure there '+'is no trailing or leading whitespace around it.');}}prepareToReadContext(workInProgress,renderExpirationTime);var newValue=readContext(context,newProps.unstable_observedBits);var newChildren;{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);newChildren=render(newValue);setIsRendering(false);}// React DevTools reads this flag.
  workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,newChildren,renderExpirationTime);return workInProgress.child;}function markWorkInProgressReceivedUpdate(){didReceiveUpdate=true;}function bailoutOnAlreadyFinishedWork(current,workInProgress,renderExpirationTime){cancelWorkTimer(workInProgress);if(current!==null){// Reuse previous dependencies
  workInProgress.dependencies=current.dependencies;}{// Don't update "base" render times for bailouts.
  stopProfilerTimerIfRunning();}var updateExpirationTime=workInProgress.expirationTime;if(updateExpirationTime!==NoWork){markUnprocessedUpdateTime(updateExpirationTime);}// Check if the children have any pending work.
  var childExpirationTime=workInProgress.childExpirationTime;if(childExpirationTime<renderExpirationTime){// The children don't have any work either. We can skip them.
  // TODO: Once we add back resuming, we should check if the children are
  // a work-in-progress set. If so, we need to transfer their effects.
  return null;}else {// This fiber doesn't have work, but its subtree does. Clone the child
  // fibers and continue.
  cloneChildFibers(current,workInProgress);return workInProgress.child;}}function remountFiber(current,oldWorkInProgress,newWorkInProgress){{var returnFiber=oldWorkInProgress.return;if(returnFiber===null){throw new Error('Cannot swap the root fiber.');}// Disconnect from the old current.
  // It will get deleted.
  current.alternate=null;oldWorkInProgress.alternate=null;// Connect to the new tree.
  newWorkInProgress.index=oldWorkInProgress.index;newWorkInProgress.sibling=oldWorkInProgress.sibling;newWorkInProgress.return=oldWorkInProgress.return;newWorkInProgress.ref=oldWorkInProgress.ref;// Replace the child/sibling pointers above it.
  if(oldWorkInProgress===returnFiber.child){returnFiber.child=newWorkInProgress;}else {var prevSibling=returnFiber.child;if(prevSibling===null){throw new Error('Expected parent to have a child.');}while(prevSibling.sibling!==oldWorkInProgress){prevSibling=prevSibling.sibling;if(prevSibling===null){throw new Error('Expected to find the previous sibling.');}}prevSibling.sibling=newWorkInProgress;}// Delete the old fiber and place the new one.
  // Since the old fiber is disconnected, we have to schedule it manually.
  var last=returnFiber.lastEffect;if(last!==null){last.nextEffect=current;returnFiber.lastEffect=current;}else {returnFiber.firstEffect=returnFiber.lastEffect=current;}current.nextEffect=null;current.effectTag=Deletion;newWorkInProgress.effectTag|=Placement;// Restart work from the new fiber.
  return newWorkInProgress;}}function beginWork(current,workInProgress,renderExpirationTime){var updateExpirationTime=workInProgress.expirationTime;{if(workInProgress._debugNeedsRemount&&current!==null){// This will restart the begin phase with a new fiber.
  return remountFiber(current,workInProgress,createFiberFromTypeAndProps(workInProgress.type,workInProgress.key,workInProgress.pendingProps,workInProgress._debugOwner||null,workInProgress.mode,workInProgress.expirationTime));}}if(current!==null){var oldProps=current.memoizedProps;var newProps=workInProgress.pendingProps;if(oldProps!==newProps||hasContextChanged()||// Force a re-render if the implementation changed due to hot reload:
  workInProgress.type!==current.type){// If props or context changed, mark the fiber as having performed work.
  // This may be unset if the props are determined to be equal later (memo).
  didReceiveUpdate=true;}else if(updateExpirationTime<renderExpirationTime){didReceiveUpdate=false;// This fiber does not have any pending work. Bailout without entering
  // the begin phase. There's still some bookkeeping we that needs to be done
  // in this optimized path, mostly pushing stuff onto the stack.
  switch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);resetHydrationState();break;case HostComponent:pushHostContext(workInProgress);if(workInProgress.mode&ConcurrentMode&&renderExpirationTime!==Never&&shouldDeprioritizeSubtree(workInProgress.type,newProps)){{markSpawnedWork(Never);}// Schedule this fiber to re-render at offscreen priority. Then bailout.
  workInProgress.expirationTime=workInProgress.childExpirationTime=Never;return null;}break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){pushContextProvider(workInProgress);}break;}case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress.memoizedProps.value;pushProvider(workInProgress,newValue);break;}case Profiler:{// Profiler should only call onRender when one of its descendants actually rendered.
  var hasChildWork=workInProgress.childExpirationTime>=renderExpirationTime;if(hasChildWork){workInProgress.effectTag|=Update;}}break;case SuspenseComponent:{var state=workInProgress.memoizedState;if(state!==null){// whether to retry the primary children, or to skip over it and
  // go straight to the fallback. Check the priority of the primary
  // child fragment.
  var primaryChildFragment=workInProgress.child;var primaryChildExpirationTime=primaryChildFragment.childExpirationTime;if(primaryChildExpirationTime!==NoWork&&primaryChildExpirationTime>=renderExpirationTime){// The primary children have pending work. Use the normal path
  // to attempt to render the primary children again.
  return updateSuspenseComponent(current,workInProgress,renderExpirationTime);}else {pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// The primary children do not have pending work with sufficient
  // priority. Bailout.
  var child=bailoutOnAlreadyFinishedWork(current,workInProgress,renderExpirationTime);if(child!==null){// The fallback children have pending work. Skip over the
  // primary children and work on the fallback.
  return child.sibling;}else {return null;}}}else {pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));}break;}case SuspenseListComponent:{var didSuspendBefore=(current.effectTag&DidCapture)!==NoEffect;var _hasChildWork=workInProgress.childExpirationTime>=renderExpirationTime;if(didSuspendBefore){if(_hasChildWork){// If something was in fallback state last time, and we have all the
  // same children then we're still in progressive loading state.
  // Something might get unblocked by state updates or retries in the
  // tree which will affect the tail. So we need to use the normal
  // path to compute the correct tail.
  return updateSuspenseListComponent(current,workInProgress,renderExpirationTime);}// If none of the children had any work, that means that none of
  // them got retried so they'll still be blocked in the same way
  // as before. We can fast bail out.
  workInProgress.effectTag|=DidCapture;}// If nothing suspended before and we're rendering the same children,
  // then the tail doesn't matter. Anything new that suspends will work
  // in the "together" mode, so we can continue from the state we had.
  var renderState=workInProgress.memoizedState;if(renderState!==null){// Reset to the "together" mode in case we've started a different
  // update in the past but didn't complete it.
  renderState.rendering=null;renderState.tail=null;}pushSuspenseContext(workInProgress,suspenseStackCursor.current);if(_hasChildWork){break;}else {// If none of the children had any work, that means that none of
  // them got retried so they'll still be blocked in the same way
  // as before. We can fast bail out.
  return null;}}}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderExpirationTime);}else {// An update was scheduled on this fiber, but there are no new props
  // nor legacy context. Set this to false. If an update queue or context
  // consumer produces a changed value, it will set this to true. Otherwise,
  // the component will assume the children have not changed and bail out.
  didReceiveUpdate=false;}}else {didReceiveUpdate=false;}// Before entering the begin phase, clear pending update priority.
  // TODO: This assumes that we're about to evaluate the component and process
  // the update queue. However, there's an exception: SimpleMemoComponent
  // sometimes bails out later in the begin phase. This indicates that we should
  // move this assignment out of the common path and into each branch.
  workInProgress.expirationTime=NoWork;switch(workInProgress.tag){case IndeterminateComponent:{return mountIndeterminateComponent(current,workInProgress,workInProgress.type,renderExpirationTime);}case LazyComponent:{var elementType=workInProgress.elementType;return mountLazyComponent(current,workInProgress,elementType,updateExpirationTime,renderExpirationTime);}case FunctionComponent:{var _Component=workInProgress.type;var unresolvedProps=workInProgress.pendingProps;var resolvedProps=workInProgress.elementType===_Component?unresolvedProps:resolveDefaultProps(_Component,unresolvedProps);return updateFunctionComponent(current,workInProgress,_Component,resolvedProps,renderExpirationTime);}case ClassComponent:{var _Component2=workInProgress.type;var _unresolvedProps=workInProgress.pendingProps;var _resolvedProps=workInProgress.elementType===_Component2?_unresolvedProps:resolveDefaultProps(_Component2,_unresolvedProps);return updateClassComponent(current,workInProgress,_Component2,_resolvedProps,renderExpirationTime);}case HostRoot:return updateHostRoot(current,workInProgress,renderExpirationTime);case HostComponent:return updateHostComponent(current,workInProgress,renderExpirationTime);case HostText:return updateHostText(current,workInProgress);case SuspenseComponent:return updateSuspenseComponent(current,workInProgress,renderExpirationTime);case HostPortal:return updatePortalComponent(current,workInProgress,renderExpirationTime);case ForwardRef:{var type=workInProgress.type;var _unresolvedProps2=workInProgress.pendingProps;var _resolvedProps2=workInProgress.elementType===type?_unresolvedProps2:resolveDefaultProps(type,_unresolvedProps2);return updateForwardRef(current,workInProgress,type,_resolvedProps2,renderExpirationTime);}case Fragment:return updateFragment(current,workInProgress,renderExpirationTime);case Mode:return updateMode(current,workInProgress,renderExpirationTime);case Profiler:return updateProfiler(current,workInProgress,renderExpirationTime);case ContextProvider:return updateContextProvider(current,workInProgress,renderExpirationTime);case ContextConsumer:return updateContextConsumer(current,workInProgress,renderExpirationTime);case MemoComponent:{var _type2=workInProgress.type;var _unresolvedProps3=workInProgress.pendingProps;// Resolve outer props first, then resolve inner props.
  var _resolvedProps3=resolveDefaultProps(_type2,_unresolvedProps3);{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=_type2.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,_resolvedProps3,// Resolved for outer only
  'prop',getComponentName(_type2),getCurrentFiberStackInDev);}}}_resolvedProps3=resolveDefaultProps(_type2.type,_resolvedProps3);return updateMemoComponent(current,workInProgress,_type2,_resolvedProps3,updateExpirationTime,renderExpirationTime);}case SimpleMemoComponent:{return updateSimpleMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,updateExpirationTime,renderExpirationTime);}case IncompleteClassComponent:{var _Component3=workInProgress.type;var _unresolvedProps4=workInProgress.pendingProps;var _resolvedProps4=workInProgress.elementType===_Component3?_unresolvedProps4:resolveDefaultProps(_Component3,_unresolvedProps4);return mountIncompleteClassComponent(current,workInProgress,_Component3,_resolvedProps4,renderExpirationTime);}case SuspenseListComponent:{return updateSuspenseListComponent(current,workInProgress,renderExpirationTime);}}{{throw Error("Unknown unit of work tag ("+workInProgress.tag+"). This error is likely caused by a bug in React. Please file an issue.");}}}function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into
  // a PlacementAndUpdate.
  workInProgress.effectTag|=Update;}function markRef$1(workInProgress){workInProgress.effectTag|=Ref;}var appendAllChildren;var updateHostContainer;var updateHostComponent$1;var updateHostText$1;{// Mutation mode
  appendAllChildren=function(parent,workInProgress,needsVisibilityToggle,isHidden){// We only have the top Fiber that was created but we need recurse down its
  // children to find all the terminal nodes.
  var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal);else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}};updateHostContainer=function(workInProgress){// Noop
  };updateHostComponent$1=function(current,workInProgress,type,newProps,rootContainerInstance){// If we have an alternate, that means this is an update and we need to
  // schedule a side-effect to do the updates.
  var oldProps=current.memoizedProps;if(oldProps===newProps){// In mutation mode, this is sufficient for a bailout because
  // we won't touch this node even if children changed.
  return;}// If we get updated because one of our children updated, we don't
  // have newProps so we'll have to reuse them.
  // TODO: Split the update API as separate for the props vs. children.
  // Even better would be if children weren't special cased at all tho.
  var instance=workInProgress.stateNode;var currentHostContext=getHostContext();// TODO: Experiencing an error where oldProps is null. Suggests a host
  // component is hitting the resume path. Figure out why. Possibly
  // related to `hidden`.
  var updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);// TODO: Type this specific to this type of component.
  workInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
  // is a new ref we mark this as an update. All the work is done in commitWork.
  if(updatePayload){markUpdate(workInProgress);}};updateHostText$1=function(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.
  if(oldText!==newText){markUpdate(workInProgress);}};}function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){switch(renderState.tailMode){case'hidden':{// Any insertions at the end of the tail list after this point
  // should be invisible. If there are already mounted boundaries
  // anything before them are not considered for collapsing.
  // Therefore we need to go through the whole tail to find if
  // there are any.
  var tailNode=renderState.tail;var lastTailNode=null;while(tailNode!==null){if(tailNode.alternate!==null){lastTailNode=tailNode;}tailNode=tailNode.sibling;}// Next we're simply going to delete all insertions after the
  // last rendered item.
  if(lastTailNode===null){// All remaining items in the tail are insertions.
  renderState.tail=null;}else {// Detach the insertion after the last node that was already
  // inserted.
  lastTailNode.sibling=null;}break;}case'collapsed':{// Any insertions at the end of the tail list after this point
  // should be invisible. If there are already mounted boundaries
  // anything before them are not considered for collapsing.
  // Therefore we need to go through the whole tail to find if
  // there are any.
  var _tailNode=renderState.tail;var _lastTailNode=null;while(_tailNode!==null){if(_tailNode.alternate!==null){_lastTailNode=_tailNode;}_tailNode=_tailNode.sibling;}// Next we're simply going to delete all insertions after the
  // last rendered item.
  if(_lastTailNode===null){// All remaining items in the tail are insertions.
  if(!hasRenderedATailFallback&&renderState.tail!==null){// We suspended during the head. We want to show at least one
  // row at the tail. So we'll keep on and cut off the rest.
  renderState.tail.sibling=null;}else {renderState.tail=null;}}else {// Detach the insertion after the last node that was already
  // inserted.
  _lastTailNode.sibling=null;}break;}}}function completeWork(current,workInProgress,renderExpirationTime){var newProps=workInProgress.pendingProps;switch(workInProgress.tag){case IndeterminateComponent:case LazyComponent:case SimpleMemoComponent:case FunctionComponent:case ForwardRef:case Fragment:case Mode:case Profiler:case ContextConsumer:case MemoComponent:return null;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);var fiberRoot=workInProgress.stateNode;if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children
  // that weren't hydrated.
  var wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// If we hydrated, then we'll need to schedule an update for
  // the commit side-effects on the root.
  markUpdate(workInProgress);}}updateHostContainer(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef$1(workInProgress);}}else {if(!newProps){if(!(workInProgress.stateNode!==null)){{throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");}}// This can happen when we abort work.
  return null;}var currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context
  // "stack" as the parent. Then append children as we go in beginWork
  // or completeWork depending on whether we want to add them top->down or
  // bottom->up. Top->down is faster in IE11.
  var _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){// TODO: Move this and createInstance step into the beginPhase
  // to consolidate.
  if(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,currentHostContext)){// If changes to the hydrated node need to be applied at the
  // commit-phase we mark this as such.
  markUpdate(workInProgress);}}else {var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress);appendAllChildren(instance,workInProgress,false,false);// This needs to be set before we mount Flare event listeners
  workInProgress.stateNode=instance;// (eg DOM renderer supports auto-focus for certain elements).
  // Make sure such renderers get scheduled for later work.
  if(finalizeInitialChildren(instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback
  markRef$1(workInProgress);}}return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need
  // to schedule a side-effect to do the updates.
  updateHostText$1(current,workInProgress,oldText,newText);}else {if(typeof newText!=='string'){if(!(workInProgress.stateNode!==null)){{throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");}}// This can happen when we abort work.
  }var _rootContainerInstance=getRootHostContainer();var _currentHostContext=getHostContext();var _wasHydrated2=popHydrationState(workInProgress);if(_wasHydrated2){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else {workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress);}}return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var nextState=workInProgress.memoizedState;if((workInProgress.effectTag&DidCapture)!==NoEffect){// Something suspended. Re-render with the fallback children.
  workInProgress.expirationTime=renderExpirationTime;// Do not reset the effect list.
  return workInProgress;}var nextDidTimeout=nextState!==null;var prevDidTimeout=false;if(current===null){if(workInProgress.memoizedProps.fallback!==undefined){popHydrationState(workInProgress);}}else {var prevState=current.memoizedState;prevDidTimeout=prevState!==null;if(!nextDidTimeout&&prevState!==null){// We just switched from the fallback to the normal children.
  // Delete the fallback.
  // TODO: Would it be better to store the fallback fragment on
  // the stateNode during the begin phase?
  var currentFallbackChild=current.child.sibling;if(currentFallbackChild!==null){// Deletions go at the beginning of the return fiber's effect list
  var first=workInProgress.firstEffect;if(first!==null){workInProgress.firstEffect=currentFallbackChild;currentFallbackChild.nextEffect=first;}else {workInProgress.firstEffect=workInProgress.lastEffect=currentFallbackChild;currentFallbackChild.nextEffect=null;}currentFallbackChild.effectTag=Deletion;}}}if(nextDidTimeout&&!prevDidTimeout){// If this subtreee is running in blocking mode we can suspend,
  // otherwise we won't suspend.
  // TODO: This will still suspend a synchronous tree if anything
  // in the concurrent tree already suspended during this render.
  // This is a known bug.
  if((workInProgress.mode&BlockingMode)!==NoMode){// TODO: Move this back to throwException because this is too late
  // if this is a large tree which is common for initial loads. We
  // don't know if we should restart a render or not until we get
  // this marker, and this is too late.
  // If this render already had a ping or lower pri updates,
  // and this is the first time we know we're going to suspend we
  // should be able to immediately restart from within throwException.
  var hasInvisibleChildContext=current===null&&workInProgress.memoizedProps.unstable_avoidThisFallback!==true;if(hasInvisibleChildContext||hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext)){// If this was in an invisible tree or a new render, then showing
  // this boundary is ok.
  renderDidSuspend();}else {// Otherwise, we're going to have to hide content so we should
  // suspend for longer if possible.
  renderDidSuspendDelayIfPossible();}}}{// TODO: Only schedule updates if these values are non equal, i.e. it changed.
  if(nextDidTimeout||prevDidTimeout){// If this boundary just timed out, schedule an effect to attach a
  // retry listener to the promise. This flag is also used to hide the
  // primary children. In mutation mode, we also need the flag to
  // *unhide* children that were previously hidden, so check if this
  // is currently timed out, too.
  workInProgress.effectTag|=Update;}}return null;}case HostPortal:popHostContainer(workInProgress);updateHostContainer(workInProgress);return null;case ContextProvider:// Pop provider fiber
  popProvider(workInProgress);return null;case IncompleteClassComponent:{// Same as class component case. I put it down here so that the tags are
  // sequential to ensure this switch is compiled to a jump table.
  var _Component=workInProgress.type;if(isContextProvider(_Component)){popContext(workInProgress);}return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);var renderState=workInProgress.memoizedState;if(renderState===null){// We're running in the default, "independent" mode.
  // We don't do anything in this mode.
  return null;}var didSuspendAlready=(workInProgress.effectTag&DidCapture)!==NoEffect;var renderedTail=renderState.rendering;if(renderedTail===null){// We just rendered the head.
  if(!didSuspendAlready){// This is the first pass. We need to figure out if anything is still
  // suspended in the rendered set.
  // If new content unsuspended, but there's still some content that
  // didn't. Then we need to do a second pass that forces everything
  // to keep showing their fallbacks.
  // We might be suspended if something in this render pass suspended, or
  // something in the previous committed pass suspended. Otherwise,
  // there's no chance so we can skip the expensive call to
  // findFirstSuspended.
  var cannotBeSuspended=renderHasNotSuspendedYet()&&(current===null||(current.effectTag&DidCapture)===NoEffect);if(!cannotBeSuspended){var row=workInProgress.child;while(row!==null){var suspended=findFirstSuspended(row);if(suspended!==null){didSuspendAlready=true;workInProgress.effectTag|=DidCapture;cutOffTailIfNeeded(renderState,false);// If this is a newly suspended tree, it might not get committed as
  // part of the second pass. In that case nothing will subscribe to
  // its thennables. Instead, we'll transfer its thennables to the
  // SuspenseList so that it can retry if they resolve.
  // There might be multiple of these in the list but since we're
  // going to wait for all of them anyway, it doesn't really matter
  // which ones gets to ping. In theory we could get clever and keep
  // track of how many dependencies remain but it gets tricky because
  // in the meantime, we can add/remove/change items and dependencies.
  // We might bail out of the loop before finding any but that
  // doesn't matter since that means that the other boundaries that
  // we did find already has their listeners attached.
  var newThennables=suspended.updateQueue;if(newThennables!==null){workInProgress.updateQueue=newThennables;workInProgress.effectTag|=Update;}// Rerender the whole list, but this time, we'll force fallbacks
  // to stay in place.
  // Reset the effect list before doing the second pass since that's now invalid.
  if(renderState.lastEffect===null){workInProgress.firstEffect=null;}workInProgress.lastEffect=renderState.lastEffect;// Reset the child fibers to their original state.
  resetChildFibers(workInProgress,renderExpirationTime);// Set up the Suspense Context to force suspense and immediately
  // rerender the children.
  pushSuspenseContext(workInProgress,setShallowSuspenseContext(suspenseStackCursor.current,ForceSuspenseFallback));return workInProgress.child;}row=row.sibling;}}}else {cutOffTailIfNeeded(renderState,false);}// Next we're going to render the tail.
  }else {// Append the rendered row to the child list.
  if(!didSuspendAlready){var _suspended=findFirstSuspended(renderedTail);if(_suspended!==null){workInProgress.effectTag|=DidCapture;didSuspendAlready=true;// Ensure we transfer the update queue to the parent so that it doesn't
  // get lost if this row ends up dropped during a second pass.
  var _newThennables=_suspended.updateQueue;if(_newThennables!==null){workInProgress.updateQueue=_newThennables;workInProgress.effectTag|=Update;}cutOffTailIfNeeded(renderState,true);// This might have been modified.
  if(renderState.tail===null&&renderState.tailMode==='hidden'&&!renderedTail.alternate){// We need to delete the row we just rendered.
  // Reset the effect list to what it was before we rendered this
  // child. The nested children have already appended themselves.
  var lastEffect=workInProgress.lastEffect=renderState.lastEffect;// Remove any effects that were appended after this point.
  if(lastEffect!==null){lastEffect.nextEffect=null;}// We're done.
  return null;}}else if(// The time it took to render last row is greater than time until
  // the expiration.
  now()*2-renderState.renderingStartTime>renderState.tailExpiration&&renderExpirationTime>Never){// We have now passed our CPU deadline and we'll just give up further
  // attempts to render the main content and only render fallbacks.
  // The assumption is that this is usually faster.
  workInProgress.effectTag|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this
  // to get it started back up to attempt the next item. If we can show
  // them, then they really have the same priority as this render.
  // So we'll pick it back up the very next render pass once we've had
  // an opportunity to yield for paint.
  var nextPriority=renderExpirationTime-1;workInProgress.expirationTime=workInProgress.childExpirationTime=nextPriority;{markSpawnedWork(nextPriority);}}}if(renderState.isBackwards){// The effect list of the backwards tail will have been added
  // to the end. This breaks the guarantee that life-cycles fire in
  // sibling order but that isn't a strong guarantee promised by React.
  // Especially since these might also just pop in during future commits.
  // Append to the beginning of the list.
  renderedTail.sibling=workInProgress.child;workInProgress.child=renderedTail;}else {var previousSibling=renderState.last;if(previousSibling!==null){previousSibling.sibling=renderedTail;}else {workInProgress.child=renderedTail;}renderState.last=renderedTail;}}if(renderState.tail!==null){// We still have tail rows to render.
  if(renderState.tailExpiration===0){// Heuristic for how long we're willing to spend rendering rows
  // until we just give up and show what we have so far.
  var TAIL_EXPIRATION_TIMEOUT_MS=500;renderState.tailExpiration=now()+TAIL_EXPIRATION_TIMEOUT_MS;// TODO: This is meant to mimic the train model or JND but this
  // is a per component value. It should really be since the start
  // of the total render or last commit. Consider using something like
  // globalMostRecentFallbackTime. That doesn't account for being
  // suspended for part of the time or when it's a new render.
  // It should probably use a global start time value instead.
  }// Pop a row.
  var next=renderState.tail;renderState.rendering=next;renderState.tail=next.sibling;renderState.lastEffect=workInProgress.lastEffect;renderState.renderingStartTime=now();next.sibling=null;// Restore the context.
  // TODO: We can probably just avoid popping it instead and only
  // setting it the first time we go from not suspended to suspended.
  var suspenseContext=suspenseStackCursor.current;if(didSuspendAlready){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);}else {suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);// Do a pass over the next row.
  return next;}return null;}}{{throw Error("Unknown unit of work tag ("+workInProgress.tag+"). This error is likely caused by a bug in React. Please file an issue.");}}}function unwindWork(workInProgress,renderExpirationTime){switch(workInProgress.tag){case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}var effectTag=workInProgress.effectTag;if(effectTag&ShouldCapture){workInProgress.effectTag=effectTag&~ShouldCapture|DidCapture;return workInProgress;}return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);var _effectTag=workInProgress.effectTag;if(!((_effectTag&DidCapture)===NoEffect)){{throw Error("The root failed to unmount after an error. This is likely a bug in React. Please file an issue.");}}workInProgress.effectTag=_effectTag&~ShouldCapture|DidCapture;return workInProgress;}case HostComponent:{// TODO: popHydrationState
  popHostContext(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var _effectTag2=workInProgress.effectTag;if(_effectTag2&ShouldCapture){workInProgress.effectTag=_effectTag2&~ShouldCapture|DidCapture;// Captured a suspense effect. Re-render the boundary.
  return workInProgress;}return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);// SuspenseList doesn't actually catch anything. It should've been
  // caught by a nested boundary. If not, it should bubble through.
  return null;}case HostPortal:popHostContainer(workInProgress);return null;case ContextProvider:popProvider(workInProgress);return null;default:return null;}}function unwindInterruptedWork(interruptedWork){switch(interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;if(childContextTypes!==null&&childContextTypes!==undefined){popContext(interruptedWork);}break;}case HostRoot:{popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);break;}case HostComponent:{popHostContext(interruptedWork);break;}case HostPortal:popHostContainer(interruptedWork);break;case SuspenseComponent:popSuspenseContext(interruptedWork);break;case SuspenseListComponent:popSuspenseContext(interruptedWork);break;case ContextProvider:popProvider(interruptedWork);break;}}function createCapturedValue(value,source){// If the value is an error, call this function immediately after it is thrown
  // so the stack is accurate.
  return {value:value,source:source,stack:getStackByFiberInDevAndProd(source)};}function logCapturedError(capturedError){var error=capturedError.error;{var componentName=capturedError.componentName,componentStack=capturedError.componentStack,errorBoundaryName=capturedError.errorBoundaryName,errorBoundaryFound=capturedError.errorBoundaryFound,willRetry=capturedError.willRetry;// Browsers support silencing uncaught errors by calling
  // `preventDefault()` in window `error` handler.
  // We record this information as an expando on the error.
  if(error!=null&&error._suppressLogging){if(errorBoundaryFound&&willRetry){// The error is recoverable and was silenced.
  // Ignore it and don't print the stack addendum.
  // This is handy for testing error boundaries without noise.
  return;}// The error is fatal. Since the silencing might have
  // been accidental, we'll surface it anyway.
  // However, the browser would have silenced the original error
  // so we'll print it first, and then print the stack addendum.
  console['error'](error);// Don't transform to our wrapper
  // For a more detailed description of this block, see:
  // https://github.com/facebook/react/pull/13384
  }var componentNameMessage=componentName?"The above error occurred in the <"+componentName+"> component:":'The above error occurred in one of your React components:';var errorBoundaryMessage;// errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
  if(errorBoundaryFound&&errorBoundaryName){if(willRetry){errorBoundaryMessage="React will try to recreate this component tree from scratch "+("using the error boundary you provided, "+errorBoundaryName+".");}else {errorBoundaryMessage="This error was initially handled by the error boundary "+errorBoundaryName+".\n"+"Recreating the tree from scratch failed so React will unmount the tree.";}}else {errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\n'+'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';}var combinedMessage=""+componentNameMessage+componentStack+"\n\n"+(""+errorBoundaryMessage);// In development, we provide our own message with just the component stack.
  // We don't include the original error message and JS stack because the browser
  // has already printed it. Even if the application swallows the error, it is still
  // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
  console['error'](combinedMessage);// Don't transform to our wrapper
  }}var didWarnAboutUndefinedSnapshotBeforeUpdate=null;{didWarnAboutUndefinedSnapshotBeforeUpdate=new Set();}var PossiblyWeakSet=typeof WeakSet==='function'?WeakSet:Set;function logError(boundary,errorInfo){var source=errorInfo.source;var stack=errorInfo.stack;if(stack===null&&source!==null){stack=getStackByFiberInDevAndProd(source);}var capturedError={componentName:source!==null?getComponentName(source.type):null,componentStack:stack!==null?stack:'',error:errorInfo.value,errorBoundary:null,errorBoundaryName:null,errorBoundaryFound:false,willRetry:false};if(boundary!==null&&boundary.tag===ClassComponent){capturedError.errorBoundary=boundary.stateNode;capturedError.errorBoundaryName=getComponentName(boundary.type);capturedError.errorBoundaryFound=true;capturedError.willRetry=true;}try{logCapturedError(capturedError);}catch(e){// This method must not throw, or React internal state will get messed up.
  // If console.error is overridden, or logCapturedError() shows a dialog that throws,
  // we want to report this error outside of the normal stack as a last resort.
  // https://github.com/facebook/react/issues/13188
  setTimeout(function(){throw e;});}}var callComponentWillUnmountWithTimer=function(current,instance){startPhaseTimer(current,'componentWillUnmount');instance.props=current.memoizedProps;instance.state=current.memoizedState;instance.componentWillUnmount();stopPhaseTimer();};// Capture errors so they don't interrupt unmounting.
  function safelyCallComponentWillUnmount(current,instance){{invokeGuardedCallback(null,callComponentWillUnmountWithTimer,null,current,instance);if(hasCaughtError()){var unmountError=clearCaughtError();captureCommitPhaseError(current,unmountError);}}}function safelyDetachRef(current){var ref=current.ref;if(ref!==null){if(typeof ref==='function'){{invokeGuardedCallback(null,ref,null,null);if(hasCaughtError()){var refError=clearCaughtError();captureCommitPhaseError(current,refError);}}}else {ref.current=null;}}}function safelyCallDestroy(current,destroy){{invokeGuardedCallback(null,destroy,null);if(hasCaughtError()){var error=clearCaughtError();captureCommitPhaseError(current,error);}}}function commitBeforeMutationLifeCycles(current,finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:case Block:{return;}case ClassComponent:{if(finishedWork.effectTag&Snapshot){if(current!==null){var prevProps=current.memoizedProps;var prevState=current.memoizedState;startPhaseTimer(finishedWork,'getSnapshotBeforeUpdate');var instance=finishedWork.stateNode;// We could update instance props and state here,
  // but instead we rely on them being set during last render.
  // TODO: revisit this when we implement resuming.
  {if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}}}var snapshot=instance.getSnapshotBeforeUpdate(finishedWork.elementType===finishedWork.type?prevProps:resolveDefaultProps(finishedWork.type,prevProps),prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;if(snapshot===undefined&&!didWarnSet.has(finishedWork.type)){didWarnSet.add(finishedWork.type);error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '+'must be returned. You have returned undefined.',getComponentName(finishedWork.type));}}instance.__reactInternalSnapshotBeforeUpdate=snapshot;stopPhaseTimer();}}return;}case HostRoot:case HostComponent:case HostText:case HostPortal:case IncompleteClassComponent:// Nothing to do for these component types
  return;}{{throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");}}}function commitHookEffectListUnmount(tag,finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&tag)===tag){// Unmount
  var destroy=effect.destroy;effect.destroy=undefined;if(destroy!==undefined){destroy();}}effect=effect.next;}while(effect!==firstEffect);}}function commitHookEffectListMount(tag,finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&tag)===tag){// Mount
  var create=effect.create;effect.destroy=create();{var destroy=effect.destroy;if(destroy!==undefined&&typeof destroy!=='function'){var addendum=void 0;if(destroy===null){addendum=' You returned null. If your effect does not require clean '+'up, return undefined (or nothing).';}else if(typeof destroy.then==='function'){addendum='\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. '+'Instead, write the async function inside your effect '+'and call it immediately:\n\n'+'useEffect(() => {\n'+'  async function fetchData() {\n'+'    // You can await here\n'+'    const response = await MyAPI.getData(someId);\n'+'    // ...\n'+'  }\n'+'  fetchData();\n'+"}, [someId]); // Or [] if effect doesn't need props or state\n\n"+'Learn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching';}else {addendum=' You returned: '+destroy;}error('An effect function must not return anything besides a function, '+'which is used for clean-up.%s%s',addendum,getStackByFiberInDevAndProd(finishedWork));}}}effect=effect.next;}while(effect!==firstEffect);}}function commitPassiveHookEffects(finishedWork){if((finishedWork.effectTag&Passive)!==NoEffect){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:case Block:{// TODO (#17945) We should call all passive destroy functions (for all fibers)
  // before calling any create functions. The current approach only serializes
  // these for a single fiber.
  commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork);commitHookEffectListMount(Passive$1|HasEffect,finishedWork);break;}}}}function commitLifeCycles(finishedRoot,current,finishedWork,committedExpirationTime){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:case Block:{// At this point layout effects have already been destroyed (during mutation phase).
  // This is done to prevent sibling component effects from interfering with each other,
  // e.g. a destroy function in one component should never override a ref set
  // by a create function in another component during the same commit.
  commitHookEffectListMount(Layout|HasEffect,finishedWork);return;}case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.effectTag&Update){if(current===null){startPhaseTimer(finishedWork,'componentDidMount');// We could update instance props and state here,
  // but instead we rely on them being set during last render.
  // TODO: revisit this when we implement resuming.
  {if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}}}instance.componentDidMount();stopPhaseTimer();}else {var prevProps=finishedWork.elementType===finishedWork.type?current.memoizedProps:resolveDefaultProps(finishedWork.type,current.memoizedProps);var prevState=current.memoizedState;startPhaseTimer(finishedWork,'componentDidUpdate');// We could update instance props and state here,
  // but instead we rely on them being set during last render.
  // TODO: revisit this when we implement resuming.
  {if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}}}instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);stopPhaseTimer();}}var updateQueue=finishedWork.updateQueue;if(updateQueue!==null){{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}}}// We could update instance props and state here,
  // but instead we rely on them being set during last render.
  // TODO: revisit this when we implement resuming.
  commitUpdateQueue(finishedWork,updateQueue,instance);}return;}case HostRoot:{var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null){switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:_instance=finishedWork.child.stateNode;break;}}commitUpdateQueue(finishedWork,_updateQueue,_instance);}return;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted
  // (eg DOM renderer may schedule auto-focus for inputs and form controls).
  // These effects should only be committed when components are first mounted,
  // aka when there is no current/alternate.
  if(current===null&&finishedWork.effectTag&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props);}return;}case HostText:{// We have no life-cycles associated with text.
  return;}case HostPortal:{// We have no life-cycles associated with portals.
  return;}case Profiler:{{var onRender=finishedWork.memoizedProps.onRender;if(typeof onRender==='function'){{onRender(finishedWork.memoizedProps.id,current===null?'mount':'update',finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,getCommitTime(),finishedRoot.memoizedInteractions);}}}return;}case SuspenseComponent:{commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);return;}case SuspenseListComponent:case IncompleteClassComponent:case FundamentalComponent:case ScopeComponent:return;}{{throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");}}}function hideOrUnhideAllChildren(finishedWork,isHidden){{// We only have the top Fiber that was inserted but we need to recurse down its
  // children to find all the terminal nodes.
  var node=finishedWork;while(true){if(node.tag===HostComponent){var instance=node.stateNode;if(isHidden){hideInstance(instance);}else {unhideInstance(node.stateNode,node.memoizedProps);}}else if(node.tag===HostText){var _instance3=node.stateNode;if(isHidden){hideTextInstance(_instance3);}else {unhideTextInstance(_instance3,node.memoizedProps);}}else if(node.tag===SuspenseComponent&&node.memoizedState!==null&&node.memoizedState.dehydrated===null){// Found a nested Suspense component that timed out. Skip over the
  // primary child fragment, which should remain hidden.
  var fallbackChildFragment=node.child.sibling;fallbackChildFragment.return=node;node=fallbackChildFragment;continue;}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;var instanceToUse;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance;}// Moved outside to ensure DCE works with this flag
  if(typeof ref==='function'){ref(instanceToUse);}else {{if(!ref.hasOwnProperty('current')){error('Unexpected ref object provided for %s. '+'Use either a ref-setter function or React.createRef().%s',getComponentName(finishedWork.type),getStackByFiberInDevAndProd(finishedWork));}}ref.current=instanceToUse;}}}function commitDetachRef(current){var currentRef=current.ref;if(currentRef!==null){if(typeof currentRef==='function'){currentRef(null);}else {currentRef.current=null;}}}// User-originating errors (lifecycles and refs) should not interrupt
  // deletion, so don't let them throw. Host-originating errors should
  // interrupt deletion, so it's okay
  function commitUnmount(finishedRoot,current,renderPriorityLevel){onCommitUnmount(current);switch(current.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:case Block:{var updateQueue=current.updateQueue;if(updateQueue!==null){var lastEffect=updateQueue.lastEffect;if(lastEffect!==null){var firstEffect=lastEffect.next;{// When the owner fiber is deleted, the destroy function of a passive
  // effect hook is called during the synchronous commit phase. This is
  // a concession to implementation complexity. Calling it in the
  // passive effect phase (like they usually are, when dependencies
  // change during an update) would require either traversing the
  // children of the deleted fiber again, or including unmount effects
  // as part of the fiber effect list.
  //
  // Because this is during the sync commit phase, we need to change
  // the priority.
  //
  // TODO: Reconsider this implementation trade off.
  var priorityLevel=renderPriorityLevel>NormalPriority?NormalPriority:renderPriorityLevel;runWithPriority$1(priorityLevel,function(){var effect=firstEffect;do{var _destroy=effect.destroy;if(_destroy!==undefined){safelyCallDestroy(current,_destroy);}effect=effect.next;}while(effect!==firstEffect);});}}}return;}case ClassComponent:{safelyDetachRef(current);var instance=current.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(current,instance);}return;}case HostComponent:{safelyDetachRef(current);return;}case HostPortal:{// TODO: this is recursive.
  // We are also not using this parent because
  // the portal will get pushed immediately.
  {unmountHostComponents(finishedRoot,current,renderPriorityLevel);}return;}case FundamentalComponent:{return;}case DehydratedFragment:{return;}case ScopeComponent:{return;}}}function commitNestedUnmounts(finishedRoot,root,renderPriorityLevel){// While we're inside a removed host node we don't want to call
  // removeChild on the inner nodes because they're removed by the top
  // call anyway. We also want to call componentWillUnmount on all
  // composites before this host node is removed from the tree. Therefore
  // we do an inner loop while we're still inside the host node.
  var node=root;while(true){commitUnmount(finishedRoot,node,renderPriorityLevel);// Visit children because they may contain more composite or host nodes.
  // Skip portals because commitUnmount() currently visits them recursively.
  if(node.child!==null&&// If we use mutation we drill down into portals using commitUnmount above.
  // If we don't use mutation we drill down into portals here instead.
  node.tag!==HostPortal){node.child.return=node;node=node.child;continue;}if(node===root){return;}while(node.sibling===null){if(node.return===null||node.return===root){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function detachFiber(current){var alternate=current.alternate;// Cut off the return pointers to disconnect it from the tree. Ideally, we
  // should clear the child pointer of the parent alternate to let this
  // get GC:ed but we don't know which for sure which parent is the current
  // one so we'll settle for GC:ing the subtree of this child. This child
  // itself will be GC:ed when the parent updates the next time.
  current.return=null;current.child=null;current.memoizedState=null;current.updateQueue=null;current.dependencies=null;current.alternate=null;current.firstEffect=null;current.lastEffect=null;current.pendingProps=null;current.memoizedProps=null;current.stateNode=null;if(alternate!==null){detachFiber(alternate);}}function getHostParentFiber(fiber){var parent=fiber.return;while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent.return;}{{throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");}}}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host
  // node. Unfortunately, if multiple insertions are done in a row we have to
  // search past them. This leads to exponential search for the next sibling.
  // TODO: Find a more efficient way to do this.
  var node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.
  while(node.sibling===null){if(node.return===null||isHostParent(node.return)){// If we pop out of the root or hit the parent the fiber we are the
  // last sibling.
  return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText&&node.tag!==DehydratedFragment){// If it is not host node and, we might have a host node inside it.
  // Try to search down until we find one.
  if(node.effectTag&Placement){// If we don't have a child, try the siblings instead.
  continue siblings;}// If we don't have a child, try the siblings instead.
  // We also skip portals because they are not part of this host tree.
  if(node.child===null||node.tag===HostPortal){continue siblings;}else {node.child.return=node;node=node.child;}}// Check if this host node is stable or about to be placed.
  if(!(node.effectTag&Placement)){// Found it!
  return node.stateNode;}}}function commitPlacement(finishedWork){var parentFiber=getHostParentFiber(finishedWork);// Note: these two variables *must* always be updated together.
  var parent;var isContainer;var parentStateNode=parentFiber.stateNode;switch(parentFiber.tag){case HostComponent:parent=parentStateNode;isContainer=false;break;case HostRoot:parent=parentStateNode.containerInfo;isContainer=true;break;case HostPortal:parent=parentStateNode.containerInfo;isContainer=true;break;case FundamentalComponent:// eslint-disable-next-line-no-fallthrough
  default:{{throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");}}}if(parentFiber.effectTag&ContentReset){// Reset the text content of the parent before doing any insertions
  resetTextContent(parent);// Clear ContentReset from the effect tag
  parentFiber.effectTag&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need to recurse down its
  // children to find all the terminal nodes.
  if(isContainer){insertOrAppendPlacementNodeIntoContainer(finishedWork,before,parent);}else {insertOrAppendPlacementNode(finishedWork,before,parent);}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost||enableFundamentalAPI){var stateNode=isHost?node.stateNode:node.stateNode.instance;if(before){insertInContainerBefore(parent,stateNode,before);}else {appendChildToContainer(parent,stateNode);}}else if(tag===HostPortal);else {var child=node.child;if(child!==null){insertOrAppendPlacementNodeIntoContainer(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNodeIntoContainer(sibling,before,parent);sibling=sibling.sibling;}}}}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost||enableFundamentalAPI){var stateNode=isHost?node.stateNode:node.stateNode.instance;if(before){insertBefore(parent,stateNode,before);}else {appendChild(parent,stateNode);}}else if(tag===HostPortal);else {var child=node.child;if(child!==null){insertOrAppendPlacementNode(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNode(sibling,before,parent);sibling=sibling.sibling;}}}}function unmountHostComponents(finishedRoot,current,renderPriorityLevel){// We only have the top Fiber that was deleted but we need to recurse down its
  // children to find all the terminal nodes.
  var node=current;// Each iteration, currentParent is populated with node's host parent if not
  // currentParentIsValid.
  var currentParentIsValid=false;// Note: these two variables *must* always be updated together.
  var currentParent;var currentParentIsContainer;while(true){if(!currentParentIsValid){var parent=node.return;findParent:while(true){if(!(parent!==null)){{throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");}}var parentStateNode=parent.stateNode;switch(parent.tag){case HostComponent:currentParent=parentStateNode;currentParentIsContainer=false;break findParent;case HostRoot:currentParent=parentStateNode.containerInfo;currentParentIsContainer=true;break findParent;case HostPortal:currentParent=parentStateNode.containerInfo;currentParentIsContainer=true;break findParent;}parent=parent.return;}currentParentIsValid=true;}if(node.tag===HostComponent||node.tag===HostText){commitNestedUnmounts(finishedRoot,node,renderPriorityLevel);// After all the children have unmounted, it is now safe to remove the
  // node from the tree.
  if(currentParentIsContainer){removeChildFromContainer(currentParent,node.stateNode);}else {removeChild(currentParent,node.stateNode);}// Don't visit children because we already visited them.
  }else if(node.tag===HostPortal){if(node.child!==null){// When we go into a portal, it becomes the parent to remove from.
  // We will reassign it back when we pop the portal on the way up.
  currentParent=node.stateNode.containerInfo;currentParentIsContainer=true;// Visit children because portals might contain host components.
  node.child.return=node;node=node.child;continue;}}else {commitUnmount(finishedRoot,node,renderPriorityLevel);// Visit children because we may find more host components below.
  if(node.child!==null){node.child.return=node;node=node.child;continue;}}if(node===current){return;}while(node.sibling===null){if(node.return===null||node.return===current){return;}node=node.return;if(node.tag===HostPortal){// When we go out of the portal, we need to restore the parent.
  // Since we don't keep a stack of them, we will search for it.
  currentParentIsValid=false;}}node.sibling.return=node.return;node=node.sibling;}}function commitDeletion(finishedRoot,current,renderPriorityLevel){{// Recursively delete all host nodes from the parent.
  // Detach refs and call componentWillUnmount() on the whole subtree.
  unmountHostComponents(finishedRoot,current,renderPriorityLevel);}detachFiber(current);}function commitWork(current,finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:case Block:{// Layout effects are destroyed during the mutation phase so that all
  // destroy functions for all fibers are called before any create functions.
  // This prevents sibling component effects from interfering with each other,
  // e.g. a destroy function in one component should never override a ref set
  // by a create function in another component during the same commit.
  commitHookEffectListUnmount(Layout|HasEffect,finishedWork);return;}case ClassComponent:{return;}case HostComponent:{var instance=finishedWork.stateNode;if(instance!=null){// Commit the work prepared earlier.
  var newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
  // as the newProps. The updatePayload will contain the real change in
  // this case.
  var oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.
  var updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){commitUpdate(instance,updatePayload,type,oldProps,newProps);}}return;}case HostText:{if(!(finishedWork.stateNode!==null)){{throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");}}var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
  // as the newProps. The updatePayload will contain the real change in
  // this case.
  var oldText=current!==null?current.memoizedProps:newText;commitTextUpdate(textInstance,oldText,newText);return;}case HostRoot:{{var _root=finishedWork.stateNode;if(_root.hydrate){// We've just hydrated. No need to hydrate again.
  _root.hydrate=false;commitHydratedContainer(_root.containerInfo);}}return;}case Profiler:{return;}case SuspenseComponent:{commitSuspenseComponent(finishedWork);attachSuspenseRetryListeners(finishedWork);return;}case SuspenseListComponent:{attachSuspenseRetryListeners(finishedWork);return;}case IncompleteClassComponent:{return;}}{{throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");}}}function commitSuspenseComponent(finishedWork){var newState=finishedWork.memoizedState;var newDidTimeout;var primaryChildParent=finishedWork;if(newState===null){newDidTimeout=false;}else {newDidTimeout=true;primaryChildParent=finishedWork.child;markCommitTimeOfFallback();}if(primaryChildParent!==null){hideOrUnhideAllChildren(primaryChildParent,newDidTimeout);}}function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork){var newState=finishedWork.memoizedState;if(newState===null){var current=finishedWork.alternate;if(current!==null){var prevState=current.memoizedState;if(prevState!==null){var suspenseInstance=prevState.dehydrated;if(suspenseInstance!==null){commitHydratedSuspenseInstance(suspenseInstance);}}}}}function attachSuspenseRetryListeners(finishedWork){// If this boundary just timed out, then it will have a set of thenables.
  // For each thenable, attach a listener so that when it resolves, React
  // attempts to re-render the boundary in the primary (pre-timeout) state.
  var thenables=finishedWork.updateQueue;if(thenables!==null){finishedWork.updateQueue=null;var retryCache=finishedWork.stateNode;if(retryCache===null){retryCache=finishedWork.stateNode=new PossiblyWeakSet();}thenables.forEach(function(thenable){// Memoize using the boundary fiber to prevent redundant listeners.
  var retry=resolveRetryThenable.bind(null,finishedWork,thenable);if(!retryCache.has(thenable)){{if(thenable.__reactDoNotTraceInteractions!==true){retry=tracing.unstable_wrap(retry);}}retryCache.add(thenable);thenable.then(retry,retry);}});}}function commitResetTextContent(current){resetTextContent(current.stateNode);}var PossiblyWeakMap$1=typeof WeakMap==='function'?WeakMap:Map;function createRootErrorUpdate(fiber,errorInfo,expirationTime){var update=createUpdate(expirationTime,null);// Unmount the root by rendering null.
  update.tag=CaptureUpdate;// Caution: React DevTools currently depends on this property
  // being called "element".
  update.payload={element:null};var error=errorInfo.value;update.callback=function(){onUncaughtError(error);logError(fiber,errorInfo);};return update;}function createClassErrorUpdate(fiber,errorInfo,expirationTime){var update=createUpdate(expirationTime,null);update.tag=CaptureUpdate;var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if(typeof getDerivedStateFromError==='function'){var error$1=errorInfo.value;update.payload=function(){logError(fiber,errorInfo);return getDerivedStateFromError(error$1);};}var inst=fiber.stateNode;if(inst!==null&&typeof inst.componentDidCatch==='function'){update.callback=function callback(){{markFailedErrorBoundaryForHotReloading(fiber);}if(typeof getDerivedStateFromError!=='function'){// To preserve the preexisting retry behavior of error boundaries,
  // we keep track of which ones already failed during this batch.
  // This gets reset before we yield back to the browser.
  // TODO: Warn in strict mode if getDerivedStateFromError is
  // not defined.
  markLegacyErrorBoundaryAsFailed(this);// Only log here if componentDidCatch is the only error boundary method defined
  logError(fiber,errorInfo);}var error$1=errorInfo.value;var stack=errorInfo.stack;this.componentDidCatch(error$1,{componentStack:stack!==null?stack:''});{if(typeof getDerivedStateFromError!=='function'){// If componentDidCatch is the only error boundary method defined,
  // then it needs to call setState to recover from errors.
  // If no state update is scheduled then the boundary will swallow the error.
  if(fiber.expirationTime!==Sync){error('%s: Error boundaries should implement getDerivedStateFromError(). '+'In that method, return a state update to display an error message or fallback UI.',getComponentName(fiber.type)||'Unknown');}}}};}else {update.callback=function(){markFailedErrorBoundaryForHotReloading(fiber);};}return update;}function attachPingListener(root,renderExpirationTime,thenable){// Attach a listener to the promise to "ping" the root and retry. But
  // only if one does not already exist for the current render expiration
  // time (which acts like a "thread ID" here).
  var pingCache=root.pingCache;var threadIDs;if(pingCache===null){pingCache=root.pingCache=new PossiblyWeakMap$1();threadIDs=new Set();pingCache.set(thenable,threadIDs);}else {threadIDs=pingCache.get(thenable);if(threadIDs===undefined){threadIDs=new Set();pingCache.set(thenable,threadIDs);}}if(!threadIDs.has(renderExpirationTime)){// Memoize using the thread ID to prevent redundant listeners.
  threadIDs.add(renderExpirationTime);var ping=pingSuspendedRoot.bind(null,root,thenable,renderExpirationTime);thenable.then(ping,ping);}}function throwException(root,returnFiber,sourceFiber,value,renderExpirationTime){// The source fiber did not complete.
  sourceFiber.effectTag|=Incomplete;// Its effect list is no longer valid.
  sourceFiber.firstEffect=sourceFiber.lastEffect=null;if(value!==null&&typeof value==='object'&&typeof value.then==='function'){// This is a thenable.
  var thenable=value;if((sourceFiber.mode&BlockingMode)===NoMode){// Reset the memoizedState to what it was before we attempted
  // to render it.
  var currentSource=sourceFiber.alternate;if(currentSource){sourceFiber.updateQueue=currentSource.updateQueue;sourceFiber.memoizedState=currentSource.memoizedState;sourceFiber.expirationTime=currentSource.expirationTime;}else {sourceFiber.updateQueue=null;sourceFiber.memoizedState=null;}}var hasInvisibleParentBoundary=hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext);// Schedule the nearest Suspense to re-render the timed out view.
  var _workInProgress=returnFiber;do{if(_workInProgress.tag===SuspenseComponent&&shouldCaptureSuspense(_workInProgress,hasInvisibleParentBoundary)){// Found the nearest boundary.
  // Stash the promise on the boundary fiber. If the boundary times out, we'll
  // attach another listener to flip the boundary back to its normal state.
  var thenables=_workInProgress.updateQueue;if(thenables===null){var updateQueue=new Set();updateQueue.add(thenable);_workInProgress.updateQueue=updateQueue;}else {thenables.add(thenable);}// If the boundary is outside of blocking mode, we should *not*
  // suspend the commit. Pretend as if the suspended component rendered
  // null and keep rendering. In the commit phase, we'll schedule a
  // subsequent synchronous update to re-render the Suspense.
  //
  // Note: It doesn't matter whether the component that suspended was
  // inside a blocking mode tree. If the Suspense is outside of it, we
  // should *not* suspend the commit.
  if((_workInProgress.mode&BlockingMode)===NoMode){_workInProgress.effectTag|=DidCapture;// We're going to commit this fiber even though it didn't complete.
  // But we shouldn't call any lifecycle methods or callbacks. Remove
  // all lifecycle effect tags.
  sourceFiber.effectTag&=~(LifecycleEffectMask|Incomplete);if(sourceFiber.tag===ClassComponent){var currentSourceFiber=sourceFiber.alternate;if(currentSourceFiber===null){// This is a new mount. Change the tag so it's not mistaken for a
  // completed class component. For example, we should not call
  // componentWillUnmount if it is deleted.
  sourceFiber.tag=IncompleteClassComponent;}else {// When we try rendering again, we should not reuse the current fiber,
  // since it's known to be in an inconsistent state. Use a force update to
  // prevent a bail out.
  var update=createUpdate(Sync,null);update.tag=ForceUpdate;enqueueUpdate(sourceFiber,update);}}// The source fiber did not complete. Mark it with Sync priority to
  // indicate that it still has pending work.
  sourceFiber.expirationTime=Sync;// Exit without suspending.
  return;}// Confirmed that the boundary is in a concurrent mode tree. Continue
  // with the normal suspend path.
  //
  // After this we'll use a set of heuristics to determine whether this
  // render pass will run to completion or restart or "suspend" the commit.
  // The actual logic for this is spread out in different places.
  //
  // This first principle is that if we're going to suspend when we complete
  // a root, then we should also restart if we get an update or ping that
  // might unsuspend it, and vice versa. The only reason to suspend is
  // because you think you might want to restart before committing. However,
  // it doesn't make sense to restart only while in the period we're suspended.
  //
  // Restarting too aggressively is also not good because it starves out any
  // intermediate loading state. So we use heuristics to determine when.
  // Suspense Heuristics
  //
  // If nothing threw a Promise or all the same fallbacks are already showing,
  // then don't suspend/restart.
  //
  // If this is an initial render of a new tree of Suspense boundaries and
  // those trigger a fallback, then don't suspend/restart. We want to ensure
  // that we can show the initial loading state as quickly as possible.
  //
  // If we hit a "Delayed" case, such as when we'd switch from content back into
  // a fallback, then we should always suspend/restart. SuspenseConfig applies to
  // this case. If none is defined, JND is used instead.
  //
  // If we're already showing a fallback and it gets "retried", allowing us to show
  // another level, but there's still an inner boundary that would show a fallback,
  // then we suspend/restart for 500ms since the last time we showed a fallback
  // anywhere in the tree. This effectively throttles progressive loading into a
  // consistent train of commits. This also gives us an opportunity to restart to
  // get to the completed state slightly earlier.
  //
  // If there's ambiguity due to batching it's resolved in preference of:
  // 1) "delayed", 2) "initial render", 3) "retry".
  //
  // We want to ensure that a "busy" state doesn't get force committed. We want to
  // ensure that new initial loading states can commit as soon as possible.
  attachPingListener(root,renderExpirationTime,thenable);_workInProgress.effectTag|=ShouldCapture;_workInProgress.expirationTime=renderExpirationTime;return;}// This boundary already captured during this render. Continue to the next
  // boundary.
  _workInProgress=_workInProgress.return;}while(_workInProgress!==null);// No boundary was found. Fallthrough to error mode.
  // TODO: Use invariant so the message is stripped in prod?
  value=new Error((getComponentName(sourceFiber.type)||'A React component')+' suspended while rendering, but no fallback UI was specified.\n'+'\n'+'Add a <Suspense fallback=...> component higher in the tree to '+'provide a loading indicator or placeholder to display.'+getStackByFiberInDevAndProd(sourceFiber));}// We didn't find a boundary that could handle this type of exception. Start
  // over and traverse parent path again, this time treating the exception
  // as an error.
  renderDidError();value=createCapturedValue(value,sourceFiber);var workInProgress=returnFiber;do{switch(workInProgress.tag){case HostRoot:{var _errorInfo=value;workInProgress.effectTag|=ShouldCapture;workInProgress.expirationTime=renderExpirationTime;var _update=createRootErrorUpdate(workInProgress,_errorInfo,renderExpirationTime);enqueueCapturedUpdate(workInProgress,_update);return;}case ClassComponent:// Capture and retry
  var errorInfo=value;var ctor=workInProgress.type;var instance=workInProgress.stateNode;if((workInProgress.effectTag&DidCapture)===NoEffect&&(typeof ctor.getDerivedStateFromError==='function'||instance!==null&&typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress.effectTag|=ShouldCapture;workInProgress.expirationTime=renderExpirationTime;// Schedule the error boundary to re-render using updated state
  var _update2=createClassErrorUpdate(workInProgress,errorInfo,renderExpirationTime);enqueueCapturedUpdate(workInProgress,_update2);return;}break;}workInProgress=workInProgress.return;}while(workInProgress!==null);}var ceil=Math.ceil;var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner,IsSomeRendererActing=ReactSharedInternals.IsSomeRendererActing;var NoContext=/*                    */0;var BatchedContext=/*               */1;var EventContext=/*                 */2;var DiscreteEventContext=/*         */4;var LegacyUnbatchedContext=/*       */8;var RenderContext=/*                */16;var CommitContext=/*                */32;var RootIncomplete=0;var RootFatalErrored=1;var RootErrored=2;var RootSuspended=3;var RootSuspendedWithDelay=4;var RootCompleted=5;// Describes where we are in the React execution stack
  var executionContext=NoContext;// The root we're working on
  var workInProgressRoot=null;// The fiber we're working on
  var workInProgress=null;// The expiration time we're rendering
  var renderExpirationTime$1=NoWork;// Whether to root completed, errored, suspended, etc.
  var workInProgressRootExitStatus=RootIncomplete;// A fatal error, if one is thrown
  var workInProgressRootFatalError=null;// Most recent event time among processed updates during this render.
  // This is conceptually a time stamp but expressed in terms of an ExpirationTime
  // because we deal mostly with expiration times in the hot path, so this avoids
  // the conversion happening in the hot path.
  var workInProgressRootLatestProcessedExpirationTime=Sync;var workInProgressRootLatestSuspenseTimeout=Sync;var workInProgressRootCanSuspendUsingConfig=null;// The work left over by components that were visited during this render. Only
  // includes unprocessed updates, not work in bailed out children.
  var workInProgressRootNextUnprocessedUpdateTime=NoWork;// If we're pinged while rendering we don't always restart immediately.
  // This flag determines if it might be worthwhile to restart if an opportunity
  // happens latere.
  var workInProgressRootHasPendingPing=false;// The most recent time we committed a fallback. This lets us ensure a train
  // model where we don't commit new loading states in too quick succession.
  var globalMostRecentFallbackTime=0;var FALLBACK_THROTTLE_MS=500;var nextEffect=null;var hasUncaughtError=false;var firstUncaughtError=null;var legacyErrorBoundariesThatAlreadyFailed=null;var rootDoesHavePassiveEffects=false;var rootWithPendingPassiveEffects=null;var pendingPassiveEffectsRenderPriority=NoPriority;var pendingPassiveEffectsExpirationTime=NoWork;var rootsWithPendingDiscreteUpdates=null;// Use these to prevent an infinite loop of nested updates
  var NESTED_UPDATE_LIMIT=50;var nestedUpdateCount=0;var rootWithNestedUpdates=null;var NESTED_PASSIVE_UPDATE_LIMIT=50;var nestedPassiveUpdateCount=0;var interruptedBy=null;// Marks the need to reschedule pending interactions at these expiration times
  // during the commit phase. This enables them to be traced across components
  // that spawn new work during render. E.g. hidden boundaries, suspended SSR
  // hydration or SuspenseList.
  var spawnedWorkDuringRender=null;// Expiration times are computed by adding to the current time (the start
  // time). However, if two updates are scheduled within the same event, we
  // should treat their start times as simultaneous, even if the actual clock
  // time has advanced between the first and second call.
  // In other words, because expiration times determine how updates are batched,
  // we want all updates of like priority that occur within the same event to
  // receive the same expiration time. Otherwise we get tearing.
  var currentEventTime=NoWork;function requestCurrentTimeForUpdate(){if((executionContext&(RenderContext|CommitContext))!==NoContext){// We're inside React, so it's fine to read the actual time.
  return msToExpirationTime(now());}// We're not inside React, so we may be in the middle of a browser event.
  if(currentEventTime!==NoWork){// Use the same start time for all updates until we enter React again.
  return currentEventTime;}// This is the first update since React yielded. Compute a new start time.
  currentEventTime=msToExpirationTime(now());return currentEventTime;}function getCurrentTime(){return msToExpirationTime(now());}function computeExpirationForFiber(currentTime,fiber,suspenseConfig){var mode=fiber.mode;if((mode&BlockingMode)===NoMode){return Sync;}var priorityLevel=getCurrentPriorityLevel();if((mode&ConcurrentMode)===NoMode){return priorityLevel===ImmediatePriority?Sync:Batched;}if((executionContext&RenderContext)!==NoContext){// Use whatever time we're already rendering
  // TODO: Should there be a way to opt out, like with `runWithPriority`?
  return renderExpirationTime$1;}var expirationTime;if(suspenseConfig!==null){// Compute an expiration time based on the Suspense timeout.
  expirationTime=computeSuspenseExpiration(currentTime,suspenseConfig.timeoutMs|0||LOW_PRIORITY_EXPIRATION);}else {// Compute an expiration time based on the Scheduler priority.
  switch(priorityLevel){case ImmediatePriority:expirationTime=Sync;break;case UserBlockingPriority$1:// TODO: Rename this to computeUserBlockingExpiration
  expirationTime=computeInteractiveExpiration(currentTime);break;case NormalPriority:case LowPriority:// TODO: Handle LowPriority
  // TODO: Rename this to... something better.
  expirationTime=computeAsyncExpiration(currentTime);break;case IdlePriority:expirationTime=Idle;break;default:{{throw Error("Expected a valid priority level");}}}}// If we're in the middle of rendering a tree, do not update at the same
  // expiration time that is already rendering.
  // TODO: We shouldn't have to do this if the update is on a different root.
  // Refactor computeExpirationForFiber + scheduleUpdate so we have access to
  // the root when we check for this condition.
  if(workInProgressRoot!==null&&expirationTime===renderExpirationTime$1){// This is a trick to move this update into a separate batch
  expirationTime-=1;}return expirationTime;}function scheduleUpdateOnFiber(fiber,expirationTime){checkForNestedUpdates();warnAboutRenderPhaseUpdatesInDEV(fiber);var root=markUpdateTimeFromFiberToRoot(fiber,expirationTime);if(root===null){warnAboutUpdateOnUnmountedFiberInDEV(fiber);return;}checkForInterruption(fiber,expirationTime);recordScheduleUpdate();// TODO: computeExpirationForFiber also reads the priority. Pass the
  // priority as an argument to that function and this one.
  var priorityLevel=getCurrentPriorityLevel();if(expirationTime===Sync){if(// Check if we're inside unbatchedUpdates
  (executionContext&LegacyUnbatchedContext)!==NoContext&&// Check if we're not already rendering
  (executionContext&(RenderContext|CommitContext))===NoContext){// Register pending interactions on the root to avoid losing traced interaction data.
  schedulePendingInteractions(root,expirationTime);// This is a legacy edge case. The initial mount of a ReactDOM.render-ed
  // root inside of batchedUpdates should be synchronous, but layout updates
  // should be deferred until the end of the batch.
  performSyncWorkOnRoot(root);}else {ensureRootIsScheduled(root);schedulePendingInteractions(root,expirationTime);if(executionContext===NoContext){// Flush the synchronous work now, unless we're already working or inside
  // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
  // scheduleCallbackForFiber to preserve the ability to schedule a callback
  // without immediately flushing it. We only do this for user-initiated
  // updates, to preserve historical behavior of legacy mode.
  flushSyncCallbackQueue();}}}else {ensureRootIsScheduled(root);schedulePendingInteractions(root,expirationTime);}if((executionContext&DiscreteEventContext)!==NoContext&&(// Only updates at user-blocking priority or greater are considered
  // discrete, even inside a discrete event.
  priorityLevel===UserBlockingPriority$1||priorityLevel===ImmediatePriority)){// This is the result of a discrete event. Track the lowest priority
  // discrete update per root so we can flush them early, if needed.
  if(rootsWithPendingDiscreteUpdates===null){rootsWithPendingDiscreteUpdates=new Map([[root,expirationTime]]);}else {var lastDiscreteTime=rootsWithPendingDiscreteUpdates.get(root);if(lastDiscreteTime===undefined||lastDiscreteTime>expirationTime){rootsWithPendingDiscreteUpdates.set(root,expirationTime);}}}}var scheduleWork=scheduleUpdateOnFiber;// This is split into a separate function so we can mark a fiber with pending
  // work without treating it as a typical update that originates from an event;
  // e.g. retrying a Suspense boundary isn't an update, but it does schedule work
  // on a fiber.
  function markUpdateTimeFromFiberToRoot(fiber,expirationTime){// Update the source fiber's expiration time
  if(fiber.expirationTime<expirationTime){fiber.expirationTime=expirationTime;}var alternate=fiber.alternate;if(alternate!==null&&alternate.expirationTime<expirationTime){alternate.expirationTime=expirationTime;}// Walk the parent path to the root and update the child expiration time.
  var node=fiber.return;var root=null;if(node===null&&fiber.tag===HostRoot){root=fiber.stateNode;}else {while(node!==null){alternate=node.alternate;if(node.childExpirationTime<expirationTime){node.childExpirationTime=expirationTime;if(alternate!==null&&alternate.childExpirationTime<expirationTime){alternate.childExpirationTime=expirationTime;}}else if(alternate!==null&&alternate.childExpirationTime<expirationTime){alternate.childExpirationTime=expirationTime;}if(node.return===null&&node.tag===HostRoot){root=node.stateNode;break;}node=node.return;}}if(root!==null){if(workInProgressRoot===root){// Received an update to a tree that's in the middle of rendering. Mark
  // that's unprocessed work on this root.
  markUnprocessedUpdateTime(expirationTime);if(workInProgressRootExitStatus===RootSuspendedWithDelay){// The root already suspended with a delay, which means this render
  // definitely won't finish. Since we have a new update, let's mark it as
  // suspended now, right before marking the incoming update. This has the
  // effect of interrupting the current render and switching to the update.
  // TODO: This happens to work when receiving an update during the render
  // phase, because of the trick inside computeExpirationForFiber to
  // subtract 1 from `renderExpirationTime` to move it into a
  // separate bucket. But we should probably model it with an exception,
  // using the same mechanism we use to force hydration of a subtree.
  // TODO: This does not account for low pri updates that were already
  // scheduled before the root started rendering. Need to track the next
  // pending expiration time (perhaps by backtracking the return path) and
  // then trigger a restart in the `renderDidSuspendDelayIfPossible` path.
  markRootSuspendedAtTime(root,renderExpirationTime$1);}}// Mark that the root has a pending update.
  markRootUpdatedAtTime(root,expirationTime);}return root;}function getNextRootExpirationTimeToWorkOn(root){// Determines the next expiration time that the root should render, taking
  // into account levels that may be suspended, or levels that may have
  // received a ping.
  var lastExpiredTime=root.lastExpiredTime;if(lastExpiredTime!==NoWork){return lastExpiredTime;}// "Pending" refers to any update that hasn't committed yet, including if it
  // suspended. The "suspended" range is therefore a subset.
  var firstPendingTime=root.firstPendingTime;if(!isRootSuspendedAtTime(root,firstPendingTime)){// The highest priority pending time is not suspended. Let's work on that.
  return firstPendingTime;}// If the first pending time is suspended, check if there's a lower priority
  // pending level that we know about. Or check if we received a ping. Work
  // on whichever is higher priority.
  var lastPingedTime=root.lastPingedTime;var nextKnownPendingLevel=root.nextKnownPendingLevel;var nextLevel=lastPingedTime>nextKnownPendingLevel?lastPingedTime:nextKnownPendingLevel;if(nextLevel<=Idle&&firstPendingTime!==nextLevel){// Don't work on Idle/Never priority unless everything else is committed.
  return NoWork;}return nextLevel;}// Use this function to schedule a task for a root. There's only one task per
  // root; if a task was already scheduled, we'll check to make sure the
  // expiration time of the existing task is the same as the expiration time of
  // the next level that the root has work on. This function is called on every
  // update, and right before exiting a task.
  function ensureRootIsScheduled(root){var lastExpiredTime=root.lastExpiredTime;if(lastExpiredTime!==NoWork){// Special case: Expired work should flush synchronously.
  root.callbackExpirationTime=Sync;root.callbackPriority=ImmediatePriority;root.callbackNode=scheduleSyncCallback(performSyncWorkOnRoot.bind(null,root));return;}var expirationTime=getNextRootExpirationTimeToWorkOn(root);var existingCallbackNode=root.callbackNode;if(expirationTime===NoWork){// There's nothing to work on.
  if(existingCallbackNode!==null){root.callbackNode=null;root.callbackExpirationTime=NoWork;root.callbackPriority=NoPriority;}return;}// TODO: If this is an update, we already read the current time. Pass the
  // time as an argument.
  var currentTime=requestCurrentTimeForUpdate();var priorityLevel=inferPriorityFromExpirationTime(currentTime,expirationTime);// If there's an existing render task, confirm it has the correct priority and
  // expiration time. Otherwise, we'll cancel it and schedule a new one.
  if(existingCallbackNode!==null){var existingCallbackPriority=root.callbackPriority;var existingCallbackExpirationTime=root.callbackExpirationTime;if(// Callback must have the exact same expiration time.
  existingCallbackExpirationTime===expirationTime&&// Callback must have greater or equal priority.
  existingCallbackPriority>=priorityLevel){// Existing callback is sufficient.
  return;}// Need to schedule a new task.
  // TODO: Instead of scheduling a new task, we should be able to change the
  // priority of the existing one.
  cancelCallback(existingCallbackNode);}root.callbackExpirationTime=expirationTime;root.callbackPriority=priorityLevel;var callbackNode;if(expirationTime===Sync){// Sync React callbacks are scheduled on a special internal queue
  callbackNode=scheduleSyncCallback(performSyncWorkOnRoot.bind(null,root));}else {callbackNode=scheduleCallback(priorityLevel,performConcurrentWorkOnRoot.bind(null,root),// Compute a task timeout based on the expiration time. This also affects
  // ordering because tasks are processed in timeout order.
  {timeout:expirationTimeToMs(expirationTime)-now()});}root.callbackNode=callbackNode;}// This is the entry point for every concurrent task, i.e. anything that
  // goes through Scheduler.
  function performConcurrentWorkOnRoot(root,didTimeout){// Since we know we're in a React event, we can clear the current
  // event time. The next update will compute a new event time.
  currentEventTime=NoWork;if(didTimeout){// The render task took too long to complete. Mark the current time as
  // expired to synchronously render all expired work in a single batch.
  var currentTime=requestCurrentTimeForUpdate();markRootExpiredAtTime(root,currentTime);// This will schedule a synchronous callback.
  ensureRootIsScheduled(root);return null;}// Determine the next expiration time to work on, using the fields stored
  // on the root.
  var expirationTime=getNextRootExpirationTimeToWorkOn(root);if(expirationTime!==NoWork){var originalCallbackNode=root.callbackNode;if(!((executionContext&(RenderContext|CommitContext))===NoContext)){{throw Error("Should not already be working.");}}flushPassiveEffects();// If the root or expiration time have changed, throw out the existing stack
  // and prepare a fresh one. Otherwise we'll continue where we left off.
  if(root!==workInProgressRoot||expirationTime!==renderExpirationTime$1){prepareFreshStack(root,expirationTime);startWorkOnPendingInteractions(root,expirationTime);}// If we have a work-in-progress fiber, it means there's still work to do
  // in this root.
  if(workInProgress!==null){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();var prevInteractions=pushInteractions(root);startWorkLoopTimer(workInProgress);do{try{workLoopConcurrent();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();executionContext=prevExecutionContext;popDispatcher(prevDispatcher);{popInteractions(prevInteractions);}if(workInProgressRootExitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;stopInterruptedWorkLoopTimer();prepareFreshStack(root,expirationTime);markRootSuspendedAtTime(root,expirationTime);ensureRootIsScheduled(root);throw fatalError;}if(workInProgress!==null){// There's still work left over. Exit without committing.
  stopInterruptedWorkLoopTimer();}else {// We now have a consistent tree. The next step is either to commit it,
  // or, if something suspended, wait to commit it after a timeout.
  stopFinishedWorkLoopTimer();var finishedWork=root.finishedWork=root.current.alternate;root.finishedExpirationTime=expirationTime;finishConcurrentRender(root,finishedWork,workInProgressRootExitStatus,expirationTime);}ensureRootIsScheduled(root);if(root.callbackNode===originalCallbackNode){// The task node scheduled for this root is the same one that's
  // currently executed. Need to return a continuation.
  return performConcurrentWorkOnRoot.bind(null,root);}}}return null;}function finishConcurrentRender(root,finishedWork,exitStatus,expirationTime){// Set this to null to indicate there's no in-progress render.
  workInProgressRoot=null;switch(exitStatus){case RootIncomplete:case RootFatalErrored:{{{throw Error("Root did not complete. This is a bug in React.");}}}// Flow knows about invariant, so it complains if I add a break
  // statement, but eslint doesn't know about invariant, so it complains
  // if I do. eslint-disable-next-line no-fallthrough
  case RootErrored:{// If this was an async render, the error may have happened due to
  // a mutation in a concurrent event. Try rendering one more time,
  // synchronously, to see if the error goes away. If there are
  // lower priority updates, let's include those, too, in case they
  // fix the inconsistency. Render at Idle to include all updates.
  // If it was Idle or Never or some not-yet-invented time, render
  // at that time.
  markRootExpiredAtTime(root,expirationTime>Idle?Idle:expirationTime);// We assume that this second render pass will be synchronous
  // and therefore not hit this path again.
  break;}case RootSuspended:{markRootSuspendedAtTime(root,expirationTime);var lastSuspendedTime=root.lastSuspendedTime;if(expirationTime===lastSuspendedTime){root.nextKnownPendingLevel=getRemainingExpirationTime(finishedWork);}// We have an acceptable loading state. We need to figure out if we
  // should immediately commit it or wait a bit.
  // If we have processed new updates during this render, we may now
  // have a new loading state ready. We want to ensure that we commit
  // that as soon as possible.
  var hasNotProcessedNewUpdates=workInProgressRootLatestProcessedExpirationTime===Sync;if(hasNotProcessedNewUpdates&&// do not delay if we're inside an act() scope
  !IsThisRendererActing.current){// If we have not processed any new updates during this pass, then
  // this is either a retry of an existing fallback state or a
  // hidden tree. Hidden trees shouldn't be batched with other work
  // and after that's fixed it can only be a retry. We're going to
  // throttle committing retries so that we don't show too many
  // loading states too quickly.
  var msUntilTimeout=globalMostRecentFallbackTime+FALLBACK_THROTTLE_MS-now();// Don't bother with a very short suspense time.
  if(msUntilTimeout>10){if(workInProgressRootHasPendingPing){var lastPingedTime=root.lastPingedTime;if(lastPingedTime===NoWork||lastPingedTime>=expirationTime){// This render was pinged but we didn't get to restart
  // earlier so try restarting now instead.
  root.lastPingedTime=expirationTime;prepareFreshStack(root,expirationTime);break;}}var nextTime=getNextRootExpirationTimeToWorkOn(root);if(nextTime!==NoWork&&nextTime!==expirationTime){// There's additional work on this root.
  break;}if(lastSuspendedTime!==NoWork&&lastSuspendedTime!==expirationTime){// We should prefer to render the fallback of at the last
  // suspended level. Ping the last suspended level to try
  // rendering it again.
  root.lastPingedTime=lastSuspendedTime;break;}// The render is suspended, it hasn't timed out, and there's no
  // lower priority work to do. Instead of committing the fallback
  // immediately, wait for more data to arrive.
  root.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root),msUntilTimeout);break;}}// The work expired. Commit immediately.
  commitRoot(root);break;}case RootSuspendedWithDelay:{markRootSuspendedAtTime(root,expirationTime);var _lastSuspendedTime=root.lastSuspendedTime;if(expirationTime===_lastSuspendedTime){root.nextKnownPendingLevel=getRemainingExpirationTime(finishedWork);}if(// do not delay if we're inside an act() scope
  !IsThisRendererActing.current){// We're suspended in a state that should be avoided. We'll try to
  // avoid committing it for as long as the timeouts let us.
  if(workInProgressRootHasPendingPing){var _lastPingedTime=root.lastPingedTime;if(_lastPingedTime===NoWork||_lastPingedTime>=expirationTime){// This render was pinged but we didn't get to restart earlier
  // so try restarting now instead.
  root.lastPingedTime=expirationTime;prepareFreshStack(root,expirationTime);break;}}var _nextTime=getNextRootExpirationTimeToWorkOn(root);if(_nextTime!==NoWork&&_nextTime!==expirationTime){// There's additional work on this root.
  break;}if(_lastSuspendedTime!==NoWork&&_lastSuspendedTime!==expirationTime){// We should prefer to render the fallback of at the last
  // suspended level. Ping the last suspended level to try
  // rendering it again.
  root.lastPingedTime=_lastSuspendedTime;break;}var _msUntilTimeout;if(workInProgressRootLatestSuspenseTimeout!==Sync){// We have processed a suspense config whose expiration time we
  // can use as the timeout.
  _msUntilTimeout=expirationTimeToMs(workInProgressRootLatestSuspenseTimeout)-now();}else if(workInProgressRootLatestProcessedExpirationTime===Sync){// This should never normally happen because only new updates
  // cause delayed states, so we should have processed something.
  // However, this could also happen in an offscreen tree.
  _msUntilTimeout=0;}else {// If we don't have a suspense config, we're going to use a
  // heuristic to determine how long we can suspend.
  var eventTimeMs=inferTimeFromExpirationTime(workInProgressRootLatestProcessedExpirationTime);var currentTimeMs=now();var timeUntilExpirationMs=expirationTimeToMs(expirationTime)-currentTimeMs;var timeElapsed=currentTimeMs-eventTimeMs;if(timeElapsed<0){// We get this wrong some time since we estimate the time.
  timeElapsed=0;}_msUntilTimeout=jnd(timeElapsed)-timeElapsed;// Clamp the timeout to the expiration time. TODO: Once the
  // event time is exact instead of inferred from expiration time
  // we don't need this.
  if(timeUntilExpirationMs<_msUntilTimeout){_msUntilTimeout=timeUntilExpirationMs;}}// Don't bother with a very short suspense time.
  if(_msUntilTimeout>10){// The render is suspended, it hasn't timed out, and there's no
  // lower priority work to do. Instead of committing the fallback
  // immediately, wait for more data to arrive.
  root.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root),_msUntilTimeout);break;}}// The work expired. Commit immediately.
  commitRoot(root);break;}case RootCompleted:{// The work completed. Ready to commit.
  if(// do not delay if we're inside an act() scope
  !IsThisRendererActing.current&&workInProgressRootLatestProcessedExpirationTime!==Sync&&workInProgressRootCanSuspendUsingConfig!==null){// If we have exceeded the minimum loading delay, which probably
  // means we have shown a spinner already, we might have to suspend
  // a bit longer to ensure that the spinner is shown for
  // enough time.
  var _msUntilTimeout2=computeMsUntilSuspenseLoadingDelay(workInProgressRootLatestProcessedExpirationTime,expirationTime,workInProgressRootCanSuspendUsingConfig);if(_msUntilTimeout2>10){markRootSuspendedAtTime(root,expirationTime);root.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root),_msUntilTimeout2);break;}}commitRoot(root);break;}default:{{{throw Error("Unknown root exit status.");}}}}}// This is the entry point for synchronous tasks that don't go
  // through Scheduler
  function performSyncWorkOnRoot(root){// Check if there's expired work on this root. Otherwise, render at Sync.
  var lastExpiredTime=root.lastExpiredTime;var expirationTime=lastExpiredTime!==NoWork?lastExpiredTime:Sync;if(!((executionContext&(RenderContext|CommitContext))===NoContext)){{throw Error("Should not already be working.");}}flushPassiveEffects();// If the root or expiration time have changed, throw out the existing stack
  // and prepare a fresh one. Otherwise we'll continue where we left off.
  if(root!==workInProgressRoot||expirationTime!==renderExpirationTime$1){prepareFreshStack(root,expirationTime);startWorkOnPendingInteractions(root,expirationTime);}// If we have a work-in-progress fiber, it means there's still work to do
  // in this root.
  if(workInProgress!==null){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();var prevInteractions=pushInteractions(root);startWorkLoopTimer(workInProgress);do{try{workLoopSync();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();executionContext=prevExecutionContext;popDispatcher(prevDispatcher);{popInteractions(prevInteractions);}if(workInProgressRootExitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;stopInterruptedWorkLoopTimer();prepareFreshStack(root,expirationTime);markRootSuspendedAtTime(root,expirationTime);ensureRootIsScheduled(root);throw fatalError;}if(workInProgress!==null){// This is a sync render, so we should have finished the whole tree.
  {{throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");}}}else {// We now have a consistent tree. Because this is a sync render, we
  // will commit it even if something suspended.
  stopFinishedWorkLoopTimer();root.finishedWork=root.current.alternate;root.finishedExpirationTime=expirationTime;finishSyncRender(root);}// Before exiting, make sure there's a callback scheduled for the next
  // pending level.
  ensureRootIsScheduled(root);}return null;}function finishSyncRender(root){// Set this to null to indicate there's no in-progress render.
  workInProgressRoot=null;commitRoot(root);}function flushDiscreteUpdates(){// TODO: Should be able to flush inside batchedUpdates, but not inside `act`.
  // However, `act` uses `batchedUpdates`, so there's no way to distinguish
  // those two cases. Need to fix this before exposing flushDiscreteUpdates
  // as a public API.
  if((executionContext&(BatchedContext|RenderContext|CommitContext))!==NoContext){{if((executionContext&RenderContext)!==NoContext){error('unstable_flushDiscreteUpdates: Cannot flush updates when React is '+'already rendering.');}}// We're already rendering, so we can't synchronously flush pending work.
  // This is probably a nested event dispatch triggered by a lifecycle/effect,
  // like `el.focus()`. Exit.
  return;}flushPendingDiscreteUpdates();// If the discrete updates scheduled passive effects, flush them now so that
  // they fire before the next serial event.
  flushPassiveEffects();}function syncUpdates(fn,a,b,c){return runWithPriority$1(ImmediatePriority,fn.bind(null,a,b,c));}function flushPendingDiscreteUpdates(){if(rootsWithPendingDiscreteUpdates!==null){// For each root with pending discrete updates, schedule a callback to
  // immediately flush them.
  var roots=rootsWithPendingDiscreteUpdates;rootsWithPendingDiscreteUpdates=null;roots.forEach(function(expirationTime,root){markRootExpiredAtTime(root,expirationTime);ensureRootIsScheduled(root);});// Now flush the immediate queue.
  flushSyncCallbackQueue();}}function batchedUpdates$1(fn,a){var prevExecutionContext=executionContext;executionContext|=BatchedContext;try{return fn(a);}finally{executionContext=prevExecutionContext;if(executionContext===NoContext){// Flush the immediate callbacks that were scheduled during this batch
  flushSyncCallbackQueue();}}}function batchedEventUpdates$1(fn,a){var prevExecutionContext=executionContext;executionContext|=EventContext;try{return fn(a);}finally{executionContext=prevExecutionContext;if(executionContext===NoContext){// Flush the immediate callbacks that were scheduled during this batch
  flushSyncCallbackQueue();}}}function discreteUpdates$1(fn,a,b,c,d){var prevExecutionContext=executionContext;executionContext|=DiscreteEventContext;try{// Should this
  return runWithPriority$1(UserBlockingPriority$1,fn.bind(null,a,b,c,d));}finally{executionContext=prevExecutionContext;if(executionContext===NoContext){// Flush the immediate callbacks that were scheduled during this batch
  flushSyncCallbackQueue();}}}function unbatchedUpdates(fn,a){var prevExecutionContext=executionContext;executionContext&=~BatchedContext;executionContext|=LegacyUnbatchedContext;try{return fn(a);}finally{executionContext=prevExecutionContext;if(executionContext===NoContext){// Flush the immediate callbacks that were scheduled during this batch
  flushSyncCallbackQueue();}}}function flushSync(fn,a){if((executionContext&(RenderContext|CommitContext))!==NoContext){{{throw Error("flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.");}}}var prevExecutionContext=executionContext;executionContext|=BatchedContext;try{return runWithPriority$1(ImmediatePriority,fn.bind(null,a));}finally{executionContext=prevExecutionContext;// Flush the immediate callbacks that were scheduled during this batch.
  // Note that this will happen even if batchedUpdates is higher up
  // the stack.
  flushSyncCallbackQueue();}}function prepareFreshStack(root,expirationTime){root.finishedWork=null;root.finishedExpirationTime=NoWork;var timeoutHandle=root.timeoutHandle;if(timeoutHandle!==noTimeout){// The root previous suspended and scheduled a timeout to commit a fallback
  // state. Now that we have additional work, cancel the timeout.
  root.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
  cancelTimeout(timeoutHandle);}if(workInProgress!==null){var interruptedWork=workInProgress.return;while(interruptedWork!==null){unwindInterruptedWork(interruptedWork);interruptedWork=interruptedWork.return;}}workInProgressRoot=root;workInProgress=createWorkInProgress(root.current,null);renderExpirationTime$1=expirationTime;workInProgressRootExitStatus=RootIncomplete;workInProgressRootFatalError=null;workInProgressRootLatestProcessedExpirationTime=Sync;workInProgressRootLatestSuspenseTimeout=Sync;workInProgressRootCanSuspendUsingConfig=null;workInProgressRootNextUnprocessedUpdateTime=NoWork;workInProgressRootHasPendingPing=false;{spawnedWorkDuringRender=null;}{ReactStrictModeWarnings.discardPendingWarnings();}}function handleError(root,thrownValue){do{try{// Reset module-level state that was set during the render phase.
  resetContextDependencies();resetHooksAfterThrow();resetCurrentFiber();if(workInProgress===null||workInProgress.return===null){// Expected to be working on a non-root fiber. This is a fatal error
  // because there's no ancestor that can handle it; the root is
  // supposed to capture all errors that weren't caught by an error
  // boundary.
  workInProgressRootExitStatus=RootFatalErrored;workInProgressRootFatalError=thrownValue;// Set `workInProgress` to null. This represents advancing to the next
  // sibling, or the parent if there are no siblings. But since the root
  // has no siblings nor a parent, we set it to null. Usually this is
  // handled by `completeUnitOfWork` or `unwindWork`, but since we're
  // interntionally not calling those, we need set it here.
  // TODO: Consider calling `unwindWork` to pop the contexts.
  workInProgress=null;return null;}if(enableProfilerTimer&&workInProgress.mode&ProfileMode){// Record the time spent rendering before an error was thrown. This
  // avoids inaccurate Profiler durations in the case of a
  // suspended render.
  stopProfilerTimerIfRunningAndRecordDelta(workInProgress,true);}throwException(root,workInProgress.return,workInProgress,thrownValue,renderExpirationTime$1);workInProgress=completeUnitOfWork(workInProgress);}catch(yetAnotherThrownValue){// Something in the return path also threw.
  thrownValue=yetAnotherThrownValue;continue;}// Return to the normal work loop.
  return;}while(true);}function pushDispatcher(root){var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=ContextOnlyDispatcher;if(prevDispatcher===null){// The React isomorphic package does not include a default dispatcher.
  // Instead the first renderer will lazily attach one, in order to give
  // nicer error messages.
  return ContextOnlyDispatcher;}else {return prevDispatcher;}}function popDispatcher(prevDispatcher){ReactCurrentDispatcher$1.current=prevDispatcher;}function pushInteractions(root){{var prevInteractions=tracing.__interactionsRef.current;tracing.__interactionsRef.current=root.memoizedInteractions;return prevInteractions;}}function popInteractions(prevInteractions){{tracing.__interactionsRef.current=prevInteractions;}}function markCommitTimeOfFallback(){globalMostRecentFallbackTime=now();}function markRenderEventTimeAndConfig(expirationTime,suspenseConfig){if(expirationTime<workInProgressRootLatestProcessedExpirationTime&&expirationTime>Idle){workInProgressRootLatestProcessedExpirationTime=expirationTime;}if(suspenseConfig!==null){if(expirationTime<workInProgressRootLatestSuspenseTimeout&&expirationTime>Idle){workInProgressRootLatestSuspenseTimeout=expirationTime;// Most of the time we only have one config and getting wrong is not bad.
  workInProgressRootCanSuspendUsingConfig=suspenseConfig;}}}function markUnprocessedUpdateTime(expirationTime){if(expirationTime>workInProgressRootNextUnprocessedUpdateTime){workInProgressRootNextUnprocessedUpdateTime=expirationTime;}}function renderDidSuspend(){if(workInProgressRootExitStatus===RootIncomplete){workInProgressRootExitStatus=RootSuspended;}}function renderDidSuspendDelayIfPossible(){if(workInProgressRootExitStatus===RootIncomplete||workInProgressRootExitStatus===RootSuspended){workInProgressRootExitStatus=RootSuspendedWithDelay;}// Check if there's a lower priority update somewhere else in the tree.
  if(workInProgressRootNextUnprocessedUpdateTime!==NoWork&&workInProgressRoot!==null){// Mark the current render as suspended, and then mark that there's a
  // pending update.
  // TODO: This should immediately interrupt the current render, instead
  // of waiting until the next time we yield.
  markRootSuspendedAtTime(workInProgressRoot,renderExpirationTime$1);markRootUpdatedAtTime(workInProgressRoot,workInProgressRootNextUnprocessedUpdateTime);}}function renderDidError(){if(workInProgressRootExitStatus!==RootCompleted){workInProgressRootExitStatus=RootErrored;}}// Called during render to determine if anything has suspended.
  // Returns false if we're not sure.
  function renderHasNotSuspendedYet(){// If something errored or completed, we can't really be sure,
  // so those are false.
  return workInProgressRootExitStatus===RootIncomplete;}function inferTimeFromExpirationTime(expirationTime){// We don't know exactly when the update was scheduled, but we can infer an
  // approximate start time from the expiration time.
  var earliestExpirationTimeMs=expirationTimeToMs(expirationTime);return earliestExpirationTimeMs-LOW_PRIORITY_EXPIRATION;}function inferTimeFromExpirationTimeWithSuspenseConfig(expirationTime,suspenseConfig){// We don't know exactly when the update was scheduled, but we can infer an
  // approximate start time from the expiration time by subtracting the timeout
  // that was added to the event time.
  var earliestExpirationTimeMs=expirationTimeToMs(expirationTime);return earliestExpirationTimeMs-(suspenseConfig.timeoutMs|0||LOW_PRIORITY_EXPIRATION);}// The work loop is an extremely hot path. Tell Closure not to inline it.
  /** @noinline */function workLoopSync(){// Already timed out, so perform work without checking if we need to yield.
  while(workInProgress!==null){workInProgress=performUnitOfWork(workInProgress);}}/** @noinline */function workLoopConcurrent(){// Perform work until Scheduler asks us to yield
  while(workInProgress!==null&&!shouldYield()){workInProgress=performUnitOfWork(workInProgress);}}function performUnitOfWork(unitOfWork){// The current, flushed, state of this fiber is the alternate. Ideally
  // nothing should rely on this, but relying on it here means that we don't
  // need an additional field on the work in progress.
  var current=unitOfWork.alternate;startWorkTimer(unitOfWork);setCurrentFiber(unitOfWork);var next;if((unitOfWork.mode&ProfileMode)!==NoMode){startProfilerTimer(unitOfWork);next=beginWork$1(current,unitOfWork,renderExpirationTime$1);stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,true);}else {next=beginWork$1(current,unitOfWork,renderExpirationTime$1);}resetCurrentFiber();unitOfWork.memoizedProps=unitOfWork.pendingProps;if(next===null){// If this doesn't spawn new work, complete the current work.
  next=completeUnitOfWork(unitOfWork);}ReactCurrentOwner$2.current=null;return next;}function completeUnitOfWork(unitOfWork){// Attempt to complete the current unit of work, then move to the next
  // sibling. If there are no more siblings, return to the parent fiber.
  workInProgress=unitOfWork;do{// The current, flushed, state of this fiber is the alternate. Ideally
  // nothing should rely on this, but relying on it here means that we don't
  // need an additional field on the work in progress.
  var current=workInProgress.alternate;var returnFiber=workInProgress.return;// Check if the work completed or if something threw.
  if((workInProgress.effectTag&Incomplete)===NoEffect){setCurrentFiber(workInProgress);var next=void 0;if((workInProgress.mode&ProfileMode)===NoMode){next=completeWork(current,workInProgress,renderExpirationTime$1);}else {startProfilerTimer(workInProgress);next=completeWork(current,workInProgress,renderExpirationTime$1);// Update render duration assuming we didn't error.
  stopProfilerTimerIfRunningAndRecordDelta(workInProgress,false);}stopWorkTimer(workInProgress);resetCurrentFiber();resetChildExpirationTime(workInProgress);if(next!==null){// Completing this fiber spawned new work. Work on that next.
  return next;}if(returnFiber!==null&&// Do not append effects to parents if a sibling failed to complete
  (returnFiber.effectTag&Incomplete)===NoEffect){// Append all the effects of the subtree and this fiber onto the effect
  // list of the parent. The completion order of the children affects the
  // side-effect order.
  if(returnFiber.firstEffect===null){returnFiber.firstEffect=workInProgress.firstEffect;}if(workInProgress.lastEffect!==null){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress.firstEffect;}returnFiber.lastEffect=workInProgress.lastEffect;}// If this fiber had side-effects, we append it AFTER the children's
  // side-effects. We can perform certain side-effects earlier if needed,
  // by doing multiple passes over the effect list. We don't want to
  // schedule our own side-effect on our own list because if end up
  // reusing children we'll schedule this effect onto itself since we're
  // at the end.
  var effectTag=workInProgress.effectTag;// Skip both NoWork and PerformedWork tags when creating the effect
  // list. PerformedWork effect is read by React DevTools but shouldn't be
  // committed.
  if(effectTag>PerformedWork){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress;}else {returnFiber.firstEffect=workInProgress;}returnFiber.lastEffect=workInProgress;}}}else {// This fiber did not complete because something threw. Pop values off
  // the stack without entering the complete phase. If this is a boundary,
  // capture values if possible.
  var _next=unwindWork(workInProgress);// Because this fiber did not complete, don't reset its expiration time.
  if((workInProgress.mode&ProfileMode)!==NoMode){// Record the render duration for the fiber that errored.
  stopProfilerTimerIfRunningAndRecordDelta(workInProgress,false);// Include the time spent working on failed children before continuing.
  var actualDuration=workInProgress.actualDuration;var child=workInProgress.child;while(child!==null){actualDuration+=child.actualDuration;child=child.sibling;}workInProgress.actualDuration=actualDuration;}if(_next!==null){// If completing this work spawned new work, do that next. We'll come
  // back here again.
  // Since we're restarting, remove anything that is not a host effect
  // from the effect tag.
  // TODO: The name stopFailedWorkTimer is misleading because Suspense
  // also captures and restarts.
  stopFailedWorkTimer(workInProgress);_next.effectTag&=HostEffectMask;return _next;}stopWorkTimer(workInProgress);if(returnFiber!==null){// Mark the parent fiber as incomplete and clear its effect list.
  returnFiber.firstEffect=returnFiber.lastEffect=null;returnFiber.effectTag|=Incomplete;}}var siblingFiber=workInProgress.sibling;if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.
  return siblingFiber;}// Otherwise, return to the parent
  workInProgress=returnFiber;}while(workInProgress!==null);// We've reached the root.
  if(workInProgressRootExitStatus===RootIncomplete){workInProgressRootExitStatus=RootCompleted;}return null;}function getRemainingExpirationTime(fiber){var updateExpirationTime=fiber.expirationTime;var childExpirationTime=fiber.childExpirationTime;return updateExpirationTime>childExpirationTime?updateExpirationTime:childExpirationTime;}function resetChildExpirationTime(completedWork){if(renderExpirationTime$1!==Never&&completedWork.childExpirationTime===Never){// The children of this component are hidden. Don't bubble their
  // expiration times.
  return;}var newChildExpirationTime=NoWork;// Bubble up the earliest expiration time.
  if((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset
  // profiler durations.
  var actualDuration=completedWork.actualDuration;var treeBaseDuration=completedWork.selfBaseDuration;// When a fiber is cloned, its actualDuration is reset to 0. This value will
  // only be updated if work is done on the fiber (i.e. it doesn't bailout).
  // When work is done, it should bubble to the parent's actualDuration. If
  // the fiber has not been cloned though, (meaning no work was done), then
  // this value will reflect the amount of time spent working on a previous
  // render. In that case it should not bubble. We determine whether it was
  // cloned by comparing the child pointer.
  var shouldBubbleActualDurations=completedWork.alternate===null||completedWork.child!==completedWork.alternate.child;var child=completedWork.child;while(child!==null){var childUpdateExpirationTime=child.expirationTime;var childChildExpirationTime=child.childExpirationTime;if(childUpdateExpirationTime>newChildExpirationTime){newChildExpirationTime=childUpdateExpirationTime;}if(childChildExpirationTime>newChildExpirationTime){newChildExpirationTime=childChildExpirationTime;}if(shouldBubbleActualDurations){actualDuration+=child.actualDuration;}treeBaseDuration+=child.treeBaseDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;completedWork.treeBaseDuration=treeBaseDuration;}else {var _child=completedWork.child;while(_child!==null){var _childUpdateExpirationTime=_child.expirationTime;var _childChildExpirationTime=_child.childExpirationTime;if(_childUpdateExpirationTime>newChildExpirationTime){newChildExpirationTime=_childUpdateExpirationTime;}if(_childChildExpirationTime>newChildExpirationTime){newChildExpirationTime=_childChildExpirationTime;}_child=_child.sibling;}}completedWork.childExpirationTime=newChildExpirationTime;}function commitRoot(root){var renderPriorityLevel=getCurrentPriorityLevel();runWithPriority$1(ImmediatePriority,commitRootImpl.bind(null,root,renderPriorityLevel));return null;}function commitRootImpl(root,renderPriorityLevel){do{// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
  // means `flushPassiveEffects` will sometimes result in additional
  // passive effects. So we need to keep flushing in a loop until there are
  // no more pending effects.
  // TODO: Might be better if `flushPassiveEffects` did not automatically
  // flush synchronous work at the end, to avoid factoring hazards like this.
  flushPassiveEffects();}while(rootWithPendingPassiveEffects!==null);flushRenderPhaseStrictModeWarningsInDEV();if(!((executionContext&(RenderContext|CommitContext))===NoContext)){{throw Error("Should not already be working.");}}var finishedWork=root.finishedWork;var expirationTime=root.finishedExpirationTime;if(finishedWork===null){return null;}root.finishedWork=null;root.finishedExpirationTime=NoWork;if(!(finishedWork!==root.current)){{throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");}}// commitRoot never returns a continuation; it always finishes synchronously.
  // So we can clear these now to allow a new callback to be scheduled.
  root.callbackNode=null;root.callbackExpirationTime=NoWork;root.callbackPriority=NoPriority;root.nextKnownPendingLevel=NoWork;startCommitTimer();// Update the first and last pending times on this root. The new first
  // pending time is whatever is left on the root fiber.
  var remainingExpirationTimeBeforeCommit=getRemainingExpirationTime(finishedWork);markRootFinishedAtTime(root,expirationTime,remainingExpirationTimeBeforeCommit);if(root===workInProgressRoot){// We can reset these now that they are finished.
  workInProgressRoot=null;workInProgress=null;renderExpirationTime$1=NoWork;}// This indicates that the last root we worked on is not the same one that
  // we're committing now. This most commonly happens when a suspended root
  // times out.
  // Get the list of effects.
  var firstEffect;if(finishedWork.effectTag>PerformedWork){// A fiber's effect list consists only of its children, not itself. So if
  // the root has an effect, we need to add it to the end of the list. The
  // resulting list is the set that would belong to the root's parent, if it
  // had one; that is, all the effects in the tree including the root.
  if(finishedWork.lastEffect!==null){finishedWork.lastEffect.nextEffect=finishedWork;firstEffect=finishedWork.firstEffect;}else {firstEffect=finishedWork;}}else {// There is no effect on the root.
  firstEffect=finishedWork.firstEffect;}if(firstEffect!==null){var prevExecutionContext=executionContext;executionContext|=CommitContext;var prevInteractions=pushInteractions(root);// Reset this to null before calling lifecycles
  ReactCurrentOwner$2.current=null;// The commit phase is broken into several sub-phases. We do a separate pass
  // of the effect list for each phase: all mutation effects come before all
  // layout effects, and so on.
  // The first phase a "before mutation" phase. We use this phase to read the
  // state of the host tree right before we mutate it. This is where
  // getSnapshotBeforeUpdate is called.
  startCommitSnapshotEffectsTimer();prepareForCommit(root.containerInfo);nextEffect=firstEffect;do{{invokeGuardedCallback(null,commitBeforeMutationEffects,null);if(hasCaughtError()){if(!(nextEffect!==null)){{throw Error("Should be working on an effect.");}}var error=clearCaughtError();captureCommitPhaseError(nextEffect,error);nextEffect=nextEffect.nextEffect;}}}while(nextEffect!==null);stopCommitSnapshotEffectsTimer();{// Mark the current commit time to be shared by all Profilers in this
  // batch. This enables them to be grouped later.
  recordCommitTime();}// The next phase is the mutation phase, where we mutate the host tree.
  startCommitHostEffectsTimer();nextEffect=firstEffect;do{{invokeGuardedCallback(null,commitMutationEffects,null,root,renderPriorityLevel);if(hasCaughtError()){if(!(nextEffect!==null)){{throw Error("Should be working on an effect.");}}var _error=clearCaughtError();captureCommitPhaseError(nextEffect,_error);nextEffect=nextEffect.nextEffect;}}}while(nextEffect!==null);stopCommitHostEffectsTimer();resetAfterCommit(root.containerInfo);// The work-in-progress tree is now the current tree. This must come after
  // the mutation phase, so that the previous tree is still current during
  // componentWillUnmount, but before the layout phase, so that the finished
  // work is current during componentDidMount/Update.
  root.current=finishedWork;// The next phase is the layout phase, where we call effects that read
  // the host tree after it's been mutated. The idiomatic use case for this is
  // layout, but class component lifecycles also fire here for legacy reasons.
  startCommitLifeCyclesTimer();nextEffect=firstEffect;do{{invokeGuardedCallback(null,commitLayoutEffects,null,root,expirationTime);if(hasCaughtError()){if(!(nextEffect!==null)){{throw Error("Should be working on an effect.");}}var _error2=clearCaughtError();captureCommitPhaseError(nextEffect,_error2);nextEffect=nextEffect.nextEffect;}}}while(nextEffect!==null);stopCommitLifeCyclesTimer();nextEffect=null;// Tell Scheduler to yield at the end of the frame, so the browser has an
  // opportunity to paint.
  requestPaint();{popInteractions(prevInteractions);}executionContext=prevExecutionContext;}else {// No effects.
  root.current=finishedWork;// Measure these anyway so the flamegraph explicitly shows that there were
  // no effects.
  // TODO: Maybe there's a better way to report this.
  startCommitSnapshotEffectsTimer();stopCommitSnapshotEffectsTimer();{recordCommitTime();}startCommitHostEffectsTimer();stopCommitHostEffectsTimer();startCommitLifeCyclesTimer();stopCommitLifeCyclesTimer();}stopCommitTimer();var rootDidHavePassiveEffects=rootDoesHavePassiveEffects;if(rootDoesHavePassiveEffects){// This commit has passive effects. Stash a reference to them. But don't
  // schedule a callback until after flushing layout work.
  rootDoesHavePassiveEffects=false;rootWithPendingPassiveEffects=root;pendingPassiveEffectsExpirationTime=expirationTime;pendingPassiveEffectsRenderPriority=renderPriorityLevel;}else {// We are done with the effect chain at this point so let's clear the
  // nextEffect pointers to assist with GC. If we have passive effects, we'll
  // clear this in flushPassiveEffects.
  nextEffect=firstEffect;while(nextEffect!==null){var nextNextEffect=nextEffect.nextEffect;nextEffect.nextEffect=null;nextEffect=nextNextEffect;}}// Check if there's remaining work on this root
  var remainingExpirationTime=root.firstPendingTime;if(remainingExpirationTime!==NoWork){{if(spawnedWorkDuringRender!==null){var expirationTimes=spawnedWorkDuringRender;spawnedWorkDuringRender=null;for(var i=0;i<expirationTimes.length;i++){scheduleInteractions(root,expirationTimes[i],root.memoizedInteractions);}}schedulePendingInteractions(root,remainingExpirationTime);}}else {// If there's no remaining work, we can clear the set of already failed
  // error boundaries.
  legacyErrorBoundariesThatAlreadyFailed=null;}{if(!rootDidHavePassiveEffects){// If there are no passive effects, then we can complete the pending interactions.
  // Otherwise, we'll wait until after the passive effects are flushed.
  // Wait to do this until after remaining work has been scheduled,
  // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.
  finishPendingInteractions(root,expirationTime);}}if(remainingExpirationTime===Sync){// Count the number of times the root synchronously re-renders without
  // finishing. If there are too many, it indicates an infinite update loop.
  if(root===rootWithNestedUpdates){nestedUpdateCount++;}else {nestedUpdateCount=0;rootWithNestedUpdates=root;}}else {nestedUpdateCount=0;}onCommitRoot(finishedWork.stateNode,expirationTime);// Always call this before exiting `commitRoot`, to ensure that any
  // additional work on this root is scheduled.
  ensureRootIsScheduled(root);if(hasUncaughtError){hasUncaughtError=false;var _error3=firstUncaughtError;firstUncaughtError=null;throw _error3;}if((executionContext&LegacyUnbatchedContext)!==NoContext){// This is a legacy edge case. We just committed the initial mount of
  // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
  // synchronously, but layout updates should be deferred until the end
  // of the batch.
  return null;}// If layout work was scheduled, flush it now.
  flushSyncCallbackQueue();return null;}function commitBeforeMutationEffects(){while(nextEffect!==null){var effectTag=nextEffect.effectTag;if((effectTag&Snapshot)!==NoEffect){setCurrentFiber(nextEffect);recordEffect();var current=nextEffect.alternate;commitBeforeMutationLifeCycles(current,nextEffect);resetCurrentFiber();}if((effectTag&Passive)!==NoEffect){// If there are passive effects, schedule a callback to flush at
  // the earliest opportunity.
  if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;scheduleCallback(NormalPriority,function(){flushPassiveEffects();return null;});}}nextEffect=nextEffect.nextEffect;}}function commitMutationEffects(root,renderPriorityLevel){// TODO: Should probably move the bulk of this function to commitWork.
  while(nextEffect!==null){setCurrentFiber(nextEffect);var effectTag=nextEffect.effectTag;if(effectTag&ContentReset){commitResetTextContent(nextEffect);}if(effectTag&Ref){var current=nextEffect.alternate;if(current!==null){commitDetachRef(current);}}// The following switch statement is only concerned about placement,
  // updates, and deletions. To avoid needing to add a case for every possible
  // bitmap value, we remove the secondary effects from the effect tag and
  // switch on that value.
  var primaryEffectTag=effectTag&(Placement|Update|Deletion|Hydrating);switch(primaryEffectTag){case Placement:{commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is
  // inserted, before any life-cycles like componentDidMount gets called.
  // TODO: findDOMNode doesn't rely on this any more but isMounted does
  // and isMounted is deprecated anyway so we should be able to kill this.
  nextEffect.effectTag&=~Placement;break;}case PlacementAndUpdate:{// Placement
  commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is
  // inserted, before any life-cycles like componentDidMount gets called.
  nextEffect.effectTag&=~Placement;// Update
  var _current=nextEffect.alternate;commitWork(_current,nextEffect);break;}case Hydrating:{nextEffect.effectTag&=~Hydrating;break;}case HydratingAndUpdate:{nextEffect.effectTag&=~Hydrating;// Update
  var _current2=nextEffect.alternate;commitWork(_current2,nextEffect);break;}case Update:{var _current3=nextEffect.alternate;commitWork(_current3,nextEffect);break;}case Deletion:{commitDeletion(root,nextEffect,renderPriorityLevel);break;}}// TODO: Only record a mutation effect if primaryEffectTag is non-zero.
  recordEffect();resetCurrentFiber();nextEffect=nextEffect.nextEffect;}}function commitLayoutEffects(root,committedExpirationTime){// TODO: Should probably move the bulk of this function to commitWork.
  while(nextEffect!==null){setCurrentFiber(nextEffect);var effectTag=nextEffect.effectTag;if(effectTag&(Update|Callback)){recordEffect();var current=nextEffect.alternate;commitLifeCycles(root,current,nextEffect);}if(effectTag&Ref){recordEffect();commitAttachRef(nextEffect);}resetCurrentFiber();nextEffect=nextEffect.nextEffect;}}function flushPassiveEffects(){if(pendingPassiveEffectsRenderPriority!==NoPriority){var priorityLevel=pendingPassiveEffectsRenderPriority>NormalPriority?NormalPriority:pendingPassiveEffectsRenderPriority;pendingPassiveEffectsRenderPriority=NoPriority;return runWithPriority$1(priorityLevel,flushPassiveEffectsImpl);}}function flushPassiveEffectsImpl(){if(rootWithPendingPassiveEffects===null){return false;}var root=rootWithPendingPassiveEffects;var expirationTime=pendingPassiveEffectsExpirationTime;rootWithPendingPassiveEffects=null;pendingPassiveEffectsExpirationTime=NoWork;if(!((executionContext&(RenderContext|CommitContext))===NoContext)){{throw Error("Cannot flush passive effects while already rendering.");}}var prevExecutionContext=executionContext;executionContext|=CommitContext;var prevInteractions=pushInteractions(root);{// Note: This currently assumes there are no passive effects on the root fiber
  // because the root is not part of its own effect list.
  // This could change in the future.
  var _effect2=root.current.firstEffect;while(_effect2!==null){{setCurrentFiber(_effect2);invokeGuardedCallback(null,commitPassiveHookEffects,null,_effect2);if(hasCaughtError()){if(!(_effect2!==null)){{throw Error("Should be working on an effect.");}}var _error5=clearCaughtError();captureCommitPhaseError(_effect2,_error5);}resetCurrentFiber();}var nextNextEffect=_effect2.nextEffect;// Remove nextEffect pointer to assist GC
  _effect2.nextEffect=null;_effect2=nextNextEffect;}}{popInteractions(prevInteractions);finishPendingInteractions(root,expirationTime);}executionContext=prevExecutionContext;flushSyncCallbackQueue();// If additional passive effects were scheduled, increment a counter. If this
  // exceeds the limit, we'll fire a warning.
  nestedPassiveUpdateCount=rootWithPendingPassiveEffects===null?0:nestedPassiveUpdateCount+1;return true;}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance);}function markLegacyErrorBoundaryAsFailed(instance){if(legacyErrorBoundariesThatAlreadyFailed===null){legacyErrorBoundariesThatAlreadyFailed=new Set([instance]);}else {legacyErrorBoundariesThatAlreadyFailed.add(instance);}}function prepareToThrowUncaughtError(error){if(!hasUncaughtError){hasUncaughtError=true;firstUncaughtError=error;}}var onUncaughtError=prepareToThrowUncaughtError;function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error){var errorInfo=createCapturedValue(error,sourceFiber);var update=createRootErrorUpdate(rootFiber,errorInfo,Sync);enqueueUpdate(rootFiber,update);var root=markUpdateTimeFromFiberToRoot(rootFiber,Sync);if(root!==null){ensureRootIsScheduled(root);schedulePendingInteractions(root,Sync);}}function captureCommitPhaseError(sourceFiber,error){if(sourceFiber.tag===HostRoot){// Error was thrown at the root. There is no parent, so the root
  // itself should capture it.
  captureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error);return;}var fiber=sourceFiber.return;while(fiber!==null){if(fiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(fiber,sourceFiber,error);return;}else if(fiber.tag===ClassComponent){var ctor=fiber.type;var instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromError==='function'||typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValue(error,sourceFiber);var update=createClassErrorUpdate(fiber,errorInfo,// TODO: This is always sync
  Sync);enqueueUpdate(fiber,update);var root=markUpdateTimeFromFiberToRoot(fiber,Sync);if(root!==null){ensureRootIsScheduled(root);schedulePendingInteractions(root,Sync);}return;}}fiber=fiber.return;}}function pingSuspendedRoot(root,thenable,suspendedTime){var pingCache=root.pingCache;if(pingCache!==null){// The thenable resolved, so we no longer need to memoize, because it will
  // never be thrown again.
  pingCache.delete(thenable);}if(workInProgressRoot===root&&renderExpirationTime$1===suspendedTime){// Received a ping at the same priority level at which we're currently
  // rendering. We might want to restart this render. This should mirror
  // the logic of whether or not a root suspends once it completes.
  // TODO: If we're rendering sync either due to Sync, Batched or expired,
  // we should probably never restart.
  // If we're suspended with delay, we'll always suspend so we can always
  // restart. If we're suspended without any updates, it might be a retry.
  // If it's early in the retry we can restart. We can't know for sure
  // whether we'll eventually process an update during this render pass,
  // but it's somewhat unlikely that we get to a ping before that, since
  // getting to the root most update is usually very fast.
  if(workInProgressRootExitStatus===RootSuspendedWithDelay||workInProgressRootExitStatus===RootSuspended&&workInProgressRootLatestProcessedExpirationTime===Sync&&now()-globalMostRecentFallbackTime<FALLBACK_THROTTLE_MS){// Restart from the root. Don't need to schedule a ping because
  // we're already working on this tree.
  prepareFreshStack(root,renderExpirationTime$1);}else {// Even though we can't restart right now, we might get an
  // opportunity later. So we mark this render as having a ping.
  workInProgressRootHasPendingPing=true;}return;}if(!isRootSuspendedAtTime(root,suspendedTime)){// The root is no longer suspended at this time.
  return;}var lastPingedTime=root.lastPingedTime;if(lastPingedTime!==NoWork&&lastPingedTime<suspendedTime){// There's already a lower priority ping scheduled.
  return;}// Mark the time at which this ping was scheduled.
  root.lastPingedTime=suspendedTime;ensureRootIsScheduled(root);schedulePendingInteractions(root,suspendedTime);}function retryTimedOutBoundary(boundaryFiber,retryTime){// The boundary fiber (a Suspense component or SuspenseList component)
  // previously was rendered in its fallback state. One of the promises that
  // suspended it has resolved, which means at least part of the tree was
  // likely unblocked. Try rendering again, at a new expiration time.
  if(retryTime===NoWork){var suspenseConfig=null;// Retries don't carry over the already committed update.
  var currentTime=requestCurrentTimeForUpdate();retryTime=computeExpirationForFiber(currentTime,boundaryFiber,suspenseConfig);}// TODO: Special case idle priority?
  var root=markUpdateTimeFromFiberToRoot(boundaryFiber,retryTime);if(root!==null){ensureRootIsScheduled(root);schedulePendingInteractions(root,retryTime);}}function resolveRetryThenable(boundaryFiber,thenable){var retryTime=NoWork;// Default
  var retryCache;{retryCache=boundaryFiber.stateNode;}if(retryCache!==null){// The thenable resolved, so we no longer need to memoize, because it will
  // never be thrown again.
  retryCache.delete(thenable);}retryTimedOutBoundary(boundaryFiber,retryTime);}// Computes the next Just Noticeable Difference (JND) boundary.
  // The theory is that a person can't tell the difference between small differences in time.
  // Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
  // difference in the experience. However, waiting for longer might mean that we can avoid
  // showing an intermediate loading state. The longer we have already waited, the harder it
  // is to tell small differences in time. Therefore, the longer we've already waited,
  // the longer we can wait additionally. At some point we have to give up though.
  // We pick a train model where the next boundary commits at a consistent schedule.
  // These particular numbers are vague estimates. We expect to adjust them based on research.
  function jnd(timeElapsed){return timeElapsed<120?120:timeElapsed<480?480:timeElapsed<1080?1080:timeElapsed<1920?1920:timeElapsed<3000?3000:timeElapsed<4320?4320:ceil(timeElapsed/1960)*1960;}function computeMsUntilSuspenseLoadingDelay(mostRecentEventTime,committedExpirationTime,suspenseConfig){var busyMinDurationMs=suspenseConfig.busyMinDurationMs|0;if(busyMinDurationMs<=0){return 0;}var busyDelayMs=suspenseConfig.busyDelayMs|0;// Compute the time until this render pass would expire.
  var currentTimeMs=now();var eventTimeMs=inferTimeFromExpirationTimeWithSuspenseConfig(mostRecentEventTime,suspenseConfig);var timeElapsed=currentTimeMs-eventTimeMs;if(timeElapsed<=busyDelayMs){// If we haven't yet waited longer than the initial delay, we don't
  // have to wait any additional time.
  return 0;}var msUntilTimeout=busyDelayMs+busyMinDurationMs-timeElapsed;// This is the value that is passed to `setTimeout`.
  return msUntilTimeout;}function checkForNestedUpdates(){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){nestedUpdateCount=0;rootWithNestedUpdates=null;{{throw Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");}}}{if(nestedPassiveUpdateCount>NESTED_PASSIVE_UPDATE_LIMIT){nestedPassiveUpdateCount=0;error('Maximum update depth exceeded. This can happen when a component '+"calls setState inside useEffect, but useEffect either doesn't "+'have a dependency array, or one of the dependencies changes on '+'every render.');}}}function flushRenderPhaseStrictModeWarningsInDEV(){{ReactStrictModeWarnings.flushLegacyContextWarning();{ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();}}}function stopFinishedWorkLoopTimer(){var didCompleteRoot=true;stopWorkLoopTimer(interruptedBy,didCompleteRoot);interruptedBy=null;}function stopInterruptedWorkLoopTimer(){// TODO: Track which fiber caused the interruption.
  var didCompleteRoot=false;stopWorkLoopTimer(interruptedBy,didCompleteRoot);interruptedBy=null;}function checkForInterruption(fiberThatReceivedUpdate,updateExpirationTime){if(workInProgressRoot!==null&&updateExpirationTime>renderExpirationTime$1){interruptedBy=fiberThatReceivedUpdate;}}var didWarnStateUpdateForUnmountedComponent=null;function warnAboutUpdateOnUnmountedFiberInDEV(fiber){{var tag=fiber.tag;if(tag!==HostRoot&&tag!==ClassComponent&&tag!==FunctionComponent&&tag!==ForwardRef&&tag!==MemoComponent&&tag!==SimpleMemoComponent&&tag!==Block){// Only warn for user-defined components, not internal ones like Suspense.
  return;}// the problematic code almost always lies inside that component.
  var componentName=getComponentName(fiber.type)||'ReactComponent';if(didWarnStateUpdateForUnmountedComponent!==null){if(didWarnStateUpdateForUnmountedComponent.has(componentName)){return;}didWarnStateUpdateForUnmountedComponent.add(componentName);}else {didWarnStateUpdateForUnmountedComponent=new Set([componentName]);}error("Can't perform a React state update on an unmounted component. This "+'is a no-op, but it indicates a memory leak in your application. To '+'fix, cancel all subscriptions and asynchronous tasks in %s.%s',tag===ClassComponent?'the componentWillUnmount method':'a useEffect cleanup function',getStackByFiberInDevAndProd(fiber));}}var beginWork$1;{var dummyFiber=null;beginWork$1=function(current,unitOfWork,expirationTime){// If a component throws an error, we replay it again in a synchronously
  // dispatched event, so that the debugger will treat it as an uncaught
  // error See ReactErrorUtils for more information.
  // Before entering the begin phase, copy the work-in-progress onto a dummy
  // fiber. If beginWork throws, we'll use this to reset the state.
  var originalWorkInProgressCopy=assignFiberPropertiesInDEV(dummyFiber,unitOfWork);try{return beginWork(current,unitOfWork,expirationTime);}catch(originalError){if(originalError!==null&&typeof originalError==='object'&&typeof originalError.then==='function'){// Don't replay promises. Treat everything else like an error.
  throw originalError;}// Keep this code in sync with handleError; any changes here must have
  // corresponding changes there.
  resetContextDependencies();resetHooksAfterThrow();// Don't reset current debug fiber, since we're about to work on the
  // same fiber again.
  // Unwind the failed stack frame
  unwindInterruptedWork(unitOfWork);// Restore the original properties of the fiber.
  assignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy);if(unitOfWork.mode&ProfileMode){// Reset the profiler timer.
  startProfilerTimer(unitOfWork);}// Run beginWork again.
  invokeGuardedCallback(null,beginWork,null,current,unitOfWork,expirationTime);if(hasCaughtError()){var replayError=clearCaughtError();// `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.
  // Rethrow this error instead of the original one.
  throw replayError;}else {// This branch is reachable if the render phase is impure.
  throw originalError;}}};}var didWarnAboutUpdateInRender=false;var didWarnAboutUpdateInRenderForAnotherComponent;{didWarnAboutUpdateInRenderForAnotherComponent=new Set();}function warnAboutRenderPhaseUpdatesInDEV(fiber){{if(isRendering&&(executionContext&RenderContext)!==NoContext){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{var renderingComponentName=workInProgress&&getComponentName(workInProgress.type)||'Unknown';// Dedupe by the rendering component because it's the one that needs to be fixed.
  var dedupeKey=renderingComponentName;if(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)){didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);var setStateComponentName=getComponentName(fiber.type)||'Unknown';error('Cannot update a component (`%s`) while rendering a '+'different component (`%s`). To locate the bad setState() call inside `%s`, '+'follow the stack trace as described in https://fb.me/setstate-in-render',setStateComponentName,renderingComponentName,renderingComponentName);}break;}case ClassComponent:{if(!didWarnAboutUpdateInRender){error('Cannot update during an existing state transition (such as '+'within `render`). Render methods should be a pure '+'function of props and state.');didWarnAboutUpdateInRender=true;}break;}}}}}// a 'shared' variable that changes when act() opens/closes in tests.
  var IsThisRendererActing={current:false};function warnIfNotScopedWithMatchingAct(fiber){{if(IsSomeRendererActing.current===true&&IsThisRendererActing.current!==true){error("It looks like you're using the wrong act() around your test interactions.\n"+'Be sure to use the matching version of act() corresponding to your renderer:\n\n'+'// for react-dom:\n'+"import {act} from 'react-dom/test-utils';\n"+'// ...\n'+'act(() => ...);\n\n'+'// for react-test-renderer:\n'+"import TestRenderer from 'react-test-renderer';\n"+'const {act} = TestRenderer;\n'+'// ...\n'+'act(() => ...);'+'%s',getStackByFiberInDevAndProd(fiber));}}}function warnIfNotCurrentlyActingEffectsInDEV(fiber){{if((fiber.mode&StrictMode)!==NoMode&&IsSomeRendererActing.current===false&&IsThisRendererActing.current===false){error('An update to %s ran an effect, but was not wrapped in act(...).\n\n'+'When testing, code that causes React state updates should be '+'wrapped into act(...):\n\n'+'act(() => {\n'+'  /* fire events that update state */\n'+'});\n'+'/* assert on the output */\n\n'+"This ensures that you're testing the behavior the user would see "+'in the browser.'+' Learn more at https://fb.me/react-wrap-tests-with-act'+'%s',getComponentName(fiber.type),getStackByFiberInDevAndProd(fiber));}}}function warnIfNotCurrentlyActingUpdatesInDEV(fiber){{if(executionContext===NoContext&&IsSomeRendererActing.current===false&&IsThisRendererActing.current===false){error('An update to %s inside a test was not wrapped in act(...).\n\n'+'When testing, code that causes React state updates should be '+'wrapped into act(...):\n\n'+'act(() => {\n'+'  /* fire events that update state */\n'+'});\n'+'/* assert on the output */\n\n'+"This ensures that you're testing the behavior the user would see "+'in the browser.'+' Learn more at https://fb.me/react-wrap-tests-with-act'+'%s',getComponentName(fiber.type),getStackByFiberInDevAndProd(fiber));}}}var warnIfNotCurrentlyActingUpdatesInDev=warnIfNotCurrentlyActingUpdatesInDEV;// In tests, we want to enforce a mocked scheduler.
  var didWarnAboutUnmockedScheduler=false;// TODO Before we release concurrent mode, revisit this and decide whether a mocked
  // scheduler is the actual recommendation. The alternative could be a testing build,
  // a new lib, or whatever; we dunno just yet. This message is for early adopters
  // to get their tests right.
  function warnIfUnmockedScheduler(fiber){{if(didWarnAboutUnmockedScheduler===false&&Scheduler.unstable_flushAllWithoutAsserting===undefined){if(fiber.mode&BlockingMode||fiber.mode&ConcurrentMode){didWarnAboutUnmockedScheduler=true;error('In Concurrent or Sync modes, the "scheduler" module needs to be mocked '+'to guarantee consistent behaviour across tests and browsers. '+'For example, with jest: \n'+"jest.mock('scheduler', () => require('scheduler/unstable_mock'));\n\n"+'For more info, visit https://fb.me/react-mock-scheduler');}}}}function computeThreadID(root,expirationTime){// Interaction threads are unique per root and expiration time.
  return expirationTime*1000+root.interactionThreadID;}function markSpawnedWork(expirationTime){if(spawnedWorkDuringRender===null){spawnedWorkDuringRender=[expirationTime];}else {spawnedWorkDuringRender.push(expirationTime);}}function scheduleInteractions(root,expirationTime,interactions){if(interactions.size>0){var pendingInteractionMap=root.pendingInteractionMap;var pendingInteractions=pendingInteractionMap.get(expirationTime);if(pendingInteractions!=null){interactions.forEach(function(interaction){if(!pendingInteractions.has(interaction)){// Update the pending async work count for previously unscheduled interaction.
  interaction.__count++;}pendingInteractions.add(interaction);});}else {pendingInteractionMap.set(expirationTime,new Set(interactions));// Update the pending async work count for the current interactions.
  interactions.forEach(function(interaction){interaction.__count++;});}var subscriber=tracing.__subscriberRef.current;if(subscriber!==null){var threadID=computeThreadID(root,expirationTime);subscriber.onWorkScheduled(interactions,threadID);}}}function schedulePendingInteractions(root,expirationTime){scheduleInteractions(root,expirationTime,tracing.__interactionsRef.current);}function startWorkOnPendingInteractions(root,expirationTime){// we can accurately attribute time spent working on it, And so that cascading
  // work triggered during the render phase will be associated with it.
  var interactions=new Set();root.pendingInteractionMap.forEach(function(scheduledInteractions,scheduledExpirationTime){if(scheduledExpirationTime>=expirationTime){scheduledInteractions.forEach(function(interaction){return interactions.add(interaction);});}});// Store the current set of interactions on the FiberRoot for a few reasons:
  // We can re-use it in hot functions like performConcurrentWorkOnRoot()
  // without having to recalculate it. We will also use it in commitWork() to
  // pass to any Profiler onRender() hooks. This also provides DevTools with a
  // way to access it when the onCommitRoot() hook is called.
  root.memoizedInteractions=interactions;if(interactions.size>0){var subscriber=tracing.__subscriberRef.current;if(subscriber!==null){var threadID=computeThreadID(root,expirationTime);try{subscriber.onWorkStarted(interactions,threadID);}catch(error){// If the subscriber throws, rethrow it in a separate task
  scheduleCallback(ImmediatePriority,function(){throw error;});}}}}function finishPendingInteractions(root,committedExpirationTime){var earliestRemainingTimeAfterCommit=root.firstPendingTime;var subscriber;try{subscriber=tracing.__subscriberRef.current;if(subscriber!==null&&root.memoizedInteractions.size>0){var threadID=computeThreadID(root,committedExpirationTime);subscriber.onWorkStopped(root.memoizedInteractions,threadID);}}catch(error){// If the subscriber throws, rethrow it in a separate task
  scheduleCallback(ImmediatePriority,function(){throw error;});}finally{// Clear completed interactions from the pending Map.
  // Unless the render was suspended or cascading work was scheduled,
  // In which case– leave pending interactions until the subsequent render.
  var pendingInteractionMap=root.pendingInteractionMap;pendingInteractionMap.forEach(function(scheduledInteractions,scheduledExpirationTime){// Only decrement the pending interaction count if we're done.
  // If there's still work at the current priority,
  // That indicates that we are waiting for suspense data.
  if(scheduledExpirationTime>earliestRemainingTimeAfterCommit){pendingInteractionMap.delete(scheduledExpirationTime);scheduledInteractions.forEach(function(interaction){interaction.__count--;if(subscriber!==null&&interaction.__count===0){try{subscriber.onInteractionScheduledWorkCompleted(interaction);}catch(error){// If the subscriber throws, rethrow it in a separate task
  scheduleCallback(ImmediatePriority,function(){throw error;});}}});}});}}var onScheduleFiberRoot=null;var onCommitFiberRoot=null;var onCommitFiberUnmount=null;var hasLoggedError=false;var isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined';function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools
  return false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out
  // of DevTools integration and associated warnings and logs.
  // https://github.com/facebook/react/issues/3877
  return true;}if(!hook.supportsFiber){{error('The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://fb.me/react-devtools');}// DevTools exists, even though it doesn't support Fiber.
  return true;}try{var rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.
  if(true){// Only used by Fast Refresh
  if(typeof hook.onScheduleFiberRoot==='function'){onScheduleFiberRoot=function(root,children){try{hook.onScheduleFiberRoot(rendererID,root,children);}catch(err){if(true&&!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}};}}onCommitFiberRoot=function(root,expirationTime){try{var didError=(root.current.effectTag&DidCapture)===DidCapture;if(enableProfilerTimer){var currentTime=getCurrentTime();var priorityLevel=inferPriorityFromExpirationTime(currentTime,expirationTime);hook.onCommitFiberRoot(rendererID,root,priorityLevel,didError);}}catch(err){if(true){if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}};onCommitFiberUnmount=function(fiber){try{hook.onCommitFiberUnmount(rendererID,fiber);}catch(err){if(true){if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}};}catch(err){// Catch all errors because it is unsafe to throw during initialization.
  {error('React instrumentation encountered an error: %s.',err);}}// DevTools exists
  return true;}function onScheduleRoot(root,children){if(typeof onScheduleFiberRoot==='function'){onScheduleFiberRoot(root,children);}}function onCommitRoot(root,expirationTime){if(typeof onCommitFiberRoot==='function'){onCommitFiberRoot(root,expirationTime);}}function onCommitUnmount(fiber){if(typeof onCommitFiberUnmount==='function'){onCommitFiberUnmount(fiber);}}var hasBadMapPolyfill;{hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});var testMap=new Map([[nonExtensibleObject,null]]);var testSet=new Set([nonExtensibleObject]);// This is necessary for Rollup to not consider these unused.
  // https://github.com/rollup/rollup/issues/1771
  // TODO: we can remove these if Rollup fixes the bug.
  testMap.set(0,0);testSet.add(0);}catch(e){// TODO: Consider warning about bad polyfills
  hasBadMapPolyfill=true;}}var debugCounter=1;function FiberNode(tag,pendingProps,key,mode){// Instance
  this.tag=tag;this.key=key;this.elementType=null;this.type=null;this.stateNode=null;// Fiber
  this.return=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=pendingProps;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.dependencies=null;this.mode=mode;// Effects
  this.effectTag=NoEffect;this.nextEffect=null;this.firstEffect=null;this.lastEffect=null;this.expirationTime=NoWork;this.childExpirationTime=NoWork;this.alternate=null;{// Note: The following is done to avoid a v8 performance cliff.
  //
  // Initializing the fields below to smis and later updating them with
  // double values will cause Fibers to end up having separate shapes.
  // This behavior/bug has something to do with Object.preventExtension().
  // Fortunately this only impacts DEV builds.
  // Unfortunately it makes React unusably slow for some applications.
  // To work around this, initialize the fields below with doubles.
  //
  // Learn more about this here:
  // https://github.com/facebook/react/issues/14365
  // https://bugs.chromium.org/p/v8/issues/detail?id=8538
  this.actualDuration=Number.NaN;this.actualStartTime=Number.NaN;this.selfBaseDuration=Number.NaN;this.treeBaseDuration=Number.NaN;// It's okay to replace the initial doubles with smis after initialization.
  // This won't trigger the performance cliff mentioned above,
  // and it simplifies other profiler code (including DevTools).
  this.actualDuration=0;this.actualStartTime=-1;this.selfBaseDuration=0;this.treeBaseDuration=0;}// This is normally DEV-only except www when it adds listeners.
  // TODO: remove the User Timing integration in favor of Root Events.
  {this._debugID=debugCounter++;this._debugIsCurrentlyTiming=false;}{this._debugSource=null;this._debugOwner=null;this._debugNeedsRemount=false;this._debugHookTypes=null;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still
  // please ensure we do the following:
  // 1) Nobody should add any instance methods on this. Instance methods can be
  //    more difficult to predict when they get optimized and they are almost
  //    never inlined properly in static compilers.
  // 2) Nobody should rely on `instanceof Fiber` for type testing. We should
  //    always know when it is a fiber.
  // 3) We might want to experiment with using numeric keys since they are easier
  //    to optimize in a non-JIT environment.
  // 4) We can easily go from a constructor to a createFiber object literal if that
  //    is faster.
  // 5) It should be easy to port this to a C struct and keep a C implementation
  //    compatible.
  var createFiber=function(tag,pendingProps,key,mode){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag,pendingProps,key,mode);};function shouldConstruct(Component){var prototype=Component.prototype;return !!(prototype&&prototype.isReactComponent);}function isSimpleFunctionComponent(type){return typeof type==='function'&&!shouldConstruct(type)&&type.defaultProps===undefined;}function resolveLazyComponentTag(Component){if(typeof Component==='function'){return shouldConstruct(Component)?ClassComponent:FunctionComponent;}else if(Component!==undefined&&Component!==null){var $$typeof=Component.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE){return ForwardRef;}if($$typeof===REACT_MEMO_TYPE){return MemoComponent;}}return IndeterminateComponent;}// This is used to create an alternate fiber to do work on.
  function createWorkInProgress(current,pendingProps){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll
  // only ever need at most two versions of a tree. We pool the "other" unused
  // node that we're free to reuse. This is lazily created to avoid allocating
  // extra objects for things that are never updated. It also allow us to
  // reclaim the extra memory if needed.
  workInProgress=createFiber(current.tag,pendingProps,current.key,current.mode);workInProgress.elementType=current.elementType;workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields
  {workInProgress._debugID=current._debugID;}workInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;workInProgress._debugHookTypes=current._debugHookTypes;}workInProgress.alternate=current;current.alternate=workInProgress;}else {workInProgress.pendingProps=pendingProps;// We already have an alternate.
  // Reset the effect tag.
  workInProgress.effectTag=NoEffect;// The effect list is no longer valid.
  workInProgress.nextEffect=null;workInProgress.firstEffect=null;workInProgress.lastEffect=null;{// We intentionally reset, rather than copy, actualDuration & actualStartTime.
  // This prevents time from endlessly accumulating in new commits.
  // This has the downside of resetting values for different priority renders,
  // But works for yielding (the common case) and should support resuming.
  workInProgress.actualDuration=0;workInProgress.actualStartTime=-1;}}workInProgress.childExpirationTime=current.childExpirationTime;workInProgress.expirationTime=current.expirationTime;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Clone the dependencies object. This is mutated during the render phase, so
  // it cannot be shared with the current fiber.
  var currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{expirationTime:currentDependencies.expirationTime,firstContext:currentDependencies.firstContext,responders:currentDependencies.responders};// These will be overridden during the parent's reconciliation
  workInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;{workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}{workInProgress._debugNeedsRemount=current._debugNeedsRemount;switch(workInProgress.tag){case IndeterminateComponent:case FunctionComponent:case SimpleMemoComponent:workInProgress.type=resolveFunctionForHotReloading(current.type);break;case ClassComponent:workInProgress.type=resolveClassForHotReloading(current.type);break;case ForwardRef:workInProgress.type=resolveForwardRefForHotReloading(current.type);break;}}return workInProgress;}// Used to reuse a Fiber for a second pass.
  function resetWorkInProgress(workInProgress,renderExpirationTime){// This resets the Fiber to what createFiber or createWorkInProgress would
  // have set the values to before during the first pass. Ideally this wouldn't
  // be necessary but unfortunately many code paths reads from the workInProgress
  // when they should be reading from current and writing to workInProgress.
  // We assume pendingProps, index, key, ref, return are still untouched to
  // avoid doing another reconciliation.
  // Reset the effect tag but keep any Placement tags, since that's something
  // that child fiber is setting, not the reconciliation.
  workInProgress.effectTag&=Placement;// The effect list is no longer valid.
  workInProgress.nextEffect=null;workInProgress.firstEffect=null;workInProgress.lastEffect=null;var current=workInProgress.alternate;if(current===null){// Reset to createFiber's initial values.
  workInProgress.childExpirationTime=NoWork;workInProgress.expirationTime=renderExpirationTime;workInProgress.child=null;workInProgress.memoizedProps=null;workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.dependencies=null;{// Note: We don't reset the actualTime counts. It's useful to accumulate
  // actual time across multiple render passes.
  workInProgress.selfBaseDuration=0;workInProgress.treeBaseDuration=0;}}else {// Reset to the cloned values that createWorkInProgress would've.
  workInProgress.childExpirationTime=current.childExpirationTime;workInProgress.expirationTime=current.expirationTime;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Clone the dependencies object. This is mutated during the render phase, so
  // it cannot be shared with the current fiber.
  var currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{expirationTime:currentDependencies.expirationTime,firstContext:currentDependencies.firstContext,responders:currentDependencies.responders};{// Note: We don't reset the actualTime counts. It's useful to accumulate
  // actual time across multiple render passes.
  workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}}return workInProgress;}function createHostRootFiber(tag){var mode;if(tag===ConcurrentRoot){mode=ConcurrentMode|BlockingMode|StrictMode;}else if(tag===BlockingRoot){mode=BlockingMode|StrictMode;}else {mode=NoMode;}if(isDevToolsPresent){// Always collect profile timings when DevTools are present.
  // This enables DevTools to start capturing timing at any point–
  // Without some nodes in the tree having empty base times.
  mode|=ProfileMode;}return createFiber(HostRoot,null,null,mode);}function createFiberFromTypeAndProps(type,// React$ElementType
  key,pendingProps,owner,mode,expirationTime){var fiber;var fiberTag=IndeterminateComponent;// The resolved type is set if we know what the final type will be. I.e. it's not lazy.
  var resolvedType=type;if(typeof type==='function'){if(shouldConstruct(type)){fiberTag=ClassComponent;{resolvedType=resolveClassForHotReloading(resolvedType);}}else {{resolvedType=resolveFunctionForHotReloading(resolvedType);}}}else if(typeof type==='string'){fiberTag=HostComponent;}else {getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,expirationTime,key);case REACT_CONCURRENT_MODE_TYPE:fiberTag=Mode;mode|=ConcurrentMode|BlockingMode|StrictMode;break;case REACT_STRICT_MODE_TYPE:fiberTag=Mode;mode|=StrictMode;break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,expirationTime,key);case REACT_SUSPENSE_TYPE:return createFiberFromSuspense(pendingProps,mode,expirationTime,key);case REACT_SUSPENSE_LIST_TYPE:return createFiberFromSuspenseList(pendingProps,mode,expirationTime,key);default:{if(typeof type==='object'&&type!==null){switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:// This is a consumer
  fiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef;{resolvedType=resolveForwardRefForHotReloading(resolvedType);}break getTag;case REACT_MEMO_TYPE:fiberTag=MemoComponent;break getTag;case REACT_LAZY_TYPE:fiberTag=LazyComponent;resolvedType=null;break getTag;case REACT_BLOCK_TYPE:fiberTag=Block;break getTag;}}var info='';{if(type===undefined||typeof type==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+"it's defined in, or you might have mixed up default and "+'named imports.';}var ownerName=owner?getComponentName(owner.type):null;if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}}{{throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: "+(type==null?type:typeof type)+"."+info);}}}}}fiber=createFiber(fiberTag,pendingProps,key,mode);fiber.elementType=type;fiber.type=resolvedType;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromElement(element,mode,expirationTime){var owner=null;{owner=element._owner;}var type=element.type;var key=element.key;var pendingProps=element.props;var fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,expirationTime);{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}return fiber;}function createFiberFromFragment(elements,mode,expirationTime,key){var fiber=createFiber(Fragment,elements,key,mode);fiber.expirationTime=expirationTime;return fiber;}function createFiberFromProfiler(pendingProps,mode,expirationTime,key){{if(typeof pendingProps.id!=='string'||typeof pendingProps.onRender!=='function'){error('Profiler must specify an "id" string and "onRender" function as props');}}var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);// TODO: The Profiler fiber shouldn't have a type. It has a tag.
  fiber.elementType=REACT_PROFILER_TYPE;fiber.type=REACT_PROFILER_TYPE;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromSuspense(pendingProps,mode,expirationTime,key){var fiber=createFiber(SuspenseComponent,pendingProps,key,mode);// TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
  // This needs to be fixed in getComponentName so that it relies on the tag
  // instead.
  fiber.type=REACT_SUSPENSE_TYPE;fiber.elementType=REACT_SUSPENSE_TYPE;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromSuspenseList(pendingProps,mode,expirationTime,key){var fiber=createFiber(SuspenseListComponent,pendingProps,key,mode);{// TODO: The SuspenseListComponent fiber shouldn't have a type. It has a tag.
  // This needs to be fixed in getComponentName so that it relies on the tag
  // instead.
  fiber.type=REACT_SUSPENSE_LIST_TYPE;}fiber.elementType=REACT_SUSPENSE_LIST_TYPE;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromText(content,mode,expirationTime){var fiber=createFiber(HostText,content,null,mode);fiber.expirationTime=expirationTime;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoMode);// TODO: These should not need a type.
  fiber.elementType='DELETED';fiber.type='DELETED';return fiber;}function createFiberFromPortal(portal,mode,expirationTime){var pendingProps=portal.children!==null?portal.children:[];var fiber=createFiber(HostPortal,pendingProps,portal.key,mode);fiber.expirationTime=expirationTime;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates
  implementation:portal.implementation};return fiber;}// Used for stashing WIP properties to replay failed work in DEV.
  function assignFiberPropertiesInDEV(target,source){if(target===null){// This Fiber's initial properties will always be overwritten.
  // We only use a Fiber to ensure the same hidden class so DEV isn't slow.
  target=createFiber(IndeterminateComponent,null,null,NoMode);}// This is intentionally written as a list of all properties.
  // We tried to use Object.assign() instead but this is called in
  // the hottest path, and Object.assign() was too slow:
  // https://github.com/facebook/react/issues/12502
  // This code is DEV-only so size is not a concern.
  target.tag=source.tag;target.key=source.key;target.elementType=source.elementType;target.type=source.type;target.stateNode=source.stateNode;target.return=source.return;target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.dependencies=source.dependencies;target.mode=source.mode;target.effectTag=source.effectTag;target.nextEffect=source.nextEffect;target.firstEffect=source.firstEffect;target.lastEffect=source.lastEffect;target.expirationTime=source.expirationTime;target.childExpirationTime=source.childExpirationTime;target.alternate=source.alternate;{target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseDuration=source.selfBaseDuration;target.treeBaseDuration=source.treeBaseDuration;}{target._debugID=source._debugID;}target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugIsCurrentlyTiming=source._debugIsCurrentlyTiming;target._debugNeedsRemount=source._debugNeedsRemount;target._debugHookTypes=source._debugHookTypes;return target;}function FiberRootNode(containerInfo,tag,hydrate){this.tag=tag;this.current=null;this.containerInfo=containerInfo;this.pendingChildren=null;this.pingCache=null;this.finishedExpirationTime=NoWork;this.finishedWork=null;this.timeoutHandle=noTimeout;this.context=null;this.pendingContext=null;this.hydrate=hydrate;this.callbackNode=null;this.callbackPriority=NoPriority;this.firstPendingTime=NoWork;this.firstSuspendedTime=NoWork;this.lastSuspendedTime=NoWork;this.nextKnownPendingLevel=NoWork;this.lastPingedTime=NoWork;this.lastExpiredTime=NoWork;{this.interactionThreadID=tracing.unstable_getThreadID();this.memoizedInteractions=new Set();this.pendingInteractionMap=new Map();}}function createFiberRoot(containerInfo,tag,hydrate,hydrationCallbacks){var root=new FiberRootNode(containerInfo,tag,hydrate);// stateNode is any.
  var uninitializedFiber=createHostRootFiber(tag);root.current=uninitializedFiber;uninitializedFiber.stateNode=root;initializeUpdateQueue(uninitializedFiber);return root;}function isRootSuspendedAtTime(root,expirationTime){var firstSuspendedTime=root.firstSuspendedTime;var lastSuspendedTime=root.lastSuspendedTime;return firstSuspendedTime!==NoWork&&firstSuspendedTime>=expirationTime&&lastSuspendedTime<=expirationTime;}function markRootSuspendedAtTime(root,expirationTime){var firstSuspendedTime=root.firstSuspendedTime;var lastSuspendedTime=root.lastSuspendedTime;if(firstSuspendedTime<expirationTime){root.firstSuspendedTime=expirationTime;}if(lastSuspendedTime>expirationTime||firstSuspendedTime===NoWork){root.lastSuspendedTime=expirationTime;}if(expirationTime<=root.lastPingedTime){root.lastPingedTime=NoWork;}if(expirationTime<=root.lastExpiredTime){root.lastExpiredTime=NoWork;}}function markRootUpdatedAtTime(root,expirationTime){// Update the range of pending times
  var firstPendingTime=root.firstPendingTime;if(expirationTime>firstPendingTime){root.firstPendingTime=expirationTime;}// Update the range of suspended times. Treat everything lower priority or
  // equal to this update as unsuspended.
  var firstSuspendedTime=root.firstSuspendedTime;if(firstSuspendedTime!==NoWork){if(expirationTime>=firstSuspendedTime){// The entire suspended range is now unsuspended.
  root.firstSuspendedTime=root.lastSuspendedTime=root.nextKnownPendingLevel=NoWork;}else if(expirationTime>=root.lastSuspendedTime){root.lastSuspendedTime=expirationTime+1;}// This is a pending level. Check if it's higher priority than the next
  // known pending level.
  if(expirationTime>root.nextKnownPendingLevel){root.nextKnownPendingLevel=expirationTime;}}}function markRootFinishedAtTime(root,finishedExpirationTime,remainingExpirationTime){// Update the range of pending times
  root.firstPendingTime=remainingExpirationTime;// Update the range of suspended times. Treat everything higher priority or
  // equal to this update as unsuspended.
  if(finishedExpirationTime<=root.lastSuspendedTime){// The entire suspended range is now unsuspended.
  root.firstSuspendedTime=root.lastSuspendedTime=root.nextKnownPendingLevel=NoWork;}else if(finishedExpirationTime<=root.firstSuspendedTime){// Part of the suspended range is now unsuspended. Narrow the range to
  // include everything between the unsuspended time (non-inclusive) and the
  // last suspended time.
  root.firstSuspendedTime=finishedExpirationTime-1;}if(finishedExpirationTime<=root.lastPingedTime){// Clear the pinged time
  root.lastPingedTime=NoWork;}if(finishedExpirationTime<=root.lastExpiredTime){// Clear the expired time
  root.lastExpiredTime=NoWork;}}function markRootExpiredAtTime(root,expirationTime){var lastExpiredTime=root.lastExpiredTime;if(lastExpiredTime===NoWork||lastExpiredTime>expirationTime){root.lastExpiredTime=expirationTime;}}var didWarnAboutNestedUpdates;var didWarnAboutFindNodeInStrictMode;{didWarnAboutNestedUpdates=false;didWarnAboutFindNodeInStrictMode={};}function getContextForSubtree(parentComponent){if(!parentComponent){return emptyContextObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component)){return processChildContext(fiber,Component,parentContext);}}return parentContext;}function findHostInstanceWithWarning(component,methodName){{var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){{{throw Error("Unable to find node on an unmounted component.");}}}else {{{throw Error("Argument appears to not be a ReactComponent. Keys: "+Object.keys(component));}}}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}if(hostFiber.mode&StrictMode){var componentName=getComponentName(fiber.type)||'Component';if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=true;if(fiber.mode&StrictMode){error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which is inside StrictMode. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://fb.me/react-strict-mode-find-node%s',methodName,methodName,componentName,getStackByFiberInDevAndProd(hostFiber));}else {error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which renders StrictMode children. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://fb.me/react-strict-mode-find-node%s',methodName,methodName,componentName,getStackByFiberInDevAndProd(hostFiber));}}}return hostFiber.stateNode;}}function createContainer(containerInfo,tag,hydrate,hydrationCallbacks){return createFiberRoot(containerInfo,tag,hydrate);}function updateContainer(element,container,parentComponent,callback){{onScheduleRoot(container,element);}var current$1=container.current;var currentTime=requestCurrentTimeForUpdate();{// $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
  if('undefined'!==typeof jest){warnIfUnmockedScheduler(current$1);warnIfNotScopedWithMatchingAct(current$1);}}var suspenseConfig=requestCurrentSuspenseConfig();var expirationTime=computeExpirationForFiber(currentTime,current$1,suspenseConfig);var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else {container.pendingContext=context;}{if(isRendering&&current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;error('Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\n\n'+'Check the render method of %s.',getComponentName(current.type)||'Unknown');}}var update=createUpdate(expirationTime,suspenseConfig);// Caution: React DevTools currently depends on this property
  // being called "element".
  update.payload={element:element};callback=callback===undefined?null:callback;if(callback!==null){{if(typeof callback!=='function'){error('render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}}update.callback=callback;}enqueueUpdate(current$1,update);scheduleWork(current$1,expirationTime);return expirationTime;}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}}function markRetryTimeImpl(fiber,retryTime){var suspenseState=fiber.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){if(suspenseState.retryTime<retryTime){suspenseState.retryTime=retryTime;}}}// Increases the priority of thennables when they resolve within this boundary.
  function markRetryTimeIfNotHydrated(fiber,retryTime){markRetryTimeImpl(fiber,retryTime);var alternate=fiber.alternate;if(alternate){markRetryTimeImpl(alternate,retryTime);}}function attemptUserBlockingHydration$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase
  // their priority and they should not suspend on I/O,
  // since you have to wrap anything that might suspend in
  // Suspense.
  return;}var expTime=computeInteractiveExpiration(requestCurrentTimeForUpdate());scheduleWork(fiber,expTime);markRetryTimeIfNotHydrated(fiber,expTime);}function attemptContinuousHydration$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase
  // their priority and they should not suspend on I/O,
  // since you have to wrap anything that might suspend in
  // Suspense.
  return;}scheduleWork(fiber,ContinuousHydration);markRetryTimeIfNotHydrated(fiber,ContinuousHydration);}function attemptHydrationAtCurrentPriority$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase
  // their priority other than synchronously flush it.
  return;}var currentTime=requestCurrentTimeForUpdate();var expTime=computeExpirationForFiber(currentTime,fiber,null);scheduleWork(fiber,expTime);markRetryTimeIfNotHydrated(fiber,expTime);}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}if(hostFiber.tag===FundamentalComponent){return hostFiber.stateNode.instance;}return hostFiber.stateNode;}var shouldSuspendImpl=function(fiber){return false;};function shouldSuspend(fiber){return shouldSuspendImpl(fiber);}var overrideHookState=null;var overrideProps=null;var scheduleUpdate=null;var setSuspenseHandler=null;{var copyWithSetImpl=function(obj,path,idx,value){if(idx>=path.length){return value;}var key=path[idx];var updated=Array.isArray(obj)?obj.slice():_assign({},obj);// $FlowFixMe number or string is fine here
  updated[key]=copyWithSetImpl(obj[key],path,idx+1,value);return updated;};var copyWithSet=function(obj,path,value){return copyWithSetImpl(obj,path,0,value);};// Support DevTools editable values for useState and useReducer.
  overrideHookState=function(fiber,id,path,value){// For now, the "id" of stateful hooks is just the stateful hook index.
  // This may change in the future with e.g. nested hooks.
  var currentHook=fiber.memoizedState;while(currentHook!==null&&id>0){currentHook=currentHook.next;id--;}if(currentHook!==null){var newState=copyWithSet(currentHook.memoizedState,path,value);currentHook.memoizedState=newState;currentHook.baseState=newState;// We aren't actually adding an update to the queue,
  // because there is no update we can add for useReducer hooks that won't trigger an error.
  // (There's no appropriate action type for DevTools overrides.)
  // As a result though, React will see the scheduled update as a noop and bailout.
  // Shallow cloning props works as a workaround for now to bypass the bailout check.
  fiber.memoizedProps=_assign({},fiber.memoizedProps);scheduleWork(fiber,Sync);}};// Support DevTools props for function components, forwardRef, memo, host components, etc.
  overrideProps=function(fiber,path,value){fiber.pendingProps=copyWithSet(fiber.memoizedProps,path,value);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}scheduleWork(fiber,Sync);};scheduleUpdate=function(fiber){scheduleWork(fiber,Sync);};setSuspenseHandler=function(newShouldSuspendImpl){shouldSuspendImpl=newShouldSuspendImpl;};}function injectIntoDevTools(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;return injectInternals(_assign({},devToolsConfig,{overrideHookState:overrideHookState,overrideProps:overrideProps,setSuspenseHandler:setSuspenseHandler,scheduleUpdate:scheduleUpdate,currentDispatcherRef:ReactCurrentDispatcher,findHostInstanceByFiber:function(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;},findFiberByHostInstance:function(instance){if(!findFiberByHostInstance){// Might not be implemented by the renderer.
  return null;}return findFiberByHostInstance(instance);},// React Refresh
  findHostInstancesForRefresh:findHostInstancesForRefresh,scheduleRefresh:scheduleRefresh,scheduleRoot:scheduleRoot,setRefreshHandler:setRefreshHandler,// Enables DevTools to append owner stacks to error messages in DEV mode.
  getCurrentFiber:function(){return current;}}));}ReactSharedInternals.IsSomeRendererActing;function ReactDOMBlockingRoot(container,tag,options){this._internalRoot=createRootImpl(container,tag,options);}ReactDOMBlockingRoot.prototype.render=function(children){var root=this._internalRoot;{if(typeof arguments[1]==='function'){error('render(...): does not support the second callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}var container=root.containerInfo;if(container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(root.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of the '+'root container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+"root.unmount() to empty a root's container.");}}}}updateContainer(children,root,null,null);};ReactDOMBlockingRoot.prototype.unmount=function(){{if(typeof arguments[0]==='function'){error('unmount(...): does not support a callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}}var root=this._internalRoot;var container=root.containerInfo;updateContainer(null,root,null,function(){unmarkContainerAsRoot(container);});};function createRootImpl(container,tag,options){// Tag is either LegacyRoot or Concurrent Root
  var hydrate=options!=null&&options.hydrate===true;options!=null&&options.hydrationOptions||null;var root=createContainer(container,tag,hydrate);markContainerAsRoot(root.current,container);if(hydrate&&tag!==LegacyRoot){var doc=container.nodeType===DOCUMENT_NODE?container:container.ownerDocument;eagerlyTrapReplayableEvents(container,doc);}return root;}function createLegacyRoot(container,options){return new ReactDOMBlockingRoot(container,LegacyRoot,options);}function isValidContainer(node){return !!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}var ReactCurrentOwner$3=ReactSharedInternals.ReactCurrentOwner;var topLevelUpdateWarnings;var warnedAboutHydrateAPI=false;{topLevelUpdateWarnings=function(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode$1(rootEl));if(hasNonRootReactChild&&!isRootRenderedBySomeReact){error('render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');}if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}};}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else {return container.firstChild;}}function shouldHydrateDueToLegacyHeuristic(container){var rootElement=getReactRootElementInContainer(container);return !!(rootElement&&rootElement.nodeType===ELEMENT_NODE&&rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));}function legacyCreateRootFromDOMContainer(container,forceHydrate){var shouldHydrate=forceHydrate||shouldHydrateDueToLegacyHeuristic(container);// First clear any existing content.
  if(!shouldHydrate){var warned=false;var rootSibling;while(rootSibling=container.lastChild){{if(!warned&&rootSibling.nodeType===ELEMENT_NODE&&rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)){warned=true;error('render(): Target node has markup rendered by React, but there '+'are unrelated nodes as well. This is most commonly caused by '+'white-space inserted around server-rendered markup.');}}container.removeChild(rootSibling);}}{if(shouldHydrate&&!forceHydrate&&!warnedAboutHydrateAPI){warnedAboutHydrateAPI=true;warn('render(): Calling ReactDOM.render() to hydrate server-rendered markup '+'will stop working in React v17. Replace the ReactDOM.render() call '+'with ReactDOM.hydrate() if you want React to attach to the server HTML.');}}return createLegacyRoot(container,shouldHydrate?{hydrate:true}:undefined);}function warnOnInvalidCallback$1(callback,callerName){{if(callback!==null&&typeof callback!=='function'){error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}}}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){{topLevelUpdateWarnings(container);warnOnInvalidCallback$1(callback===undefined?null:callback,'render');}// TODO: Without `any` type, Flow says "Property cannot be accessed on any
  // member of intersection type." Whyyyyyy.
  var root=container._reactRootContainer;var fiberRoot;if(!root){// Initial mount
  root=container._reactRootContainer=legacyCreateRootFromDOMContainer(container,forceHydrate);fiberRoot=root._internalRoot;if(typeof callback==='function'){var originalCallback=callback;callback=function(){var instance=getPublicRootInstance(fiberRoot);originalCallback.call(instance);};}// Initial mount should not be batched.
  unbatchedUpdates(function(){updateContainer(children,fiberRoot,parentComponent,callback);});}else {fiberRoot=root._internalRoot;if(typeof callback==='function'){var _originalCallback=callback;callback=function(){var instance=getPublicRootInstance(fiberRoot);_originalCallback.call(instance);};}// Update
  updateContainer(children,fiberRoot,parentComponent,callback);}return getPublicRootInstance(fiberRoot);}function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner$3.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;if(!warnedAboutRefsInRender){error('%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(owner.type)||'A component');}owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}{return findHostInstanceWithWarning(componentOrElement,'findDOMNode');}}function hydrate(element,container,callback){if(!isValidContainer(container)){{throw Error("Target container is not a DOM element.");}}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.hydrate() on a container that was previously '+'passed to ReactDOM.createRoot(). This is not supported. '+'Did you mean to call createRoot(container, {hydrate: true}).render(element)?');}}// TODO: throw or warn if we couldn't hydrate?
  return legacyRenderSubtreeIntoContainer(null,element,container,true,callback);}function render(element,container,callback){if(!isValidContainer(container)){{throw Error("Target container is not a DOM element.");}}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.render() on a container that was previously '+'passed to ReactDOM.createRoot(). This is not supported. '+'Did you mean to call root.render(element)?');}}return legacyRenderSubtreeIntoContainer(null,element,container,false,callback);}function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){if(!isValidContainer(containerNode)){{throw Error("Target container is not a DOM element.");}}if(!(parentComponent!=null&&has(parentComponent))){{throw Error("parentComponent must be a valid React Component");}}return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);}function unmountComponentAtNode(container){if(!isValidContainer(container)){{throw Error("unmountComponentAtNode(...): Target container is not a DOM element.");}}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously '+'passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?');}}if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode$1(rootEl);if(renderedByDifferentReact){error("unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by another copy of React.');}}// Unmount should not be batched.
  unbatchedUpdates(function(){legacyRenderSubtreeIntoContainer(null,null,container,false,function(){// $FlowFixMe This should probably use `delete container._reactRootContainer`
  container._reactRootContainer=null;unmarkContainerAsRoot(container);});});// If you call unmountComponentAtNode twice in quick succession, you'll
  // get `true` twice. That's probably fine?
  return true;}else {{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode$1(_rootEl));// Check if the container itself is a React root node.
  var isContainerReactRoot=container.nodeType===ELEMENT_NODE&&isValidContainer(container.parentNode)&&!!container.parentNode._reactRootContainer;if(hasNonRootReactChild){error("unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}}return false;}}function createPortal(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.
  implementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;return {// This tag allow us to uniquely identify this as a React Portal
  $$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}var ReactVersion='16.14.0';setAttemptUserBlockingHydration(attemptUserBlockingHydration$1);setAttemptContinuousHydration(attemptContinuousHydration$1);setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);var didWarnAboutUnstableCreatePortal=false;{if(typeof Map!=='function'||// $FlowIssue Flow incorrectly thinks Map has no prototype
  Map.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||// $FlowIssue Flow incorrectly thinks Set has no prototype
  Set.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){error('React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. https://fb.me/react-polyfills');}}setRestoreImplementation(restoreControlledState$3);setBatchingImplementation(batchedUpdates$1,discreteUpdates$1,flushDiscreteUpdates,batchedEventUpdates$1);function createPortal$1(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(!isValidContainer(container)){{throw Error("Target container is not a DOM element.");}}// TODO: pass ReactDOM portal implementation as third argument
  // $FlowFixMe The Flow type is opaque but there's no way to actually create it.
  return createPortal(children,container,null,key);}function renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){return unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback);}function unstable_createPortal(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;{if(!didWarnAboutUnstableCreatePortal){didWarnAboutUnstableCreatePortal=true;warn('The ReactDOM.unstable_createPortal() alias has been deprecated, '+'and will be removed in React 17+. Update your code to use '+'ReactDOM.createPortal() instead. It has the exact same API, '+'but without the "unstable_" prefix.');}}return createPortal$1(children,container,key);}var Internals={// Keep in sync with ReactDOMUnstableNativeDependencies.js
  // ReactTestUtils.js, and ReactTestUtilsAct.js. This is an array for better minification.
  Events:[getInstanceFromNode$1,getNodeFromInstance$1,getFiberCurrentPropsFromNode$1,injectEventPluginsByName,eventNameDispatchConfigs,accumulateTwoPhaseDispatches,accumulateDirectDispatches,enqueueStateRestore,restoreStateIfNeeded,dispatchEvent,runEventsInBatch,flushPassiveEffects,IsThisRendererActing]};var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.
  if(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.
  if(/^(https?|file):$/.test(protocol)){// eslint-disable-next-line react-internal/no-production-logging
  console.info('%cDownload the React DevTools '+'for a better development experience: '+'https://fb.me/react-devtools'+(protocol==='file:'?'\nYou might need to use a local HTTP server (instead of file://): '+'https://fb.me/react-devtools-faq':''),'font-weight:bold');}}}}reactDom_development.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Internals;reactDom_development.createPortal=createPortal$1;reactDom_development.findDOMNode=findDOMNode;reactDom_development.flushSync=flushSync;reactDom_development.hydrate=hydrate;reactDom_development.render=render;reactDom_development.unmountComponentAtNode=unmountComponentAtNode;reactDom_development.unstable_batchedUpdates=batchedUpdates$1;reactDom_development.unstable_createPortal=unstable_createPortal;reactDom_development.unstable_renderSubtreeIntoContainer=renderSubtreeIntoContainer;reactDom_development.version=ReactVersion;})();}

  {
    reactDom.exports = reactDom_development;
  }
  var reactDomExports = reactDom.exports;
  var ReactDOM = /*@__PURE__*/getDefaultExportFromCjs(reactDomExports);

  // based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js
  var hadKeyboardEvent = true;
  var hadFocusVisibleRecently = false;
  var hadFocusVisibleRecentlyTimeout = null;
  var inputTypesWhitelist = {
    text: true,
    search: true,
    url: true,
    tel: true,
    email: true,
    password: true,
    number: true,
    date: true,
    month: true,
    week: true,
    time: true,
    datetime: true,
    'datetime-local': true
  };
  /**
   * Computes whether the given element should automatically trigger the
   * `focus-visible` class being added, i.e. whether it should always match
   * `:focus-visible` when focused.
   * @param {Element} node
   * @return {boolean}
   */

  function focusTriggersKeyboardModality(node) {
    var type = node.type,
      tagName = node.tagName;
    if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {
      return true;
    }
    if (tagName === 'TEXTAREA' && !node.readOnly) {
      return true;
    }
    if (node.isContentEditable) {
      return true;
    }
    return false;
  }
  /**
   * Keep track of our keyboard modality state with `hadKeyboardEvent`.
   * If the most recent user interaction was via the keyboard;
   * and the key press did not include a meta, alt/option, or control key;
   * then the modality is keyboard. Otherwise, the modality is not keyboard.
   * @param {KeyboardEvent} event
   */

  function handleKeyDown(event) {
    if (event.metaKey || event.altKey || event.ctrlKey) {
      return;
    }
    hadKeyboardEvent = true;
  }
  /**
   * If at any point a user clicks with a pointing device, ensure that we change
   * the modality away from keyboard.
   * This avoids the situation where a user presses a key on an already focused
   * element, and then clicks on a different element, focusing it with a
   * pointing device, while we still think we're in keyboard modality.
   */

  function handlePointerDown() {
    hadKeyboardEvent = false;
  }
  function handleVisibilityChange() {
    if (this.visibilityState === 'hidden') {
      // If the tab becomes active again, the browser will handle calling focus
      // on the element (Safari actually calls it twice).
      // If this tab change caused a blur on an element with focus-visible,
      // re-apply the class when the user switches back to the tab.
      if (hadFocusVisibleRecently) {
        hadKeyboardEvent = true;
      }
    }
  }
  function prepare(doc) {
    doc.addEventListener('keydown', handleKeyDown, true);
    doc.addEventListener('mousedown', handlePointerDown, true);
    doc.addEventListener('pointerdown', handlePointerDown, true);
    doc.addEventListener('touchstart', handlePointerDown, true);
    doc.addEventListener('visibilitychange', handleVisibilityChange, true);
  }
  function isFocusVisible(event) {
    var target = event.target;
    try {
      return target.matches(':focus-visible');
    } catch (error) {} // browsers not implementing :focus-visible will throw a SyntaxError
    // we use our own heuristic for those browsers
    // rethrow might be better if it's not the expected error but do we really
    // want to crash if focus-visible malfunctioned?
    // no need for validFocusTarget check. the user does that by attaching it to
    // focusable events only

    return hadKeyboardEvent || focusTriggersKeyboardModality(target);
  }
  /**
   * Should be called if a blur event is fired on a focus-visible element
   */

  function handleBlurVisible() {
    // To detect a tab/window switch, we look for a blur event followed
    // rapidly by a visibility change.
    // If we don't see a visibility change within 100ms, it's probably a
    // regular focus change.
    hadFocusVisibleRecently = true;
    window.clearTimeout(hadFocusVisibleRecentlyTimeout);
    hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {
      hadFocusVisibleRecently = false;
    }, 100);
  }
  function useIsFocusVisible() {
    var ref = reactExports.useCallback(function (instance) {
      var node = reactDomExports.findDOMNode(instance);
      if (node != null) {
        prepare(node.ownerDocument);
      }
    }, []);
    {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      reactExports.useDebugValue(isFocusVisible);
    }
    return {
      isFocusVisible: isFocusVisible,
      onBlurVisible: handleBlurVisible,
      ref: ref
    };
  }

  var config = {
    disabled: false
  };

  var timeoutsShape = PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    enter: PropTypes.number,
    exit: PropTypes.number,
    appear: PropTypes.number
  }).isRequired]) ;
  PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
    enter: PropTypes.string,
    exit: PropTypes.string,
    active: PropTypes.string
  }), PropTypes.shape({
    enter: PropTypes.string,
    enterDone: PropTypes.string,
    enterActive: PropTypes.string,
    exit: PropTypes.string,
    exitDone: PropTypes.string,
    exitActive: PropTypes.string
  })]) ;

  var TransitionGroupContext = React.createContext(null);

  var forceReflow = function forceReflow(node) {
    return node.scrollTop;
  };

  var UNMOUNTED = 'unmounted';
  var EXITED = 'exited';
  var ENTERING = 'entering';
  var ENTERED = 'entered';
  var EXITING = 'exiting';
  /**
   * The Transition component lets you describe a transition from one component
   * state to another _over time_ with a simple declarative API. Most commonly
   * it's used to animate the mounting and unmounting of a component, but can also
   * be used to describe in-place transition states as well.
   *
   * ---
   *
   * **Note**: `Transition` is a platform-agnostic base component. If you're using
   * transitions in CSS, you'll probably want to use
   * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
   * instead. It inherits all the features of `Transition`, but contains
   * additional features necessary to play nice with CSS transitions (hence the
   * name of the component).
   *
   * ---
   *
   * By default the `Transition` component does not alter the behavior of the
   * component it renders, it only tracks "enter" and "exit" states for the
   * components. It's up to you to give meaning and effect to those states. For
   * example we can add styles to a component when it enters or exits:
   *
   * ```jsx
   * import { Transition } from 'react-transition-group';
   *
   * const duration = 300;
   *
   * const defaultStyle = {
   *   transition: `opacity ${duration}ms ease-in-out`,
   *   opacity: 0,
   * }
   *
   * const transitionStyles = {
   *   entering: { opacity: 1 },
   *   entered:  { opacity: 1 },
   *   exiting:  { opacity: 0 },
   *   exited:  { opacity: 0 },
   * };
   *
   * const Fade = ({ in: inProp }) => (
   *   <Transition in={inProp} timeout={duration}>
   *     {state => (
   *       <div style={{
   *         ...defaultStyle,
   *         ...transitionStyles[state]
   *       }}>
   *         I'm a fade Transition!
   *       </div>
   *     )}
   *   </Transition>
   * );
   * ```
   *
   * There are 4 main states a Transition can be in:
   *  - `'entering'`
   *  - `'entered'`
   *  - `'exiting'`
   *  - `'exited'`
   *
   * Transition state is toggled via the `in` prop. When `true` the component
   * begins the "Enter" stage. During this stage, the component will shift from
   * its current transition state, to `'entering'` for the duration of the
   * transition and then to the `'entered'` stage once it's complete. Let's take
   * the following example (we'll use the
   * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
   *
   * ```jsx
   * function App() {
   *   const [inProp, setInProp] = useState(false);
   *   return (
   *     <div>
   *       <Transition in={inProp} timeout={500}>
   *         {state => (
   *           // ...
   *         )}
   *       </Transition>
   *       <button onClick={() => setInProp(true)}>
   *         Click to Enter
   *       </button>
   *     </div>
   *   );
   * }
   * ```
   *
   * When the button is clicked the component will shift to the `'entering'` state
   * and stay there for 500ms (the value of `timeout`) before it finally switches
   * to `'entered'`.
   *
   * When `in` is `false` the same thing happens except the state moves from
   * `'exiting'` to `'exited'`.
   */

  var Transition = /*#__PURE__*/function (_React$Component) {
    _inheritsLoose(Transition, _React$Component);
    function Transition(props, context) {
      var _this;
      _this = _React$Component.call(this, props, context) || this;
      var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;
      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }
      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }
    Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;
      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }
      return null;
    } // getSnapshotBeforeUpdate(prevProps) {
    //   let nextStatus = null
    //   if (prevProps !== this.props) {
    //     const { status } = this.state
    //     if (this.props.in) {
    //       if (status !== ENTERING && status !== ENTERED) {
    //         nextStatus = ENTERING
    //       }
    //     } else {
    //       if (status === ENTERING || status === ENTERED) {
    //         nextStatus = EXITING
    //       }
    //     }
    //   }
    //   return { nextStatus }
    // }
    ;

    var _proto = Transition.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;
      if (prevProps !== this.props) {
        var status = this.state.status;
        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }
      this.updateStatus(false, nextStatus);
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };
    _proto.getTimeouts = function getTimeouts() {
      var timeout = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout;
      if (timeout != null && typeof timeout !== 'number') {
        exit = timeout.exit;
        enter = timeout.enter; // TODO: remove fallback for next major

        appear = timeout.appear !== undefined ? timeout.appear : enter;
      }
      return {
        exit: exit,
        enter: enter,
        appear: appear
      };
    };
    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }
      if (nextStatus !== null) {
        // nextStatus will always be ENTERING or EXITING.
        this.cancelNextCallback();
        if (nextStatus === ENTERING) {
          if (this.props.unmountOnExit || this.props.mountOnEnter) {
            var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this); // https://github.com/reactjs/react-transition-group/pull/749
            // With unmountOnExit or mountOnEnter, the enter animation should happen at the transition between `exited` and `entering`.
            // To make the animation happen,  we have to separate each rendering and avoid being processed as batched.

            if (node) forceReflow(node);
          }
          this.performEnter(mounting);
        } else {
          this.performExit();
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };
    _proto.performEnter = function performEnter(mounting) {
      var _this2 = this;
      var enter = this.props.enter;
      var appearing = this.context ? this.context.isMounting : mounting;
      var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing],
        maybeNode = _ref2[0],
        maybeAppearing = _ref2[1];
      var timeouts = this.getTimeouts();
      var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
      // if we are mounting and running this it means appear _must_ be set

      if (!mounting && !enter || config.disabled) {
        this.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(maybeNode);
        });
        return;
      }
      this.props.onEnter(maybeNode, maybeAppearing);
      this.safeSetState({
        status: ENTERING
      }, function () {
        _this2.props.onEntering(maybeNode, maybeAppearing);
        _this2.onTransitionEnd(enterTimeout, function () {
          _this2.safeSetState({
            status: ENTERED
          }, function () {
            _this2.props.onEntered(maybeNode, maybeAppearing);
          });
        });
      });
    };
    _proto.performExit = function performExit() {
      var _this3 = this;
      var exit = this.props.exit;
      var timeouts = this.getTimeouts();
      var maybeNode = this.props.nodeRef ? undefined : ReactDOM.findDOMNode(this); // no exit animation skip right to EXITED

      if (!exit || config.disabled) {
        this.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(maybeNode);
        });
        return;
      }
      this.props.onExit(maybeNode);
      this.safeSetState({
        status: EXITING
      }, function () {
        _this3.props.onExiting(maybeNode);
        _this3.onTransitionEnd(timeouts.exit, function () {
          _this3.safeSetState({
            status: EXITED
          }, function () {
            _this3.props.onExited(maybeNode);
          });
        });
      });
    };
    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };
    _proto.safeSetState = function safeSetState(nextState, callback) {
      // This shouldn't be necessary, but there are weird race conditions with
      // setState callbacks and unmounting in testing, so always make sure that
      // we can cancel any pending setState callbacks after we unmount.
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };
    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;
      var active = true;
      this.nextCallback = function (event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };
      this.nextCallback.cancel = function () {
        active = false;
      };
      return this.nextCallback;
    };
    _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
      this.setNextCallback(handler);
      var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
      var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
      if (!node || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
          maybeNode = _ref3[0],
          maybeNextCallback = _ref3[1];
        this.props.addEndListener(maybeNode, maybeNextCallback);
      }
      if (timeout != null) {
        setTimeout(this.nextCallback, timeout);
      }
    };
    _proto.render = function render() {
      var status = this.state.status;
      if (status === UNMOUNTED) {
        return null;
      }
      var _this$props = this.props,
        children = _this$props.children;
        _this$props.in;
        _this$props.mountOnEnter;
        _this$props.unmountOnExit;
        _this$props.appear;
        _this$props.enter;
        _this$props.exit;
        _this$props.timeout;
        _this$props.addEndListener;
        _this$props.onEnter;
        _this$props.onEntering;
        _this$props.onEntered;
        _this$props.onExit;
        _this$props.onExiting;
        _this$props.onExited;
        _this$props.nodeRef;
        var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return /*#__PURE__*/(
        // allows for nested Transitions
        React.createElement(TransitionGroupContext.Provider, {
          value: null
        }, typeof children === 'function' ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
      );
    };
    return Transition;
  }(React.Component);
  Transition.contextType = TransitionGroupContext;
  Transition.propTypes = {
    /**
     * A React reference to DOM element that need to transition:
     * https://stackoverflow.com/a/51127130/4671932
     *
     *   - When `nodeRef` prop is used, `node` is not passed to callback functions
     *      (e.g. `onEnter`) because user already has direct access to the node.
     *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
     *     `nodeRef` need to be provided to `Transition` with changed `key` prop
     *     (see
     *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
     */
    nodeRef: PropTypes.shape({
      current: typeof Element === 'undefined' ? PropTypes.any : function (propValue, key, componentName, location, propFullName, secret) {
        var value = propValue[key];
        return PropTypes.instanceOf(value && 'ownerDocument' in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
      }
    }),
    /**
     * A `function` child can be used instead of a React element. This function is
     * called with the current transition status (`'entering'`, `'entered'`,
     * `'exiting'`, `'exited'`), which can be used to apply context
     * specific props to a component.
     *
     * ```jsx
     * <Transition in={this.state.in} timeout={150}>
     *   {state => (
     *     <MyComponent className={`fade fade-${state}`} />
     *   )}
     * </Transition>
     * ```
     */
    children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,
    /**
     * Show the component; triggers the enter or exit states
     */
    in: PropTypes.bool,
    /**
     * By default the child component is mounted immediately along with
     * the parent `Transition` component. If you want to "lazy mount" the component on the
     * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
     * mounted, even on "exited", unless you also specify `unmountOnExit`.
     */
    mountOnEnter: PropTypes.bool,
    /**
     * By default the child component stays mounted after it reaches the `'exited'` state.
     * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
     */
    unmountOnExit: PropTypes.bool,
    /**
     * By default the child component does not perform the enter transition when
     * it first mounts, regardless of the value of `in`. If you want this
     * behavior, set both `appear` and `in` to `true`.
     *
     * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
     * > only adds an additional enter transition. However, in the
     * > `<CSSTransition>` component that first enter transition does result in
     * > additional `.appear-*` classes, that way you can choose to style it
     * > differently.
     */
    appear: PropTypes.bool,
    /**
     * Enable or disable enter transitions.
     */
    enter: PropTypes.bool,
    /**
     * Enable or disable exit transitions.
     */
    exit: PropTypes.bool,
    /**
     * The duration of the transition, in milliseconds.
     * Required unless `addEndListener` is provided.
     *
     * You may specify a single timeout for all transitions:
     *
     * ```jsx
     * timeout={500}
     * ```
     *
     * or individually:
     *
     * ```jsx
     * timeout={{
     *  appear: 500,
     *  enter: 300,
     *  exit: 500,
     * }}
     * ```
     *
     * - `appear` defaults to the value of `enter`
     * - `enter` defaults to `0`
     * - `exit` defaults to `0`
     *
     * @type {number | { enter?: number, exit?: number, appear?: number }}
     */
    timeout: function timeout(props) {
      var pt = timeoutsShape;
      if (!props.addEndListener) pt = pt.isRequired;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return pt.apply(void 0, [props].concat(args));
    },
    /**
     * Add a custom transition end trigger. Called with the transitioning
     * DOM node and a `done` callback. Allows for more fine grained transition end
     * logic. Timeouts are still used as a fallback if provided.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * ```jsx
     * addEndListener={(node, done) => {
     *   // use the css transitionend event to mark the finish of a transition
     *   node.addEventListener('transitionend', done, false);
     * }}
     * ```
     */
    addEndListener: PropTypes.func,
    /**
     * Callback fired before the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEnter: PropTypes.func,
    /**
     * Callback fired after the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntering: PropTypes.func,
    /**
     * Callback fired after the "entered" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEntered: PropTypes.func,
    /**
     * Callback fired before the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExit: PropTypes.func,
    /**
     * Callback fired after the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExiting: PropTypes.func,
    /**
     * Callback fired after the "exited" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExited: PropTypes.func
  } ; // Name the function so it is clearer in the documentation

  function noop() {}
  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop,
    onEntering: noop,
    onEntered: noop,
    onExit: noop,
    onExiting: noop,
    onExited: noop
  };
  Transition.UNMOUNTED = UNMOUNTED;
  Transition.EXITED = EXITED;
  Transition.ENTERING = ENTERING;
  Transition.ENTERED = ENTERED;
  Transition.EXITING = EXITING;
  var Transition$1 = Transition;

  /**
   * Given `this.props.children`, return an object mapping key to child.
   *
   * @param {*} children `this.props.children`
   * @return {object} Mapping of key to child
   */

  function getChildMapping(children, mapFn) {
    var mapper = function mapper(child) {
      return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
    };
    var result = Object.create(null);
    if (children) reactExports.Children.map(children, function (c) {
      return c;
    }).forEach(function (child) {
      // run the map function here instead so that the key is the computed one
      result[child.key] = mapper(child);
    });
    return result;
  }
  /**
   * When you're adding or removing children some may be added or removed in the
   * same render pass. We want to show *both* since we want to simultaneously
   * animate elements in and out. This function takes a previous set of keys
   * and a new set of keys and merges them with its best guess of the correct
   * ordering. In the future we may expose some of the utilities in
   * ReactMultiChild to make this easy, but for now React itself does not
   * directly have this concept of the union of prevChildren and nextChildren
   * so we implement it here.
   *
   * @param {object} prev prev children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @param {object} next next children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @return {object} a key set that contains all keys in `prev` and all keys
   * in `next` in a reasonable order.
   */

  function mergeChildMappings(prev, next) {
    prev = prev || {};
    next = next || {};
    function getValueForKey(key) {
      return key in next ? next[key] : prev[key];
    } // For each key of `next`, the list of keys to insert before that key in
    // the combined list

    var nextKeysPending = Object.create(null);
    var pendingKeys = [];
    for (var prevKey in prev) {
      if (prevKey in next) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }
    var i;
    var childMapping = {};
    for (var nextKey in next) {
      if (nextKeysPending[nextKey]) {
        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey][i];
          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
        }
      }
      childMapping[nextKey] = getValueForKey(nextKey);
    } // Finally, add the keys which didn't appear before any key in `next`

    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }
    return childMapping;
  }
  function getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
  }
  function getInitialChildMapping(props, onExited) {
    return getChildMapping(props.children, function (child) {
      return reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        appear: getProp(child, 'appear', props),
        enter: getProp(child, 'enter', props),
        exit: getProp(child, 'exit', props)
      });
    });
  }
  function getNextChildMapping(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = getChildMapping(nextProps.children);
    var children = mergeChildMappings(prevChildMapping, nextChildMapping);
    Object.keys(children).forEach(function (key) {
      var child = children[key];
      if (!reactExports.isValidElement(child)) return;
      var hasPrev = (key in prevChildMapping);
      var hasNext = (key in nextChildMapping);
      var prevChild = prevChildMapping[key];
      var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)

      if (hasNext && (!hasPrev || isLeaving)) {
        // console.log('entering', key)
        children[key] = reactExports.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: true,
          exit: getProp(child, 'exit', nextProps),
          enter: getProp(child, 'enter', nextProps)
        });
      } else if (!hasNext && hasPrev && !isLeaving) {
        // item is old (exiting)
        // console.log('leaving', key)
        children[key] = reactExports.cloneElement(child, {
          in: false
        });
      } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
        // item hasn't changed transition states
        // copy over the last transition props;
        // console.log('unchanged', key)
        children[key] = reactExports.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: prevChild.props.in,
          exit: getProp(child, 'exit', nextProps),
          enter: getProp(child, 'enter', nextProps)
        });
      }
    });
    return children;
  }

  var values = Object.values || function (obj) {
    return Object.keys(obj).map(function (k) {
      return obj[k];
    });
  };
  var defaultProps = {
    component: 'div',
    childFactory: function childFactory(child) {
      return child;
    }
  };
  /**
   * The `<TransitionGroup>` component manages a set of transition components
   * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
   * components, `<TransitionGroup>` is a state machine for managing the mounting
   * and unmounting of components over time.
   *
   * Consider the example below. As items are removed or added to the TodoList the
   * `in` prop is toggled automatically by the `<TransitionGroup>`.
   *
   * Note that `<TransitionGroup>`  does not define any animation behavior!
   * Exactly _how_ a list item animates is up to the individual transition
   * component. This means you can mix and match animations across different list
   * items.
   */

  var TransitionGroup = /*#__PURE__*/function (_React$Component) {
    _inheritsLoose(TransitionGroup, _React$Component);
    function TransitionGroup(props, context) {
      var _this;
      _this = _React$Component.call(this, props, context) || this;
      var handleExited = _this.handleExited.bind(_assertThisInitialized(_this)); // Initial children should all be entering, dependent on appear

      _this.state = {
        contextValue: {
          isMounting: true
        },
        handleExited: handleExited,
        firstRender: true
      };
      return _this;
    }
    var _proto = TransitionGroup.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.mounted = true;
      this.setState({
        contextValue: {
          isMounting: false
        }
      });
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.mounted = false;
    };
    TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
      var prevChildMapping = _ref.children,
        handleExited = _ref.handleExited,
        firstRender = _ref.firstRender;
      return {
        children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
        firstRender: false
      };
    } // node is `undefined` when user provided `nodeRef` prop
    ;

    _proto.handleExited = function handleExited(child, node) {
      var currentChildMapping = getChildMapping(this.props.children);
      if (child.key in currentChildMapping) return;
      if (child.props.onExited) {
        child.props.onExited(node);
      }
      if (this.mounted) {
        this.setState(function (state) {
          var children = _extends({}, state.children);
          delete children[child.key];
          return {
            children: children
          };
        });
      }
    };
    _proto.render = function render() {
      var _this$props = this.props,
        Component = _this$props.component,
        childFactory = _this$props.childFactory,
        props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
      var contextValue = this.state.contextValue;
      var children = values(this.state.children).map(childFactory);
      delete props.appear;
      delete props.enter;
      delete props.exit;
      if (Component === null) {
        return /*#__PURE__*/React.createElement(TransitionGroupContext.Provider, {
          value: contextValue
        }, children);
      }
      return /*#__PURE__*/React.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, /*#__PURE__*/React.createElement(Component, props, children));
    };
    return TransitionGroup;
  }(React.Component);
  TransitionGroup.propTypes = {
    /**
     * `<TransitionGroup>` renders a `<div>` by default. You can change this
     * behavior by providing a `component` prop.
     * If you use React v16+ and would like to avoid a wrapping `<div>` element
     * you can pass in `component={null}`. This is useful if the wrapping div
     * borks your css styles.
     */
    component: PropTypes.any,
    /**
     * A set of `<Transition>` components, that are toggled `in` and out as they
     * leave. the `<TransitionGroup>` will inject specific transition props, so
     * remember to spread them through if you are wrapping the `<Transition>` as
     * with our `<Fade>` example.
     *
     * While this component is meant for multiple `Transition` or `CSSTransition`
     * children, sometimes you may want to have a single transition child with
     * content that you want to be transitioned out and in when you change it
     * (e.g. routes, images etc.) In that case you can change the `key` prop of
     * the transition child as you change its content, this will cause
     * `TransitionGroup` to transition the child out and back in.
     */
    children: PropTypes.node,
    /**
     * A convenience prop that enables or disables appear animations
     * for all children. Note that specifying this will override any defaults set
     * on individual children Transitions.
     */
    appear: PropTypes.bool,
    /**
     * A convenience prop that enables or disables enter animations
     * for all children. Note that specifying this will override any defaults set
     * on individual children Transitions.
     */
    enter: PropTypes.bool,
    /**
     * A convenience prop that enables or disables exit animations
     * for all children. Note that specifying this will override any defaults set
     * on individual children Transitions.
     */
    exit: PropTypes.bool,
    /**
     * You may need to apply reactive updates to a child as it is exiting.
     * This is generally done by using `cloneElement` however in the case of an exiting
     * child the element has already been removed and not accessible to the consumer.
     *
     * If you do need to update a child as it leaves you can provide a `childFactory`
     * to wrap every child, even the ones that are leaving.
     *
     * @type Function(child: ReactElement) -> ReactElement
     */
    childFactory: PropTypes.func
  } ;
  TransitionGroup.defaultProps = defaultProps;
  var TransitionGroup$1 = TransitionGroup;

  var reflow = function reflow(node) {
    return node.scrollTop;
  };
  function getTransitionProps(props, options) {
    var timeout = props.timeout,
      _props$style = props.style,
      style = _props$style === void 0 ? {} : _props$style;
    return {
      duration: style.transitionDuration || typeof timeout === 'number' ? timeout : timeout[options.mode] || 0,
      delay: style.transitionDelay
    };
  }

  var styles$c = function styles(theme) {
    var elevations = {};
    theme.shadows.forEach(function (shadow, index) {
      elevations["elevation".concat(index)] = {
        boxShadow: shadow
      };
    });
    return _extends({
      /* Styles applied to the root element. */
      root: {
        backgroundColor: theme.palette.background.paper,
        color: theme.palette.text.primary,
        transition: theme.transitions.create('box-shadow')
      },
      /* Styles applied to the root element if `square={false}`. */
      rounded: {
        borderRadius: theme.shape.borderRadius
      },
      /* Styles applied to the root element if `variant="outlined"`. */
      outlined: {
        border: "1px solid ".concat(theme.palette.divider)
      }
    }, elevations);
  };
  var Paper = /*#__PURE__*/reactExports.forwardRef(function Paper(props, ref) {
    var classes = props.classes,
      className = props.className,
      _props$component = props.component,
      Component = _props$component === void 0 ? 'div' : _props$component,
      _props$square = props.square,
      square = _props$square === void 0 ? false : _props$square,
      _props$elevation = props.elevation,
      elevation = _props$elevation === void 0 ? 1 : _props$elevation,
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? 'elevation' : _props$variant,
      other = _objectWithoutProperties(props, ["classes", "className", "component", "square", "elevation", "variant"]);
    return /*#__PURE__*/reactExports.createElement(Component, _extends({
      className: clsx(classes.root, className, variant === 'outlined' ? classes.outlined : classes["elevation".concat(elevation)], !square && classes.rounded),
      ref: ref
    }, other));
  });
  Paper.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * The content of the component.
     */
    children: PropTypes.node,
    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,
    /**
     * @ignore
     */
    className: PropTypes.string,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: PropTypes
    /* @typescript-to-proptypes-ignore */.elementType,
    /**
     * Shadow depth, corresponds to `dp` in the spec.
     * It accepts values between 0 and 24 inclusive.
     */
    elevation: chainPropTypes(PropTypes.number, function (props) {
      var classes = props.classes,
        elevation = props.elevation; // in case `withStyles` fails to inject we don't need this warning

      if (classes === undefined) {
        return null;
      }
      if (elevation != null && classes["elevation".concat(elevation)] === undefined) {
        return new Error("Material-UI: This elevation `".concat(elevation, "` is not implemented."));
      }
      return null;
    }),
    /**
     * If `true`, rounded corners are disabled.
     */
    square: PropTypes.bool,
    /**
     * The variant to use.
     */
    variant: PropTypes.oneOf(['elevation', 'outlined'])
  } ;
  var Paper$1 = withStyles(styles$c, {
    name: 'MuiPaper'
  })(Paper);

  var useEnhancedEffect$2 = typeof window === 'undefined' ? reactExports.useEffect : reactExports.useLayoutEffect;
  /**
   * @ignore - internal component.
   */

  function Ripple(props) {
    var classes = props.classes,
      _props$pulsate = props.pulsate,
      pulsate = _props$pulsate === void 0 ? false : _props$pulsate,
      rippleX = props.rippleX,
      rippleY = props.rippleY,
      rippleSize = props.rippleSize,
      inProp = props.in,
      _props$onExited = props.onExited,
      onExited = _props$onExited === void 0 ? function () {} : _props$onExited,
      timeout = props.timeout;
    var _React$useState = reactExports.useState(false),
      leaving = _React$useState[0],
      setLeaving = _React$useState[1];
    var rippleClassName = clsx(classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
    var rippleStyles = {
      width: rippleSize,
      height: rippleSize,
      top: -(rippleSize / 2) + rippleY,
      left: -(rippleSize / 2) + rippleX
    };
    var childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
    var handleExited = useEventCallback(onExited); // Ripple is used for user feedback (e.g. click or press) so we want to apply styles with the highest priority

    useEnhancedEffect$2(function () {
      if (!inProp) {
        // react-transition-group#onExit
        setLeaving(true); // react-transition-group#onExited

        var timeoutId = setTimeout(handleExited, timeout);
        return function () {
          clearTimeout(timeoutId);
        };
      }
      return undefined;
    }, [handleExited, inProp, timeout]);
    return /*#__PURE__*/reactExports.createElement("span", {
      className: rippleClassName,
      style: rippleStyles
    }, /*#__PURE__*/reactExports.createElement("span", {
      className: childClassName
    }));
  }
  Ripple.propTypes = {
    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object.isRequired,
    /**
     * @ignore - injected from TransitionGroup
     */
    in: PropTypes.bool,
    /**
     * @ignore - injected from TransitionGroup
     */
    onExited: PropTypes.func,
    /**
     * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
     */
    pulsate: PropTypes.bool,
    /**
     * Diameter of the ripple.
     */
    rippleSize: PropTypes.number,
    /**
     * Horizontal position of the ripple center.
     */
    rippleX: PropTypes.number,
    /**
     * Vertical position of the ripple center.
     */
    rippleY: PropTypes.number,
    /**
     * exit delay
     */
    timeout: PropTypes.number.isRequired
  } ;

  var DURATION = 550;
  var DELAY_RIPPLE = 80;
  var styles$b = function styles(theme) {
    return {
      /* Styles applied to the root element. */
      root: {
        overflow: 'hidden',
        pointerEvents: 'none',
        position: 'absolute',
        zIndex: 0,
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        borderRadius: 'inherit'
      },
      /* Styles applied to the internal `Ripple` components `ripple` class. */
      ripple: {
        opacity: 0,
        position: 'absolute'
      },
      /* Styles applied to the internal `Ripple` components `rippleVisible` class. */
      rippleVisible: {
        opacity: 0.3,
        transform: 'scale(1)',
        animation: "$enter ".concat(DURATION, "ms ").concat(theme.transitions.easing.easeInOut)
      },
      /* Styles applied to the internal `Ripple` components `ripplePulsate` class. */
      ripplePulsate: {
        animationDuration: "".concat(theme.transitions.duration.shorter, "ms")
      },
      /* Styles applied to the internal `Ripple` components `child` class. */
      child: {
        opacity: 1,
        display: 'block',
        width: '100%',
        height: '100%',
        borderRadius: '50%',
        backgroundColor: 'currentColor'
      },
      /* Styles applied to the internal `Ripple` components `childLeaving` class. */
      childLeaving: {
        opacity: 0,
        animation: "$exit ".concat(DURATION, "ms ").concat(theme.transitions.easing.easeInOut)
      },
      /* Styles applied to the internal `Ripple` components `childPulsate` class. */
      childPulsate: {
        position: 'absolute',
        left: 0,
        top: 0,
        animation: "$pulsate 2500ms ".concat(theme.transitions.easing.easeInOut, " 200ms infinite")
      },
      '@keyframes enter': {
        '0%': {
          transform: 'scale(0)',
          opacity: 0.1
        },
        '100%': {
          transform: 'scale(1)',
          opacity: 0.3
        }
      },
      '@keyframes exit': {
        '0%': {
          opacity: 1
        },
        '100%': {
          opacity: 0
        }
      },
      '@keyframes pulsate': {
        '0%': {
          transform: 'scale(1)'
        },
        '50%': {
          transform: 'scale(0.92)'
        },
        '100%': {
          transform: 'scale(1)'
        }
      }
    };
  };
  /**
   * @ignore - internal component.
   *
   * TODO v5: Make private
   */

  var TouchRipple = /*#__PURE__*/reactExports.forwardRef(function TouchRipple(props, ref) {
    var _props$center = props.center,
      centerProp = _props$center === void 0 ? false : _props$center,
      classes = props.classes,
      className = props.className,
      other = _objectWithoutProperties(props, ["center", "classes", "className"]);
    var _React$useState = reactExports.useState([]),
      ripples = _React$useState[0],
      setRipples = _React$useState[1];
    var nextKey = reactExports.useRef(0);
    var rippleCallback = reactExports.useRef(null);
    reactExports.useEffect(function () {
      if (rippleCallback.current) {
        rippleCallback.current();
        rippleCallback.current = null;
      }
    }, [ripples]); // Used to filter out mouse emulated events on mobile.

    var ignoringMouseDown = reactExports.useRef(false); // We use a timer in order to only show the ripples for touch "click" like events.
    // We don't want to display the ripple for touch scroll events.

    var startTimer = reactExports.useRef(null); // This is the hook called once the previous timeout is ready.

    var startTimerCommit = reactExports.useRef(null);
    var container = reactExports.useRef(null);
    reactExports.useEffect(function () {
      return function () {
        clearTimeout(startTimer.current);
      };
    }, []);
    var startCommit = reactExports.useCallback(function (params) {
      var pulsate = params.pulsate,
        rippleX = params.rippleX,
        rippleY = params.rippleY,
        rippleSize = params.rippleSize,
        cb = params.cb;
      setRipples(function (oldRipples) {
        return [].concat(_toConsumableArray(oldRipples), [/*#__PURE__*/reactExports.createElement(Ripple, {
          key: nextKey.current,
          classes: classes,
          timeout: DURATION,
          pulsate: pulsate,
          rippleX: rippleX,
          rippleY: rippleY,
          rippleSize: rippleSize
        })]);
      });
      nextKey.current += 1;
      rippleCallback.current = cb;
    }, [classes]);
    var start = reactExports.useCallback(function () {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var cb = arguments.length > 2 ? arguments[2] : undefined;
      var _options$pulsate = options.pulsate,
        pulsate = _options$pulsate === void 0 ? false : _options$pulsate,
        _options$center = options.center,
        center = _options$center === void 0 ? centerProp || options.pulsate : _options$center,
        _options$fakeElement = options.fakeElement,
        fakeElement = _options$fakeElement === void 0 ? false : _options$fakeElement;
      if (event.type === 'mousedown' && ignoringMouseDown.current) {
        ignoringMouseDown.current = false;
        return;
      }
      if (event.type === 'touchstart') {
        ignoringMouseDown.current = true;
      }
      var element = fakeElement ? null : container.current;
      var rect = element ? element.getBoundingClientRect() : {
        width: 0,
        height: 0,
        left: 0,
        top: 0
      }; // Get the size of the ripple

      var rippleX;
      var rippleY;
      var rippleSize;
      if (center || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
        rippleX = Math.round(rect.width / 2);
        rippleY = Math.round(rect.height / 2);
      } else {
        var _ref = event.touches ? event.touches[0] : event,
          clientX = _ref.clientX,
          clientY = _ref.clientY;
        rippleX = Math.round(clientX - rect.left);
        rippleY = Math.round(clientY - rect.top);
      }
      if (center) {
        rippleSize = Math.sqrt((2 * Math.pow(rect.width, 2) + Math.pow(rect.height, 2)) / 3); // For some reason the animation is broken on Mobile Chrome if the size if even.

        if (rippleSize % 2 === 0) {
          rippleSize += 1;
        }
      } else {
        var sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
        var sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
        rippleSize = Math.sqrt(Math.pow(sizeX, 2) + Math.pow(sizeY, 2));
      } // Touche devices

      if (event.touches) {
        // check that this isn't another touchstart due to multitouch
        // otherwise we will only clear a single timer when unmounting while two
        // are running
        if (startTimerCommit.current === null) {
          // Prepare the ripple effect.
          startTimerCommit.current = function () {
            startCommit({
              pulsate: pulsate,
              rippleX: rippleX,
              rippleY: rippleY,
              rippleSize: rippleSize,
              cb: cb
            });
          }; // Delay the execution of the ripple effect.

          startTimer.current = setTimeout(function () {
            if (startTimerCommit.current) {
              startTimerCommit.current();
              startTimerCommit.current = null;
            }
          }, DELAY_RIPPLE); // We have to make a tradeoff with this value.
        }
      } else {
        startCommit({
          pulsate: pulsate,
          rippleX: rippleX,
          rippleY: rippleY,
          rippleSize: rippleSize,
          cb: cb
        });
      }
    }, [centerProp, startCommit]);
    var pulsate = reactExports.useCallback(function () {
      start({}, {
        pulsate: true
      });
    }, [start]);
    var stop = reactExports.useCallback(function (event, cb) {
      clearTimeout(startTimer.current); // The touch interaction occurs too quickly.
      // We still want to show ripple effect.

      if (event.type === 'touchend' && startTimerCommit.current) {
        event.persist();
        startTimerCommit.current();
        startTimerCommit.current = null;
        startTimer.current = setTimeout(function () {
          stop(event, cb);
        });
        return;
      }
      startTimerCommit.current = null;
      setRipples(function (oldRipples) {
        if (oldRipples.length > 0) {
          return oldRipples.slice(1);
        }
        return oldRipples;
      });
      rippleCallback.current = cb;
    }, []);
    reactExports.useImperativeHandle(ref, function () {
      return {
        pulsate: pulsate,
        start: start,
        stop: stop
      };
    }, [pulsate, start, stop]);
    return /*#__PURE__*/reactExports.createElement("span", _extends({
      className: clsx(classes.root, className),
      ref: container
    }, other), /*#__PURE__*/reactExports.createElement(TransitionGroup$1, {
      component: null,
      exit: true
    }, ripples));
  });
  TouchRipple.propTypes = {
    /**
     * If `true`, the ripple starts at the center of the component
     * rather than at the point of interaction.
     */
    center: PropTypes.bool,
    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object.isRequired,
    /**
     * @ignore
     */
    className: PropTypes.string
  } ;
  var TouchRipple$1 = withStyles(styles$b, {
    flip: false,
    name: 'MuiTouchRipple'
  })( /*#__PURE__*/reactExports.memo(TouchRipple));

  var styles$a = {
    /* Styles applied to the root element. */
    root: {
      display: 'inline-flex',
      alignItems: 'center',
      justifyContent: 'center',
      position: 'relative',
      WebkitTapHighlightColor: 'transparent',
      backgroundColor: 'transparent',
      // Reset default value
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0,
      border: 0,
      margin: 0,
      // Remove the margin in Safari
      borderRadius: 0,
      padding: 0,
      // Remove the padding in Firefox
      cursor: 'pointer',
      userSelect: 'none',
      verticalAlign: 'middle',
      '-moz-appearance': 'none',
      // Reset
      '-webkit-appearance': 'none',
      // Reset
      textDecoration: 'none',
      // So we take precedent over the style of a native <a /> element.
      color: 'inherit',
      '&::-moz-focus-inner': {
        borderStyle: 'none' // Remove Firefox dotted outline.
      },

      '&$disabled': {
        pointerEvents: 'none',
        // Disable link interactions
        cursor: 'default'
      },
      '@media print': {
        colorAdjust: 'exact'
      }
    },
    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},
    /* Pseudo-class applied to the root element if keyboard focused. */
    focusVisible: {}
  };
  /**
   * `ButtonBase` contains as few styles as possible.
   * It aims to be a simple building block for creating a button.
   * It contains a load of style reset and some focus/ripple logic.
   */

  var ButtonBase = /*#__PURE__*/reactExports.forwardRef(function ButtonBase(props, ref) {
    var action = props.action,
      buttonRefProp = props.buttonRef,
      _props$centerRipple = props.centerRipple,
      centerRipple = _props$centerRipple === void 0 ? false : _props$centerRipple,
      children = props.children,
      classes = props.classes,
      className = props.className,
      _props$component = props.component,
      component = _props$component === void 0 ? 'button' : _props$component,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      _props$disableRipple = props.disableRipple,
      disableRipple = _props$disableRipple === void 0 ? false : _props$disableRipple,
      _props$disableTouchRi = props.disableTouchRipple,
      disableTouchRipple = _props$disableTouchRi === void 0 ? false : _props$disableTouchRi,
      _props$focusRipple = props.focusRipple,
      focusRipple = _props$focusRipple === void 0 ? false : _props$focusRipple,
      focusVisibleClassName = props.focusVisibleClassName,
      onBlur = props.onBlur,
      onClick = props.onClick,
      onFocus = props.onFocus,
      onFocusVisible = props.onFocusVisible,
      onKeyDown = props.onKeyDown,
      onKeyUp = props.onKeyUp,
      onMouseDown = props.onMouseDown,
      onMouseLeave = props.onMouseLeave,
      onMouseUp = props.onMouseUp,
      onTouchEnd = props.onTouchEnd,
      onTouchMove = props.onTouchMove,
      onTouchStart = props.onTouchStart,
      onDragLeave = props.onDragLeave,
      _props$tabIndex = props.tabIndex,
      tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex,
      TouchRippleProps = props.TouchRippleProps,
      _props$type = props.type,
      type = _props$type === void 0 ? 'button' : _props$type,
      other = _objectWithoutProperties(props, ["action", "buttonRef", "centerRipple", "children", "classes", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "onBlur", "onClick", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "onDragLeave", "tabIndex", "TouchRippleProps", "type"]);
    var buttonRef = reactExports.useRef(null);
    function getButtonNode() {
      // #StrictMode ready
      return reactDomExports.findDOMNode(buttonRef.current);
    }
    var rippleRef = reactExports.useRef(null);
    var _React$useState = reactExports.useState(false),
      focusVisible = _React$useState[0],
      setFocusVisible = _React$useState[1];
    if (disabled && focusVisible) {
      setFocusVisible(false);
    }
    var _useIsFocusVisible = useIsFocusVisible(),
      isFocusVisible = _useIsFocusVisible.isFocusVisible,
      onBlurVisible = _useIsFocusVisible.onBlurVisible,
      focusVisibleRef = _useIsFocusVisible.ref;
    reactExports.useImperativeHandle(action, function () {
      return {
        focusVisible: function focusVisible() {
          setFocusVisible(true);
          buttonRef.current.focus();
        }
      };
    }, []);
    reactExports.useEffect(function () {
      if (focusVisible && focusRipple && !disableRipple) {
        rippleRef.current.pulsate();
      }
    }, [disableRipple, focusRipple, focusVisible]);
    function useRippleHandler(rippleAction, eventCallback) {
      var skipRippleAction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : disableTouchRipple;
      return useEventCallback(function (event) {
        if (eventCallback) {
          eventCallback(event);
        }
        var ignore = skipRippleAction;
        if (!ignore && rippleRef.current) {
          rippleRef.current[rippleAction](event);
        }
        return true;
      });
    }
    var handleMouseDown = useRippleHandler('start', onMouseDown);
    var handleDragLeave = useRippleHandler('stop', onDragLeave);
    var handleMouseUp = useRippleHandler('stop', onMouseUp);
    var handleMouseLeave = useRippleHandler('stop', function (event) {
      if (focusVisible) {
        event.preventDefault();
      }
      if (onMouseLeave) {
        onMouseLeave(event);
      }
    });
    var handleTouchStart = useRippleHandler('start', onTouchStart);
    var handleTouchEnd = useRippleHandler('stop', onTouchEnd);
    var handleTouchMove = useRippleHandler('stop', onTouchMove);
    var handleBlur = useRippleHandler('stop', function (event) {
      if (focusVisible) {
        onBlurVisible(event);
        setFocusVisible(false);
      }
      if (onBlur) {
        onBlur(event);
      }
    }, false);
    var handleFocus = useEventCallback(function (event) {
      // Fix for https://github.com/facebook/react/issues/7769
      if (!buttonRef.current) {
        buttonRef.current = event.currentTarget;
      }
      if (isFocusVisible(event)) {
        setFocusVisible(true);
        if (onFocusVisible) {
          onFocusVisible(event);
        }
      }
      if (onFocus) {
        onFocus(event);
      }
    });
    var isNonNativeButton = function isNonNativeButton() {
      var button = getButtonNode();
      return component && component !== 'button' && !(button.tagName === 'A' && button.href);
    };
    /**
     * IE 11 shim for https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat
     */

    var keydownRef = reactExports.useRef(false);
    var handleKeyDown = useEventCallback(function (event) {
      // Check if key is already down to avoid repeats being counted as multiple activations
      if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === ' ') {
        keydownRef.current = true;
        event.persist();
        rippleRef.current.stop(event, function () {
          rippleRef.current.start(event);
        });
      }
      if (event.target === event.currentTarget && isNonNativeButton() && event.key === ' ') {
        event.preventDefault();
      }
      if (onKeyDown) {
        onKeyDown(event);
      } // Keyboard accessibility for non interactive elements

      if (event.target === event.currentTarget && isNonNativeButton() && event.key === 'Enter' && !disabled) {
        event.preventDefault();
        if (onClick) {
          onClick(event);
        }
      }
    });
    var handleKeyUp = useEventCallback(function (event) {
      // calling preventDefault in keyUp on a <button> will not dispatch a click event if Space is pressed
      // https://codesandbox.io/s/button-keyup-preventdefault-dn7f0
      if (focusRipple && event.key === ' ' && rippleRef.current && focusVisible && !event.defaultPrevented) {
        keydownRef.current = false;
        event.persist();
        rippleRef.current.stop(event, function () {
          rippleRef.current.pulsate(event);
        });
      }
      if (onKeyUp) {
        onKeyUp(event);
      } // Keyboard accessibility for non interactive elements

      if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === ' ' && !event.defaultPrevented) {
        onClick(event);
      }
    });
    var ComponentProp = component;
    if (ComponentProp === 'button' && other.href) {
      ComponentProp = 'a';
    }
    var buttonProps = {};
    if (ComponentProp === 'button') {
      buttonProps.type = type;
      buttonProps.disabled = disabled;
    } else {
      if (ComponentProp !== 'a' || !other.href) {
        buttonProps.role = 'button';
      }
      buttonProps['aria-disabled'] = disabled;
    }
    var handleUserRef = useForkRef(buttonRefProp, ref);
    var handleOwnRef = useForkRef(focusVisibleRef, buttonRef);
    var handleRef = useForkRef(handleUserRef, handleOwnRef);
    var _React$useState2 = reactExports.useState(false),
      mountedState = _React$useState2[0],
      setMountedState = _React$useState2[1];
    reactExports.useEffect(function () {
      setMountedState(true);
    }, []);
    var enableTouchRipple = mountedState && !disableRipple && !disabled;
    {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      reactExports.useEffect(function () {
        if (enableTouchRipple && !rippleRef.current) {
          console.error(['Material-UI: The `component` prop provided to ButtonBase is invalid.', 'Please make sure the children prop is rendered in this custom component.'].join('\n'));
        }
      }, [enableTouchRipple]);
    }
    return /*#__PURE__*/reactExports.createElement(ComponentProp, _extends({
      className: clsx(classes.root, className, focusVisible && [classes.focusVisible, focusVisibleClassName], disabled && classes.disabled),
      onBlur: handleBlur,
      onClick: onClick,
      onFocus: handleFocus,
      onKeyDown: handleKeyDown,
      onKeyUp: handleKeyUp,
      onMouseDown: handleMouseDown,
      onMouseLeave: handleMouseLeave,
      onMouseUp: handleMouseUp,
      onDragLeave: handleDragLeave,
      onTouchEnd: handleTouchEnd,
      onTouchMove: handleTouchMove,
      onTouchStart: handleTouchStart,
      ref: handleRef,
      tabIndex: disabled ? -1 : tabIndex
    }, buttonProps, other), children, enableTouchRipple ? 

    /* TouchRipple is only needed client-side, x2 boost on the server. */
    reactExports.createElement(TouchRipple$1, _extends({
      ref: rippleRef,
      center: centerRipple
    }, TouchRippleProps)) : null);
  });
  ButtonBase.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * A ref for imperative actions.
     * It currently only supports `focusVisible()` action.
     */
    action: refType$1,
    /**
     * @ignore
     *
     * Use that prop to pass a ref to the native button component.
     * @deprecated Use `ref` instead.
     */
    buttonRef: deprecatedPropType(refType$1, 'Use `ref` instead.'),
    /**
     * If `true`, the ripples will be centered.
     * They won't start at the cursor interaction position.
     */
    centerRipple: PropTypes.bool,
    /**
     * The content of the component.
     */
    children: PropTypes.node,
    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,
    /**
     * @ignore
     */
    className: PropTypes.string,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: elementTypeAcceptingRef$1,
    /**
     * If `true`, the base button will be disabled.
     */
    disabled: PropTypes.bool,
    /**
     * If `true`, the ripple effect will be disabled.
     *
     * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
     * to highlight the element by applying separate styles with the `focusVisibleClassName`.
     */
    disableRipple: PropTypes.bool,
    /**
     * If `true`, the touch ripple effect will be disabled.
     */
    disableTouchRipple: PropTypes.bool,
    /**
     * If `true`, the base button will have a keyboard focus ripple.
     */
    focusRipple: PropTypes.bool,
    /**
     * This prop can help identify which element has keyboard focus.
     * The class name will be applied when the element gains the focus through keyboard interaction.
     * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
     * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/master/explainer.md).
     * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
     * if needed.
     */
    focusVisibleClassName: PropTypes.string,
    /**
     * @ignore
     */
    href: PropTypes.string,
    /**
     * @ignore
     */
    onBlur: PropTypes.func,
    /**
     * @ignore
     */
    onClick: PropTypes.func,
    /**
     * @ignore
     */
    onDragLeave: PropTypes.func,
    /**
     * @ignore
     */
    onFocus: PropTypes.func,
    /**
     * Callback fired when the component is focused with a keyboard.
     * We trigger a `onFocus` callback too.
     */
    onFocusVisible: PropTypes.func,
    /**
     * @ignore
     */
    onKeyDown: PropTypes.func,
    /**
     * @ignore
     */
    onKeyUp: PropTypes.func,
    /**
     * @ignore
     */
    onMouseDown: PropTypes.func,
    /**
     * @ignore
     */
    onMouseLeave: PropTypes.func,
    /**
     * @ignore
     */
    onMouseUp: PropTypes.func,
    /**
     * @ignore
     */
    onTouchEnd: PropTypes.func,
    /**
     * @ignore
     */
    onTouchMove: PropTypes.func,
    /**
     * @ignore
     */
    onTouchStart: PropTypes.func,
    /**
     * @ignore
     */
    tabIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    /**
     * Props applied to the `TouchRipple` element.
     */
    TouchRippleProps: PropTypes.object,
    /**
     * @ignore
     */
    type: PropTypes.oneOfType([PropTypes.oneOf(['button', 'reset', 'submit']), PropTypes.string])
  } ;
  var ButtonBase$1 = withStyles(styles$a, {
    name: 'MuiButtonBase'
  })(ButtonBase);

  var styles$9 = function styles(theme) {
    return {
      /* Styles applied to the root element. */
      root: {
        margin: 0
      },
      /* Styles applied to the root element if `variant="body2"`. */
      body2: theme.typography.body2,
      /* Styles applied to the root element if `variant="body1"`. */
      body1: theme.typography.body1,
      /* Styles applied to the root element if `variant="caption"`. */
      caption: theme.typography.caption,
      /* Styles applied to the root element if `variant="button"`. */
      button: theme.typography.button,
      /* Styles applied to the root element if `variant="h1"`. */
      h1: theme.typography.h1,
      /* Styles applied to the root element if `variant="h2"`. */
      h2: theme.typography.h2,
      /* Styles applied to the root element if `variant="h3"`. */
      h3: theme.typography.h3,
      /* Styles applied to the root element if `variant="h4"`. */
      h4: theme.typography.h4,
      /* Styles applied to the root element if `variant="h5"`. */
      h5: theme.typography.h5,
      /* Styles applied to the root element if `variant="h6"`. */
      h6: theme.typography.h6,
      /* Styles applied to the root element if `variant="subtitle1"`. */
      subtitle1: theme.typography.subtitle1,
      /* Styles applied to the root element if `variant="subtitle2"`. */
      subtitle2: theme.typography.subtitle2,
      /* Styles applied to the root element if `variant="overline"`. */
      overline: theme.typography.overline,
      /* Styles applied to the root element if `variant="srOnly"`. Only accessible to screen readers. */
      srOnly: {
        position: 'absolute',
        height: 1,
        width: 1,
        overflow: 'hidden'
      },
      /* Styles applied to the root element if `align="left"`. */
      alignLeft: {
        textAlign: 'left'
      },
      /* Styles applied to the root element if `align="center"`. */
      alignCenter: {
        textAlign: 'center'
      },
      /* Styles applied to the root element if `align="right"`. */
      alignRight: {
        textAlign: 'right'
      },
      /* Styles applied to the root element if `align="justify"`. */
      alignJustify: {
        textAlign: 'justify'
      },
      /* Styles applied to the root element if `nowrap={true}`. */
      noWrap: {
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap'
      },
      /* Styles applied to the root element if `gutterBottom={true}`. */
      gutterBottom: {
        marginBottom: '0.35em'
      },
      /* Styles applied to the root element if `paragraph={true}`. */
      paragraph: {
        marginBottom: 16
      },
      /* Styles applied to the root element if `color="inherit"`. */
      colorInherit: {
        color: 'inherit'
      },
      /* Styles applied to the root element if `color="primary"`. */
      colorPrimary: {
        color: theme.palette.primary.main
      },
      /* Styles applied to the root element if `color="secondary"`. */
      colorSecondary: {
        color: theme.palette.secondary.main
      },
      /* Styles applied to the root element if `color="textPrimary"`. */
      colorTextPrimary: {
        color: theme.palette.text.primary
      },
      /* Styles applied to the root element if `color="textSecondary"`. */
      colorTextSecondary: {
        color: theme.palette.text.secondary
      },
      /* Styles applied to the root element if `color="error"`. */
      colorError: {
        color: theme.palette.error.main
      },
      /* Styles applied to the root element if `display="inline"`. */
      displayInline: {
        display: 'inline'
      },
      /* Styles applied to the root element if `display="block"`. */
      displayBlock: {
        display: 'block'
      }
    };
  };
  var defaultVariantMapping = {
    h1: 'h1',
    h2: 'h2',
    h3: 'h3',
    h4: 'h4',
    h5: 'h5',
    h6: 'h6',
    subtitle1: 'h6',
    subtitle2: 'h6',
    body1: 'p',
    body2: 'p'
  };
  var Typography = /*#__PURE__*/reactExports.forwardRef(function Typography(props, ref) {
    var _props$align = props.align,
      align = _props$align === void 0 ? 'inherit' : _props$align,
      classes = props.classes,
      className = props.className,
      _props$color = props.color,
      color = _props$color === void 0 ? 'initial' : _props$color,
      component = props.component,
      _props$display = props.display,
      display = _props$display === void 0 ? 'initial' : _props$display,
      _props$gutterBottom = props.gutterBottom,
      gutterBottom = _props$gutterBottom === void 0 ? false : _props$gutterBottom,
      _props$noWrap = props.noWrap,
      noWrap = _props$noWrap === void 0 ? false : _props$noWrap,
      _props$paragraph = props.paragraph,
      paragraph = _props$paragraph === void 0 ? false : _props$paragraph,
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? 'body1' : _props$variant,
      _props$variantMapping = props.variantMapping,
      variantMapping = _props$variantMapping === void 0 ? defaultVariantMapping : _props$variantMapping,
      other = _objectWithoutProperties(props, ["align", "classes", "className", "color", "component", "display", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"]);
    var Component = component || (paragraph ? 'p' : variantMapping[variant] || defaultVariantMapping[variant]) || 'span';
    return /*#__PURE__*/reactExports.createElement(Component, _extends({
      className: clsx(classes.root, className, variant !== 'inherit' && classes[variant], color !== 'initial' && classes["color".concat(capitalize(color))], noWrap && classes.noWrap, gutterBottom && classes.gutterBottom, paragraph && classes.paragraph, align !== 'inherit' && classes["align".concat(capitalize(align))], display !== 'initial' && classes["display".concat(capitalize(display))]),
      ref: ref
    }, other));
  });
  Typography.propTypes = {
    /**
     * Set the text-align on the component.
     */
    align: PropTypes.oneOf(['inherit', 'left', 'center', 'right', 'justify']),
    /**
     * The content of the component.
     */
    children: PropTypes.node,
    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object.isRequired,
    /**
     * @ignore
     */
    className: PropTypes.string,
    /**
     * The color of the component. It supports those theme colors that make sense for this component.
     */
    color: PropTypes.oneOf(['initial', 'inherit', 'primary', 'secondary', 'textPrimary', 'textSecondary', 'error']),
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     * Overrides the behavior of the `variantMapping` prop.
     */
    component: PropTypes
    /* @typescript-to-proptypes-ignore */.elementType,
    /**
     * Controls the display type
     */
    display: PropTypes.oneOf(['initial', 'block', 'inline']),
    /**
     * If `true`, the text will have a bottom margin.
     */
    gutterBottom: PropTypes.bool,
    /**
     * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.
     *
     * Note that text overflow can only happen with block or inline-block level elements
     * (the element needs to have a width in order to overflow).
     */
    noWrap: PropTypes.bool,
    /**
     * If `true`, the text will have a bottom margin.
     */
    paragraph: PropTypes.bool,
    /**
     * Applies the theme typography styles.
     */
    variant: PropTypes.oneOf(['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'subtitle1', 'subtitle2', 'body1', 'body2', 'caption', 'button', 'overline', 'srOnly', 'inherit']),
    /**
     * The component maps the variant prop to a range of different HTML element types.
     * For instance, subtitle1 to `<h6>`.
     * If you wish to change that mapping, you can provide your own.
     * Alternatively, you can use the `component` prop.
     */
    variantMapping: PropTypes.object
  } ;
  var Typography$1 = withStyles(styles$9, {
    name: 'MuiTypography'
  })(Typography);

  var styles$8 = function styles(theme) {
    return {
      /* Styles applied to the root element. */
      root: _extends({}, theme.typography.button, {
        boxSizing: 'border-box',
        minWidth: 64,
        padding: '6px 16px',
        borderRadius: theme.shape.borderRadius,
        color: theme.palette.text.primary,
        transition: theme.transitions.create(['background-color', 'box-shadow', 'border'], {
          duration: theme.transitions.duration.short
        }),
        '&:hover': {
          textDecoration: 'none',
          backgroundColor: alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: 'transparent'
          },
          '&$disabled': {
            backgroundColor: 'transparent'
          }
        },
        '&$disabled': {
          color: theme.palette.action.disabled
        }
      }),
      /* Styles applied to the span element that wraps the children. */
      label: {
        width: '100%',
        // Ensure the correct width for iOS Safari
        display: 'inherit',
        alignItems: 'inherit',
        justifyContent: 'inherit'
      },
      /* Styles applied to the root element if `variant="text"`. */
      text: {
        padding: '6px 8px'
      },
      /* Styles applied to the root element if `variant="text"` and `color="primary"`. */
      textPrimary: {
        color: theme.palette.primary.main,
        '&:hover': {
          backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: 'transparent'
          }
        }
      },
      /* Styles applied to the root element if `variant="text"` and `color="secondary"`. */
      textSecondary: {
        color: theme.palette.secondary.main,
        '&:hover': {
          backgroundColor: alpha(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: 'transparent'
          }
        }
      },
      /* Styles applied to the root element if `variant="outlined"`. */
      outlined: {
        padding: '5px 15px',
        border: "1px solid ".concat(theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)'),
        '&$disabled': {
          border: "1px solid ".concat(theme.palette.action.disabledBackground)
        }
      },
      /* Styles applied to the root element if `variant="outlined"` and `color="primary"`. */
      outlinedPrimary: {
        color: theme.palette.primary.main,
        border: "1px solid ".concat(alpha(theme.palette.primary.main, 0.5)),
        '&:hover': {
          border: "1px solid ".concat(theme.palette.primary.main),
          backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: 'transparent'
          }
        }
      },
      /* Styles applied to the root element if `variant="outlined"` and `color="secondary"`. */
      outlinedSecondary: {
        color: theme.palette.secondary.main,
        border: "1px solid ".concat(alpha(theme.palette.secondary.main, 0.5)),
        '&:hover': {
          border: "1px solid ".concat(theme.palette.secondary.main),
          backgroundColor: alpha(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: 'transparent'
          }
        },
        '&$disabled': {
          border: "1px solid ".concat(theme.palette.action.disabled)
        }
      },
      /* Styles applied to the root element if `variant="contained"`. */
      contained: {
        color: theme.palette.getContrastText(theme.palette.grey[300]),
        backgroundColor: theme.palette.grey[300],
        boxShadow: theme.shadows[2],
        '&:hover': {
          backgroundColor: theme.palette.grey.A100,
          boxShadow: theme.shadows[4],
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            boxShadow: theme.shadows[2],
            backgroundColor: theme.palette.grey[300]
          },
          '&$disabled': {
            backgroundColor: theme.palette.action.disabledBackground
          }
        },
        '&$focusVisible': {
          boxShadow: theme.shadows[6]
        },
        '&:active': {
          boxShadow: theme.shadows[8]
        },
        '&$disabled': {
          color: theme.palette.action.disabled,
          boxShadow: theme.shadows[0],
          backgroundColor: theme.palette.action.disabledBackground
        }
      },
      /* Styles applied to the root element if `variant="contained"` and `color="primary"`. */
      containedPrimary: {
        color: theme.palette.primary.contrastText,
        backgroundColor: theme.palette.primary.main,
        '&:hover': {
          backgroundColor: theme.palette.primary.dark,
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: theme.palette.primary.main
          }
        }
      },
      /* Styles applied to the root element if `variant="contained"` and `color="secondary"`. */
      containedSecondary: {
        color: theme.palette.secondary.contrastText,
        backgroundColor: theme.palette.secondary.main,
        '&:hover': {
          backgroundColor: theme.palette.secondary.dark,
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: theme.palette.secondary.main
          }
        }
      },
      /* Styles applied to the root element if `disableElevation={true}`. */
      disableElevation: {
        boxShadow: 'none',
        '&:hover': {
          boxShadow: 'none'
        },
        '&$focusVisible': {
          boxShadow: 'none'
        },
        '&:active': {
          boxShadow: 'none'
        },
        '&$disabled': {
          boxShadow: 'none'
        }
      },
      /* Pseudo-class applied to the ButtonBase root element if the button is keyboard focused. */
      focusVisible: {},
      /* Pseudo-class applied to the root element if `disabled={true}`. */
      disabled: {},
      /* Styles applied to the root element if `color="inherit"`. */
      colorInherit: {
        color: 'inherit',
        borderColor: 'currentColor'
      },
      /* Styles applied to the root element if `size="small"` and `variant="text"`. */
      textSizeSmall: {
        padding: '4px 5px',
        fontSize: theme.typography.pxToRem(13)
      },
      /* Styles applied to the root element if `size="large"` and `variant="text"`. */
      textSizeLarge: {
        padding: '8px 11px',
        fontSize: theme.typography.pxToRem(15)
      },
      /* Styles applied to the root element if `size="small"` and `variant="outlined"`. */
      outlinedSizeSmall: {
        padding: '3px 9px',
        fontSize: theme.typography.pxToRem(13)
      },
      /* Styles applied to the root element if `size="large"` and `variant="outlined"`. */
      outlinedSizeLarge: {
        padding: '7px 21px',
        fontSize: theme.typography.pxToRem(15)
      },
      /* Styles applied to the root element if `size="small"` and `variant="contained"`. */
      containedSizeSmall: {
        padding: '4px 10px',
        fontSize: theme.typography.pxToRem(13)
      },
      /* Styles applied to the root element if `size="large"` and `variant="contained"`. */
      containedSizeLarge: {
        padding: '8px 22px',
        fontSize: theme.typography.pxToRem(15)
      },
      /* Styles applied to the root element if `size="small"`. */
      sizeSmall: {},
      /* Styles applied to the root element if `size="large"`. */
      sizeLarge: {},
      /* Styles applied to the root element if `fullWidth={true}`. */
      fullWidth: {
        width: '100%'
      },
      /* Styles applied to the startIcon element if supplied. */
      startIcon: {
        display: 'inherit',
        marginRight: 8,
        marginLeft: -4,
        '&$iconSizeSmall': {
          marginLeft: -2
        }
      },
      /* Styles applied to the endIcon element if supplied. */
      endIcon: {
        display: 'inherit',
        marginRight: -4,
        marginLeft: 8,
        '&$iconSizeSmall': {
          marginRight: -2
        }
      },
      /* Styles applied to the icon element if supplied and `size="small"`. */
      iconSizeSmall: {
        '& > *:first-child': {
          fontSize: 18
        }
      },
      /* Styles applied to the icon element if supplied and `size="medium"`. */
      iconSizeMedium: {
        '& > *:first-child': {
          fontSize: 20
        }
      },
      /* Styles applied to the icon element if supplied and `size="large"`. */
      iconSizeLarge: {
        '& > *:first-child': {
          fontSize: 22
        }
      }
    };
  };
  var Button = /*#__PURE__*/reactExports.forwardRef(function Button(props, ref) {
    var children = props.children,
      classes = props.classes,
      className = props.className,
      _props$color = props.color,
      color = _props$color === void 0 ? 'default' : _props$color,
      _props$component = props.component,
      component = _props$component === void 0 ? 'button' : _props$component,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      _props$disableElevati = props.disableElevation,
      disableElevation = _props$disableElevati === void 0 ? false : _props$disableElevati,
      _props$disableFocusRi = props.disableFocusRipple,
      disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi,
      endIconProp = props.endIcon,
      focusVisibleClassName = props.focusVisibleClassName,
      _props$fullWidth = props.fullWidth,
      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
      _props$size = props.size,
      size = _props$size === void 0 ? 'medium' : _props$size,
      startIconProp = props.startIcon,
      _props$type = props.type,
      type = _props$type === void 0 ? 'button' : _props$type,
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? 'text' : _props$variant,
      other = _objectWithoutProperties(props, ["children", "classes", "className", "color", "component", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"]);
    var startIcon = startIconProp && /*#__PURE__*/reactExports.createElement("span", {
      className: clsx(classes.startIcon, classes["iconSize".concat(capitalize(size))])
    }, startIconProp);
    var endIcon = endIconProp && /*#__PURE__*/reactExports.createElement("span", {
      className: clsx(classes.endIcon, classes["iconSize".concat(capitalize(size))])
    }, endIconProp);
    return /*#__PURE__*/reactExports.createElement(ButtonBase$1, _extends({
      className: clsx(classes.root, classes[variant], className, color === 'inherit' ? classes.colorInherit : color !== 'default' && classes["".concat(variant).concat(capitalize(color))], size !== 'medium' && [classes["".concat(variant, "Size").concat(capitalize(size))], classes["size".concat(capitalize(size))]], disableElevation && classes.disableElevation, disabled && classes.disabled, fullWidth && classes.fullWidth),
      component: component,
      disabled: disabled,
      focusRipple: !disableFocusRipple,
      focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
      ref: ref,
      type: type
    }, other), /*#__PURE__*/reactExports.createElement("span", {
      className: classes.label
    }, startIcon, children, endIcon));
  });
  Button.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * The content of the button.
     */
    children: PropTypes.node,
    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,
    /**
     * @ignore
     */
    className: PropTypes.string,
    /**
     * The color of the component. It supports those theme colors that make sense for this component.
     */
    color: PropTypes.oneOf(['default', 'inherit', 'primary', 'secondary']),
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: PropTypes
    /* @typescript-to-proptypes-ignore */.elementType,
    /**
     * If `true`, the button will be disabled.
     */
    disabled: PropTypes.bool,
    /**
     * If `true`, no elevation is used.
     */
    disableElevation: PropTypes.bool,
    /**
     * If `true`, the  keyboard focus ripple will be disabled.
     */
    disableFocusRipple: PropTypes.bool,
    /**
     * If `true`, the ripple effect will be disabled.
     *
     * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
     * to highlight the element by applying separate styles with the `focusVisibleClassName`.
     */
    disableRipple: PropTypes.bool,
    /**
     * Element placed after the children.
     */
    endIcon: PropTypes.node,
    /**
     * @ignore
     */
    focusVisibleClassName: PropTypes.string,
    /**
     * If `true`, the button will take up the full width of its container.
     */
    fullWidth: PropTypes.bool,
    /**
     * The URL to link to when the button is clicked.
     * If defined, an `a` element will be used as the root node.
     */
    href: PropTypes.string,
    /**
     * The size of the button.
     * `small` is equivalent to the dense button styling.
     */
    size: PropTypes.oneOf(['large', 'medium', 'small']),
    /**
     * Element placed before the children.
     */
    startIcon: PropTypes.node,
    /**
     * @ignore
     */
    type: PropTypes.oneOfType([PropTypes.oneOf(['button', 'reset', 'submit']), PropTypes.string]),
    /**
     * The variant to use.
     */
    variant: PropTypes.oneOf(['contained', 'outlined', 'text'])
  } ;
  var Button$1 = withStyles(styles$8, {
    name: 'MuiButton'
  })(Button);

  function getContainer$1(container) {
    container = typeof container === 'function' ? container() : container; // #StrictMode ready

    return reactDomExports.findDOMNode(container);
  }
  var useEnhancedEffect$1 = typeof window !== 'undefined' ? reactExports.useLayoutEffect : reactExports.useEffect;
  /**
   * Portals provide a first-class way to render children into a DOM node
   * that exists outside the DOM hierarchy of the parent component.
   */

  var Portal = /*#__PURE__*/reactExports.forwardRef(function Portal(props, ref) {
    var children = props.children,
      container = props.container,
      _props$disablePortal = props.disablePortal,
      disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal,
      onRendered = props.onRendered;
    var _React$useState = reactExports.useState(null),
      mountNode = _React$useState[0],
      setMountNode = _React$useState[1];
    var handleRef = useForkRef( /*#__PURE__*/reactExports.isValidElement(children) ? children.ref : null, ref);
    useEnhancedEffect$1(function () {
      if (!disablePortal) {
        setMountNode(getContainer$1(container) || document.body);
      }
    }, [container, disablePortal]);
    useEnhancedEffect$1(function () {
      if (mountNode && !disablePortal) {
        setRef(ref, mountNode);
        return function () {
          setRef(ref, null);
        };
      }
      return undefined;
    }, [ref, mountNode, disablePortal]);
    useEnhancedEffect$1(function () {
      if (onRendered && (mountNode || disablePortal)) {
        onRendered();
      }
    }, [onRendered, mountNode, disablePortal]);
    if (disablePortal) {
      if ( /*#__PURE__*/reactExports.isValidElement(children)) {
        return /*#__PURE__*/reactExports.cloneElement(children, {
          ref: handleRef
        });
      }
      return children;
    }
    return mountNode ? /*#__PURE__*/reactDomExports.createPortal(children, mountNode) : mountNode;
  });
  Portal.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * The children to render into the `container`.
     */
    children: PropTypes.node,
    /**
     * A HTML element, component instance, or function that returns either.
     * The `container` will have the portal children appended to it.
     *
     * By default, it uses the body of the top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: PropTypes
    /* @typescript-to-proptypes-ignore */.oneOfType([HTMLElementType, PropTypes.instanceOf(reactExports.Component), PropTypes.func]),
    /**
     * Disable the portal behavior.
     * The children stay within it's parent DOM hierarchy.
     */
    disablePortal: PropTypes.bool,
    /**
     * Callback fired once the children has been mounted into the `container`.
     *
     * This prop will be removed in v5, the ref can be used instead.
     * @deprecated Use the ref instead.
     */
    onRendered: deprecatedPropType(PropTypes.func, 'Use the ref instead.')
  } ;
  {
    // eslint-disable-next-line
    Portal['propTypes' + ''] = exactProp(Portal.propTypes);
  }
  var Portal$1 = Portal;

  // A change of the browser zoom change the scrollbar size.
  // Credit https://github.com/twbs/bootstrap/blob/3ffe3a5d82f6f561b82ff78d82b32a7d14aed558/js/src/modal.js#L512-L519
  function getScrollbarSize() {
    var scrollDiv = document.createElement('div');
    scrollDiv.style.width = '99px';
    scrollDiv.style.height = '99px';
    scrollDiv.style.position = 'absolute';
    scrollDiv.style.top = '-9999px';
    scrollDiv.style.overflow = 'scroll';
    document.body.appendChild(scrollDiv);
    var scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    return scrollbarSize;
  }

  function isOverflowing(container) {
    var doc = ownerDocument(container);
    if (doc.body === container) {
      return ownerWindow(doc).innerWidth > doc.documentElement.clientWidth;
    }
    return container.scrollHeight > container.clientHeight;
  }
  function ariaHidden(node, show) {
    if (show) {
      node.setAttribute('aria-hidden', 'true');
    } else {
      node.removeAttribute('aria-hidden');
    }
  }
  function getPaddingRight(node) {
    return parseInt(window.getComputedStyle(node)['padding-right'], 10) || 0;
  }
  function ariaHiddenSiblings(container, mountNode, currentNode) {
    var nodesToExclude = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    var show = arguments.length > 4 ? arguments[4] : undefined;
    var blacklist = [mountNode, currentNode].concat(_toConsumableArray(nodesToExclude));
    var blacklistTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE'];
    [].forEach.call(container.children, function (node) {
      if (node.nodeType === 1 && blacklist.indexOf(node) === -1 && blacklistTagNames.indexOf(node.tagName) === -1) {
        ariaHidden(node, show);
      }
    });
  }
  function findIndexOf(containerInfo, callback) {
    var idx = -1;
    containerInfo.some(function (item, index) {
      if (callback(item)) {
        idx = index;
        return true;
      }
      return false;
    });
    return idx;
  }
  function handleContainer(containerInfo, props) {
    var restoreStyle = [];
    var restorePaddings = [];
    var container = containerInfo.container;
    var fixedNodes;
    if (!props.disableScrollLock) {
      if (isOverflowing(container)) {
        // Compute the size before applying overflow hidden to avoid any scroll jumps.
        var scrollbarSize = getScrollbarSize();
        restoreStyle.push({
          value: container.style.paddingRight,
          key: 'padding-right',
          el: container
        }); // Use computed style, here to get the real padding to add our scrollbar width.

        container.style['padding-right'] = "".concat(getPaddingRight(container) + scrollbarSize, "px"); // .mui-fixed is a global helper.

        fixedNodes = ownerDocument(container).querySelectorAll('.mui-fixed');
        [].forEach.call(fixedNodes, function (node) {
          restorePaddings.push(node.style.paddingRight);
          node.style.paddingRight = "".concat(getPaddingRight(node) + scrollbarSize, "px");
        });
      } // Improve Gatsby support
      // https://css-tricks.com/snippets/css/force-vertical-scrollbar/

      var parent = container.parentElement;
      var scrollContainer = parent.nodeName === 'HTML' && window.getComputedStyle(parent)['overflow-y'] === 'scroll' ? parent : container; // Block the scroll even if no scrollbar is visible to account for mobile keyboard
      // screensize shrink.

      restoreStyle.push({
        value: scrollContainer.style.overflow,
        key: 'overflow',
        el: scrollContainer
      });
      scrollContainer.style.overflow = 'hidden';
    }
    var restore = function restore() {
      if (fixedNodes) {
        [].forEach.call(fixedNodes, function (node, i) {
          if (restorePaddings[i]) {
            node.style.paddingRight = restorePaddings[i];
          } else {
            node.style.removeProperty('padding-right');
          }
        });
      }
      restoreStyle.forEach(function (_ref) {
        var value = _ref.value,
          el = _ref.el,
          key = _ref.key;
        if (value) {
          el.style.setProperty(key, value);
        } else {
          el.style.removeProperty(key);
        }
      });
    };
    return restore;
  }
  function getHiddenSiblings(container) {
    var hiddenSiblings = [];
    [].forEach.call(container.children, function (node) {
      if (node.getAttribute && node.getAttribute('aria-hidden') === 'true') {
        hiddenSiblings.push(node);
      }
    });
    return hiddenSiblings;
  }
  /**
   * @ignore - do not document.
   *
   * Proper state management for containers and the modals in those containers.
   * Simplified, but inspired by react-overlay's ModalManager class.
   * Used by the Modal to ensure proper styling of containers.
   */

  var ModalManager = /*#__PURE__*/function () {
    function ModalManager() {
      _classCallCheck(this, ModalManager);

      // this.modals[modalIndex] = modal
      this.modals = []; // this.containers[containerIndex] = {
      //   modals: [],
      //   container,
      //   restore: null,
      // }

      this.containers = [];
    }
    _createClass(ModalManager, [{
      key: "add",
      value: function add(modal, container) {
        var modalIndex = this.modals.indexOf(modal);
        if (modalIndex !== -1) {
          return modalIndex;
        }
        modalIndex = this.modals.length;
        this.modals.push(modal); // If the modal we are adding is already in the DOM.

        if (modal.modalRef) {
          ariaHidden(modal.modalRef, false);
        }
        var hiddenSiblingNodes = getHiddenSiblings(container);
        ariaHiddenSiblings(container, modal.mountNode, modal.modalRef, hiddenSiblingNodes, true);
        var containerIndex = findIndexOf(this.containers, function (item) {
          return item.container === container;
        });
        if (containerIndex !== -1) {
          this.containers[containerIndex].modals.push(modal);
          return modalIndex;
        }
        this.containers.push({
          modals: [modal],
          container: container,
          restore: null,
          hiddenSiblingNodes: hiddenSiblingNodes
        });
        return modalIndex;
      }
    }, {
      key: "mount",
      value: function mount(modal, props) {
        var containerIndex = findIndexOf(this.containers, function (item) {
          return item.modals.indexOf(modal) !== -1;
        });
        var containerInfo = this.containers[containerIndex];
        if (!containerInfo.restore) {
          containerInfo.restore = handleContainer(containerInfo, props);
        }
      }
    }, {
      key: "remove",
      value: function remove(modal) {
        var modalIndex = this.modals.indexOf(modal);
        if (modalIndex === -1) {
          return modalIndex;
        }
        var containerIndex = findIndexOf(this.containers, function (item) {
          return item.modals.indexOf(modal) !== -1;
        });
        var containerInfo = this.containers[containerIndex];
        containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
        this.modals.splice(modalIndex, 1); // If that was the last modal in a container, clean up the container.

        if (containerInfo.modals.length === 0) {
          // The modal might be closed before it had the chance to be mounted in the DOM.
          if (containerInfo.restore) {
            containerInfo.restore();
          }
          if (modal.modalRef) {
            // In case the modal wasn't in the DOM yet.
            ariaHidden(modal.modalRef, true);
          }
          ariaHiddenSiblings(containerInfo.container, modal.mountNode, modal.modalRef, containerInfo.hiddenSiblingNodes, false);
          this.containers.splice(containerIndex, 1);
        } else {
          // Otherwise make sure the next top modal is visible to a screen reader.
          var nextTop = containerInfo.modals[containerInfo.modals.length - 1]; // as soon as a modal is adding its modalRef is undefined. it can't set
          // aria-hidden because the dom element doesn't exist either
          // when modal was unmounted before modalRef gets null

          if (nextTop.modalRef) {
            ariaHidden(nextTop.modalRef, false);
          }
        }
        return modalIndex;
      }
    }, {
      key: "isTopModal",
      value: function isTopModal(modal) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
      }
    }]);
    return ModalManager;
  }();

  /* eslint-disable consistent-return, jsx-a11y/no-noninteractive-tabindex, camelcase */
  /**
   * Utility component that locks focus inside the component.
   */

  function Unstable_TrapFocus(props) {
    var children = props.children,
      _props$disableAutoFoc = props.disableAutoFocus,
      disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc,
      _props$disableEnforce = props.disableEnforceFocus,
      disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce,
      _props$disableRestore = props.disableRestoreFocus,
      disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore,
      getDoc = props.getDoc,
      isEnabled = props.isEnabled,
      open = props.open;
    var ignoreNextEnforceFocus = reactExports.useRef();
    var sentinelStart = reactExports.useRef(null);
    var sentinelEnd = reactExports.useRef(null);
    var nodeToRestore = reactExports.useRef();
    var rootRef = reactExports.useRef(null); // can be removed once we drop support for non ref forwarding class components

    var handleOwnRef = reactExports.useCallback(function (instance) {
      // #StrictMode ready
      rootRef.current = reactDomExports.findDOMNode(instance);
    }, []);
    var handleRef = useForkRef(children.ref, handleOwnRef);
    var prevOpenRef = reactExports.useRef();
    reactExports.useEffect(function () {
      prevOpenRef.current = open;
    }, [open]);
    if (!prevOpenRef.current && open && typeof window !== 'undefined') {
      // WARNING: Potentially unsafe in concurrent mode.
      // The way the read on `nodeToRestore` is setup could make this actually safe.
      // Say we render `open={false}` -> `open={true}` but never commit.
      // We have now written a state that wasn't committed. But no committed effect
      // will read this wrong value. We only read from `nodeToRestore` in effects
      // that were committed on `open={true}`
      // WARNING: Prevents the instance from being garbage collected. Should only
      // hold a weak ref.
      nodeToRestore.current = getDoc().activeElement;
    }
    reactExports.useEffect(function () {
      if (!open) {
        return;
      }
      var doc = ownerDocument(rootRef.current); // We might render an empty child.

      if (!disableAutoFocus && rootRef.current && !rootRef.current.contains(doc.activeElement)) {
        if (!rootRef.current.hasAttribute('tabIndex')) {
          {
            console.error(['Material-UI: The modal content node does not accept focus.', 'For the benefit of assistive technologies, ' + 'the tabIndex of the node is being set to "-1".'].join('\n'));
          }
          rootRef.current.setAttribute('tabIndex', -1);
        }
        rootRef.current.focus();
      }
      var contain = function contain() {
        var rootElement = rootRef.current; // Cleanup functions are executed lazily in React 17.
        // Contain can be called between the component being unmounted and its cleanup function being run.

        if (rootElement === null) {
          return;
        }
        if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
          ignoreNextEnforceFocus.current = false;
          return;
        }
        if (rootRef.current && !rootRef.current.contains(doc.activeElement)) {
          rootRef.current.focus();
        }
      };
      var loopFocus = function loopFocus(event) {
        // 9 = Tab
        if (disableEnforceFocus || !isEnabled() || event.keyCode !== 9) {
          return;
        } // Make sure the next tab starts from the right place.

        if (doc.activeElement === rootRef.current) {
          // We need to ignore the next contain as
          // it will try to move the focus back to the rootRef element.
          ignoreNextEnforceFocus.current = true;
          if (event.shiftKey) {
            sentinelEnd.current.focus();
          } else {
            sentinelStart.current.focus();
          }
        }
      };
      doc.addEventListener('focus', contain, true);
      doc.addEventListener('keydown', loopFocus, true); // With Edge, Safari and Firefox, no focus related events are fired when the focused area stops being a focused area
      // e.g. https://bugzilla.mozilla.org/show_bug.cgi?id=559561.
      //
      // The whatwg spec defines how the browser should behave but does not explicitly mention any events:
      // https://html.spec.whatwg.org/multipage/interaction.html#focus-fixup-rule.

      var interval = setInterval(function () {
        contain();
      }, 50);
      return function () {
        clearInterval(interval);
        doc.removeEventListener('focus', contain, true);
        doc.removeEventListener('keydown', loopFocus, true); // restoreLastFocus()

        if (!disableRestoreFocus) {
          // In IE 11 it is possible for document.activeElement to be null resulting
          // in nodeToRestore.current being null.
          // Not all elements in IE 11 have a focus method.
          // Once IE 11 support is dropped the focus() call can be unconditional.
          if (nodeToRestore.current && nodeToRestore.current.focus) {
            nodeToRestore.current.focus();
          }
          nodeToRestore.current = null;
        }
      };
    }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open]);
    return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement("div", {
      tabIndex: 0,
      ref: sentinelStart,
      "data-test": "sentinelStart"
    }), /*#__PURE__*/reactExports.cloneElement(children, {
      ref: handleRef
    }), /*#__PURE__*/reactExports.createElement("div", {
      tabIndex: 0,
      ref: sentinelEnd,
      "data-test": "sentinelEnd"
    }));
  }
  Unstable_TrapFocus.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * A single child content element.
     */
    children: PropTypes.node,
    /**
     * If `true`, the trap focus will not automatically shift focus to itself when it opens, and
     * replace it to the last focused element when it closes.
     * This also works correctly with any trap focus children that have the `disableAutoFocus` prop.
     *
     * Generally this should never be set to `true` as it makes the trap focus less
     * accessible to assistive technologies, like screen readers.
     */
    disableAutoFocus: PropTypes.bool,
    /**
     * If `true`, the trap focus will not prevent focus from leaving the trap focus while open.
     *
     * Generally this should never be set to `true` as it makes the trap focus less
     * accessible to assistive technologies, like screen readers.
     */
    disableEnforceFocus: PropTypes.bool,
    /**
     * If `true`, the trap focus will not restore focus to previously focused element once
     * trap focus is hidden.
     */
    disableRestoreFocus: PropTypes.bool,
    /**
     * Return the document to consider.
     * We use it to implement the restore focus between different browser documents.
     */
    getDoc: PropTypes.func.isRequired,
    /**
     * Do we still want to enforce the focus?
     * This prop helps nesting TrapFocus elements.
     */
    isEnabled: PropTypes.func.isRequired,
    /**
     * If `true`, focus will be locked.
     */
    open: PropTypes.bool.isRequired
  } ;
  {
    // eslint-disable-next-line
    Unstable_TrapFocus['propTypes' + ''] = exactProp(Unstable_TrapFocus.propTypes);
  }

  var styles$7 = {
    /* Styles applied to the root element. */
    root: {
      zIndex: -1,
      position: 'fixed',
      right: 0,
      bottom: 0,
      top: 0,
      left: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      WebkitTapHighlightColor: 'transparent'
    },
    /* Styles applied to the root element if `invisible={true}`. */
    invisible: {
      backgroundColor: 'transparent'
    }
  };
  /**
   * @ignore - internal component.
   */

  var SimpleBackdrop = /*#__PURE__*/reactExports.forwardRef(function SimpleBackdrop(props, ref) {
    var _props$invisible = props.invisible,
      invisible = _props$invisible === void 0 ? false : _props$invisible,
      open = props.open,
      other = _objectWithoutProperties(props, ["invisible", "open"]);
    return open ? /*#__PURE__*/reactExports.createElement("div", _extends({
      "aria-hidden": true,
      ref: ref
    }, other, {
      style: _extends({}, styles$7.root, invisible ? styles$7.invisible : {}, other.style)
    })) : null;
  });
  SimpleBackdrop.propTypes = {
    /**
     * If `true`, the backdrop is invisible.
     * It can be used when rendering a popover or a custom select component.
     */
    invisible: PropTypes.bool,
    /**
     * If `true`, the backdrop is open.
     */
    open: PropTypes.bool.isRequired
  } ;
  var SimpleBackdrop$1 = SimpleBackdrop;

  function getContainer(container) {
    container = typeof container === 'function' ? container() : container;
    return reactDomExports.findDOMNode(container);
  }
  function getHasTransition(props) {
    return props.children ? props.children.props.hasOwnProperty('in') : false;
  } // A modal manager used to track and manage the state of open Modals.
  // Modals don't open on the server so this won't conflict with concurrent requests.

  var defaultManager = new ModalManager();
  var styles$6 = function styles(theme) {
    return {
      /* Styles applied to the root element. */
      root: {
        position: 'fixed',
        zIndex: theme.zIndex.modal,
        right: 0,
        bottom: 0,
        top: 0,
        left: 0
      },
      /* Styles applied to the root element if the `Modal` has exited. */
      hidden: {
        visibility: 'hidden'
      }
    };
  };
  /**
   * Modal is a lower-level construct that is leveraged by the following components:
   *
   * - [Dialog](/api/dialog/)
   * - [Drawer](/api/drawer/)
   * - [Menu](/api/menu/)
   * - [Popover](/api/popover/)
   *
   * If you are creating a modal dialog, you probably want to use the [Dialog](/api/dialog/) component
   * rather than directly using Modal.
   *
   * This component shares many concepts with [react-overlays](https://react-bootstrap.github.io/react-overlays/#modals).
   */

  var Modal = /*#__PURE__*/reactExports.forwardRef(function Modal(inProps, ref) {
    var theme = useTheme$1();
    var props = getThemeProps({
      name: 'MuiModal',
      props: _extends({}, inProps),
      theme: theme
    });
    var _props$BackdropCompon = props.BackdropComponent,
      BackdropComponent = _props$BackdropCompon === void 0 ? SimpleBackdrop$1 : _props$BackdropCompon,
      BackdropProps = props.BackdropProps,
      children = props.children,
      _props$closeAfterTran = props.closeAfterTransition,
      closeAfterTransition = _props$closeAfterTran === void 0 ? false : _props$closeAfterTran,
      container = props.container,
      _props$disableAutoFoc = props.disableAutoFocus,
      disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc,
      _props$disableBackdro = props.disableBackdropClick,
      disableBackdropClick = _props$disableBackdro === void 0 ? false : _props$disableBackdro,
      _props$disableEnforce = props.disableEnforceFocus,
      disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce,
      _props$disableEscapeK = props.disableEscapeKeyDown,
      disableEscapeKeyDown = _props$disableEscapeK === void 0 ? false : _props$disableEscapeK,
      _props$disablePortal = props.disablePortal,
      disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal,
      _props$disableRestore = props.disableRestoreFocus,
      disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore,
      _props$disableScrollL = props.disableScrollLock,
      disableScrollLock = _props$disableScrollL === void 0 ? false : _props$disableScrollL,
      _props$hideBackdrop = props.hideBackdrop,
      hideBackdrop = _props$hideBackdrop === void 0 ? false : _props$hideBackdrop,
      _props$keepMounted = props.keepMounted,
      keepMounted = _props$keepMounted === void 0 ? false : _props$keepMounted,
      _props$manager = props.manager,
      manager = _props$manager === void 0 ? defaultManager : _props$manager,
      onBackdropClick = props.onBackdropClick,
      onClose = props.onClose,
      onEscapeKeyDown = props.onEscapeKeyDown,
      onRendered = props.onRendered,
      open = props.open,
      other = _objectWithoutProperties(props, ["BackdropComponent", "BackdropProps", "children", "closeAfterTransition", "container", "disableAutoFocus", "disableBackdropClick", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onEscapeKeyDown", "onRendered", "open"]);
    var _React$useState = reactExports.useState(true),
      exited = _React$useState[0],
      setExited = _React$useState[1];
    var modal = reactExports.useRef({});
    var mountNodeRef = reactExports.useRef(null);
    var modalRef = reactExports.useRef(null);
    var handleRef = useForkRef(modalRef, ref);
    var hasTransition = getHasTransition(props);
    var getDoc = function getDoc() {
      return ownerDocument(mountNodeRef.current);
    };
    var getModal = function getModal() {
      modal.current.modalRef = modalRef.current;
      modal.current.mountNode = mountNodeRef.current;
      return modal.current;
    };
    var handleMounted = function handleMounted() {
      manager.mount(getModal(), {
        disableScrollLock: disableScrollLock
      }); // Fix a bug on Chrome where the scroll isn't initially 0.

      modalRef.current.scrollTop = 0;
    };
    var handleOpen = useEventCallback(function () {
      var resolvedContainer = getContainer(container) || getDoc().body;
      manager.add(getModal(), resolvedContainer); // The element was already mounted.

      if (modalRef.current) {
        handleMounted();
      }
    });
    var isTopModal = reactExports.useCallback(function () {
      return manager.isTopModal(getModal());
    }, [manager]);
    var handlePortalRef = useEventCallback(function (node) {
      mountNodeRef.current = node;
      if (!node) {
        return;
      }
      if (onRendered) {
        onRendered();
      }
      if (open && isTopModal()) {
        handleMounted();
      } else {
        ariaHidden(modalRef.current, true);
      }
    });
    var handleClose = reactExports.useCallback(function () {
      manager.remove(getModal());
    }, [manager]);
    reactExports.useEffect(function () {
      return function () {
        handleClose();
      };
    }, [handleClose]);
    reactExports.useEffect(function () {
      if (open) {
        handleOpen();
      } else if (!hasTransition || !closeAfterTransition) {
        handleClose();
      }
    }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
    if (!keepMounted && !open && (!hasTransition || exited)) {
      return null;
    }
    var handleEnter = function handleEnter() {
      setExited(false);
    };
    var handleExited = function handleExited() {
      setExited(true);
      if (closeAfterTransition) {
        handleClose();
      }
    };
    var handleBackdropClick = function handleBackdropClick(event) {
      if (event.target !== event.currentTarget) {
        return;
      }
      if (onBackdropClick) {
        onBackdropClick(event);
      }
      if (!disableBackdropClick && onClose) {
        onClose(event, 'backdropClick');
      }
    };
    var handleKeyDown = function handleKeyDown(event) {
      // The handler doesn't take event.defaultPrevented into account:
      //
      // event.preventDefault() is meant to stop default behaviours like
      // clicking a checkbox to check it, hitting a button to submit a form,
      // and hitting left arrow to move the cursor in a text input etc.
      // Only special HTML elements have these default behaviors.
      if (event.key !== 'Escape' || !isTopModal()) {
        return;
      }
      if (onEscapeKeyDown) {
        onEscapeKeyDown(event);
      }
      if (!disableEscapeKeyDown) {
        // Swallow the event, in case someone is listening for the escape key on the body.
        event.stopPropagation();
        if (onClose) {
          onClose(event, 'escapeKeyDown');
        }
      }
    };
    var inlineStyle = styles$6(theme || {
      zIndex: zIndex$1
    });
    var childProps = {};
    if (children.props.tabIndex === undefined) {
      childProps.tabIndex = children.props.tabIndex || '-1';
    } // It's a Transition like component

    if (hasTransition) {
      childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter);
      childProps.onExited = createChainedFunction(handleExited, children.props.onExited);
    }
    return /*#__PURE__*/reactExports.createElement(Portal$1, {
      ref: handlePortalRef,
      container: container,
      disablePortal: disablePortal
    }, /*#__PURE__*/reactExports.createElement("div", _extends({
      ref: handleRef,
      onKeyDown: handleKeyDown,
      role: "presentation"
    }, other, {
      style: _extends({}, inlineStyle.root, !open && exited ? inlineStyle.hidden : {}, other.style)
    }), hideBackdrop ? null : /*#__PURE__*/reactExports.createElement(BackdropComponent, _extends({
      open: open,
      onClick: handleBackdropClick
    }, BackdropProps)), /*#__PURE__*/reactExports.createElement(Unstable_TrapFocus, {
      disableEnforceFocus: disableEnforceFocus,
      disableAutoFocus: disableAutoFocus,
      disableRestoreFocus: disableRestoreFocus,
      getDoc: getDoc,
      isEnabled: isTopModal,
      open: open
    }, /*#__PURE__*/reactExports.cloneElement(children, childProps))));
  });
  Modal.propTypes = {
    /**
     * A backdrop component. This prop enables custom backdrop rendering.
     */
    BackdropComponent: PropTypes.elementType,
    /**
     * Props applied to the [`Backdrop`](/api/backdrop/) element.
     */
    BackdropProps: PropTypes.object,
    /**
     * A single child content element.
     */
    children: elementAcceptingRef$1.isRequired,
    /**
     * When set to true the Modal waits until a nested Transition is completed before closing.
     */
    closeAfterTransition: PropTypes.bool,
    /**
     * A HTML element, component instance, or function that returns either.
     * The `container` will have the portal children appended to it.
     *
     * By default, it uses the body of the top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: PropTypes
    /* @typescript-to-proptypes-ignore */.oneOfType([HTMLElementType, PropTypes.instanceOf(reactExports.Component), PropTypes.func]),
    /**
     * If `true`, the modal will not automatically shift focus to itself when it opens, and
     * replace it to the last focused element when it closes.
     * This also works correctly with any modal children that have the `disableAutoFocus` prop.
     *
     * Generally this should never be set to `true` as it makes the modal less
     * accessible to assistive technologies, like screen readers.
     */
    disableAutoFocus: PropTypes.bool,
    /**
     * If `true`, clicking the backdrop will not fire `onClose`.
     */
    disableBackdropClick: deprecatedPropType(PropTypes.bool, 'Use the onClose prop with the `reason` argument to filter the `backdropClick` events.'),
    /**
     * If `true`, the modal will not prevent focus from leaving the modal while open.
     *
     * Generally this should never be set to `true` as it makes the modal less
     * accessible to assistive technologies, like screen readers.
     */
    disableEnforceFocus: PropTypes.bool,
    /**
     * If `true`, hitting escape will not fire `onClose`.
     */
    disableEscapeKeyDown: PropTypes.bool,
    /**
     * Disable the portal behavior.
     * The children stay within it's parent DOM hierarchy.
     */
    disablePortal: PropTypes.bool,
    /**
     * If `true`, the modal will not restore focus to previously focused element once
     * modal is hidden.
     */
    disableRestoreFocus: PropTypes.bool,
    /**
     * Disable the scroll lock behavior.
     */
    disableScrollLock: PropTypes.bool,
    /**
     * If `true`, the backdrop is not rendered.
     */
    hideBackdrop: PropTypes.bool,
    /**
     * Always keep the children in the DOM.
     * This prop can be useful in SEO situation or
     * when you want to maximize the responsiveness of the Modal.
     */
    keepMounted: PropTypes.bool,
    /**
     * @ignore
     */
    manager: PropTypes.object,
    /**
     * Callback fired when the backdrop is clicked.
     */
    onBackdropClick: deprecatedPropType(PropTypes.func, 'Use the onClose prop with the `reason` argument to handle the `backdropClick` events.'),
    /**
     * Callback fired when the component requests to be closed.
     * The `reason` parameter can optionally be used to control the response to `onClose`.
     *
     * @param {object} event The event source of the callback.
     * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
     */
    onClose: PropTypes.func,
    /**
     * Callback fired when the escape key is pressed,
     * `disableEscapeKeyDown` is false and the modal is in focus.
     */
    onEscapeKeyDown: deprecatedPropType(PropTypes.func, 'Use the onClose prop with the `reason` argument to handle the `escapeKeyDown` events.'),
    /**
     * Callback fired once the children has been mounted into the `container`.
     * It signals that the `open={true}` prop took effect.
     *
     * This prop will be removed in v5, the ref can be used instead.
     */
    onRendered: deprecatedPropType(PropTypes.func, 'Use the ref instead.'),
    /**
     * If `true`, the modal is open.
     */
    open: PropTypes.bool.isRequired
  } ;
  var Modal$1 = Modal;

  function getScale$1(value) {
    return "scale(".concat(value, ", ").concat(Math.pow(value, 2), ")");
  }
  var styles$5 = {
    entering: {
      opacity: 1,
      transform: getScale$1(1)
    },
    entered: {
      opacity: 1,
      transform: 'none'
    }
  };
  /**
   * The Grow transition is used by the [Tooltip](/components/tooltips/) and
   * [Popover](/components/popover/) components.
   * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
   */

  var Grow = /*#__PURE__*/reactExports.forwardRef(function Grow(props, ref) {
    var children = props.children,
      _props$disableStrictM = props.disableStrictModeCompat,
      disableStrictModeCompat = _props$disableStrictM === void 0 ? false : _props$disableStrictM,
      inProp = props.in,
      onEnter = props.onEnter,
      onEntered = props.onEntered,
      onEntering = props.onEntering,
      onExit = props.onExit,
      onExited = props.onExited,
      onExiting = props.onExiting,
      style = props.style,
      _props$timeout = props.timeout,
      timeout = _props$timeout === void 0 ? 'auto' : _props$timeout,
      _props$TransitionComp = props.TransitionComponent,
      TransitionComponent = _props$TransitionComp === void 0 ? Transition$1 : _props$TransitionComp,
      other = _objectWithoutProperties(props, ["children", "disableStrictModeCompat", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"]);
    var timer = reactExports.useRef();
    var autoTimeout = reactExports.useRef();
    var theme = useTheme();
    var enableStrictModeCompat = theme.unstable_strictMode && !disableStrictModeCompat;
    var nodeRef = reactExports.useRef(null);
    var foreignRef = useForkRef(children.ref, ref);
    var handleRef = useForkRef(enableStrictModeCompat ? nodeRef : undefined, foreignRef);
    var normalizedTransitionCallback = function normalizedTransitionCallback(callback) {
      return function (nodeOrAppearing, maybeAppearing) {
        if (callback) {
          var _ref = enableStrictModeCompat ? [nodeRef.current, nodeOrAppearing] : [nodeOrAppearing, maybeAppearing],
            _ref2 = _slicedToArray(_ref, 2),
            node = _ref2[0],
            isAppearing = _ref2[1]; // onEnterXxx and onExitXxx callbacks have a different arguments.length value.

          if (isAppearing === undefined) {
            callback(node);
          } else {
            callback(node, isAppearing);
          }
        }
      };
    };
    var handleEntering = normalizedTransitionCallback(onEntering);
    var handleEnter = normalizedTransitionCallback(function (node, isAppearing) {
      reflow(node); // So the animation always start from the start.

      var _getTransitionProps = getTransitionProps({
          style: style,
          timeout: timeout
        }, {
          mode: 'enter'
        }),
        transitionDuration = _getTransitionProps.duration,
        delay = _getTransitionProps.delay;
      var duration;
      if (timeout === 'auto') {
        duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
        autoTimeout.current = duration;
      } else {
        duration = transitionDuration;
      }
      node.style.transition = [theme.transitions.create('opacity', {
        duration: duration,
        delay: delay
      }), theme.transitions.create('transform', {
        duration: duration * 0.666,
        delay: delay
      })].join(',');
      if (onEnter) {
        onEnter(node, isAppearing);
      }
    });
    var handleEntered = normalizedTransitionCallback(onEntered);
    var handleExiting = normalizedTransitionCallback(onExiting);
    var handleExit = normalizedTransitionCallback(function (node) {
      var _getTransitionProps2 = getTransitionProps({
          style: style,
          timeout: timeout
        }, {
          mode: 'exit'
        }),
        transitionDuration = _getTransitionProps2.duration,
        delay = _getTransitionProps2.delay;
      var duration;
      if (timeout === 'auto') {
        duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
        autoTimeout.current = duration;
      } else {
        duration = transitionDuration;
      }
      node.style.transition = [theme.transitions.create('opacity', {
        duration: duration,
        delay: delay
      }), theme.transitions.create('transform', {
        duration: duration * 0.666,
        delay: delay || duration * 0.333
      })].join(',');
      node.style.opacity = '0';
      node.style.transform = getScale$1(0.75);
      if (onExit) {
        onExit(node);
      }
    });
    var handleExited = normalizedTransitionCallback(onExited);
    var addEndListener = function addEndListener(nodeOrNext, maybeNext) {
      var next = enableStrictModeCompat ? nodeOrNext : maybeNext;
      if (timeout === 'auto') {
        timer.current = setTimeout(next, autoTimeout.current || 0);
      }
    };
    reactExports.useEffect(function () {
      return function () {
        clearTimeout(timer.current);
      };
    }, []);
    return /*#__PURE__*/reactExports.createElement(TransitionComponent, _extends({
      appear: true,
      in: inProp,
      nodeRef: enableStrictModeCompat ? nodeRef : undefined,
      onEnter: handleEnter,
      onEntered: handleEntered,
      onEntering: handleEntering,
      onExit: handleExit,
      onExited: handleExited,
      onExiting: handleExiting,
      addEndListener: addEndListener,
      timeout: timeout === 'auto' ? null : timeout
    }, other), function (state, childProps) {
      return /*#__PURE__*/reactExports.cloneElement(children, _extends({
        style: _extends({
          opacity: 0,
          transform: getScale$1(0.75),
          visibility: state === 'exited' && !inProp ? 'hidden' : undefined
        }, styles$5[state], style, children.props.style),
        ref: handleRef
      }, childProps));
    });
  });
  Grow.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * A single child content element.
     */
    children: PropTypes.element,
    /**
     * Enable this prop if you encounter 'Function components cannot be given refs',
     * use `unstable_createStrictModeTheme`,
     * and can't forward the ref in the child component.
     */
    disableStrictModeCompat: PropTypes.bool,
    /**
     * If `true`, show the component; triggers the enter or exit animation.
     */
    in: PropTypes.bool,
    /**
     * @ignore
     */
    onEnter: PropTypes.func,
    /**
     * @ignore
     */
    onEntered: PropTypes.func,
    /**
     * @ignore
     */
    onEntering: PropTypes.func,
    /**
     * @ignore
     */
    onExit: PropTypes.func,
    /**
     * @ignore
     */
    onExited: PropTypes.func,
    /**
     * @ignore
     */
    onExiting: PropTypes.func,
    /**
     * @ignore
     */
    style: PropTypes.object,
    /**
     * The duration for the transition, in milliseconds.
     * You may specify a single timeout for all transitions, or individually with an object.
     *
     * Set to 'auto' to automatically calculate transition time based on height.
     */
    timeout: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number, PropTypes.shape({
      appear: PropTypes.number,
      enter: PropTypes.number,
      exit: PropTypes.number
    })])
  } ;
  Grow.muiSupportAuto = true;
  var Grow$1 = Grow;

  /**
   * @ignore - internal component.
   */

  var ListContext = reactExports.createContext({});
  {
    ListContext.displayName = 'ListContext';
  }
  var ListContext$1 = ListContext;

  var styles$4 = {
    /* Styles applied to the root element. */
    root: {
      listStyle: 'none',
      margin: 0,
      padding: 0,
      position: 'relative'
    },
    /* Styles applied to the root element if `disablePadding={false}`. */
    padding: {
      paddingTop: 8,
      paddingBottom: 8
    },
    /* Styles applied to the root element if dense. */
    dense: {},
    /* Styles applied to the root element if a `subheader` is provided. */
    subheader: {
      paddingTop: 0
    }
  };
  var List = /*#__PURE__*/reactExports.forwardRef(function List(props, ref) {
    var children = props.children,
      classes = props.classes,
      className = props.className,
      _props$component = props.component,
      Component = _props$component === void 0 ? 'ul' : _props$component,
      _props$dense = props.dense,
      dense = _props$dense === void 0 ? false : _props$dense,
      _props$disablePadding = props.disablePadding,
      disablePadding = _props$disablePadding === void 0 ? false : _props$disablePadding,
      subheader = props.subheader,
      other = _objectWithoutProperties(props, ["children", "classes", "className", "component", "dense", "disablePadding", "subheader"]);
    var context = reactExports.useMemo(function () {
      return {
        dense: dense
      };
    }, [dense]);
    return /*#__PURE__*/reactExports.createElement(ListContext$1.Provider, {
      value: context
    }, /*#__PURE__*/reactExports.createElement(Component, _extends({
      className: clsx(classes.root, className, dense && classes.dense, !disablePadding && classes.padding, subheader && classes.subheader),
      ref: ref
    }, other), subheader, children));
  });
  List.propTypes = {
    /**
     * The content of the component.
     */
    children: PropTypes.node,
    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object.isRequired,
    /**
     * @ignore
     */
    className: PropTypes.string,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: PropTypes
    /* @typescript-to-proptypes-ignore */.elementType,
    /**
     * If `true`, compact vertical padding designed for keyboard and mouse input will be used for
     * the list and list items.
     * The prop is available to descendant components as the `dense` context.
     */
    dense: PropTypes.bool,
    /**
     * If `true`, vertical padding will be removed from the list.
     */
    disablePadding: PropTypes.bool,
    /**
     * The content of the subheader, normally `ListSubheader`.
     */
    subheader: PropTypes.node
  } ;
  var List$1 = withStyles(styles$4, {
    name: 'MuiList'
  })(List);

  var styles$3 = function styles(theme) {
    return {
      /* Styles applied to the (normally root) `component` element. May be wrapped by a `container`. */
      root: {
        display: 'flex',
        justifyContent: 'flex-start',
        alignItems: 'center',
        position: 'relative',
        textDecoration: 'none',
        width: '100%',
        boxSizing: 'border-box',
        textAlign: 'left',
        paddingTop: 8,
        paddingBottom: 8,
        '&$focusVisible': {
          backgroundColor: theme.palette.action.selected
        },
        '&$selected, &$selected:hover': {
          backgroundColor: theme.palette.action.selected
        },
        '&$disabled': {
          opacity: 0.5
        }
      },
      /* Styles applied to the `container` element if `children` includes `ListItemSecondaryAction`. */
      container: {
        position: 'relative'
      },
      /* Pseudo-class applied to the `component`'s `focusVisibleClassName` prop if `button={true}`. */
      focusVisible: {},
      /* Styles applied to the `component` element if dense. */
      dense: {
        paddingTop: 4,
        paddingBottom: 4
      },
      /* Styles applied to the `component` element if `alignItems="flex-start"`. */
      alignItemsFlexStart: {
        alignItems: 'flex-start'
      },
      /* Pseudo-class applied to the inner `component` element if `disabled={true}`. */
      disabled: {},
      /* Styles applied to the inner `component` element if `divider={true}`. */
      divider: {
        borderBottom: "1px solid ".concat(theme.palette.divider),
        backgroundClip: 'padding-box'
      },
      /* Styles applied to the inner `component` element if `disableGutters={false}`. */
      gutters: {
        paddingLeft: 16,
        paddingRight: 16
      },
      /* Styles applied to the inner `component` element if `button={true}`. */
      button: {
        transition: theme.transitions.create('background-color', {
          duration: theme.transitions.duration.shortest
        }),
        '&:hover': {
          textDecoration: 'none',
          backgroundColor: theme.palette.action.hover,
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: 'transparent'
          }
        }
      },
      /* Styles applied to the `component` element if `children` includes `ListItemSecondaryAction`. */
      secondaryAction: {
        // Add some space to avoid collision as `ListItemSecondaryAction`
        // is absolutely positioned.
        paddingRight: 48
      },
      /* Pseudo-class applied to the root element if `selected={true}`. */
      selected: {}
    };
  };
  var useEnhancedEffect = typeof window === 'undefined' ? reactExports.useEffect : reactExports.useLayoutEffect;
  /**
   * Uses an additional container component if `ListItemSecondaryAction` is the last child.
   */

  var ListItem = /*#__PURE__*/reactExports.forwardRef(function ListItem(props, ref) {
    var _props$alignItems = props.alignItems,
      alignItems = _props$alignItems === void 0 ? 'center' : _props$alignItems,
      _props$autoFocus = props.autoFocus,
      autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,
      _props$button = props.button,
      button = _props$button === void 0 ? false : _props$button,
      childrenProp = props.children,
      classes = props.classes,
      className = props.className,
      componentProp = props.component,
      _props$ContainerCompo = props.ContainerComponent,
      ContainerComponent = _props$ContainerCompo === void 0 ? 'li' : _props$ContainerCompo,
      _props$ContainerProps = props.ContainerProps;
    _props$ContainerProps = _props$ContainerProps === void 0 ? {} : _props$ContainerProps;
    var ContainerClassName = _props$ContainerProps.className,
      ContainerProps = _objectWithoutProperties(_props$ContainerProps, ["className"]),
      _props$dense = props.dense,
      dense = _props$dense === void 0 ? false : _props$dense,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      _props$disableGutters = props.disableGutters,
      disableGutters = _props$disableGutters === void 0 ? false : _props$disableGutters,
      _props$divider = props.divider,
      divider = _props$divider === void 0 ? false : _props$divider,
      focusVisibleClassName = props.focusVisibleClassName,
      _props$selected = props.selected,
      selected = _props$selected === void 0 ? false : _props$selected,
      other = _objectWithoutProperties(props, ["alignItems", "autoFocus", "button", "children", "classes", "className", "component", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "divider", "focusVisibleClassName", "selected"]);
    var context = reactExports.useContext(ListContext$1);
    var childContext = {
      dense: dense || context.dense || false,
      alignItems: alignItems
    };
    var listItemRef = reactExports.useRef(null);
    useEnhancedEffect(function () {
      if (autoFocus) {
        if (listItemRef.current) {
          listItemRef.current.focus();
        } else {
          console.error('Material-UI: Unable to set focus to a ListItem whose component has not been rendered.');
        }
      }
    }, [autoFocus]);
    var children = reactExports.Children.toArray(childrenProp);
    var hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ['ListItemSecondaryAction']);
    var handleOwnRef = reactExports.useCallback(function (instance) {
      // #StrictMode ready
      listItemRef.current = reactDomExports.findDOMNode(instance);
    }, []);
    var handleRef = useForkRef(handleOwnRef, ref);
    var componentProps = _extends({
      className: clsx(classes.root, className, childContext.dense && classes.dense, !disableGutters && classes.gutters, divider && classes.divider, disabled && classes.disabled, button && classes.button, alignItems !== "center" && classes.alignItemsFlexStart, hasSecondaryAction && classes.secondaryAction, selected && classes.selected),
      disabled: disabled
    }, other);
    var Component = componentProp || 'li';
    if (button) {
      componentProps.component = componentProp || 'div';
      componentProps.focusVisibleClassName = clsx(classes.focusVisible, focusVisibleClassName);
      Component = ButtonBase$1;
    }
    if (hasSecondaryAction) {
      // Use div by default.
      Component = !componentProps.component && !componentProp ? 'div' : Component; // Avoid nesting of li > li.

      if (ContainerComponent === 'li') {
        if (Component === 'li') {
          Component = 'div';
        } else if (componentProps.component === 'li') {
          componentProps.component = 'div';
        }
      }
      return /*#__PURE__*/reactExports.createElement(ListContext$1.Provider, {
        value: childContext
      }, /*#__PURE__*/reactExports.createElement(ContainerComponent, _extends({
        className: clsx(classes.container, ContainerClassName),
        ref: handleRef
      }, ContainerProps), /*#__PURE__*/reactExports.createElement(Component, componentProps, children), children.pop()));
    }
    return /*#__PURE__*/reactExports.createElement(ListContext$1.Provider, {
      value: childContext
    }, /*#__PURE__*/reactExports.createElement(Component, _extends({
      ref: handleRef
    }, componentProps), children));
  });
  ListItem.propTypes = {
    /**
     * Defines the `align-items` style property.
     */
    alignItems: PropTypes.oneOf(['flex-start', 'center']),
    /**
     * If `true`, the list item will be focused during the first mount.
     * Focus will also be triggered if the value changes from false to true.
     */
    autoFocus: PropTypes.bool,
    /**
     * If `true`, the list item will be a button (using `ButtonBase`). Props intended
     * for `ButtonBase` can then be applied to `ListItem`.
     */
    button: PropTypes.bool,
    /**
     * The content of the component. If a `ListItemSecondaryAction` is used it must
     * be the last child.
     */
    children: chainPropTypes(PropTypes.node, function (props) {
      var children = reactExports.Children.toArray(props.children); // React.Children.toArray(props.children).findLastIndex(isListItemSecondaryAction)

      var secondaryActionIndex = -1;
      for (var i = children.length - 1; i >= 0; i -= 1) {
        var child = children[i];
        if (isMuiElement(child, ['ListItemSecondaryAction'])) {
          secondaryActionIndex = i;
          break;
        }
      } //  is ListItemSecondaryAction the last child of ListItem

      if (secondaryActionIndex !== -1 && secondaryActionIndex !== children.length - 1) {
        return new Error('Material-UI: You used an element after ListItemSecondaryAction. ' + 'For ListItem to detect that it has a secondary action ' + 'you must pass it as the last child to ListItem.');
      }
      return null;
    }),
    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object.isRequired,
    /**
     * @ignore
     */
    className: PropTypes.string,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     * By default, it's a `li` when `button` is `false` and a `div` when `button` is `true`.
     */
    component: PropTypes
    /* @typescript-to-proptypes-ignore */.elementType,
    /**
     * The container component used when a `ListItemSecondaryAction` is the last child.
     */
    ContainerComponent: PropTypes.elementType,
    /**
     * Props applied to the container component if used.
     */
    ContainerProps: PropTypes.object,
    /**
     * If `true`, compact vertical padding designed for keyboard and mouse input will be used.
     */
    dense: PropTypes.bool,
    /**
     * If `true`, the list item will be disabled.
     */
    disabled: PropTypes.bool,
    /**
     * If `true`, the left and right padding is removed.
     */
    disableGutters: PropTypes.bool,
    /**
     * If `true`, a 1px light border is added to the bottom of the list item.
     */
    divider: PropTypes.bool,
    /**
     * @ignore
     */
    focusVisibleClassName: PropTypes.string,
    /**
     * Use to apply selected styling.
     */
    selected: PropTypes.bool
  } ;
  var ListItem$1 = withStyles(styles$3, {
    name: 'MuiListItem'
  })(ListItem);

  var styles$2 = function styles(theme) {
    return {
      /* Styles applied to the root element. */
      root: {
        minWidth: 56,
        color: theme.palette.action.active,
        flexShrink: 0,
        display: 'inline-flex'
      },
      /* Styles applied to the root element when the parent `ListItem` uses `alignItems="flex-start"`. */
      alignItemsFlexStart: {
        marginTop: 8
      }
    };
  };
  /**
   * A simple wrapper to apply `List` styles to an `Icon` or `SvgIcon`.
   */

  var ListItemIcon = /*#__PURE__*/reactExports.forwardRef(function ListItemIcon(props, ref) {
    var classes = props.classes,
      className = props.className,
      other = _objectWithoutProperties(props, ["classes", "className"]);
    var context = reactExports.useContext(ListContext$1);
    return /*#__PURE__*/reactExports.createElement("div", _extends({
      className: clsx(classes.root, className, context.alignItems === 'flex-start' && classes.alignItemsFlexStart),
      ref: ref
    }, other));
  });
  ListItemIcon.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * The content of the component, normally `Icon`, `SvgIcon`,
     * or a `@material-ui/icons` SVG icon element.
     */
    children: PropTypes.node,
    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,
    /**
     * @ignore
     */
    className: PropTypes.string
  } ;
  var ListItemIcon$1 = withStyles(styles$2, {
    name: 'MuiListItemIcon'
  })(ListItemIcon);

  var styles$1 = {
    /* Styles applied to the root element. */
    root: {
      flex: '1 1 auto',
      minWidth: 0,
      marginTop: 4,
      marginBottom: 4
    },
    /* Styles applied to the `Typography` components if primary and secondary are set. */
    multiline: {
      marginTop: 6,
      marginBottom: 6
    },
    /* Styles applied to the `Typography` components if dense. */
    dense: {},
    /* Styles applied to the root element if `inset={true}`. */
    inset: {
      paddingLeft: 56
    },
    /* Styles applied to the primary `Typography` component. */
    primary: {},
    /* Styles applied to the secondary `Typography` component. */
    secondary: {}
  };
  var ListItemText = /*#__PURE__*/reactExports.forwardRef(function ListItemText(props, ref) {
    var children = props.children,
      classes = props.classes,
      className = props.className,
      _props$disableTypogra = props.disableTypography,
      disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra,
      _props$inset = props.inset,
      inset = _props$inset === void 0 ? false : _props$inset,
      primaryProp = props.primary,
      primaryTypographyProps = props.primaryTypographyProps,
      secondaryProp = props.secondary,
      secondaryTypographyProps = props.secondaryTypographyProps,
      other = _objectWithoutProperties(props, ["children", "classes", "className", "disableTypography", "inset", "primary", "primaryTypographyProps", "secondary", "secondaryTypographyProps"]);
    var _React$useContext = reactExports.useContext(ListContext$1),
      dense = _React$useContext.dense;
    var primary = primaryProp != null ? primaryProp : children;
    if (primary != null && primary.type !== Typography$1 && !disableTypography) {
      primary = /*#__PURE__*/reactExports.createElement(Typography$1, _extends({
        variant: dense ? 'body2' : 'body1',
        className: classes.primary,
        component: "span",
        display: "block"
      }, primaryTypographyProps), primary);
    }
    var secondary = secondaryProp;
    if (secondary != null && secondary.type !== Typography$1 && !disableTypography) {
      secondary = /*#__PURE__*/reactExports.createElement(Typography$1, _extends({
        variant: "body2",
        className: classes.secondary,
        color: "textSecondary",
        display: "block"
      }, secondaryTypographyProps), secondary);
    }
    return /*#__PURE__*/reactExports.createElement("div", _extends({
      className: clsx(classes.root, className, dense && classes.dense, inset && classes.inset, primary && secondary && classes.multiline),
      ref: ref
    }, other), primary, secondary);
  });
  ListItemText.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * Alias for the `primary` prop.
     */
    children: PropTypes.node,
    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,
    /**
     * @ignore
     */
    className: PropTypes.string,
    /**
     * If `true`, the children won't be wrapped by a Typography component.
     * This can be useful to render an alternative Typography variant by wrapping
     * the `children` (or `primary`) text, and optional `secondary` text
     * with the Typography component.
     */
    disableTypography: PropTypes.bool,
    /**
     * If `true`, the children will be indented.
     * This should be used if there is no left avatar or left icon.
     */
    inset: PropTypes.bool,
    /**
     * The main content element.
     */
    primary: PropTypes.node,
    /**
     * These props will be forwarded to the primary typography component
     * (as long as disableTypography is not `true`).
     */
    primaryTypographyProps: PropTypes.object,
    /**
     * The secondary content element.
     */
    secondary: PropTypes.node,
    /**
     * These props will be forwarded to the secondary typography component
     * (as long as disableTypography is not `true`).
     */
    secondaryTypographyProps: PropTypes.object
  } ;
  var ListItemText$1 = withStyles(styles$1, {
    name: 'MuiListItemText'
  })(ListItemText);

  function getOffsetTop(rect, vertical) {
    var offset = 0;
    if (typeof vertical === 'number') {
      offset = vertical;
    } else if (vertical === 'center') {
      offset = rect.height / 2;
    } else if (vertical === 'bottom') {
      offset = rect.height;
    }
    return offset;
  }
  function getOffsetLeft(rect, horizontal) {
    var offset = 0;
    if (typeof horizontal === 'number') {
      offset = horizontal;
    } else if (horizontal === 'center') {
      offset = rect.width / 2;
    } else if (horizontal === 'right') {
      offset = rect.width;
    }
    return offset;
  }
  function getTransformOriginValue(transformOrigin) {
    return [transformOrigin.horizontal, transformOrigin.vertical].map(function (n) {
      return typeof n === 'number' ? "".concat(n, "px") : n;
    }).join(' ');
  } // Sum the scrollTop between two elements.

  function getScrollParent(parent, child) {
    var element = child;
    var scrollTop = 0;
    while (element && element !== parent) {
      element = element.parentElement;
      scrollTop += element.scrollTop;
    }
    return scrollTop;
  }
  function getAnchorEl(anchorEl) {
    return typeof anchorEl === 'function' ? anchorEl() : anchorEl;
  }
  var styles = {
    /* Styles applied to the root element. */
    root: {},
    /* Styles applied to the `Paper` component. */
    paper: {
      position: 'absolute',
      overflowY: 'auto',
      overflowX: 'hidden',
      // So we see the popover when it's empty.
      // It's most likely on issue on userland.
      minWidth: 16,
      minHeight: 16,
      maxWidth: 'calc(100% - 32px)',
      maxHeight: 'calc(100% - 32px)',
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0
    }
  };
  var Popover = /*#__PURE__*/reactExports.forwardRef(function Popover(props, ref) {
    var action = props.action,
      anchorEl = props.anchorEl,
      _props$anchorOrigin = props.anchorOrigin,
      anchorOrigin = _props$anchorOrigin === void 0 ? {
        vertical: 'top',
        horizontal: 'left'
      } : _props$anchorOrigin,
      anchorPosition = props.anchorPosition,
      _props$anchorReferenc = props.anchorReference,
      anchorReference = _props$anchorReferenc === void 0 ? 'anchorEl' : _props$anchorReferenc,
      children = props.children,
      classes = props.classes,
      className = props.className,
      containerProp = props.container,
      _props$elevation = props.elevation,
      elevation = _props$elevation === void 0 ? 8 : _props$elevation,
      getContentAnchorEl = props.getContentAnchorEl,
      _props$marginThreshol = props.marginThreshold,
      marginThreshold = _props$marginThreshol === void 0 ? 16 : _props$marginThreshol,
      onEnter = props.onEnter,
      onEntered = props.onEntered,
      onEntering = props.onEntering,
      onExit = props.onExit,
      onExited = props.onExited,
      onExiting = props.onExiting,
      open = props.open,
      _props$PaperProps = props.PaperProps,
      PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps,
      _props$transformOrigi = props.transformOrigin,
      transformOrigin = _props$transformOrigi === void 0 ? {
        vertical: 'top',
        horizontal: 'left'
      } : _props$transformOrigi,
      _props$TransitionComp = props.TransitionComponent,
      TransitionComponent = _props$TransitionComp === void 0 ? Grow$1 : _props$TransitionComp,
      _props$transitionDura = props.transitionDuration,
      transitionDurationProp = _props$transitionDura === void 0 ? 'auto' : _props$transitionDura,
      _props$TransitionProp = props.TransitionProps,
      TransitionProps = _props$TransitionProp === void 0 ? {} : _props$TransitionProp,
      other = _objectWithoutProperties(props, ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "classes", "className", "container", "elevation", "getContentAnchorEl", "marginThreshold", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "open", "PaperProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps"]);
    var paperRef = reactExports.useRef(); // Returns the top/left offset of the position
    // to attach to on the anchor element (or body if none is provided)

    var getAnchorOffset = reactExports.useCallback(function (contentAnchorOffset) {
      if (anchorReference === 'anchorPosition') {
        {
          if (!anchorPosition) {
            console.error('Material-UI: You need to provide a `anchorPosition` prop when using ' + '<Popover anchorReference="anchorPosition" />.');
          }
        }
        return anchorPosition;
      }
      var resolvedAnchorEl = getAnchorEl(anchorEl); // If an anchor element wasn't provided, just use the parent body element of this Popover

      var anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
      var anchorRect = anchorElement.getBoundingClientRect();
      {
        var box = anchorElement.getBoundingClientRect();
        if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          console.warn(['Material-UI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
        }
      }
      var anchorVertical = contentAnchorOffset === 0 ? anchorOrigin.vertical : 'center';
      return {
        top: anchorRect.top + getOffsetTop(anchorRect, anchorVertical),
        left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
      };
    }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]); // Returns the vertical offset of inner content to anchor the transform on if provided

    var getContentAnchorOffset = reactExports.useCallback(function (element) {
      var contentAnchorOffset = 0;
      if (getContentAnchorEl && anchorReference === 'anchorEl') {
        var contentAnchorEl = getContentAnchorEl(element);
        if (contentAnchorEl && element.contains(contentAnchorEl)) {
          var scrollTop = getScrollParent(element, contentAnchorEl);
          contentAnchorOffset = contentAnchorEl.offsetTop + contentAnchorEl.clientHeight / 2 - scrollTop || 0;
        } // != the default value

        {
          if (anchorOrigin.vertical !== 'top') {
            console.error(['Material-UI: You can not change the default `anchorOrigin.vertical` value ', 'when also providing the `getContentAnchorEl` prop to the popover component.', 'Only use one of the two props.', 'Set `getContentAnchorEl` to `null | undefined`' + ' or leave `anchorOrigin.vertical` unchanged.'].join('\n'));
          }
        }
      }
      return contentAnchorOffset;
    }, [anchorOrigin.vertical, anchorReference, getContentAnchorEl]); // Return the base transform origin using the element
    // and taking the content anchor offset into account if in use

    var getTransformOrigin = reactExports.useCallback(function (elemRect) {
      var contentAnchorOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return {
        vertical: getOffsetTop(elemRect, transformOrigin.vertical) + contentAnchorOffset,
        horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
      };
    }, [transformOrigin.horizontal, transformOrigin.vertical]);
    var getPositioningStyle = reactExports.useCallback(function (element) {
      // Check if the parent has requested anchoring on an inner content node
      var contentAnchorOffset = getContentAnchorOffset(element);
      var elemRect = {
        width: element.offsetWidth,
        height: element.offsetHeight
      }; // Get the transform origin point on the element itself

      var elemTransformOrigin = getTransformOrigin(elemRect, contentAnchorOffset);
      if (anchorReference === 'none') {
        return {
          top: null,
          left: null,
          transformOrigin: getTransformOriginValue(elemTransformOrigin)
        };
      } // Get the offset of of the anchoring element

      var anchorOffset = getAnchorOffset(contentAnchorOffset); // Calculate element positioning

      var top = anchorOffset.top - elemTransformOrigin.vertical;
      var left = anchorOffset.left - elemTransformOrigin.horizontal;
      var bottom = top + elemRect.height;
      var right = left + elemRect.width; // Use the parent window of the anchorEl if provided

      var containerWindow = ownerWindow(getAnchorEl(anchorEl)); // Window thresholds taking required margin into account

      var heightThreshold = containerWindow.innerHeight - marginThreshold;
      var widthThreshold = containerWindow.innerWidth - marginThreshold; // Check if the vertical axis needs shifting

      if (top < marginThreshold) {
        var diff = top - marginThreshold;
        top -= diff;
        elemTransformOrigin.vertical += diff;
      } else if (bottom > heightThreshold) {
        var _diff = bottom - heightThreshold;
        top -= _diff;
        elemTransformOrigin.vertical += _diff;
      }
      {
        if (elemRect.height > heightThreshold && elemRect.height && heightThreshold) {
          console.error(['Material-UI: The popover component is too tall.', "Some part of it can not be seen on the screen (".concat(elemRect.height - heightThreshold, "px)."), 'Please consider adding a `max-height` to improve the user-experience.'].join('\n'));
        }
      } // Check if the horizontal axis needs shifting

      if (left < marginThreshold) {
        var _diff2 = left - marginThreshold;
        left -= _diff2;
        elemTransformOrigin.horizontal += _diff2;
      } else if (right > widthThreshold) {
        var _diff3 = right - widthThreshold;
        left -= _diff3;
        elemTransformOrigin.horizontal += _diff3;
      }
      return {
        top: "".concat(Math.round(top), "px"),
        left: "".concat(Math.round(left), "px"),
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }, [anchorEl, anchorReference, getAnchorOffset, getContentAnchorOffset, getTransformOrigin, marginThreshold]);
    var setPositioningStyles = reactExports.useCallback(function () {
      var element = paperRef.current;
      if (!element) {
        return;
      }
      var positioning = getPositioningStyle(element);
      if (positioning.top !== null) {
        element.style.top = positioning.top;
      }
      if (positioning.left !== null) {
        element.style.left = positioning.left;
      }
      element.style.transformOrigin = positioning.transformOrigin;
    }, [getPositioningStyle]);
    var handleEntering = function handleEntering(element, isAppearing) {
      if (onEntering) {
        onEntering(element, isAppearing);
      }
      setPositioningStyles();
    };
    var handlePaperRef = reactExports.useCallback(function (instance) {
      // #StrictMode ready
      paperRef.current = reactDomExports.findDOMNode(instance);
    }, []);
    reactExports.useEffect(function () {
      if (open) {
        setPositioningStyles();
      }
    });
    reactExports.useImperativeHandle(action, function () {
      return open ? {
        updatePosition: function updatePosition() {
          setPositioningStyles();
        }
      } : null;
    }, [open, setPositioningStyles]);
    reactExports.useEffect(function () {
      if (!open) {
        return undefined;
      }
      var handleResize = debounce(function () {
        setPositioningStyles();
      });
      window.addEventListener('resize', handleResize);
      return function () {
        handleResize.clear();
        window.removeEventListener('resize', handleResize);
      };
    }, [open, setPositioningStyles]);
    var transitionDuration = transitionDurationProp;
    if (transitionDurationProp === 'auto' && !TransitionComponent.muiSupportAuto) {
      transitionDuration = undefined;
    } // If the container prop is provided, use that
    // If the anchorEl prop is provided, use its parent body element as the container
    // If neither are provided let the Modal take care of choosing the container

    var container = containerProp || (anchorEl ? ownerDocument(getAnchorEl(anchorEl)).body : undefined);
    return /*#__PURE__*/reactExports.createElement(Modal$1, _extends({
      container: container,
      open: open,
      ref: ref,
      BackdropProps: {
        invisible: true
      },
      className: clsx(classes.root, className)
    }, other), /*#__PURE__*/reactExports.createElement(TransitionComponent, _extends({
      appear: true,
      in: open,
      onEnter: onEnter,
      onEntered: onEntered,
      onExit: onExit,
      onExited: onExited,
      onExiting: onExiting,
      timeout: transitionDuration
    }, TransitionProps, {
      onEntering: createChainedFunction(handleEntering, TransitionProps.onEntering)
    }), /*#__PURE__*/reactExports.createElement(Paper$1, _extends({
      elevation: elevation,
      ref: handlePaperRef
    }, PaperProps, {
      className: clsx(classes.paper, PaperProps.className)
    }), children)));
  });
  Popover.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * A ref for imperative actions.
     * It currently only supports updatePosition() action.
     */
    action: refType$1,
    /**
     * A HTML element, or a function that returns it.
     * It's used to set the position of the popover.
     */
    anchorEl: chainPropTypes(PropTypes.oneOfType([HTMLElementType, PropTypes.func]), function (props) {
      if (props.open && (!props.anchorReference || props.anchorReference === 'anchorEl')) {
        var resolvedAnchorEl = getAnchorEl(props.anchorEl);
        if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
          var box = resolvedAnchorEl.getBoundingClientRect();
          if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
            return new Error(['Material-UI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
          }
        } else {
          return new Error(['Material-UI: The `anchorEl` prop provided to the component is invalid.', "It should be an Element instance but it's `".concat(resolvedAnchorEl, "` instead.")].join('\n'));
        }
      }
      return null;
    }),
    /**
     * This is the point on the anchor where the popover's
     * `anchorEl` will attach to. This is not used when the
     * anchorReference is 'anchorPosition'.
     *
     * Options:
     * vertical: [top, center, bottom];
     * horizontal: [left, center, right].
     */
    anchorOrigin: PropTypes.shape({
      horizontal: PropTypes.oneOfType([PropTypes.oneOf(['center', 'left', 'right']), PropTypes.number]).isRequired,
      vertical: PropTypes.oneOfType([PropTypes.oneOf(['bottom', 'center', 'top']), PropTypes.number]).isRequired
    }),
    /**
     * This is the position that may be used
     * to set the position of the popover.
     * The coordinates are relative to
     * the application's client area.
     */
    anchorPosition: PropTypes.shape({
      left: PropTypes.number.isRequired,
      top: PropTypes.number.isRequired
    }),
    /**
     * This determines which anchor prop to refer to to set
     * the position of the popover.
     */
    anchorReference: PropTypes.oneOf(['anchorEl', 'anchorPosition', 'none']),
    /**
     * The content of the component.
     */
    children: PropTypes.node,
    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,
    /**
     * @ignore
     */
    className: PropTypes.string,
    /**
     * A HTML element, component instance, or function that returns either.
     * The `container` will passed to the Modal component.
     *
     * By default, it uses the body of the anchorEl's top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: PropTypes
    /* @typescript-to-proptypes-ignore */.oneOfType([HTMLElementType, PropTypes.instanceOf(reactExports.Component), PropTypes.func]),
    /**
     * The elevation of the popover.
     */
    elevation: PropTypes.number,
    /**
     * This function is called in order to retrieve the content anchor element.
     * It's the opposite of the `anchorEl` prop.
     * The content anchor element should be an element inside the popover.
     * It's used to correctly scroll and set the position of the popover.
     * The positioning strategy tries to make the content anchor element just above the
     * anchor element.
     */
    getContentAnchorEl: PropTypes.func,
    /**
     * Specifies how close to the edge of the window the popover can appear.
     */
    marginThreshold: PropTypes.number,
    /**
     * Callback fired when the component requests to be closed.
     */
    onClose: PropTypes.func,
    /**
     * Callback fired before the component is entering.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onEnter: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),
    /**
     * Callback fired when the component has entered.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onEntered: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),
    /**
     * Callback fired when the component is entering.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onEntering: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),
    /**
     * Callback fired before the component is exiting.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onExit: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),
    /**
     * Callback fired when the component has exited.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onExited: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),
    /**
     * Callback fired when the component is exiting.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onExiting: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),
    /**
     * If `true`, the popover is visible.
     */
    open: PropTypes.bool.isRequired,
    /**
     * Props applied to the [`Paper`](/api/paper/) element.
     */
    PaperProps: PropTypes
    /* @typescript-to-proptypes-ignore */.shape({
      component: elementTypeAcceptingRef$1
    }),
    /**
     * This is the point on the popover which
     * will attach to the anchor's origin.
     *
     * Options:
     * vertical: [top, center, bottom, x(px)];
     * horizontal: [left, center, right, x(px)].
     */
    transformOrigin: PropTypes.shape({
      horizontal: PropTypes.oneOfType([PropTypes.oneOf(['center', 'left', 'right']), PropTypes.number]).isRequired,
      vertical: PropTypes.oneOfType([PropTypes.oneOf(['bottom', 'center', 'top']), PropTypes.number]).isRequired
    }),
    /**
     * The component used for the transition.
     * [Follow this guide](/components/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
     */
    TransitionComponent: PropTypes.elementType,
    /**
     * Set to 'auto' to automatically calculate transition time based on height.
     */
    transitionDuration: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number, PropTypes.shape({
      appear: PropTypes.number,
      enter: PropTypes.number,
      exit: PropTypes.number
    })]),
    /**
     * Props applied to the [`Transition`](http://reactcommunity.org/react-transition-group/transition#Transition-props) element.
     */
    TransitionProps: PropTypes.object
  } ;
  var Popover$1 = withStyles(styles, {
    name: 'MuiPopover'
  })(Popover);

  /* eslint react/prop-types: 0 */
  function getFontSize(size) {
    if (size === 'large') {
      return '20px';
    }
    if (size === 'small') {
      return '12px';
    }
    return '16px';
  }
  function SvgIcon({
    d,
    size,
    style = {},
    viewBox = '0 0 16 16'
  }) {
    const s = {
      fontSize: getFontSize(size),
      display: 'inline-block',
      fontStyle: 'normal',
      lineHeight: '0',
      textAlign: 'center',
      textTransform: 'none',
      verticalAlign: '-.125em',
      textRendering: 'optimizeLegibility',
      WebkitFontSmoothing: 'antialiased',
      MozOsxFontSmoothing: 'grayscale',
      ...style
    };
    return /*#__PURE__*/React.createElement("i", {
      style: s
    }, /*#__PURE__*/React.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "1em",
      height: "1em",
      viewBox: viewBox,
      fill: "currentColor"
    }, /*#__PURE__*/React.createElement("path", {
      d: d
    })));
  }

  const drillDown = {
    d: 'M15.9993744,3 L15.9993744,5 L4.99937445,5 L4.99937445,3 L15.9993744,3 Z M8.99937445,7 L15.9993744,7 L15.9993744,9 L8.99937445,9 L8.99937445,7 Z M11.9993744,11 L15.9993744,11 L15.9993744,13 L11.9993744,13 L11.9993744,11 Z M2.2,11 L7,11 L7,9.00369263 C7,8.89323568 7.08954305,8.80369263 7.2,8.80369263 C7.2549016,8.80369263 7.30738916,8.82626165 7.34515712,8.86610844 L10.1852182,11.8624926 C10.2583124,11.93961 10.258346,12.0604218 10.1852948,12.13758 L7.34523376,15.1373102 C7.2692928,15.2175206 7.14270711,15.2209817 7.06249671,15.1450407 C7.02260076,15.1072683 7,15.0547472 7,14.9998069 L7,12.9043747 C4.79351111,12.9043747 2.8018683,12.9266213 1.02507156,12.9711145 L1.02507252,12.9711526 C0.472939773,12.9849787 0.014139487,12.5485949 0.000313396522,11.9964622 C0.000104473692,11.988119 -1.32268838e-12,11.9797736 -1.3231638e-12,11.9714278 L-1.83320026e-12,3 L2,3 L2,10.8 C2,10.9104569 2.08954305,11 2.2,11 Z'
  };
  const lock = {
    d: 'M13,7 L8,7 L13,7 L13,4.98151367 C13,2.23029964 10.7614237,0 8,0 C5.23857625,0 3,2.23029964 3,4.98151367 L3,7 L3.75,7 L3,7 L4.5,7 L4.5,5.33193359 C4.5,3.21561511 5.54860291,1.5 8,1.5 C10.4513971,1.5 11.5,3.21561511 11.5,5.33193359 L11.5,7 L12.25,7 L3,7 C2.44771525,7 2,7.44771525 2,8 L2,15 C2,15.5522847 2.44771525,16 3,16 L13,16 C13.5522847,16 14,15.5522847 14,15 L14,8 C14,7.44771525 13.5522847,7 13,7 L3,7 L13,7 Z'
  };
  const tick = {
    d: 'M6,10 L13,3 L15,5 L8,12 L6,14 L1,9 L3,7 L6,10 Z'
  };
  const triangleDown = {
    d: 'M2.4,4 L13.6,4 C13.7104569,4 13.8,4.08954305 13.8,4.2 C13.8,4.24327404 13.7859644,4.28538077 13.76,4.32 L8.16,11.7866667 C8.09372583,11.8750322 7.96836556,11.8929408 7.88,11.8266667 C7.86483887,11.8152958 7.85137085,11.8018278 7.84,11.7866667 L2.24,4.32 C2.17372583,4.23163444 2.19163444,4.10627417 2.28,4.04 C2.31461923,4.01403557 2.35672596,4 2.4,4 Z'
  };
  const triangleRight = {
    d: 'M4,13.6 L4,2.4 C4,2.28954305 4.08954305,2.2 4.2,2.2 C4.24327404,2.2 4.28538077,2.21403557 4.32,2.24 L11.7866667,7.84 C11.8750322,7.90627417 11.8929408,8.03163444 11.8266667,8.12 C11.8152958,8.13516113 11.8018278,8.14862915 11.7866667,8.16 L4.32,13.76 C4.23163444,13.8262742 4.10627417,13.8083656 4.04,13.72 C4.01403557,13.6853808 4,13.643274 4,13.6 Z'
  };

  function applyModifiers({
    model,
    properties
  }) {
    return model.modifiers ? model.modifiers.apply({
      model,
      properties
    }) : Promise.resolve();
  }
  function applyPatches(model, prevEffectiveProperties, effectiveProperties) {
    applyModifiers({
      model,
      properties: effectiveProperties
    }).then(() => {
      if (model.colorSupport) {
        model.colorSupport.colorByUpdater(effectiveProperties, 'qHyperCubeDef.');
      }
      let patches = JSONPatch.generate(prevEffectiveProperties, effectiveProperties);
      if (patches && patches.length) {
        patches = patches.map(p => ({
          qOp: p.op,
          qValue: JSON.stringify(p.value),
          qPath: p.path
        }));
        model.applyPatches(patches, true);
      }
    });
  }
  function changeTo(model, id, altId, listAttr, onChange, skipAttributeExpressions) {
    model.getEffectiveProperties().then(oldProperties => {
      const index = oldProperties.qHyperCubeDef[listAttr].findIndex(d => d.qDef.cId === id);
      const altIndex = oldProperties.qHyperCubeDef.qLayoutExclude.qHyperCubeDef[listAttr].findIndex(d => d.qDef.cId === altId);
      const newProperties = extend$7(true, {}, oldProperties);
      const oldItem = newProperties.qHyperCubeDef[listAttr][index];
      const newItem = newProperties.qHyperCubeDef.qLayoutExclude.qHyperCubeDef[listAttr][altIndex];
      newItem.qAttributeDimensions = oldItem.qAttributeDimensions;
      oldItem.qAttributeDimensions = [];
      if (!skipAttributeExpressions) {
        newItem.qAttributeExpressions = oldItem.qAttributeExpressions;
        oldItem.qAttributeExpressions = [];
      }
      newProperties.qHyperCubeDef[listAttr][index] = newItem;
      newProperties.qHyperCubeDef.qLayoutExclude.qHyperCubeDef[listAttr][altIndex] = oldItem;
      if (onChange) {
        onChange({
          oldItem,
          newItem,
          oldProperties,
          newProperties,
          model
        });
      }

      // TODO: may need to recreate color expressions.
      applyPatches(model, oldProperties, newProperties);
    });
  }

  // Dimension
  function getDimensionTitle(dimensionLayout) {
    const isDrilldown = dimensionLayout.qGrouping === 'H';
    if (isDrilldown) {
      return dimensionLayout.title || '';
    }
    return dimensionLayout.qFallbackTitle || '';
  }
  function getAlternateDimensionTitle(itemProperties, app, translator) {
    const isLibraryItem = !!itemProperties.qLibraryId;
    if (isLibraryItem) {
      return app.getDimension(itemProperties.qLibraryId).then(d => d.getLayout()).catch(() => null).then(dimLayout => {
        if (!dimLayout) {
          return translator.get('Object.ErrorMessage.MissingDimension');
        }
        const isDrilldown = dimLayout.qDim.qGrouping === 'H';
        if (!isDrilldown && dimLayout.qDim.qLabelExpression) {
          return dimLayout.qDim.qLabelExpression;
        }
        return dimLayout.qDim.title;
      });
    }
    const labelExpression = itemProperties.qDef.qLabelExpression;
    const hasLabelExpression = !!labelExpression;
    if (hasLabelExpression) {
      return app.evaluate(labelExpression);
    }
    const fieldLabel = itemProperties.qDef.qFieldLabels[0];
    const title = fieldLabel || itemProperties.qDef.qFieldDefs[0];
    return Promise.resolve(title);
  }
  const getInvalidListIds = (app, altList) => {
    const ids = [];
    const list = [];
    altList.forEach(l => {
      if (l.qCalcCondition.qCond.qv) {
        list.push(app.evaluate(l.qCalcCondition.qCond.qv).then(v => {
          if (v === '0') {
            ids.push(l.qDef.cId);
          }
        }));
      }
    });
    return Promise.all(list).then(() => ids);
  };
  function getDimensionPopoverData({
    dir,
    dock,
    altList,
    model,
    translator,
    app,
    onChange
  }) {
    if (altList.length === 0) {
      return null;
    }
    return {
      dir,
      dock,
      getAlternatives() {
        const alternatives = getInvalidListIds(app, altList).then(invalidIds => Promise.all(altList.filter(l => !invalidIds.includes(l.qDef.cId)).map(dimension => getAlternateDimensionTitle(dimension, app, translator).then(title => ({
          //eslint-disable-line
          id: dimension.qDef.cId,
          selected: false,
          title
        })))));
        return alternatives;
      },
      changeTo(id, altId) {
        changeTo(model, id, altId, 'qDimensions', onChange);
      }
    };
  }
  function getDimensionTitleData(dimInfo, column, model, definitionPath = '/qHyperCubeDef') {
    return {
      breadcrumbs: dimInfo.qGroupFallbackTitles.slice(0, dimInfo.qGroupPos),
      drilldown: dimInfo.qGrouping === 'H',
      index: column,
      locked: !!dimInfo.qLocked,
      text: dimInfo.qGrouping === 'H' ? dimInfo.qGroupFallbackTitles[dimInfo.qGroupPos] : dimInfo.qFallbackTitle,
      popoverText: getDimensionTitle(dimInfo),
      drillUp(steps) {
        model.drillUp(definitionPath, column, steps);
      },
      id: dimInfo.cId
    };
  }

  // Measure
  function getAlternateMeasureTitle(itemProperties, app, translator) {
    const isLibraryItem = !!itemProperties.qLibraryId;
    if (isLibraryItem) {
      return app.getMeasure(itemProperties.qLibraryId).then(d => d.getLayout()).catch(() => null).then(layout => {
        if (!layout) {
          return translator.get('Object.ErrorMessage.MissingMeasure');
        }
        if (layout.qMeasure.qLabelExpression) {
          return layout.qMeasure.qLabelExpression;
        }
        return layout.qMeasure.qLabel || layout.qMeasure.qDef;
      });
    }
    const labelExpression = itemProperties.qDef.qLabelExpression;
    const hasLabelExpression = !!labelExpression;
    if (hasLabelExpression) {
      return app.evaluate(labelExpression);
    }
    const title = itemProperties.qDef.qLabel || itemProperties.qDef.qDef;
    return Promise.resolve(title);
  }
  function getMeasurePopoverData({
    altList,
    app,
    dir,
    dock,
    model,
    onChange,
    skipAttributeExpressions,
    translator
  }) {
    if (altList.length === 0) {
      return null;
    }
    return {
      dir,
      dock,
      getAlternatives() {
        const alternatives = getInvalidListIds(app, altList).then(invalidIds => Promise.all(altList.filter(l => !invalidIds.includes(l.qDef.cId)).map(altItem => getAlternateMeasureTitle(altItem, app, translator).then(title => ({
          //eslint-disable-line
          id: altItem.qDef.cId,
          selected: false,
          title
        })))));
        return alternatives;
      },
      changeTo(id, altId) {
        changeTo(model, id, altId, 'qMeasures', onChange, skipAttributeExpressions);
      }
    };
  }
  function getMeasureTitleData(meaInfo, index) {
    return {
      breadcrumbs: [],
      drilldown: false,
      index,
      locked: false,
      text: meaInfo.qFallbackTitle,
      popoverText: meaInfo.qFallbackTitle,
      id: meaInfo.cId
    };
  }

  const dockOrigins = {
    bottom: {
      anchorOrigin: {
        vertical: 'bottom',
        horizontal: 'center'
      },
      transformOrigin: {
        vertical: 'top',
        horizontal: 'center'
      }
    },
    top: {
      anchorOrigin: {
        vertical: 'top',
        horizontal: 'center'
      },
      transformOrigin: {
        vertical: 'bottom',
        horizontal: 'center'
      }
    },
    left: {
      anchorOrigin: {
        vertical: 'center',
        horizontal: 'left'
      },
      transformOrigin: {
        vertical: 'center',
        horizontal: 'right'
      }
    },
    right: {
      anchorOrigin: {
        vertical: 'center',
        horizontal: 'right'
      },
      transformOrigin: {
        vertical: 'center',
        horizontal: 'left'
      }
    }
  };
  const classes = {
    menuItem: 'alternative-menu-item',
    titleButton: 'title-button',
    activeTitleButton: 'active-title-button'
  };
  const FadeButton = ({
    children,
    ...rest
  } // eslint-disable-line
  ) => /*#__PURE__*/React.createElement(Button$1, _extends$1({
    size: "small",
    disableRipple: true,
    disableTouchRipple: true
  }, rest), children);
  const StyledListItem = styled$1(ListItem$1)(() => ({
    textAlign: 'start',
    '&:focus': {
      boxShadow: 'inset 0 0 0 2px #177FE6 !important'
    }
  }));
  const StyledFadeButton = styled$1(FadeButton)(() => ({
    '&:focus': {
      boxShadow: 'inset 0 0 0 2px #177FE6 !important'
    }
  }));
  function createDataTitleComponent(svgRenderer) {
    const handleKeyDown = e => {
      if (e.key === 'Tab') {
        const menuItems = document.querySelectorAll(`.${classes.menuItem}`);
        let nextToFocus;
        if (e.shiftKey) {
          if (menuItems !== null && menuItems !== void 0 && menuItems.length && menuItems[0] === e.target) {
            nextToFocus = menuItems[menuItems.length - 1];
          }
        } else if (menuItems !== null && menuItems !== void 0 && menuItems.length && menuItems[menuItems.length - 1] === e.target) {
          [nextToFocus] = menuItems;
        }
        if (nextToFocus) {
          setTimeout(() => {
            nextToFocus.focus();
          }, 50);
        }
      }
    };
    function HyperDataItem({
      title,
      selected,
      onClick
    }) {
      const localDir = rtlUtils.detectTextDirection(title);
      return /*#__PURE__*/React.createElement(StyledListItem, {
        role: "menuitem",
        button: true,
        onClick: onClick,
        className: classes.menuItem,
        onKeyDown: handleKeyDown
      }, /*#__PURE__*/React.createElement(ListItemIcon$1, {
        style: {
          minWidth: 32
        }
      }, /*#__PURE__*/React.createElement(SvgIcon, {
        d: selected ? tick.d : ''
      })), /*#__PURE__*/React.createElement(ListItemText$1, {
        primaryTypographyProps: {
          dir: localDir
        }
      }, title));
    }
    HyperDataItem.propTypes = {
      title: PropTypes.string.isRequired,
      selected: PropTypes.bool,
      onClick: PropTypes.func.isRequired
    };
    HyperDataItem.defaultProps = {
      selected: false
    };
    function AlternativesPopover({
      alignTo,
      changeTo,
      current,
      dir,
      dock,
      list,
      onClose,
      show,
      instruction
    }) {
      const items = list.map(l => /*#__PURE__*/React.createElement(HyperDataItem, {
        key: l.id,
        title: l.title,
        onClick: () => changeTo(l.id)
      }));
      return /*#__PURE__*/React.createElement(Popover$1, _extends$1({
        anchorEl: alignTo,
        open: show,
        onClose: onClose
      }, dockOrigins[dock], {
        PaperProps: {
          style: {
            minWidth: '250px',
            maxHeight: '300px'
          }
        }
      }), /*#__PURE__*/React.createElement(List$1, {
        dense: true,
        dir: dir,
        "aria-label": instruction,
        component: "nav"
      }, /*#__PURE__*/React.createElement(HyperDataItem, {
        title: current,
        selected: true,
        onClick: onClose
      }), items));
    }
    AlternativesPopover.propTypes = {
      alignTo: PropTypes.any,
      // eslint-disable-line react/forbid-prop-types
      changeTo: PropTypes.func.isRequired,
      current: PropTypes.string.isRequired,
      dir: PropTypes.string.isRequired,
      dock: PropTypes.string.isRequired,
      list: PropTypes.array,
      // eslint-disable-line react/forbid-prop-types
      onClose: PropTypes.func.isRequired,
      show: PropTypes.bool.isRequired,
      instruction: PropTypes.string.isRequired
    };
    AlternativesPopover.defaultProps = {
      list: [],
      alignTo: null
    };
    class TitleComponent extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          open: false,
          inSelection: props.selections && props.selections.isActive(),
          hasValidAlternatives: false
        };
        this.openPopover = this.openPopover.bind(this);
        this.closePopover = this.closePopover.bind(this);
        this.changeTo = this.changeTo.bind(this);
        this.alignToRef = React.createRef();
      }
      componentDidMount() {
        const {
          popover,
          selections,
          supportConditional
        } = this.props;
        if (selections) {
          this.onSelectionsActivated = () => this.setState({
            inSelection: true
          });
          this.onSelectionsDeactivated = () => this.setState({
            inSelection: false
          });
          selections.addListener('activated', this.onSelectionsActivated);
          selections.addListener('deactivated', this.onSelectionsDeactivated);
          selections.addListener('canceled', this.onSelectionsDeactivated);
        }
        if (popover && supportConditional) {
          popover.getAlternatives().then(list => {
            this.setState({
              hasValidAlternatives: list.length !== 0
            });
          });
        }
      }
      componentDidUpdate(prevProps, prevState) {
        const {
          popover,
          supportConditional
        } = this.props;
        if (popover && supportConditional) {
          popover.getAlternatives().then(list => {
            if (prevState.hasValidAlternatives !== (list.length !== 0)) {
              this.setState({
                hasValidAlternatives: list.length !== 0
              });
            }
          });
        }
      }
      componentWillUnmount() {
        const {
          selections
        } = this.props;
        if (selections) {
          selections.removeListener('activated', this.onSelectionsActivated);
          selections.removeListener('deactivated', this.onSelectionsDeactivated);
          selections.removeListener('canceled', this.onSelectionsDeactivated);
        }
      }
      changeTo(altId) {
        this.props.popover.changeTo(this.props.titleData.id, altId);
        this.closePopover(altId);
      }
      openPopover(e) {
        // catch when closing using the button on touch devices
        // when I measured I get an extra openPopover within 10ms after closePopover with touch support on
        // and I can not get a real click faster then 100ms
        if (this.state.closeTime && Date.now() - this.state.closeTime < 20) {
          return;
        }
        if (e.target) {
          const titleButton = e.target.closest(`.${classes.titleButton}`);
          if (titleButton) {
            titleButton.classList.add(classes.activeTitleButton);
          }
        }
        this.props.popover.getAlternatives().then(list => {
          this.setState({
            open: true,
            alternatives: list
          });
          const menuItem = document.querySelector(`.${classes.menuItem}`);
          menuItem.focus();
        });
      }
      closePopover(newId) {
        this.setState({
          open: false,
          closeTime: Date.now()
        });
        if (typeof newId === 'string') {
          setTimeout(() => {
            const activeTitleButton = document.querySelector(`.${classes.titleButton}[data-id="${newId}"]`);
            if (activeTitleButton) {
              activeTitleButton.focus();
            }
          }, 1000);
        } else {
          const activeTitleButton = document.querySelector(`.${classes.activeTitleButton}`);
          if (activeTitleButton) {
            activeTitleButton.classList.remove(classes.activeTitleButton);
            setTimeout(() => {
              activeTitleButton.focus();
            }, 50);
          }
        }
      }
      render() {
        const {
          titleData,
          popover,
          translator,
          disabled,
          isDimension,
          padding,
          minWidth,
          hasAlternative,
          supportConditional
        } = this.props;
        const textStyle = {
          flex: '1 1 auto',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
          whiteSpace: 'nowrap',
          fontWeight: 'normal',
          lineHeight: 'normal',
          ...this.props.style
        };
        const breadcrumbsCount = titleData.breadcrumbs.length;
        const breadcrumbsDisabled = disabled || this.state.inSelection;
        const breadcrumbs = titleData.breadcrumbs.map((b, i) => /*#__PURE__*/React.createElement(StyledFadeButton, {
          style: {
            display: 'flex',
            alignItems: 'center',
            color: breadcrumbsDisabled && 'rgba(89, 89, 89, 0.8)',
            pointerEvents: breadcrumbsDisabled ? 'none' : 'auto',
            paddingTop: 0,
            paddingBottom: 0,
            height: '100%'
          },
          key: i // eslint-disable-line react/no-array-index-key
          ,
          onClick: () => breadcrumbsDisabled ? undefined : titleData.drillUp(breadcrumbsCount - i),
          title: b
        }, /*#__PURE__*/React.createElement("span", {
          style: textStyle
        }, b), /*#__PURE__*/React.createElement(SvgIcon, _extends$1({}, triangleRight, {
          size: "small",
          style: {
            margin: '0 8px'
          }
        }))));
        const hasValidAlternative = supportConditional ? this.state.hasValidAlternatives : hasAlternative;
        const onClick = popover && !this.state.open ? this.openPopover : this.closePopover;
        const disabledLabel = !popover || disabled || this.state.inSelection;
        const style = {
          display: 'flex',
          alignItems: 'center',
          width: '100%',
          color: disabledLabel && 'rgba(89, 89, 89, 0.8)',
          // override disabled styling
          height: '100%',
          border: !isDimension && disabledLabel && 'none',
          paddingTop: 0,
          paddingBottom: 0
        };
        if (this.state.open) {
          style.background = 'rgba(0,0,0,0.08)';
        }
        const handleFocus = event => {
          // eslint-disable-next-line no-param-reassign
          event.currentTarget.style.boxShadow = '0px 0px 0px 2px #177FE6 inset';
          // eslint-disable-next-line no-param-reassign
          event.currentTarget.style.borderRadius = '2px';
        };
        const handleBlur = event => {
          // eslint-disable-next-line no-param-reassign
          event.currentTarget.style.boxShadow = 'none';
          // eslint-disable-next-line no-param-reassign
          event.currentTarget.style.borderRadius = '0px';
        };
        if (padding) {
          style.padding = padding;
        }
        if (minWidth) {
          style.minWidth = minWidth;
        }
        const dir = rtlUtils.detectTextDirection(titleData.text);
        const label = /*#__PURE__*/React.createElement(StyledFadeButton, {
          "aria-label": translator.get(`Accessibility.${popover && hasValidAlternative ? 'Alternative' : 'Normal'}.Instructions`, [titleData.text]),
          style: style,
          onClick: disabledLabel ? undefined : onClick,
          title: titleData.text,
          tabIndex: disabledLabel ? -1 : 0,
          onFocus: disabledLabel ? undefined : handleFocus,
          onBlur: disabledLabel ? undefined : handleBlur,
          onMouseDown: event => {
            event.preventDefault();
          },
          className: `${classes.titleButton} ${titleData.id}`,
          "data-id": titleData.id
        }, titleData.locked && /*#__PURE__*/React.createElement(SvgIcon, _extends$1({}, lock, {
          size: "small",
          title: translator.get('Tooltip.selections.locked')
        })), /*#__PURE__*/React.createElement("span", {
          style: textStyle,
          dir: dir
        }, titleData.text), popover && hasValidAlternative && /*#__PURE__*/React.createElement(SvgIcon, _extends$1({}, triangleDown, {
          size: "small",
          style: {
            margin: '0 8px'
          }
        })));
        return /*#__PURE__*/React.createElement(React.Fragment, null, titleData.drilldown && /*#__PURE__*/React.createElement(SvgIcon, _extends$1({}, drillDown, {
          size: "small",
          title: translator.get('Tooltip.dimensions.drilldown'),
          style: {
            margin: '0 4px 0 0'
          }
        })), breadcrumbs, /*#__PURE__*/React.createElement("div", {
          ref: this.alignToRef,
          style: {
            overflow: 'hidden',
            pointerEvents: hasValidAlternative ? 'auto' : 'none',
            height: '100%'
          }
        }, label), popover && hasValidAlternative && /*#__PURE__*/React.createElement(AlternativesPopover, {
          dock: popover.dock,
          dir: popover.dir,
          current: titleData.popoverText,
          alignTo: this.alignToRef.current,
          show: this.state.open,
          list: this.state.alternatives,
          onClose: this.closePopover,
          changeTo: this.changeTo,
          instruction: translator.get('Accessibility.Popover.Instructions')
        }));
      }
    }
    TitleComponent.propTypes = {
      disabled: PropTypes.bool.isRequired,
      padding: PropTypes.string,
      minWidth: PropTypes.string,
      titleData: PropTypes.shape({
        breadcrumbs: PropTypes.arrayOf(PropTypes.string).isRequired,
        drilldown: PropTypes.bool.isRequired,
        index: PropTypes.number.isRequired,
        locked: PropTypes.bool.isRequired,
        text: PropTypes.string.isRequired,
        popoverText: PropTypes.string.isRequired,
        drillUp: PropTypes.func,
        id: PropTypes.string.isRequired
      }).isRequired,
      popover: PropTypes.shape({
        dir: PropTypes.string.isRequired,
        dock: PropTypes.string.isRequired,
        changeTo: PropTypes.func.isRequired,
        getAlternatives: PropTypes.func.isRequired
      }),
      translator: PropTypes.shape({
        get: PropTypes.func.isRequired
      }).isRequired,
      selections: PropTypes.shape({
        isActive: PropTypes.func,
        addListener: PropTypes.func,
        removeListener: PropTypes.func
      }),
      style: PropTypes.shape({
        fontSize: PropTypes.string,
        color: PropTypes.string,
        fontFamily: PropTypes.string
      }).isRequired,
      isDimension: PropTypes.bool.isRequired,
      hasAlternative: PropTypes.bool.isRequired,
      supportConditional: PropTypes.bool.isRequired
    };
    TitleComponent.defaultProps = {
      popover: null,
      selections: null,
      padding: '',
      minWidth: ''
    };
    function getStyle(dock, rect) {
      const style = {
        pointerEvents: 'auto',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        height: '100%'
      };
      if (dock === 'left') {
        style.width = `${rect.height}px`;
        style.height = `${rect.width}px`;
        style.transform = `rotate(-90deg) translate(-${rect.height}px, 0)`;
        style.transformOrigin = 'top left';
      } else if (dock === 'right') {
        style.width = `${rect.height}px`;
        style.height = `${rect.width}px`;
        style.transform = `rotate(90deg) translate(0, -${rect.width}px)`;
        style.transformOrigin = 'top left';
      }
      return style;
    }
    function opposite(dock) {
      const map = {
        top: 'bottom',
        bottom: 'top',
        left: 'right',
        right: 'left'
      };
      return map[dock];
    }
    function isAlternativeMeasure(settings) {
      return !settings.isDimension && util$2.getValue(settings, 'hyperCubeDef.qLayoutExclude.qHyperCubeDef.qMeasures.length') > 0;
    }
    function isAlternativeDimension(settings) {
      return settings.isDimension && util$2.getValue(settings, 'hyperCubeDef.qLayoutExclude.qHyperCubeDef.qDimensions.length') > 0;
    }
    return {
      renderer: 'react',
      disableTriggers: true,
      preferredSize: function preferredSize() {
        const {
          height
        } = svgRenderer.measureText({
          text: 'M',
          fontSize: this.style.fontSize,
          fontFamily: this.style.fontFamily
        });
        if (!this.settings.settings.isDimension && !isAlternativeMeasure(this.settings.settings)) {
          return Math.max(20, height);
        }
        return Math.max(28, height);
      },
      render() {
        /* eslint-disable react/no-this-in-sfc */
        const {
          settings: {
            app,
            disabled,
            explicitItemInfos,
            hyperCube,
            hyperCubeDef,
            isDimension,
            minWidth,
            model,
            onChangeToAlternative,
            padding,
            rtl,
            selections,
            skipAttributeExpressions,
            translator,
            supportConditional = false
          },
          layout: {
            dock
          }
        } = this.settings;
        const dir = (dock === 'top' || dock === 'bottom') && rtl ? 'rtl' : 'ltr';
        const style = getStyle(dock, this.rect);
        const layoutExcludeCube = hyperCubeDef && hyperCubeDef.qLayoutExclude && hyperCubeDef.qLayoutExclude.qHyperCubeDef;
        const altList = layoutExcludeCube && layoutExcludeCube[isDimension ? 'qDimensions' : 'qMeasures'] || [];
        const itemInfos = explicitItemInfos || hyperCube[isDimension ? 'qDimensionInfo' : 'qMeasureInfo'];
        const getPopoverData = isDimension ? getDimensionPopoverData : getMeasurePopoverData;
        const getTitleData = isDimension ? getDimensionTitleData : getMeasureTitleData;
        const allowChangeOfAlternatives = model && model.colorSupport && model.modifiers;
        const popover = allowChangeOfAlternatives && getPopoverData({
          altList,
          app,
          dir: rtl ? 'rtl' : 'ltr',
          dock: opposite(dock),
          model,
          onChange: onChangeToAlternative,
          skipAttributeExpressions,
          translator
        });

        // Fix QB-903
        const hasAlternative = isAlternativeDimension(this.settings.settings) || isAlternativeMeasure(this.settings.settings);
        const titles = itemInfos.map((info, index) => {
          const column = typeof info.explicitColumn === 'number' ? info.explicitColumn : index;
          const title = getTitleData(info, column, model);
          const last = index === itemInfos.length - 1;
          return /*#__PURE__*/React.createElement(React.Fragment, {
            key: info.cId
          }, /*#__PURE__*/React.createElement(TitleComponent, {
            popover: popover,
            titleData: title,
            model: model,
            translator: translator,
            selections: selections,
            disabled: disabled(),
            style: this.style,
            isDimension: isDimension,
            padding: padding,
            minWidth: minWidth,
            hasAlternative: hasAlternative,
            supportConditional: supportConditional
          }), !last && /*#__PURE__*/React.createElement("span", {
            style: {
              lineHeight: 'normal',
              ...this.style
            }
          }, ",\xA0"));
        });
        return /*#__PURE__*/React.createElement("div", {
          style: style,
          dir: dir
        }, titles);
        /* eslint-enable react/no-this-in-sfc */
      }
    };
  }

  function disclaimer() {
    class DisclaimerComponent extends React.Component {
      render() {
        const {
          label,
          spanStyle
        } = this.props;
        return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
          ref: this.alignToRef,
          style: spanStyle,
          title: label
        }, label));
      }
    }
    DisclaimerComponent.propTypes = {
      label: PropTypes.string.isRequired,
      spanStyle: PropTypes.shape().isRequired
    };
    function getStyle(styleOverrides, dock, rect) {
      const style = {
        pointerEvents: 'auto',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        color: '#7b7a78',
        fontStyle: 'italic',
        fontSize: '13px',
        fontFamily: styleOverrides.fontFamily || '"Source Sans Pro", "Arial", "sans-serif"'
      };
      switch (dock) {
        case 'left':
          style.width = `${rect.height}px`;
          style.transform = `rotate(-90deg) translate(-${rect.height}px, 0)`;
          style.transformOrigin = 'top left';
          break;
        case 'right':
          style.width = `${rect.height}px`;
          style.transform = `rotate(90deg) translate(0, -${rect.width}px)`;
          style.transformOrigin = 'top left';
          break;
        case 'center':
          style.width = `${rect.width}px`;
          style.height = `${rect.height}px`;
          style.color = '#595959';
          style.fontStyle = 'normal';
          style.fontSize = '1.2em';
          style.textAlign = 'center';
          break;
        default:
        case 'top':
        case 'bottom':
          style.justifyContent = 'flex-start';
          style.alignItems = 'flex-start';
          break;
      }
      return style;
    }
    return {
      renderer: 'react',
      disableTriggers: true,
      preferredSize: function preferredSize() {
        return 22;
      },
      render() {
        /* eslint-disable react/no-this-in-sfc */
        const {
          settings: {
            label,
            rtl
          },
          layout: {
            dock
          },
          style = {}
        } = this.settings;
        const dir = (dock === 'top' || dock === 'bottom') && rtl ? 'rtl' : 'ltr';
        const resolvedStyle = getStyle(style, dock, this.rect);
        const modifiedLabel = dock === 'center' ? label : `* ${label}`;
        const spanStyle = dock !== 'center' ? {
          overflow: 'hidden',
          whiteSpace: 'nowrap',
          textOverflow: 'ellipsis'
        } : {};
        return /*#__PURE__*/React.createElement("div", {
          style: resolvedStyle,
          dir: dir
        }, /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(DisclaimerComponent, {
          label: modifiedLabel,
          spanStyle: spanStyle
        })));
        /* eslint-enable react/no-this-in-sfc */
      }
    };
  }

  const theme = createMuiTheme({
    palette: {
      text: {
        primary: 'rgba(89, 89, 89, 0.8)',
        secondary: 'rgba(0, 0, 0, 0.55)',
        disabled: 'rgba(0, 0, 0, 0.3)'
      },
      action: {
        disabled: 'rgba(0, 0, 0, 0.3)'
      }
    },
    typography: {
      fontFamily: '"Source Sans Pro", "Arial", "sans-serif"',
      button: {
        textTransform: 'initial',
        fontWeight: 400
      }
    },
    shape: {
      borderRadius: 2
    },
    shadows: ['none', '0px 1px 2px 0px rgba(0,0,0,0.15)', '0px 1px 2px 0px rgba(0,0,0,0.15)', '0px 1px 2px 0px rgba(0,0,0,0.15)', '0px 1px 2px 0px rgba(0,0,0,0.15)', '0px 1px 2px 0px rgba(0,0,0,0.15)', '0px 1px 2px 0px rgba(0,0,0,0.15)', '0px 2px 4px 0px rgba(0,0,0,0.15)', '0px 2px 4px 0px rgba(0,0,0,0.15)', '0px 2px 4px 0px rgba(0,0,0,0.15)', '0px 2px 4px 0px rgba(0,0,0,0.15)', '0px 2px 4px 0px rgba(0,0,0,0.15)', '0px 2px 4px 0px rgba(0,0,0,0.15)', '0px 4px 10px 0px rgba(0,0,0,0.15)', '0px 4px 10px 0px rgba(0,0,0,0.15)', '0px 4px 10px 0px rgba(0,0,0,0.15)', '0px 4px 10px 0px rgba(0,0,0,0.15)', '0px 4px 10px 0px rgba(0,0,0,0.15)', '0px 4px 10px 0px rgba(0,0,0,0.15)', '0px 6px 20px 0px rgba(0,0,0,0.15)', '0px 6px 20px 0px rgba(0,0,0,0.15)', '0px 6px 20px 0px rgba(0,0,0,0.15)', '0px 6px 20px 0px rgba(0,0,0,0.15)', '0px 6px 20px 0px rgba(0,0,0,0.15)', '0px 6px 20px 0px rgba(0,0,0,0.15)'],
    props: {
      MuiButtonBase: {
        disableRipple: true
      }
    }
  });
  function classGenerator() {
    return createGenerateClassName({
      productionPrefix: `q${"465a" }`,
      disableGlobal: true,
      seed: ''
    });
  }
  function Mui(nodes, classNameGenerator) {
    return /*#__PURE__*/React.createElement(StylesProvider, {
      generateClassName: classNameGenerator
    }, /*#__PURE__*/React.createElement(ThemeProvider, {
      theme: theme
    }, nodes));
  }

  const classNameGenerator = classGenerator();
  function r() {
    function createRendererBox({
      x,
      y,
      width,
      height,
      scaleRatio,
      margin
    } = {}) {
      const box = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        scaleRatio: {
          x: 1,
          y: 1
        },
        margin: {
          left: 0,
          top: 0
        }
      };
      box.x = Number.isNaN(x) ? box.x : x;
      box.y = Number.isNaN(y) ? box.y : y;
      box.width = Number.isNaN(width) ? box.width : width;
      box.height = Number.isNaN(height) ? box.height : height;
      if (typeof scaleRatio !== 'undefined') {
        box.scaleRatio.x = Number.isNaN(scaleRatio.x) ? box.scaleRatio.x : scaleRatio.x;
        box.scaleRatio.y = Number.isNaN(scaleRatio.y) ? box.scaleRatio.y : scaleRatio.y;
      }
      if (typeof margin !== 'undefined') {
        box.margin.left = Number.isNaN(margin.left) ? 0 : margin.left;
        box.margin.top = Number.isNaN(margin.top) ? 0 : margin.top;
      }
      return box;
    }
    return function renderer(opts = {}) {
      const {
        createElement = document.createElement.bind(document)
      } = opts;
      let el;
      let rect = createRendererBox();
      const dom = {
        element: () => el,
        root: () => el,
        appendTo(element) {
          if (!el) {
            el = createElement('div');
            el.style.position = 'absolute';
            el.style['-webkit-font-smoothing'] = 'antialiased';
            el.style['-moz-osx-font-smoothing'] = 'antialiased';
            el.style.pointerEvents = 'none';
          }
          element.appendChild(el);
          return el;
        },
        render(nodes) {
          if (!el) {
            return false;
          }
          const scaleX = rect.scaleRatio.x;
          const scaleY = rect.scaleRatio.y;
          el.style.left = `${Math.round(rect.margin.left + rect.x * scaleX)}px`;
          el.style.top = `${Math.round(rect.margin.top + rect.y * scaleY)}px`;
          el.style.width = `${Math.round(rect.width)}px`;
          el.style.height = `${Math.round(rect.height)}px`;
          el.style.transform = `scale(${scaleX}, ${scaleY})`;
          el.style.transformOrigin = 'top left';
          ReactDOM.render(Mui(nodes, classNameGenerator), el);
          return true;
        },
        /**
         * Get nodes renderer at area
         * @param {point|circle|rect|line|polygon} geometry - Get nodes that intersects with geometry
         * @returns {SceneNode[]}
         */
        itemsAt: () => [],
        /**
         * Get all nodes matching the provided selector
         * @param {string} selector CSS selector [type, attribute, universal, class]
         * @returns {SceneNode[]} Array of objects containing matching nodes
         */
        findShapes: () => [],
        clear() {
          if (el) {
            ReactDOM.unmountComponentAtNode(el);
          }
          return dom;
        },
        destroy() {
          if (el && el.parentElement) {
            ReactDOM.unmountComponentAtNode(el);
            el.parentElement.removeChild(el);
          }
          el = null;
        },
        size(inner) {
          if (inner) {
            rect = createRendererBox(inner);
          }
          return rect;
        }

        // measureText,
        // textBounds
      };

      return dom;
    };
  }

  function m() {
    return function plugin(picasso) {
      picasso.renderer('react', r());
      picasso.component('data-title', createDataTitleComponent(picasso.renderer('svg')()));
      picasso.component('disclaimer', disclaimer());
    };
  }

  /* eslint-disable no-param-reassign */
  function augmentLine({
    paths
  }) {
    const [path] = paths;
    const coordinates = command => command.replace(/L|M|C|Z/g, '');
    const reduced = paths.reduce((result, p, i) => {
      if (!p.attrs.d) {
        return result;
      }
      const parts = p.attrs.d.split(/(?=[LMC])/);
      const current = {
        parts,
        first: coordinates(parts[0]),
        last: coordinates(parts[Math.max(0, parts.length - 1)])
      };
      result[i] = current;
      if (i === 0) {
        result.combined = p.attrs.d;
        return result;
      }
      const previous = result[result.previousIndex];
      const skip = (previous === null || previous === void 0 ? void 0 : previous.last) === current.first;
      const part = current.parts.slice(skip ? 1 : 0).join('');
      result.combined = `${result.combined}${part}`;
      result.previousIndex = i;
      return result;
    }, {
      combined: '',
      previousIndex: 0
    });

    // eslint-disable-next-line no-underscore-dangle
    path._augmented = {
      d: reduced.combined
    };
    return path;
  }

  function createPathModel({
    chart
  }) {
    const state = {
      paths: chart.findShapes('path').filter(p => p.key === KEYS.COMPONENT.LINE),
      linePaths: [],
      areaPaths: [],
      lineMap: {},
      areaMap: {}
    };
    state.paths.reduce((accumulator, path) => {
      const isLine = Object.hasOwnProperty.call(path.attrs, 'stroke-linejoin');
      const bucket = isLine ? state.linePaths : state.areaPaths;
      bucket.push(path);
      return accumulator;
    }, state);
    return {
      getLine: key => {
        if (!state.lineMap[key]) {
          const paths = state.linePaths.filter(p => p.data && p.data.line.value === key);
          state.lineMap[key] = paths.length > 1 ? augmentLine({
            paths
          }) : paths[0];
        }
        return state.lineMap[key];
      },
      getArea: key => {
        if (!state.areaMap[key]) {
          const [path] = state.areaPaths.filter(p => p.data && p.data.line.value === key);
          state.areaMap[key] = path;
        }
        return state.areaMap[key];
      }
    };
  }

  /* eslint-disable no-param-reassign */
  function createGroups$1({
    items
  }) {
    const hash = items.reduce((grouped, item, index) => {
      const key = item.line.value;
      if (!grouped[key]) {
        grouped[key] = {
          key,
          items: [],
          index
        };
      }
      grouped[key].items.push(item);
      return grouped;
    }, {});
    return Object.keys(hash).map(key => hash[key]).sort((a, b) => a.index - b.index).map(item => ({
      lineKey: item.key,
      items: item.items
    }));
  }

  function createValuePredicate({
    brush
  }) {
    const values = brush.brush.values();
    return function predicate({
      value
    }) {
      return values.indexOf(value) !== -1;
    };
  }

  function createRangePredicate({
    brush,
    chart
  }) {
    const ranges = brush.brush.ranges();
    if (!ranges.length) {
      return false;
    }
    const majorScale = chart && chart.scale(KEYS.SCALE.MAIN.MAJOR);
    const max = majorScale && majorScale.max && majorScale.max();
    const maxPredicate = brush.id === 'qHyperCube/qDimensionInfo/0:numeric' ? (value, limit) => limit === max ? value <= limit : value < limit : (value, limit) => value <= limit;
    return function predicate({
      value
    }) {
      return ranges.some(range => range.min <= value && maxPredicate(value, range.max));
    };
  }

  function createPredicate({
    brush,
    chart
  }) {
    const create = brush.type === 'value' ? createValuePredicate : createRangePredicate;
    return create({
      brush,
      chart
    });
  }

  function getSelectedItems({
    brush,
    legendRange,
    minorRange,
    legendTap,
    items,
    selectionValues,
    colorByData,
    chart
  }) {
    const brushes = brush.brushes();
    if (!brushes.length) {
      return [];
    }
    const currentBrush = brushes[0];
    let valueResolvers = [legendRange ? data => data.color.value : selectionValues[currentBrush.id]].filter(Boolean);
    if (colorByData && minorRange) {
      valueResolvers.push(data => data.color.value);
    }
    if (!colorByData && legendTap) {
      valueResolvers = [data => data.color.value];
    }
    if (!valueResolvers.length) {
      return [];
    }
    const predicate = createPredicate({
      brush: currentBrush,
      chart
    });
    if (!predicate) {
      return [];
    }
    return items.reduce((filtered, item, index) => {
      if (valueResolvers.some(resolver => predicate({
        value: resolver(item)
      }))) {
        filtered.push({
          item,
          index
        });
      }
      return filtered;
    }, []);
  }

  function resolveConnections({
    selected
  }) {
    return selected.reduce((connections, item) => {
      const {
        index
      } = item;
      if (connections.length) {
        const current = connections[connections.length - 1];
        if (index === current[current.length - 1] + 1) {
          current.push(index);
        } else {
          connections.push([index]);
        }
      } else {
        connections.push([index]);
      }
      return connections;
    }, []).filter(c => c.length > 1);
  }

  function resolveCommands({
    d
  }) {
    const commands = d.replace('Z', '').split(/(?=[LMC])/).map(instruction => {
      const letter = instruction.substring(0, 1);
      const command = {
        letter,
        x: 0,
        y: 0,
        raw: instruction
      };
      const coordinates = instruction.substring(1).split(',');
      if (letter === 'M' || letter === 'L') {
        [command.x] = coordinates;
        [, command.y] = coordinates;
      } else if (letter === 'C') {
        [,,,, command.x] = coordinates;
        [,,,,, command.y] = coordinates;
      }
      return command;
    });
    return commands;
  }

  function byGradient({
    chart,
    selected,
    connection,
    gradient,
    fallback,
    orientation,
    isColorCode,
    rtl
  }) {
    const majorScale = chart.scale(KEYS.SCALE.MAIN.MAJOR);
    const colorScale = chart.scale(KEYS.SCALE.MAIN.COLOR);
    const filtered = selected.filter(s => connection.indexOf(s.index) !== -1);
    const ordered = orientation === 'horizontal' && rtl ? filtered.reverse() : filtered;
    const points = ordered.map(s => s.item);
    const values = points.map(p => majorScale(p.major.value));
    const min = Math.min(...values);
    const max = Math.max(...values);
    const difference = max - min;
    const denominator = difference === 0 ? 1 : difference;
    const scaledValues = values.map((value, index) => {
      if (index === 0) {
        return 0;
      }
      if (index === values.length - 1) {
        return 1;
      }
      return (value - min) / denominator;
    });
    const stops = [];
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      const color = isColorCode ? point.color.value : colorScale(point.color.value) || fallback;
      const currentValue = scaledValues[i];
      stops.push({
        color,
        offset: i === 0 ? 0 : Math.max(0, stops[stops.length - 1].offset)
      });
      stops.push({
        color,
        offset: i === points.length - 1 ? 1 : Math.max(0, parseFloat((currentValue + (scaledValues[i + 1] - currentValue) / 2).toFixed(5)))
      });
    }
    return {
      type: 'gradient',
      x1: gradient.x1,
      x2: gradient.x2,
      y1: gradient.y1,
      y2: gradient.y2,
      stops
    };
  }

  function byDataMeasureContinuous$1({
    chart,
    selected,
    connection,
    gradient,
    fallback,
    isArea
  }) {
    const colorScale = chart.scale(KEYS.SCALE.MAIN.COLOR);
    const values = selected.filter(s => connection.indexOf(s.index) !== -1).map(s => s.item.end.value);
    const minimum = Math.min(...values);
    const maximum = Math.max(...values);
    const min = isArea ? Math.min(0, minimum) : minimum;
    const max = isArea ? Math.max(0, maximum) : maximum;
    const difference = max - min;
    const denominator = difference === 0 ? 1 : difference;
    const domain = colorScale.domain();
    const stops = domain.map(value => ({
      color: colorScale(Math.min(max, Math.max(min, value))) || fallback,
      offset: Math.min(1, Math.max(0, (value - min) / denominator))
    }));
    const offsets = stops.map(s => s.offset);
    const zero = offsets.lastIndexOf(0);
    const one = offsets.indexOf(1);
    const filtered = stops.slice(zero === -1 ? 0 : zero, one === -1 ? stops.length : one + 1);
    return {
      type: 'gradient',
      x1: gradient.x1,
      x2: gradient.x2,
      y1: gradient.y1,
      y2: gradient.y2,
      stops: filtered
    };
  }

  function byDataMeasureCategorical$1({
    chart,
    selected,
    connection,
    gradient,
    fallback,
    isArea
  }) {
    const colorScale = chart.scale(KEYS.SCALE.MAIN.COLOR);
    const values = selected.filter(s => connection.indexOf(s.index) !== -1).map(s => s.item.end.value);
    const minimum = Math.min(...values);
    const maximum = Math.max(...values);
    const min = isArea ? Math.min(0, minimum) : minimum;
    const max = isArea ? Math.max(0, maximum) : maximum;
    const difference = max - min;
    const denominator = difference === 0 ? 1 : difference;
    const domain = colorScale.domain();
    const stops = [];
    for (let i = 0; i < domain.length - 1; i++) {
      const value = domain[i];
      const color = colorScale(value) || fallback;
      stops.push({
        color,
        offset: Math.min(1, Math.max(0, (value - min) / denominator))
      });
      const nextValue = domain[i + 1];
      stops.push({
        color,
        offset: Math.min(1, Math.max(0, (nextValue - min) / denominator))
      });
    }
    const offsets = stops.map(s => s.offset);
    const zero = offsets.lastIndexOf(0);
    const one = offsets.indexOf(1);
    const filtered = stops.slice(zero === -1 ? 0 : zero, one === -1 ? stops.length : one + 1);
    return {
      type: 'gradient',
      x1: gradient.x1,
      x2: gradient.x2,
      y1: gradient.y1,
      y2: gradient.y2,
      stops: filtered
    };
  }

  function getColor$2({
    property,
    chart,
    connection,
    attrs,
    colorSettings,
    colorByData,
    isColorCode,
    selected,
    hasMultipleMeasures,
    orientation,
    rtl,
    isArea
  }) {
    const coloring = attrs[property];
    if (coloring.type !== 'gradient') {
      return coloring;
    }
    const {
      type,
      nil: fallback
    } = colorSettings;
    if (hasMultipleMeasures || !colorByData) {
      return byGradient({
        chart,
        selected,
        connection,
        gradient: coloring,
        fallback,
        orientation,
        isColorCode,
        rtl
      });
    }
    const byDataMeasure = type === 'continuous' ? byDataMeasureContinuous$1 : byDataMeasureCategorical$1;
    return byDataMeasure({
      chart,
      selected,
      connection,
      gradient: coloring,
      fallback,
      isArea
    });
  }

  function getLine({
    chart,
    colorSettings,
    colorByData,
    isColorCode,
    hasMultipleMeasures,
    orientation,
    selected,
    connection,
    commands,
    attrs,
    rtl,
    count
  }) {
    const path = connection.map((connectionIndex, index) => {
      const command = commands[connectionIndex];
      if (!command) {
        throw new Error('command is undefined');
      }
      if (index !== 0 || command.letter === 'M') {
        return command.raw;
      }
      return `M${command.x},${command.y}`;
    }).join('');
    return {
      path,
      attrs,
      stroke: getColor$2({
        property: 'stroke',
        chart,
        connection,
        attrs,
        selected,
        colorSettings,
        colorByData,
        isColorCode,
        hasMultipleMeasures,
        orientation,
        rtl,
        count,
        isArea: false
      })
    };
  }

  function getLines({
    chart,
    pathModel,
    colorSettings,
    colorByData,
    isColorCode,
    hasMultipleMeasures,
    orientation,
    lineKey,
    selected,
    connections,
    rtl,
    count
  }) {
    const node = pathModel.getLine(lineKey);
    const {
      attrs
    } = node;
    const commands = resolveCommands({
      // eslint-disable-next-line no-underscore-dangle
      d: node._augmented ? node._augmented.d : attrs.d
    });
    const lines = connections.map(connection => getLine({
      chart,
      colorSettings,
      colorByData,
      isColorCode,
      hasMultipleMeasures,
      orientation,
      selected,
      connection,
      commands,
      attrs,
      rtl,
      count
    }));
    return {
      commands,
      lines
    };
  }

  function getAreas({
    chart,
    pathModel,
    colorSettings,
    colorByData,
    isColorCode,
    hasMultipleMeasures,
    orientation,
    isStacked,
    lineKey,
    selected,
    connections,
    commands,
    rtl,
    count
  }) {
    const node = pathModel.getArea(lineKey);
    if (!node) {
      return [];
    }
    const {
      attrs
    } = node;
    const isHorizontal = orientation === 'horizontal';
    const size = chart.component(KEYS.COMPONENT.LINE).rect.computedInner[isHorizontal ? 'height' : 'width'];
    const scale = chart.scale(KEYS.SCALE.MAIN.MINOR);
    const zero = size * scale(0);
    const parts = [];
    connections.forEach(connection => {
      connection.forEach((index, i) => {
        const command = commands[index];
        const item = {
          x: command.x,
          y: command.y,
          raw: command.raw
        };
        const start = i === 0 || command.letter === 'M' || connection[i - 1] !== connection[i] - 1;
        if (start) {
          parts.push({
            lines: [item],
            first: {
              x: item.x,
              y: item.y
            },
            connection: [connection[i]]
          });
        } else {
          const part = parts[parts.length - 1];
          part.lines.push(item);
          part.connection.push(connection[i]);
        }
      });
    });
    let areaCommands;
    if (isStacked) {
      areaCommands = resolveCommands({
        d: attrs.d
      }).reduce((accumulator, command, i) => {
        const start = i === 0 || command.letter === 'M';
        if (start) {
          accumulator.push([command]);
        } else {
          accumulator[accumulator.length - 1].push(command);
        }
        return accumulator;
      }, []);
    }
    return parts.map(part => {
      const {
        lines
      } = part;
      const paths = lines.map((line, index) => index === 0 ? `M${line.x},${line.y}` : line.raw);
      if (isStacked) {
        const target = part.connection[0];
        const meta = areaCommands.reduce((accumulator, areaCommand) => {
          if (accumulator.found) {
            return accumulator;
          }
          accumulator.counted += areaCommand.length / 2;
          if (target < accumulator.counted) {
            accumulator.areaCommand = areaCommand;
            accumulator.found = true;
          }
          return accumulator;
        }, {
          counted: 0,
          found: false
        });
        const index = areaCommands.indexOf(meta.areaCommand);
        const offset = areaCommands.reduce((counted, areaCommand, i) => {
          if (i < index) {
            // eslint-disable-next-line no-param-reassign
            counted += areaCommand.length / 2;
          }
          return counted;
        }, 0);
        const partCommands = meta.areaCommand;
        const map = partCommands.slice(partCommands.length / 2, partCommands.length).reverse();
        part.connection.map(c => map[c - offset].raw).reverse().forEach((c, i) => {
          if (i === 0 && c.charAt(0) === 'C') {
            const coordinates = c.substring(1).split(',');
            const transformed = {
              x: 0,
              y: 0
            };
            [,,,, transformed.x, transformed.y] = coordinates;
            paths.push(`L${transformed.x},${transformed.y}`);
          } else {
            paths.push(c);
          }
        });
      } else {
        const last = lines[lines.length - 1];
        const x1 = isHorizontal ? last.x : zero;
        const y1 = isHorizontal ? zero : last.y;
        paths.push(`L${x1},${y1}`);
        const x2 = isHorizontal ? part.first.x : zero;
        const y2 = isHorizontal ? zero : part.first.y;
        paths.push(`L${x2},${y2}`);
      }
      paths.push('Z');
      return {
        path: `M${paths.join('').substring(1)}`,
        attrs,
        fill: getColor$2({
          property: 'fill',
          chart,
          connection: part.connection,
          attrs,
          selected,
          colorSettings,
          colorByData,
          isColorCode,
          hasMultipleMeasures,
          orientation,
          rtl,
          count,
          isArea: true
        })
      };
    });
  }

  function createSegments({
    chart,
    pathModel,
    colorSettings,
    colorByData,
    isColorCode,
    hasMultipleMeasures,
    orientation,
    isStacked,
    lineKey,
    selected,
    connections,
    rtl,
    highlightArea,
    count
  }) {
    const {
      commands,
      lines
    } = getLines({
      chart,
      pathModel,
      colorSettings,
      colorByData,
      isColorCode,
      hasMultipleMeasures,
      orientation,
      lineKey,
      selected,
      connections,
      rtl,
      count
    });
    return {
      lines,
      areas: highlightArea ? getAreas({
        chart,
        pathModel,
        colorSettings,
        colorByData,
        isColorCode,
        hasMultipleMeasures,
        orientation,
        isStacked,
        lineKey,
        selected,
        connections,
        commands,
        rtl,
        count
      }) : []
    };
  }

  function createShapes({
    chart,
    pathModel,
    brush,
    legendRange,
    minorRange,
    legendTap,
    items,
    selectionValues,
    colorSettings,
    colorByData,
    isColorCode,
    hasMultipleMeasures,
    isStacked,
    orientation,
    rtl,
    highlightArea
  }) {
    const filtered = items.filter(i => i.end.value !== 'NaN' && !Number.isNaN(i.end.value));
    const groups = createGroups$1({
      items: filtered
    });
    const {
      lines,
      areas
    } = groups.reduce((model, group) => {
      const selected = getSelectedItems({
        brush,
        legendRange,
        minorRange,
        legendTap,
        items: group.items,
        selectionValues,
        colorByData,
        chart
      });
      if (selected.length < 2) {
        return model;
      }
      const connections = resolveConnections({
        selected
      });
      if (!connections.length) {
        return model;
      }
      const {
        lines: lineSegments,
        areas: areaSegments
      } = createSegments({
        chart,
        pathModel,
        colorSettings,
        colorByData,
        isColorCode,
        hasMultipleMeasures,
        orientation,
        isStacked,
        lineKey: group.lineKey,
        selected,
        connections,
        rtl,
        highlightArea,
        count: group.items.length
      });
      model.lines.push(...lineSegments);
      if (highlightArea) {
        model.areas.push(...areaSegments);
      }
      return model;
    }, {
      lines: [],
      areas: []
    });
    const shapes = [];
    lines.forEach(line => shapes.push({
      type: 'path',
      d: line.path,
      stroke: line.stroke,
      strokeLinejoin: line.attrs['stroke-linejoin'],
      strokeWidth: line.attrs['stroke-width'],
      strokeDasharray: line.attrs['stroke-dasharray'],
      fill: 'none'
    }));
    if (highlightArea) {
      areas.forEach(area => shapes.push({
        type: 'path',
        d: area.path,
        fill: area.fill,
        opacity: area.attrs.opacity
      }));
    }
    return shapes;
  }

  var brushHighlighter = {
    require: ['chart', 'renderer'],
    defaultSettings: {
      settings: {
        enabled: () => true,
        highlightArea: () => true,
        getSelectionContext: () => 'selection',
        getSelectionInfo: undefined,
        selectionValues: {},
        colorSettings: undefined,
        colorByData: false,
        isColorCode: false,
        hasMultipleMeasures: false,
        isStacked: false,
        orientation: 'horizontal',
        rtl: false
      }
    },
    addListener(type, fn) {
      this.state.brush.addListener(type, fn);
      this.state.listeners.push({
        type,
        fn
      });
    },
    removeListeners() {
      this.state.listeners.forEach(listener => this.state.brush.removeListener(listener.type, listener.fn));
      this.state.listeners.length = 0;
    },
    created() {
      const selectionContext = typeof this.settings.settings.getSelectionContext === 'function' ? this.settings.settings.getSelectionContext() : 'selection';
      this.state = {
        pathModel: createPathModel({
          chart: this.chart
        }),
        brush: this.chart.brush(selectionContext),
        listeners: [],
        legendRange: false,
        minorRange: false,
        legendTap: false
      };
    },
    mounted() {
      this.addListener('update', () => {
        if (typeof this.settings.settings.enabled === 'function' && !this.settings.settings.enabled()) {
          return;
        }
        const {
          legendRange = this.state.legendRange,
          minorRange = this.state.minorRange,
          legendTap = this.state.legendTap
        } = this.settings.settings.getSelectionInfo();
        const nodes = createShapes({
          chart: this.chart,
          pathModel: this.state.pathModel,
          brush: this.state.brush,
          legendRange,
          minorRange,
          legendTap,
          items: this.data.items,
          selectionValues: this.settings.settings.selectionValues,
          colorSettings: this.settings.settings.colorSettings,
          colorByData: this.settings.settings.colorByData,
          isColorCode: this.settings.settings.isColorCode,
          hasMultipleMeasures: this.settings.settings.hasMultipleMeasures,
          isStacked: this.settings.settings.isStacked,
          orientation: this.settings.settings.orientation,
          rtl: this.settings.settings.rtl,
          highlightArea: this.settings.settings.highlightArea()
        });
        const {
          getProgressiveRender
        } = this.settings.settings;
        if (typeof getProgressiveRender === 'function') {
          const progressiveRender = getProgressiveRender();
          progressiveRender({
            render: this.renderer.render,
            nodes
          });
        } else {
          this.renderer.render(nodes);
        }
      });
      this.addListener('end', () => {
        if (typeof this.settings.settings.enabled === 'function' && !this.settings.settings.enabled()) {
          return;
        }
        this.renderer.render([]);
      });
    },
    render() {
      if (typeof this.settings.settings.enabled === 'function' && !this.settings.settings.enabled()) {
        return [];
      }
      this.state.pathModel = createPathModel({
        chart: this.chart
      });
      const {
        legendRange = this.state.legendRange,
        minorRange = this.state.minorRange,
        legendTap = this.state.legendTap
      } = this.settings.settings.getSelectionInfo();
      const shapes = createShapes({
        chart: this.chart,
        pathModel: this.state.pathModel,
        brush: this.state.brush,
        legendRange,
        minorRange,
        legendTap,
        items: this.data.items,
        selectionValues: this.settings.settings.selectionValues,
        colorSettings: this.settings.settings.colorSettings,
        colorByData: this.settings.settings.colorByData,
        isColorCode: this.settings.settings.isColorCode,
        hasMultipleMeasures: this.settings.settings.hasMultipleMeasures,
        isStacked: this.settings.settings.isStacked,
        orientation: this.settings.settings.orientation,
        rtl: this.settings.settings.rtl,
        highlightArea: this.settings.settings.highlightArea()
      });
      return shapes;
    },
    destroyed() {
      if (this.state.unregisterOnStart) {
        this.state.unregisterOnStart();
      }
      this.removeListeners();
    }
  };

  var ghostPoint = {
    require: ['resolver'],
    defaultSettings: {
      settings: {
        orientation: 'horizontal'
      }
    },
    render() {
      const {
        items
      } = this.data;
      if (!items.length) {
        return [];
      }
      const values = [];
      const uniques = [];
      items.forEach(item => {
        const {
          value
        } = item.major;
        if (!values[value]) {
          values[value] = true;
          uniques.push(item);
        }
      });
      const horizontal = this.settings.settings.orientation === 'horizontal';
      const dimension = this.rect[horizontal ? 'width' : 'height'];
      const resolved = this.resolver.resolve({
        data: {
          items: uniques
        },
        settings: {
          major: {
            scale: KEYS.SCALE.MAIN.MAJOR
          }
        },
        scaled: {
          major: dimension
        }
      });
      return resolved.items.map(item => ({
        type: 'circle',
        fill: 'none',
        cx: horizontal ? dimension * item.major : 0,
        cy: horizontal ? 0 : dimension * item.major,
        r: 1,
        data: item.data
      }));
    }
  };

  function createLinePoint({
    x,
    y,
    size,
    stroke,
    strokeWidth,
    fill
  }) {
    return {
      type: 'container',
      children: [{
        type: 'line',
        stroke: stroke || fill,
        strokeWidth,
        x1: x - size / 2,
        y1: y,
        x2: x + size / 2,
        y2: y
      }, {
        type: 'circle',
        strokeWidth: 0,
        fill,
        cx: x,
        cy: y,
        r: size * 0.25
      }]
    };
  }

  function resolveSettings({
    settings = {},
    defaultSettings = {}
  }) {
    const resolved = {};
    Object.keys(defaultSettings).forEach(key => {
      const type = typeof settings[key];
      if (type === 'function') {
        resolved[key] = settings[key]();
      } else if (type === 'undefined') {
        resolved[key] = defaultSettings[key];
      } else {
        resolved[key] = settings[key];
      }
    });
    return resolved;
  }

  const DEFAULT_SETTINGS = {
    min: NaN,
    max: NaN
  };
  const DEFAULT_TICK_SETTINGS = {
    values: undefined
  };
  function initNormScale(normScale, scale) {
    if (normScale.instance) {
      return;
    }
    // eslint-disable-next-line no-param-reassign
    normScale.instance = scale.copy();
    normScale.instance.domain([scale.start(), scale.end()]);
    normScale.instance.clamp(true);
    normScale.instance.range(normScale.invert ? [1, 0] : [0, 1]);
  }
  function createLogarithmicScale(settings = {}, data = {}, resources = {}) {
    const scale = log$1();
    const normScale = {
      instance: null,
      invert: false
    };
    const {
      min,
      max
    } = resolveSettings({
      settings,
      defaultSettings: DEFAULT_SETTINGS
    });
    const {
      values: customTicks
    } = resolveSettings({
      settings: settings.ticks,
      defaultSettings: DEFAULT_TICK_SETTINGS
    });
    function fn(value) {
      if (typeof value !== 'number' || Number.isNaN(value)) {
        return NaN;
      }
      return scale(value);
    }
    fn.invert = function invert(value) {
      return scale.invert(value);
    };
    fn.clamp = function clamp(value = true) {
      scale.clamp(value);
      return fn;
    };
    fn.start = function start() {
      return fn.domain()[0];
    };
    fn.end = function end() {
      return fn.domain()[this.domain().length - 1];
    };
    fn.min = function minFnc() {
      return Math.min(this.start(), this.end());
    };
    fn.max = function maxFnc() {
      return Math.max(this.start(), this.end());
    };
    fn.copy = function copy() {
      const cop = createLogarithmicScale(settings, data, resources);
      cop.domain(fn.domain());
      cop.range(fn.range());
      cop.clamp(scale.clamp());
      return cop;
    };
    fn.norm = function norm(d) {
      initNormScale(normScale, fn);
      return normScale.instance(d);
    };
    fn.normInvert = function norm(t) {
      initNormScale(normScale, fn);
      return normScale.instance.invert(t);
    };
    fn.data = () => data;
    fn.ticks = ({
      formatter
    } = {}) => {
      const ticks = customTicks || scale.nice().ticks(5);
      return ticks.map(tick => {
        const position = fn(tick);
        return {
          position,
          start: position,
          end: position,
          value: tick,
          label: formatter ? formatter(tick) : tick
        };
      });
    };
    fn.domain = values => {
      if (values !== undefined) {
        scale.domain(values);
        return fn;
      }
      return scale.domain();
    };
    fn.range = values => {
      if (values !== undefined) {
        scale.range(values);
        return fn;
      }
      return scale.range();
    };
    fn.domain([min || 1, max]);
    fn.range(settings.invert ? [1, 0] : [0, 1]);
    normScale.invert = settings.invert;
    scale.base(10);
    return fn;
  }

  function configurePicasso() {
    const picasso = p();
    picasso.use(initialize);
    picasso.use(initialize$1(Hammer$1));
    picasso.use(m());
    picasso.component('axis-overlay', continuous$1.picassoComponents.axisOverlay);
    picasso.component('brush-highlighter', brushHighlighter);
    picasso.component('ghost-point', ghostPoint);
    picasso.component('label-space', labelSpace);
    picasso.component('out-of-bounds-marker', outOfBoundsMarker);
    picasso.component('point-label', pointLabel);
    picasso.component('reference-line-labels', refLineLabelsComponent);
    picasso.component('scroll-hint', scrollHintComponent);
    picasso.component('scrollbar', scrollbarComponent$1);
    picasso.component('time-axis', continuous$1.picassoComponents.timeAxis);
    picasso.scale('logarithmic', createLogarithmicScale);
    picasso.scale('time', continuous$1.picassoScales.time);
    picasso.symbol('line-point', createLinePoint);
    return picasso;
  }

  /**
   * Utility functions
   */
  var util = {};
  util.isObject = function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  };
  util.isNumber = function isNumber(arg) {
    return typeof arg === 'number';
  };
  util.isUndefined = function isUndefined(arg) {
    return arg === void 0;
  };
  util.isFunction = function isFunction(arg) {
    return typeof arg === 'function';
  };

  /**
   * EventEmitter class
   */

  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  var nodeEventEmitter = EventEmitter;

  // Backwards-compat with node 0.10.x
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;

  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  EventEmitter.defaultMaxListeners = 10;
  EventEmitter.init = function () {
    this._events = this._events || {};
    this._maxListeners = this._maxListeners || undefined;
  };

  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function (n) {
    if (!util.isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
    this._maxListeners = n;
    return this;
  };
  EventEmitter.prototype.emit = function (type) {
    var er, handler, len, args, i, listeners;
    if (!this._events) this._events = {};

    // If there is no 'error' event listener then throw.
    if (type === 'error' && !this._events.error) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        throw Error('Uncaught, unspecified "error" event.');
      }
    }
    handler = this._events[type];
    if (util.isUndefined(handler)) return false;
    if (util.isFunction(handler)) {
      switch (arguments.length) {
        // fast cases
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        // slower
        default:
          len = arguments.length;
          args = new Array(len - 1);
          for (i = 1; i < len; i++) args[i - 1] = arguments[i];
          handler.apply(this, args);
      }
    } else if (util.isObject(handler)) {
      len = arguments.length;
      args = new Array(len - 1);
      for (i = 1; i < len; i++) args[i - 1] = arguments[i];
      listeners = handler.slice();
      len = listeners.length;
      for (i = 0; i < len; i++) listeners[i].apply(this, args);
    }
    return true;
  };
  EventEmitter.prototype.addListener = function (type, listener) {
    var m;
    if (!util.isFunction(listener)) throw TypeError('listener must be a function');
    if (!this._events) this._events = {};

    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (this._events.newListener) this.emit('newListener', type, util.isFunction(listener.listener) ? listener.listener : listener);
    if (!this._events[type])
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;else if (util.isObject(this._events[type]))
      // If we've already got an array, just append.
      this._events[type].push(listener);else
      // Adding the second element, need to change to array.
      this._events[type] = [this._events[type], listener];

    // Check for listener leak
    if (util.isObject(this._events[type]) && !this._events[type].warned) {
      var m;
      if (!util.isUndefined(this._maxListeners)) {
        m = this._maxListeners;
      } else {
        m = EventEmitter.defaultMaxListeners;
      }
      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        if (util.isFunction(console.error)) {
          console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
        }
        if (util.isFunction(console.trace)) console.trace();
      }
    }
    return this;
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.once = function (type, listener) {
    if (!util.isFunction(listener)) throw TypeError('listener must be a function');
    var fired = false;
    function g() {
      this.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener.apply(this, arguments);
      }
    }
    g.listener = listener;
    this.on(type, g);
    return this;
  };

  // emits a 'removeListener' event iff the listener was removed
  EventEmitter.prototype.removeListener = function (type, listener) {
    var list, position, length, i;
    if (!util.isFunction(listener)) throw TypeError('listener must be a function');
    if (!this._events || !this._events[type]) return this;
    list = this._events[type];
    length = list.length;
    position = -1;
    if (list === listener || util.isFunction(list.listener) && list.listener === listener) {
      delete this._events[type];
      if (this._events.removeListener) this.emit('removeListener', type, listener);
    } else if (util.isObject(list)) {
      for (i = length; i-- > 0;) {
        if (list[i] === listener || list[i].listener && list[i].listener === listener) {
          position = i;
          break;
        }
      }
      if (position < 0) return this;
      if (list.length === 1) {
        list.length = 0;
        delete this._events[type];
      } else {
        list.splice(position, 1);
      }
      if (this._events.removeListener) this.emit('removeListener', type, listener);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function (type) {
    var key, listeners;
    if (!this._events) return this;

    // not listening for removeListener, no need to emit
    if (!this._events.removeListener) {
      if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
      return this;
    }

    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
      for (key in this._events) {
        if (key === 'removeListener') continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners('removeListener');
      this._events = {};
      return this;
    }
    listeners = this._events[type];
    if (util.isFunction(listeners)) {
      this.removeListener(type, listeners);
    } else if (Array.isArray(listeners)) {
      // LIFO order
      while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);
    }
    delete this._events[type];
    return this;
  };
  EventEmitter.prototype.listeners = function (type) {
    var ret;
    if (!this._events || !this._events[type]) ret = [];else if (util.isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
    return ret;
  };
  EventEmitter.listenerCount = function (emitter, type) {
    var ret;
    if (!emitter._events || !emitter._events[type]) ret = 0;else if (util.isFunction(emitter._events[type])) ret = 1;else ret = emitter._events[type].length;
    return ret;
  };
  var EventEmitter$1 = /*@__PURE__*/getDefaultExportFromCjs(nodeEventEmitter);

  function createActions({
    lasso,
    progressiveRendering
  }) {
    const actions = {
      interact: {
        isEnabled: true,
        enabled() {
          return this.isEnabled;
        },
        update(c) {
          this.isEnabled = !c.active;
        }
      },
      lasso,
      scroll: {
        isEnabled: true,
        enabled() {
          return this.isEnabled;
        },
        update(c) {
          this.isEnabled = !c.active;
        }
      },
      select: {
        isEnabled: true,
        enabled() {
          return this.isEnabled && !progressiveRendering.getInProgressive();
        },
        update(c) {
          this.isEnabled = !c.select && !c.active;
        }
      },
      tooltip: {
        isEnabled: true,
        enabled() {
          return this.isEnabled;
        },
        update(c) {
          this.isEnabled = !c.passive;
        }
      },
      update(c) {
        Object.keys(actions).forEach(key => {
          if (actions[key].update) {
            actions[key].update(c);
          }
        });
      },
      destroy() {
        actions.select.removeAllListeners();
      }
    };
    Object.keys(EventEmitter$1.prototype).forEach(key => {
      actions.select[key] = EventEmitter$1.prototype[key];
    });
    EventEmitter$1.init(actions.select);
    return actions;
  }

  var icon = {
    shapes: [{
      type: 'path',
      attrs: {
        d: 'M15.9488039,5.20769129 C16.0487326,6.70662306 15.3492311,8.30548361 14.050157,9.30477145 C12.651154,10.5039169 10.8524359,10.8037032 8.85386017,10.4039881 L7.3549284,10.0042729 L5.75606786,9.70448659 C5.75606786,9.90434416 5.65613907,10.0042729 5.4562815,10.2041305 C5.05656637,10.6038456 4.55692244,10.8037032 4.05727852,10.8037032 C3.75749217,10.8037032 3.45770582,10.7037744 3.15791946,10.6038456 C3.05799068,10.903632 3.15791946,11.2034184 3.45770582,11.7030623 C5.05656637,14.0014243 3.85742095,15.9000712 3.75749217,16 L2.2585604,15.3004985 C2.2585604,15.2005697 2.95806189,14.0014243 1.95877405,12.6024213 C1.6589877,12.0028486 1.15934378,11.0035608 1.55905891,10.0042729 C1.6589877,9.80441537 1.75891648,9.6045578 1.95877405,9.40470024 C1.6589877,8.90505631 1.55905891,8.30548361 1.85884527,7.7059109 C1.55905891,7.40612455 1.25927256,7.1063382 1.15934378,6.70662306 C0.859557424,5.90719279 0.959486209,4.5081898 1.6589877,3.30904439 C1.95877405,2.6095429 2.55834676,2.0099702 3.15791946,1.51032628 C3.95734974,0.91075357 4.95663758,0.610967217 6.15578299,0.311180864 C9.05371774,-0.388320626 11.9516525,0.111323295 13.9502282,1.61025506 C15.1493736,2.50961412 15.8488751,3.80868831 15.9488039,5.20769129 Z M13.0508691,8.10562604 C13.8502994,7.40612455 14.3499433,6.40683671 14.3499433,5.30762008 C14.2500145,4.20840345 13.550513,3.40897318 12.9509403,2.90932926 C12.1515101,2.40968533 11.252151,2.0099702 10.1529344,1.81011263 C8.95378895,1.61025506 7.75464354,1.71018384 6.45556935,1.91004141 C4.75678001,2.30975655 3.65756338,3.00925804 3.05799068,4.10847467 C2.55834676,5.00783373 2.65827554,5.90719279 2.75820433,6.20697914 C2.75820433,6.30690792 2.85813311,6.40683671 3.05799068,6.40683671 C3.15791946,6.40683671 3.25784825,6.40683671 3.35777703,6.40683671 C3.45770582,6.40683671 3.45770582,6.40683671 3.45770582,6.40683671 L3.5576346,6.40683671 L3.65756338,6.40683671 C4.65685123,6.40683671 5.4562815,6.90648063 5.85599664,7.80583969 L5.85599664,8.00569726 C6.35564056,8.10562604 7.05514205,8.30548361 7.75464354,8.50534118 L9.25357531,8.90505631 C10.0530056,9.0049851 10.7525071,9.0049851 11.4520086,8.80512753 C12.0515813,8.70519875 12.5512252,8.40541239 13.0508691,8.10562604 Z'
      }
    }]
  };

  function useLasso() {
    const layout = stardust.useLayout();
    const translator = stardust.useTranslator();
    const [enabled, setEnabled] = stardust.useState(false);
    const [active, setActive] = stardust.useState(false);
    const action = on => {
      const newState = typeof on === 'boolean' ? on : !active;
      setActive(newState);
    };
    const [lasso] = stardust.useState({});
    lasso.enabled = () => enabled;
    lasso.active = () => active;
    lasso.action = action;
    lasso.update = c => {
      setEnabled(!c.select && !c.active);
    };
    stardust.useAction(() => {
      var _layout$qSelectionInf, _layout$qHyperCube;
      const isInSelections = !!((_layout$qSelectionInf = layout.qSelectionInfo) !== null && _layout$qSelectionInf !== void 0 && _layout$qSelectionInf.qInSelections);
      const isSingleSelection = !!((_layout$qHyperCube = layout.qHyperCube) !== null && _layout$qHyperCube !== void 0 && (_layout$qHyperCube = _layout$qHyperCube.qDimensionInfo) !== null && _layout$qHyperCube !== void 0 && (_layout$qHyperCube = _layout$qHyperCube[0]) !== null && _layout$qHyperCube !== void 0 && _layout$qHyperCube.qIsOneAndOnlyOne);
      return {
        key: 'lasso',
        label: translator.get(active ? 'Tooltip.ToggleOffLassoSelection' : 'Tooltip.ToggleOnLassoSelection'),
        icon,
        hidden: !enabled || !isInSelections || isSingleSelection,
        action,
        active
      };
    }, [active, enabled, layout, translator.language()]);
    return lasso;
  }

  function useActions(progressiveRendering) {
    const constraints = stardust.useConstraints();
    const lasso = useLasso();
    const [actions] = stardust.useState(() => createActions({
      lasso,
      progressiveRendering
    }));
    stardust.useEffect(() => {
      actions.update(constraints);
    }, [constraints]);
    return actions;
  }

  function useProgressiveRendering() {
    const progressiveInfo = {
      timer: Date.now(),
      mainTimer: null,
      pointTimer: null,
      lineTimer: null,
      reducedLineTimer: null,
      renderPromise: null,
      getInProgressive: () => progressiveInfo.progressive,
      setInProgressive: b => {
        progressiveInfo.progressive = b;
      }
    };
    const [progressiveRendering] = stardust.useState(() => progressiveInfo);
    return progressiveRendering;
  }

  function useCore({
    env
  }) {
    const progressiveRendering = useProgressiveRendering();
    const actions = useActions(progressiveRendering);
    const deviceType = stardust.useDeviceType();
    const element = stardust.useElement();
    const options = stardust.useOptions();
    const [core, setCore] = stardust.useState();
    stardust.useEffect(() => {
      const {
        flags = {
          isEnabled: () => false
        },
        isUnsupportedFeature = () => false
      } = env;
      const createPicasso = configurePicasso();
      const picasso = createPicasso({
        renderer: {
          prio: [options.renderer || 'canvas']
        }
      });
      element.style.overflow = 'hidden';
      const chart = picasso.chart({
        element,
        data: [],
        settings: {}
      });
      setCore({
        actions,
        chart,
        deviceType,
        flags,
        isUnsupportedFeature,
        picasso,
        viewCache: wt(),
        viewState: kt({
          scrollOffset: undefined,
          viewRange: [0, 1]
        }),
        progressiveRendering
      });
      return function destroy() {
        actions.destroy();
        chart.destroy();
      };
    }, []);
    return core;
  }

  function contains$2(page, area) {
    if (!page) {
      return false;
    }
    const {
      qArea: stored
    } = page;
    if (!stored) {
      return false;
    }
    return stored.qLeft <= area.qLeft && stored.qLeft + stored.qWidth >= area.qLeft + area.qWidth && stored.qTop <= area.qTop && stored.qTop + stored.qHeight >= area.qTop + area.qHeight;
  }

  /* eslint-disable no-param-reassign */
  function patcher$3({
    layoutService
  }) {
    const patch = page => {
      page.qArea.qHeight = page.qMatrix.length;
      page.qArea.qWidth = layoutService.meta.size.x;
    };
    patch.should = page => page.qArea.qHeight === 0 && page.qArea.qWidth === 0 && !!page.qMatrix.length;
    return patch;
  }

  function straightSlicer(page, area) {
    const height = Math.max(0, area.qHeight) - Math.abs(Math.min(0, area.qTop - page.qArea.qTop));
    const width = Math.max(0, area.qWidth) - Math.abs(Math.min(0, area.qLeft - page.qArea.qLeft));
    const top = Math.max(area.qTop, page.qArea.qTop);
    const left = Math.max(area.qLeft, page.qArea.qLeft);
    const y1 = Math.max(0, top - page.qArea.qTop);
    const y2 = Math.min(top + height - page.qArea.qTop, page.qArea.qHeight);
    const x1 = Math.max(0, left - page.qArea.qLeft);
    const x2 = Math.min(left + width - page.qArea.qLeft, page.qArea.qWidth);
    const sliced = {
      qArea: {
        qHeight: y2 - y1,
        qWidth: x2 - x1,
        qTop: top,
        qLeft: left
      },
      qMatrix: []
    };
    for (let i = y1; i < y2; i++) {
      sliced.qMatrix.push(page.qMatrix[i].slice(x1, x2));
    }
    return sliced;
  }

  const REJECTION_TOKEN = 'REJECTED';
  const NOOP = () => {};
  const MAX_CELLS = 10000;
  const EXPANSION = {
    MULTIPLIER: 2,
    MINIMUM: 20,
    MAXIMUM: 200
  };
  const MAX_STACK_CELLS = 600;
  const THROTTLING_TRESHOLD = 50;
  const CACHE_MARGIN = 10;
  const SCROLL_SPEED = 100;

  function straightCacheWarden({
    bounds = {
      width: 0,
      height: 0
    }
  }) {
    return {
      release(cachedArea, subarea) {
        const nearTop = subarea.qTop - CACHE_MARGIN <= cachedArea.qTop;
        const nearRight = subarea.qLeft + subarea.qWidth + CACHE_MARGIN >= cachedArea.qLeft + cachedArea.qWidth;
        const nearBottom = subarea.qTop + subarea.qHeight + CACHE_MARGIN >= cachedArea.qTop + cachedArea.qHeight;
        const nearLeft = subarea.qLeft - CACHE_MARGIN <= cachedArea.qLeft;
        return nearTop && cachedArea.qTop > 0 || nearRight && cachedArea.qLeft + cachedArea.qWidth < bounds.width || nearBottom && cachedArea.qTop + cachedArea.qHeight < bounds.height || nearLeft && cachedArea.qLeft > 0;
      }
    };
  }

  function createRequest$2({
    definitionPath
  }) {
    return area => ({
      method: 'getHyperCubeData',
      args: [definitionPath, [area]]
    });
  }

  var straightComposition = {
    contains: contains$2,
    patcher: patcher$3,
    slicer: straightSlicer,
    cacheWarden: straightCacheWarden,
    request: createRequest$2
  };

  function contains$1(page, area) {
    if (!page) {
      return false;
    }
    const {
      qArea: stored
    } = page;
    if (!stored) {
      return false;
    }
    return stored.qTop <= area.qTop && stored.qTop + stored.qHeight >= area.qTop + area.qHeight;
  }

  /* eslint-disable no-param-reassign */
  function patcher$2({
    layoutService
  }) {
    const patch = page => {
      page.qArea.qHeight = page.qData[0].qSubNodes.length;
      page.qArea.qWidth = layoutService.meta.size.x;
    };
    patch.should = page => page.qArea.qHeight === 0 && page.qArea.qWidth === 0 && !!page.qData.length;
    return patch;
  }

  function stackedSlicer(page, area) {
    const height = Math.max(0, area.qHeight) - Math.abs(Math.min(0, area.qTop - page.qArea.qTop));
    const top = Math.max(area.qTop, page.qArea.qTop);
    const left = Math.max(area.qLeft, page.qArea.qLeft);
    const y1 = Math.max(0, top - page.qArea.qTop);
    const y2 = Math.min(top + height - page.qArea.qTop, page.qArea.qHeight);
    const down = page.qData[0].qUp + page.qArea.qHeight + page.qData[0].qDown - top - (y2 - y1);
    const sliced = {
      qArea: {
        qHeight: y2 - y1,
        qWidth: page.qArea.qWidth,
        qTop: top,
        qLeft: left
      },
      qData: [{
        ...page.qData[0],
        qUp: top,
        qDown: down,
        qSubNodes: []
      }]
    };
    for (let i = y1; i < y2; i++) {
      sliced.qData[0].qSubNodes.push(page.qData[0].qSubNodes[i]);
    }
    return sliced;
  }

  function stackedCacheWarden({
    bounds = {
      height: 0
    }
  }) {
    return {
      release(cachedArea, subarea) {
        const nearTop = subarea.qTop - CACHE_MARGIN <= cachedArea.qTop;
        const nearBottom = subarea.qTop + subarea.qHeight + CACHE_MARGIN >= cachedArea.qTop + cachedArea.qHeight;
        return nearTop && cachedArea.qTop > 0 || nearBottom && cachedArea.qTop + cachedArea.qHeight < bounds.height;
      }
    };
  }

  function createRequest$1({
    layoutService,
    definitionPath
  }) {
    const mode = layoutService.getLayoutValue('dimensionAxis.axisDisplayMode', 'auto');
    return area => {
      const request = {
        method: 'getHyperCubeStackData',
        args: [definitionPath, [area]]
      };
      if (mode === 'auto') {
        request.args.push(MAX_STACK_CELLS);
      }
      return request;
    };
  }

  var stackedComposition = {
    contains: contains$1,
    patcher: patcher$2,
    slicer: stackedSlicer,
    cacheWarden: stackedCacheWarden,
    request: createRequest$1
  };

  function contains( /* page, area */
  ) {
    return false;
  }

  function patcher$1() {
    const patch = page => page;
    patch.should = () => false;
    return patch;
  }

  function treeSlicer(page /* , area */) {
    return page;
  }

  function treeCacheWarden( /* { bounds = { width: 0, height: 0 } } */
  ) {
    return {
      release( /* cachedArea, subarea */
      ) {
        return true;
      }
    };
  }

  function createRequest({
    definitionPath
  }) {
    return area => ({
      method: 'getHyperCubeTreeData',
      args: [definitionPath, [area]]
    });
  }

  var treeComposition = {
    contains,
    patcher: patcher$1,
    slicer: treeSlicer,
    cacheWarden: treeCacheWarden,
    request: createRequest
  };

  function compositionFactory$1({
    qMode
  }) {
    switch (qMode) {
      case 'S':
      default:
        return straightComposition;
      case 'K':
        return stackedComposition;
      case 'T':
        return treeComposition;
    }
  }

  const KEY = 'pages';
  function createDataStore({
    state,
    contains
  }) {
    state.set(KEY, []);
    return {
      add: page => {
        const pages = state.get(KEY);
        pages.length = 0;
        pages.push(page);
      },
      getCurrent: () => state.get(KEY)[0],
      getAll: () => state.get(KEY),
      contains: area => contains(state.get(KEY)[0], area)
    };
  }

  const eventName$3 = 'discretePan';
  const threshold$1 = 10;
  function createPan({
    chart,
    actions,
    componentKey,
    dockService,
    rtl,
    scroller
  }) {
    return {
      type: 'Pan',
      key: 'discrete:pan',
      options: {
        event: eventName$3,
        pointers: 1,
        threshold: threshold$1,
        enable(r, e) {
          if (this.started === eventName$3 || !e) {
            return true;
          }
          if (!actions.scroll.enabled() || !scroller.enabled()) {
            return false;
          }
          return chart.componentsFromPoint({
            x: e.center.x,
            y: e.center.y
          }).some(c => c.key === componentKey);
        }
      },
      events: {
        [`${eventName$3}start`](e) {
          e.preventDefault();
          this.started = eventName$3;
          const totalDelta = dockService.meta.major.orientation === 'horizontal' ? e.deltaX : e.deltaY;
          this.previousTotalDelta = totalDelta < 0 ? -threshold$1 : threshold$1;
        },
        [`${eventName$3}move`](e) {
          e.preventDefault();
          const horizontal = dockService.meta.major.orientation === 'horizontal';
          const totalDelta = horizontal ? e.deltaX : e.deltaY;
          const invert = horizontal && rtl;
          const modifier = invert ? -1 : 1;
          const delta = (totalDelta - this.previousTotalDelta) * modifier;
          this.previousTotalDelta = totalDelta;
          scroller.scroll(delta);
        },
        [`${eventName$3}end`](e) {
          e.preventDefault();
          this.started = false;
        },
        [`${eventName$3}cancel`](e) {
          e.preventDefault();
          this.started = false;
        }
      }
    };
  }

  function createWheel({
    chart,
    componentKey,
    actions,
    scroller
  }) {
    return function wheel(e) {
      if (!actions.scroll.enabled() || !scroller.enabled()) {
        return;
      }
      const [target] = chart.componentsFromPoint({
        x: e.clientX,
        y: e.clientY
      }).filter(c => c.key === componentKey);
      if (!target) {
        return;
      }
      e.preventDefault();
      const delta = Math.abs(e.deltaY) > Math.abs(e.deltaX) ? e.deltaY : e.deltaX;
      const sign = Math.sign(-delta);
      const standardized = sign * SCROLL_SPEED;
      scroller.scroll(standardized);
    };
  }

  function createInteractions$1({
    chart,
    actions,
    componentKey,
    dockService,
    rtl,
    scroller
  }) {
    return {
      gestures: [createPan({
        chart,
        actions,
        componentKey,
        dockService,
        rtl,
        scroller
      })],
      native: {
        type: 'native',
        events: {
          wheel: createWheel({
            chart,
            actions,
            componentKey,
            scroller
          })
        }
      }
    };
  }

  function createExpansion({
    layoutService
  }) {
    const roof = Math.floor(MAX_CELLS / (layoutService.meta.dimensionCount + layoutService.meta.measureCount));
    return function expansion({
      width,
      height
    }) {
      const maximum = Math.min(roof, Math.max(EXPANSION.MAXIMUM, height));
      const expansionHeight = Math.max(EXPANSION.MINIMUM, Math.min(height * EXPANSION.MULTIPLIER, maximum));
      return {
        width,
        height: expansionHeight
      };
    };
  }

  function expander({
    layoutService
  }) {
    const expansion = createExpansion({
      layoutService
    });
    const bounds = {
      width: layoutService.meta.size.x,
      height: layoutService.meta.size.y
    };
    return function expand(area) {
      const {
        width,
        height
      } = expansion({
        width: area.qWidth,
        height: area.qHeight
      });
      const vertically = height ? Math.ceil((height - area.qHeight) / 2) : 0;
      const horizontally = width ? Math.ceil((width - area.qWidth) / 2) : 0;
      const expanded = {
        qHeight: height ? Math.min(height, bounds.height) : area.qHeight,
        qWidth: width ? Math.min(width, bounds.width) : area.qWidth,
        qTop: height ? Math.max(0, Math.min(area.qTop - vertically, bounds.height - height)) : area.qTop,
        qLeft: width ? Math.max(0, Math.min(area.qLeft - horizontally, bounds.width - width)) : area.qLeft
      };
      return expanded;
    };
  }

  function fetcher({
    dataStore,
    slice,
    warden,
    expand,
    request,
    process,
    connectionless,
    processDataPage
  }) {
    const fetch = (area, {
      onProcessing
    } = {}) => {
      if (dataStore.contains(area)) {
        const stored = dataStore.getCurrent();
        if (connectionless) {
          return Promise.resolve(slice(stored, area));
        }
        const releaseCache = warden.release(stored.qArea, area);
        const isProcessing = process.isProcessing();
        if (!releaseCache && isProcessing) {
          process.cancel();
        }
        if (!releaseCache || isProcessing) {
          return Promise.resolve(slice(stored, area));
        }
      }
      if (connectionless) {
        return Promise.resolve(dataStore.getCurrent());
      }
      if (process.isProcessing() && onProcessing) {
        onProcessing();
      }
      const expanded = expand(area);
      return process(request(expanded)).then(page => {
        processDataPage(page);
        dataStore.add(page);
        return slice(page, area);
      });
    };
    return fetch;
  }

  function requestProcessor(model) {
    let ongoing;
    let queued;
    const enqueue = candidate => {
      if (queued) {
        queued.reject(REJECTION_TOKEN);
      }
      queued = candidate;
    };
    const processNext = candidate => {
      ongoing = candidate;
      const {
        method,
        args
      } = ongoing.request;
      model[method](...args).then(pages => {
        if (ongoing.canceled || queued) {
          ongoing.reject(REJECTION_TOKEN);
          ongoing = null;
          if (queued) {
            processNext(queued);
            queued = null;
          }
          return;
        }
        ongoing.resolve(pages[0]);
        ongoing = null;
      });
    };
    const process = request => new Promise((resolve, reject) => {
      const candidate = {
        request,
        resolve,
        reject,
        canceled: false,
        cancel: () => {
          candidate.canceled = true;
        }
      };
      if (ongoing) {
        enqueue(candidate);
        return;
      }
      processNext(candidate);
    });
    process.isProcessing = () => !!ongoing;
    process.hasQueued = () => !!queued;
    process.cancel = () => {
      if (process.isProcessing()) {
        ongoing.cancel();
      }
      if (process.hasQueued()) {
        queued.reject(REJECTION_TOKEN);
        queued = null;
      }
    };
    return process;
  }

  const NOOP_TREND_LINE_MODEL = {
    command: {
      update: () => {}
    }
  };
  function createPageData({
    dataStore,
    composition,
    enigmaModel,
    layoutService,
    trendLineModel = NOOP_TREND_LINE_MODEL,
    definitionPath,
    processDataPage
  }) {
    const {
      slicer: slice,
      cacheWarden: createCacheWarden,
      request: createRequest
    } = composition;
    const fetcher$1 = fetcher({
      dataStore,
      slice,
      warden: createCacheWarden({
        bounds: {
          width: layoutService.meta.size.x,
          height: layoutService.meta.size.y
        }
      }),
      expand: expander({
        layoutService
      }),
      request: createRequest({
        layoutService,
        definitionPath
      }),
      process: requestProcessor(enigmaModel),
      connectionless: layoutService.meta.isSnapshot,
      processDataPage
    });
    const fetch = Ct((area, {
      onProcessing,
      onData
    }) => {
      fetcher$1(area, {
        onProcessing
      }).then(page => onData(page)).catch(e => {
        if (e !== REJECTION_TOKEN) {
          throw e;
        }
      });
    }, THROTTLING_TRESHOLD);
    return function pageData(area, {
      onProcessing = NOOP,
      onDataPage = NOOP
    } = {}) {
      fetch(area, {
        onProcessing,
        onData: page => {
          layoutService.setDataPages(page ? [page] : []);
          trendLineModel.command.update();
          onDataPage(page);
        }
      });
    };
  }

  function inTotal$3({
    layoutService
  }) {
    return layoutService.meta.size.x;
  }

  function area$4({
    layoutService
  }) {
    return {
      qTop: 0,
      qHeight: 1,
      qLeft: 0,
      qWidth: layoutService.meta.size.x
    };
  }

  function scaleRange$3({
    layoutService,
    offsets,
    items,
    viewSize
  }) {
    const {
      pixel: pixelOffset
    } = offsets;
    const domain = layoutService.getDataPages()[0];
    const start = pixelOffset / viewSize;
    const end = items.inView >= items.inTotal ? start + 1 : start + domain.qArea.qWidth / items.inView;
    return [start, end];
  }

  var dimensionless = {
    inTotal: inTotal$3,
    area: area$4,
    scaleRange: scaleRange$3
  };

  function inTotal$2({
    layoutService,
    reducedModel
  }) {
    if (layoutService.meta.isSnapshot && !layoutService.getLayoutValue('reducedHyperCube')) {
      var _reducedModel$query;
      const cube = (reducedModel === null || reducedModel === void 0 || (_reducedModel$query = reducedModel.query) === null || _reducedModel$query === void 0 ? void 0 : _reducedModel$query.getCube()) || undefined;
      if (cube) {
        return cube.qDataPages[0].qArea.qHeight;
      }
      const [page] = layoutService.getDataPages();
      if (page) {
        return page.qArea.qHeight;
      }
    }
    return layoutService.meta.size.y;
  }

  function area$3({
    layoutService,
    itemOffset,
    inView,
    areaBuffer
  }) {
    const buffer = areaBuffer === undefined ? 4 : areaBuffer;
    const qTop = Math.max(0, Math.floor(itemOffset) - buffer / 2);
    return {
      qTop,
      qHeight: Math.min(layoutService.meta.size.y - qTop, Math.max(0, Math.ceil(inView + buffer))),
      qLeft: 0,
      qWidth: layoutService.meta.size.x
    };
  }

  function scaleRange$2({
    layoutService,
    offsets,
    items,
    viewSize
  }) {
    const {
      pixel: pixelOffset
    } = offsets;
    const domain = layoutService.getDataPages()[0];
    const itemWidth = viewSize / items.inView;
    const start = (pixelOffset + domain.qArea.qTop * itemWidth) / viewSize;
    const end = items.inView >= items.inTotal ? start + 1 : start + domain.qArea.qHeight / items.inView;
    return [start, end];
  }

  var nonGrouped = {
    inTotal: inTotal$2,
    area: area$3,
    scaleRange: scaleRange$2
  };

  function getGroupSize(layoutService) {
    const {
      groupSize,
      measureCount
    } = layoutService.meta;
    return groupSize !== null && groupSize !== void 0 ? groupSize : measureCount;
  }

  function inTotal$1({
    layoutService
  }) {
    const groupSize = getGroupSize(layoutService);
    return layoutService.meta.size.y * groupSize * (1 + 1 / groupSize) - 1;
  }

  function area$2({
    layoutService,
    itemOffset,
    inView,
    areaBuffer
  }) {
    const groupSize = getGroupSize(layoutService);
    const buffer = areaBuffer === undefined ? groupSize : areaBuffer;
    const gaps = itemOffset / (groupSize + 1);
    const qTop = Math.max(0, Math.floor((itemOffset - gaps - buffer / 2) / groupSize));
    return {
      qTop,
      qHeight: Math.min(layoutService.meta.size.y - qTop, Math.max(0, Math.ceil((inView + buffer) / groupSize + 1))),
      qLeft: 0,
      qWidth: layoutService.meta.size.x
    };
  }

  function uniques(collection, comparator) {
    const set = [];
    for (let i = 0; i < collection.length; i++) {
      const value = comparator(collection[i]);
      if (set.indexOf(value) === -1) {
        set.push(value);
      }
    }
    return set.length;
  }

  function gapsInDomain(page) {
    return uniques(page.qMatrix, element => element[0].qElemNumber) - 1;
  }

  function scaleRange$1({
    layoutService,
    offsets,
    items,
    viewSize
  }) {
    const groupSize = getGroupSize(layoutService);
    const domain = layoutService.getDataPages()[0];
    const itemWidth = viewSize / items.inView;
    const {
      pixel: pixelOffset
    } = offsets;
    const gapsInDomain$1 = gapsInDomain(domain);
    const inDomain = domain.qArea.qHeight * groupSize + gapsInDomain$1;
    const start = (pixelOffset + (domain.qArea.qTop * groupSize + domain.qArea.qTop) * itemWidth) / viewSize;
    const end = items.inView >= items.inTotal ? start + 1 : start + inDomain / items.inView;
    return [start, end];
  }

  var groupedByMeasure = {
    inTotal: inTotal$1,
    area: area$2,
    scaleRange: scaleRange$1
  };

  function inTotal({
    layoutService
  }) {
    return layoutService.meta.size.y + layoutService.meta.size.dimensions[0] - 1;
  }

  const estimate = (layoutService, itemOffset) => {
    const perGroup = layoutService.meta.size.y / layoutService.meta.size.dimensions[0];
    return itemOffset / (perGroup + 1);
  };
  const precise = (matrix, itemOffset) => {
    const result = {
      successful: true,
      count: 0
    };
    let traverse = Math.abs(Math.floor(itemOffset));
    const set = [];
    for (let i = 0; i <= traverse; i++) {
      const element = matrix[i];
      if (!element) {
        result.successful = false;
        return result;
      }
      const value = matrix[i][0].qElemNumber;
      if (set.indexOf(value) === -1) {
        set.push(value);
        traverse--;
      }
    }
    result.count = set.length - 1;
    return result;
  };
  function gapsBefore(layoutService) {
    return {
      itemOffset(page, itemOffset) {
        if (page.qArea.qTop !== 0) {
          return estimate(layoutService, itemOffset);
        }
        const result = precise(page.qMatrix, itemOffset);
        return result.successful ? result.count : estimate(layoutService, itemOffset);
      },
      area(page, itemOffset, area) {
        if (page.qArea.qTop !== 0) {
          return estimate(layoutService, itemOffset);
        }
        const isolated = page.qMatrix.slice(0, area.qTop + 1);
        return uniques(isolated, element => element[0].qElemNumber) - 1;
      }
    };
  }

  function area$1({
    getDataPages,
    layoutService,
    itemOffset,
    inView
  }) {
    const gaps = gapsBefore(layoutService).itemOffset(getDataPages(), itemOffset);
    const qTop = Math.max(0, Math.floor(itemOffset - gaps));
    return {
      qTop,
      qHeight: Math.min(layoutService.meta.size.y - qTop, Math.max(0, Math.ceil(inView + 1))),
      qLeft: 0,
      qWidth: layoutService.meta.size.x
    };
  }

  function scaleRange({
    getDataPages,
    layoutService,
    offsets,
    items,
    viewSize,
    upperBound
  }) {
    const domain = layoutService.getDataPages()[0];
    const itemWidth = viewSize / items.inView;
    const {
      item: itemOffset,
      pixel: pixelOffset
    } = offsets;
    const gapsBefore$1 = gapsBefore(layoutService).area(getDataPages(), itemOffset, domain.qArea);
    const gapsInDomain$1 = gapsInDomain(domain);
    const inDomain = domain.qArea.qHeight + gapsInDomain$1;
    const start = pixelOffset === upperBound ? (items.inView - inDomain) * itemWidth / viewSize : (pixelOffset + (domain.qArea.qTop + gapsBefore$1) * itemWidth) / viewSize;
    const end = items.inView >= items.inTotal ? start + 1 : start + inDomain / items.inView;
    return [start, end];
  }

  var groupedByDimension = {
    inTotal,
    area: area$1,
    scaleRange
  };

  function compositionFactory({
    layoutService
  }) {
    const {
      isDimensionless,
      isGrouped,
      isGroupedByMeasure
    } = layoutService.meta;
    if (isDimensionless) {
      return dimensionless;
    }
    if (!isGrouped) {
      return nonGrouped;
    }
    return isGroupedByMeasure ? groupedByMeasure : groupedByDimension;
  }

  function labelsCollide({
    chart,
    isHorizontal,
    axisKey,
    renderer = {},
    isGrouped,
    itemSize,
    label
  }) {
    if (isGrouped || label !== 'auto' && label !== 'tilted') {
      return false;
    }
    const component = chart.component(axisKey);
    const {
      measureText
    } = renderer;
    if (!component || !measureText) {
      return true;
    }
    const {
      fontFamily,
      fontSize,
      tiltAngle
    } = component.settings.settings.labels;
    const {
      height
    } = measureText({
      fontFamily,
      fontSize,
      text: 'M'
    });
    if (!isHorizontal) {
      return height > itemSize;
    }
    const angle = 90 - tiltAngle;
    const radians = angle * (Math.PI / 180);
    const distance = Math.cos(radians) * itemSize;
    return height > distance;
  }

  function resolveItemsInView({
    chart,
    rect,
    dockService,
    itemWidths,
    axisKey,
    renderer,
    isGrouped,
    dimensionAxis,
    inTotal,
    isMajorLabelless,
    maxDataRows
  }) {
    const {
      DEFAULT,
      SQUEEZE,
      LABELLESS
    } = itemWidths[dockService.meta.chart.mode];
    const isHorizontal = dockService.meta.major.orientation === 'horizontal';
    const {
      axisDisplayMode = 'auto',
      maxVisibleItems = 10,
      label
    } = dimensionAxis;
    const size = isHorizontal ? rect.width : rect.height;
    const squeeze = size / inTotal >= SQUEEZE;
    switch (axisDisplayMode) {
      case 'max':
        return Math.min(inTotal, maxDataRows);
      case 'custom':
        return Math.min(maxVisibleItems, maxDataRows);
      case 'auto':
      default:
        if (isMajorLabelless) {
          return size / LABELLESS;
        }
        if (!squeeze) {
          return size / DEFAULT;
        }
        if (labelsCollide({
          chart,
          isHorizontal,
          axisKey,
          renderer,
          isGrouped,
          itemSize: SQUEEZE,
          label
        })) {
          return size / DEFAULT;
        }
        return inTotal;
    }
  }

  function viewRange({
    viewSize,
    inTotal,
    inView,
    pixelOffset
  }) {
    const totalWidth = viewSize / inView * inTotal;
    const lower = Math.abs(pixelOffset) / totalWidth;
    const upper = Math.min(1, lower + viewSize / totalWidth);
    return [lower, upper];
  }

  function invertScaleRange(scaleRange) {
    return [1 - scaleRange[1], 1 - scaleRange[0]];
  }

  function scrollerEngine({
    chart,
    getRect,
    getDataPages,
    layoutService,
    dockService,
    getItemWidths,
    axisKey,
    renderer,
    areaBuffer,
    rtl,
    reducedModel
  }) {
    const {
      inTotal: getItemsInTotal,
      area: getArea,
      scaleRange: getScaleRange
    } = compositionFactory({
      layoutService
    });
    const getViewSize = () => dockService.meta.major.orientation === 'horizontal' ? getRect().width : getRect().height;
    const getItemSize = inView => inView ? getViewSize() / inView : 0;
    const getUpperBound = (inTotal, inView) => -(inTotal - inView) * getItemSize(inView);
    return {
      getItems() {
        const dimensionAxis = layoutService.getLayoutValue('dimensionAxis');
        const inTotal = getItemsInTotal({
          layoutService,
          reducedModel
        });
        return {
          inTotal,
          inView: resolveItemsInView({
            chart,
            rect: getRect(),
            dockService,
            itemWidths: getItemWidths(),
            axisKey,
            renderer,
            isGrouped: layoutService.meta.isGrouped,
            dimensionAxis,
            inTotal,
            isMajorLabelless: dimensionAxis.show === 'none' || dimensionAxis.show === 'title',
            maxDataRows: Math.floor(MAX_CELLS / (layoutService.meta.dimensionCount + layoutService.meta.measureCount))
          })
        };
      },
      getItemSize({
        items
      }) {
        const {
          inView
        } = items;
        return getItemSize(inView);
      },
      getOffsets({
        pixelOffset,
        items
      }) {
        const {
          inTotal,
          inView
        } = items;
        const pixel = Math.min(0, Math.max(pixelOffset, getUpperBound(inTotal, inView)));
        const item = inView ? Math.abs(inView * pixel / getViewSize()) : 0;
        return {
          start: {
            pixel,
            item
          },
          end: {
            item: Math.min(item + (inView || 0), inTotal)
          }
        };
      },
      getUpperBound({
        items
      }) {
        const {
          inTotal,
          inView
        } = items;
        return getUpperBound(inTotal, inView);
      },
      getViewRange({
        pixelOffset,
        items
      }) {
        const {
          inTotal,
          inView
        } = items;
        return viewRange({
          viewSize: getViewSize(),
          inTotal,
          inView,
          pixelOffset
        });
      },
      getArea({
        itemOffset,
        items
      }) {
        return getArea({
          getDataPages,
          layoutService,
          itemOffset,
          inView: items.inView,
          areaBuffer
        });
      },
      getScaleRange({
        offsets,
        items
      }) {
        const scaleRange = getScaleRange({
          getDataPages,
          layoutService,
          offsets,
          items,
          viewSize: getViewSize(),
          upperBound: getUpperBound(items.inTotal, items.inView)
        });
        return dockService.meta.major.orientation === 'horizontal' && rtl ? invertScaleRange(scaleRange) : scaleRange;
      },
      validate: {
        offset({
          pixelOffset,
          items
        }) {
          const {
            inTotal,
            inView
          } = items;
          return pixelOffset <= 0 && pixelOffset >= getUpperBound(inTotal, inView);
        }
      },
      convert: {
        itemToPixelOffset({
          itemOffset,
          items
        }) {
          const {
            inView
          } = items;
          const offset = itemOffset * getItemSize(inView);
          return Number.isFinite(offset) ? -offset : 0;
        },
        relativeToPixelOffset({
          relativeOffset,
          items
        }) {
          const {
            inTotal,
            inView
          } = items;
          return -relativeOffset * (getItemSize(inView) * inTotal);
        }
      }
    };
  }

  function createScroller({
    chart,
    componentKey,
    state,
    dataStore,
    pageData,
    layoutService,
    dockService,
    itemWidths,
    getRect,
    axisKey,
    renderer,
    areaBuffer,
    viewState,
    rtl,
    reducedModel
  }) {
    state.set('rect', {
      width: 0,
      height: 0
    });
    state.set('itemWidths', {});
    state.set('itemSize', 0);
    state.set('items', {});
    state.set('offsets', {});
    state.set('finished', 0);
    state.set('scaleRange', [0, 1]);
    const engine = scrollerEngine({
      chart,
      getRect: () => state.get('rect'),
      getDataPages: dataStore.getCurrent,
      layoutService,
      dockService,
      getItemWidths: () => state.get('itemWidths'),
      axisKey,
      renderer,
      areaBuffer,
      rtl,
      reducedModel
    });
    const getItems = () => {
      const items = engine.getItems();
      state.set('items', items);
      return items;
    };
    const getOffsets = ({
      pixelOffset,
      items
    }) => {
      const offsets = engine.getOffsets({
        pixelOffset,
        items
      });
      state.set('offsets', offsets);
      return offsets;
    };
    const getPixelOffset = ({
      items
    }) => {
      const scrollStartPos = layoutService.getLayoutValue('scrollStartPos');
      const viewStateOffset = viewState.get('scrollOffset');
      if (viewStateOffset === undefined) {
        return scrollStartPos === 1 ? engine.getUpperBound({
          items
        }) : 0;
      }
      if (typeof viewStateOffset === 'number') {
        return engine.convert.itemToPixelOffset({
          itemOffset: viewStateOffset,
          items
        });
      }
      const {
        start,
        end
      } = viewStateOffset;
      const itemOffset = scrollStartPos === 1 && end ? end - items.inView : start;
      return engine.convert.itemToPixelOffset({
        itemOffset,
        items
      });
    };
    const isDuplicate = area => {
      const [{
        qArea: current
      }] = layoutService.getDataPages();
      return !!current && Object.keys(area).every(key => area[key] === current[key]);
    };
    const scrollTo = pixelOffset => {
      const timestamp = Date.now();
      const items = getItems();
      const offsets = getOffsets({
        pixelOffset,
        items
      });
      const area = engine.getArea({
        itemOffset: offsets.start.item,
        items
      });
      if (isDuplicate(area)) {
        if (engine.validate.offset({
          pixelOffset,
          items
        }) || viewState.get('scrollOffset').start !== offsets.start.item) {
          state.set('finished', timestamp);
          state.set('scaleRange', engine.getScaleRange({
            offsets: offsets.start,
            items
          }));
          viewState.preventSet('viewRange', engine.getViewRange({
            pixelOffset: offsets.start.pixel,
            items
          }));
          viewState.set('scrollOffset', {
            start: offsets.start.item,
            end: offsets.end.item
          });
        }
        return;
      }
      viewState.preventSet('viewRange', engine.getViewRange({
        pixelOffset: offsets.start.pixel,
        items
      }));
      const onUpdate = () => {
        if (state.get('finished') > timestamp) {
          return;
        }
        state.set('finished', timestamp);
        state.set('scaleRange', engine.getScaleRange({
          offsets: offsets.start,
          items
        }));
        viewState.set('scrollOffset', {
          start: offsets.start.item,
          end: offsets.end.item
        });
      };
      pageData(area, {
        onProcessing: onUpdate,
        onDataPage: onUpdate
      });
    };
    return {
      enabled() {
        const {
          inTotal,
          inView
        } = state.get('items');
        return inTotal > inView;
      },
      itemSize() {
        return state.get('itemSize');
      },
      scaleRange() {
        return state.get('scaleRange');
      },
      initialize() {
        const component = chart.component(componentKey);
        if (!component) {
          return Promise.resolve();
        }
        state.set('rect', typeof getRect === 'function' ? getRect() : component.rect);
        state.set('itemWidths', typeof itemWidths === 'function' ? itemWidths() : itemWidths);
        const items = getItems();
        state.set('itemSize', engine.getItemSize({
          items
        }));
        const pixelOffset = getPixelOffset({
          items
        });
        const offsets = getOffsets({
          pixelOffset,
          items
        });
        viewState.preventSet('viewRange', engine.getViewRange({
          pixelOffset: offsets.start.pixel,
          items
        }));
        const area = engine.getArea({
          itemOffset: offsets.start.item,
          items
        });
        return new Promise(resolve => {
          pageData(area, {
            onDataPage: () => {
              state.set('scaleRange', engine.getScaleRange({
                offsets: offsets.start,
                items
              }));
              viewState.preventSet('scrollOffset', {
                start: offsets.start.item,
                end: offsets.end.item
              });
              resolve();
            }
          });
        });
      },
      scroll(pixelDelta) {
        const offsets = state.get('offsets');
        const offset = offsets.start.pixel + pixelDelta;
        scrollTo(offset);
      },
      scrollToRelative(relativeOffset) {
        const items = state.get('items');
        const offset = engine.convert.relativeToPixelOffset({
          relativeOffset,
          items
        });
        scrollTo(offset);
      }
    };
  }

  function createSetSnapshotData({
    layoutService,
    dataStore
  }) {
    return function setSnapshotData(layout) {
      const pages = bt(layout, `${layoutService.refs.dataPages}`);
      pages.length = 0;
      pages.push(dataStore.getCurrent());
    };
  }

  function normalizeBuffer({
    buffer
  }) {
    return buffer === undefined ? undefined : 2 * Math.round(buffer / 2);
  }

  function prepareData({
    layoutService,
    dataStore,
    composition
  }) {
    const page = layoutService.getDataPages()[0];
    if (!page) {
      return;
    }
    const patch = composition.patcher({
      layoutService
    });
    if (patch.should(page)) {
      patch(page);
    }
    dataStore.add(page);
  }

  function create({
    chart,
    actions,
    componentKey,
    enigmaModel,
    layoutService,
    dockService,
    trendLineModel,
    reducedModel,
    itemWidths,
    viewState,
    rtl,
    options: {
      definitionPath = '/qHyperCubeDef',
      getRect = undefined,
      axisKey = undefined,
      renderer = undefined,
      areaBuffer = undefined,
      processDataPage = () => {}
    } = {}
  }) {
    const state = wt();
    const composition = compositionFactory$1({
      qMode: layoutService.getHyperCubeValue('qMode')
    });
    const dataStore = createDataStore({
      state,
      contains: composition.contains
    });
    prepareData({
      layoutService,
      dataStore,
      composition
    });
    const buffer = normalizeBuffer({
      buffer: areaBuffer
    });
    const pageData = createPageData({
      dataStore,
      composition,
      enigmaModel,
      layoutService,
      trendLineModel,
      definitionPath,
      processDataPage
    });
    const scroller = createScroller({
      chart,
      componentKey,
      state,
      dataStore,
      pageData,
      layoutService,
      dockService,
      itemWidths,
      getRect,
      axisKey,
      renderer,
      areaBuffer: buffer,
      viewState,
      rtl,
      reducedModel
    });
    const setSnapshotData = createSetSnapshotData({
      layoutService,
      dataStore
    });
    const interactions = createInteractions$1({
      chart,
      actions,
      componentKey,
      dockService,
      rtl,
      scroller
    });
    return {
      interactions,
      query: {
        getCanScroll: () => scroller.enabled(),
        getItemSize: () => scroller.itemSize(),
        getScaleRange: () => scroller.scaleRange(),
        getCurrentDataPage: () => dataStore.getCurrent()
      },
      command: {
        initialize: () => scroller.initialize(),
        scrollTo: relative => scroller.scrollToRelative(relative),
        setSnapshotData: layout => setSnapshotData(layout)
      }
    };
  }

  const getNumPoints = layoutService => {
    const {
      measureCount
    } = layoutService.meta;
    const tempPages = layoutService.getDataPages();
    const {
      qMatrix
    } = (tempPages === null || tempPages === void 0 ? void 0 : tempPages[0]) || {};
    const numPoints = ((qMatrix === null || qMatrix === void 0 ? void 0 : qMatrix.length) || 0) * measureCount;
    return numPoints;
  };

  /* eslint-disable no-unused-expressions */
  /* eslint-disable no-param-reassign */
  function createChartModel({
    picasso,
    chart,
    localeInfo,
    continuousModel,
    layoutService,
    reducedModel,
    legendModel,
    fieldModel,
    trendLineModel,
    colorService,
    largeDataService,
    progressiveRendering,
    options,
    flags,
    viewCache
  }) {
    const {
      POINT,
      LINE,
      BRUSH_HIGHLIGHTER,
      REDUCED_LINE
    } = KEYS.COMPONENT;
    const {
      exclude,
      resetProgressive,
      shouldUseProgressive,
      renderProgressive,
      setReducedCube
    } = largeDataService;
    const state = {
      isUpdateDataless: false,
      isUsingLegendCube: false,
      isUsingLabelSpace: false,
      isSizeChanging: false,
      isPartialUpdating: false
    };
    const {
      isContinuous,
      isStacked
    } = layoutService.meta;
    const {
      virtuals: virtualFields
    } = fieldModel;
    const EMPTY = [];
    const storage = {
      main: EMPTY,
      reduced: EMPTY,
      legend: EMPTY,
      dataset: picasso.data('q')({
        key: KEYS.DATA.MAIN,
        data: layoutService.getHyperCube(),
        config: {
          localeInfo,
          virtualFields
        }
      })
    };
    function extractDataPages() {
      storage.main = layoutService.getDataPages();
      layoutService.setDataPages([]);
    }
    function insertDataPages() {
      layoutService.setDataPages(storage.main);
      storage.main = EMPTY;
    }
    const animationsEnabled = () => {
      const minOobsComponent = chart.component(KEYS.COMPONENT.OUT_OF_MIN_BOUNDS);
      const hasVisibleMinOobs = minOobsComponent && minOobsComponent.show();
      if (options.chartAnimations !== true || !flags.isEnabled('IM_1355_ANIMATIONS_LINE') || getNumPoints(layoutService) > NUMBERS$1.LARGE_NUM_POINTS_ANIMATIONS || state.isSizeChanging || state.isPartialUpdating || viewCache.get('hasHiddenMinOobs') && hasVisibleMinOobs || animations.propertiesHaveChanged({
        viewCache,
        layout: layoutService.getLayout()
      })) {
        return false;
      }
      return true;
    };
    return {
      query: {
        getDataset: () => storage.dataset,
        getIsUpdateDataless: () => state.isUpdateDataless,
        getIsUsingLegendCube: () => state.isUsingLegendCube,
        getIsUsingLabelSpace: () => state.isUsingLabelSpace,
        animationsEnabled
      },
      command: {
        initialize: () => {
          state.isUsingLegendCube = !!(!isContinuous && (isStacked || reducedModel.query.getIsReduced()) && legendModel.query.getHasCube());
        },
        update: () => {
          resetProgressive();
          chart.layoutComponents();
          if (shouldUseProgressive()) {
            return new Promise(resolve => renderProgressive(resolve));
          }
          chart.update();
          progressiveRendering.setInProgressive(false);
          return Promise.resolve();
        },
        updateDataless: ({
          settings
        }) => {
          resetProgressive();
          exclude.duringMainProgressive = settings.components.map(c => c.key).filter(k => k !== POINT && k !== LINE);
          exclude.duringReducedLineProgressive = settings.components.map(c => c.key).filter(k => k !== REDUCED_LINE);
          exclude.forClearProgressive = settings.components.map(c => c.key).filter(k => k !== POINT && k !== LINE && k !== REDUCED_LINE);
          exclude.postUpdate = settings.components.map(c => c.key).filter(k => k !== BRUSH_HIGHLIGHTER);
          exclude.all = settings.components.map(c => c.key);
          state.isUpdateDataless = true;
          const isProgressive = shouldUseProgressive(); // This should be run before extractDataPages

          extractDataPages();
          const reducedCube = isContinuous ? continuousModel.getInitialCube() : reducedModel.query.getCube();
          setReducedCube(reducedCube);
          const isSame = layoutService.getHyperCube() === reducedCube;
          if (!isSame) {
            storage.reduced = reducedCube.qDataPages;
            reducedCube.qDataPages = EMPTY;
          }
          if (state.isUsingLegendCube) {
            storage.legend = legendModel.query.getDataPages();
            legendModel.command.setDataPages([]);
          }
          const data = [{
            type: 'q',
            key: KEYS.DATA.MAIN,
            data: layoutService.getHyperCube(),
            config: {
              localeInfo,
              virtualFields
            }
          }, {
            type: 'q',
            key: KEYS.DATA.REDUCED,
            data: reducedCube,
            config: {
              localeInfo,
              virtualFields
            }
          }, ...colorService.getMain().getData()];
          if (state.isUsingLegendCube) {
            data.push({
              type: 'q',
              key: KEYS.DATA.LEGEND,
              data: legendModel.query.getCube(),
              config: {
                localeInfo,
                virtualFields
              }
            });
          }
          if (trendLineModel.query.hasTrendLines()) {
            data.push({
              key: 'trend',
              data: trendLineModel.query.getData()
            });
          }
          if (isProgressive) {
            chart.update({
              data,
              settings
            });
          } else {
            chart.layoutComponents({
              data,
              settings
            });
          }
          insertDataPages();
          if (!isSame) {
            reducedCube.qDataPages = storage.reduced;
            storage.reduced = EMPTY;
          }
          if (state.isUsingLegendCube) {
            legendModel.command.setDataPages(storage.legend);
            storage.legend = EMPTY;
          }
          state.isUpdateDataless = false;
        },
        updatePartial: () => {
          resetProgressive(true);
          if (shouldUseProgressive()) {
            return new Promise(resolve => renderProgressive(resolve, true));
          }
          state.isPartialUpdating = true;
          chart.update({
            partialData: true,
            excludeFromUpdate: exclude.partialUpdate
          });
          state.isPartialUpdating = false;
          progressiveRendering.setInProgressive(false);
          return Promise.resolve();
        },
        setUseLabelSpace: value => {
          state.isUsingLabelSpace = value;
        },
        setState: (property, value) => {
          state[property] = value;
        }
      }
    };
  }

  const hasBase = i => i.baseColor || i.coloring && i.coloring.baseColor;
  function auto({
    layout
  }) {
    if (layout.qHyperCube.qDimensionInfo.length > 1) {
      return {
        mode: 'byDimension',
        useDimColVal: true,
        useBaseColors: 'dimension',
        byDimDef: {
          activeDimensionIndex: 1
        }
      };
    }
    if (layout.qHyperCube.qMeasureInfo.length > 1) {
      return {
        mode: 'primary',
        useBaseColors: 'measure',
        paletteColor: null
      };
    }
    const hasDimensionBase = layout.qHyperCube.qDimensionInfo.some(hasBase);
    const hasMeasureBase = layout.qHyperCube.qMeasureInfo.some(hasBase);
    return {
      mode: 'primary',
      useBaseColors: hasDimensionBase ? 'dimension' : hasMeasureBase ? 'measure' : 'off',
      // eslint-disable-line
      paletteColor: null
    };
  }

  function createColorService({
    app,
    model,
    translator,
    picasso,
    localeInfo,
    theme,
    continuousModel,
    layoutService,
    reducedModel,
    legendModel
  }) {
    const {
      isContinuous,
      isStacked
    } = layoutService.meta;
    const state = {
      main: undefined,
      reduced: undefined
    };
    return {
      isInitialized: () => !!(state.main && state.main.isInitialized()),
      initialize: () => {
        const isReduced = reducedModel.query.getIsReduced();
        const useMain = isContinuous || isStacked || isReduced;
        const useLegend = !isContinuous && legendModel.query.getHasCube();
        const mainCube = useLegend ? legendModel.query.getCube() : layoutService.getHyperCube();
        const mainSource = useLegend ? KEYS.DATA.LEGEND : undefined;
        state.main = ut({
          app,
          model,
          translator,
          picasso,
          layoutService,
          config: {
            localeInfo,
            auto,
            key: KEYS.SCALE.MAIN.COLOR
          },
          createConfig: () => ({
            hc: useMain ? mainCube : reducedModel.query.getCube(),
            source: useMain ? mainSource : KEYS.DATA.REDUCED,
            theme
          })
        });
        const queries = [state.main.initialize()];
        if (isContinuous) {
          const continuousLayout = continuousModel.getInitialLayout();
          state.reduced = ut({
            app,
            model,
            translator,
            picasso,
            layoutService,
            config: {
              localeInfo,
              auto,
              key: KEYS.SCALE.REDUCED.COLOR
            },
            createConfig: ({
              getUseBaseColors
            }) => ({
              layout: continuousLayout,
              hc: continuousModel.getInitialCube(),
              colorProps: {
                ...continuousLayout.color,
                useBaseColors: getUseBaseColors(continuousLayout)
              },
              source: KEYS.DATA.REDUCED,
              theme
            })
          });
          queries.push(state.reduced.initialize());
        }
        return Promise.all(queries);
      },
      getMain: () => state.main,
      getReduced: () => state.reduced
    };
  }

  function interpolate$3({
    dataPage
  }) {
    const {
      qMatrix
    } = dataPage;
    const groups = qMatrix.reduce((grouped, item, index) => {
      for (let i = 1; i < item.length; i++) {
        if (index === 0) {
          // eslint-disable-next-line no-param-reassign
          grouped[i] = [];
        }
        grouped[i].push(item[i]);
      }
      return grouped;
    }, {});
    const isNull = node => node.qNum === 'NaN';
    Object.keys(groups).forEach(key => {
      const group = groups[key];
      const sections = [{
        startValue: NaN,
        endValue: NaN,
        nodes: []
      }];
      for (let i = 0; i < group.length; i++) {
        const node = group[i];
        const isFirst = i === 0;
        const section = sections[sections.length - 1];
        if (isNull(node)) {
          if (!isFirst && (!section.nodes.length || Number.isNaN(section.startValue))) {
            const previousNode = group[i - 1];
            section.startValue = previousNode.qIsNull ? NaN : previousNode.qNum;
          }
          sections[sections.length - 1].nodes.push(node);
        } else if (section.nodes.length) {
          section.endValue = isNull(node) ? NaN : node.qNum;
          sections.push({
            startValue: NaN,
            endValue: NaN,
            nodes: []
          });
        }
      }
      sections.forEach(section => {
        if (!Number.isNaN(section.startValue) && !Number.isNaN(section.endValue)) {
          const difference = section.endValue - section.startValue;
          const step = difference / (section.nodes.length + 1);
          for (let i = 0; i < section.nodes.length; i++) {
            const interpolated = section.startValue + step * (i + 1);
            const node = section.nodes[i];
            node.interpolated = true;
            node.qText = `${interpolated}`;
            node.qNum = interpolated;
            delete node.qIsNull;
          }
        }
      });
    });
  }

  function createOneDimensionalDiscreteProcessor({
    layoutService
  }) {
    const {
      isStacked,
      isConnect
    } = layoutService.meta;
    const shouldInterpolate = () => isStacked && isConnect;
    return {
      shouldProcess: () => shouldInterpolate(),
      shouldProcessInitialPage: () => shouldInterpolate(),
      getFilteredDataPage: ({
        dataPage
      }) => dataPage,
      processDataPage: ({
        dataPage
      }) => interpolate$3({
        dataPage
      })
    };
  }

  /* eslint-disable no-param-reassign */
  /* eslint-disable no-return-assign */
  function createNode$1(id) {
    return {
      id,
      parents: [],
      children: [],
      parentsDict: {},
      childrenDict: {}
    };
  }
  function buildLinkedNodes(sortedArrays) {
    const nodesDict = {};
    const linkedNodes = [];
    function createLink(parent, child) {
      if (!nodesDict[parent]) {
        nodesDict[parent] = createNode$1(parent);
        linkedNodes.push(nodesDict[parent]);
      }
      if (child !== undefined) {
        if (!nodesDict[child]) {
          nodesDict[child] = createNode$1(child);
          linkedNodes.push(nodesDict[child]);
        }
        if (!nodesDict[parent].childrenDict[nodesDict[child].id]) {
          nodesDict[parent].children.push(nodesDict[child]);
          nodesDict[parent].childrenDict[nodesDict[child].id] = true;
        }
        if (!nodesDict[child].parentsDict[nodesDict[parent].id]) {
          nodesDict[child].parents.push(nodesDict[parent]);
          nodesDict[child].parentsDict[nodesDict[parent].id] = true;
        }
      }
    }
    sortedArrays.forEach(array => {
      for (let i = 0; i < array.length - 1; i++) {
        createLink(array[i], array[i + 1]);
      }
      createLink(array[array.length - 1]);
    });
    return linkedNodes;
  }
  function findRootNodes(nodes) {
    return nodes.filter(node => node.parents.length === 0);
  }
  function assignRank(nodes, rank) {
    nodes.forEach(node => node.rank = rank);
  }
  function findChildren(nodes) {
    const children = [];
    const childrenDict = {};
    nodes.forEach(node => {
      node.children.forEach(child => {
        if (!childrenDict[child.id]) {
          children.push(child);
          childrenDict[child.id] = true;
        }
      });
    });
    return children;
  }
  function getGroupsOfRanks(nodes) {
    const groups = [];
    nodes.forEach(node => {
      const {
        rank
      } = node;
      if (groups[rank] === undefined) {
        groups[rank] = [];
      }
      groups[rank].push(node.id);
    });
    return groups;
  }
  function merge(sortedArrays) {
    const linkedNodes = buildLinkedNodes(sortedArrays);
    let nodes = findRootNodes(linkedNodes);
    let rank = 0;
    while (nodes.length) {
      assignRank(nodes, rank);
      rank++;
      nodes = findChildren(nodes);
    }
    const groups = getGroupsOfRanks(linkedNodes);
    const result = [];
    groups.forEach(group => {
      result.push(...group);
    });
    return result;
  }

  function getOrder({
    dataPage
  }) {
    const {
      qSubNodes
    } = dataPage.qData[0];
    const items = {};
    for (let i = 0; i < qSubNodes.length; i++) {
      const nodes = qSubNodes[i].qSubNodes;
      for (let j = 0; j < nodes.length; j++) {
        const currentId = nodes[j].qElemNo;
        if (!items[currentId]) {
          items[currentId] = {
            id: currentId,
            text: nodes[j].qText
          };
          if (nodes[j].qAttrDims) {
            items[currentId].qAttrDims = nodes[j].qAttrDims;
          }
        }
      }
    }
    const sorted = qSubNodes.map(nodes => {
      return nodes.qSubNodes.map(node => node.qElemNo);
    });
    const merged = merge(sorted);
    return merged.map(id => items[id]);
  }

  function createNode({
    qElemNo,
    qText,
    qAttrDims,
    referenceNode
  }) {
    const [referenceInnerNode] = referenceNode.qSubNodes;
    const node = {
      qElemNo,
      qText,
      qRow: referenceNode.qRow,
      qType: 'N',
      qValue: 'NaN',
      qUp: 0,
      qDown: 0,
      qMaxPos: 'NaN',
      qMinNeg: 0,
      qSubNodes: [{
        qElemNo: 0,
        qText: '-',
        qRow: referenceInnerNode.qRow,
        qType: 'U',
        qValue: 'NaN',
        qUp: 0,
        qDown: 0,
        qMaxPos: 0,
        qMinNeg: 0,
        qSubNodes: []
      }]
    };
    if (qAttrDims) {
      node.qAttrDims = qAttrDims;
    }
    if (referenceInnerNode.qAttrExps) {
      node.qSubNodes[0].qAttrExps = {
        qValues: [{
          qNum: 'NaN'
        }]
      };
    }
    return node;
  }

  function inject$1({
    dataPage
  }) {
    var _dataPage$qData, _dataPage$qMatrix;
    if (!(dataPage !== null && dataPage !== void 0 && (_dataPage$qData = dataPage.qData) !== null && _dataPage$qData !== void 0 && _dataPage$qData.length) && !(dataPage !== null && dataPage !== void 0 && (_dataPage$qMatrix = dataPage.qMatrix) !== null && _dataPage$qMatrix !== void 0 && _dataPage$qMatrix.length)) {
      return;
    }
    const order = getOrder({
      dataPage
    });
    dataPage.qData[0].qSubNodes.forEach(node => {
      if (node.qSubNodes.length === order.length) {
        return;
      }
      const referenceNode = node.qSubNodes[0];
      for (let i = 0; i < order.length; i++) {
        if (!node.qSubNodes[i] || node.qSubNodes[i].qElemNo !== order[i].id) {
          node.qSubNodes.splice(i, 0, createNode({
            qElemNo: order[i].id,
            qText: order[i].text,
            qAttrDims: order[i].qAttrDims,
            referenceNode
          }));
        }
      }
    });
  }

  function interpolate$2({
    dataPage
  }) {
    const order = getOrder({
      dataPage
    });
    const outerSections = order.map(() => [{
      startValue: NaN,
      endValue: NaN,
      nodes: []
    }]);
    const {
      qSubNodes: outerQSubNodes
    } = dataPage.qData[0];
    const isNull = node => node.qValue === 'NaN';
    outerQSubNodes.forEach((subNode, bucket) => {
      for (let i = 0; i < order.length; i++) {
        const {
          qSubNodes
        } = subNode;
        if (!qSubNodes[i] || qSubNodes[i].qElemNo !== order[i].id) {
          const referenceNode = qSubNodes[0];
          const created = createNode({
            qElemNo: order[i].id,
            qText: order[i].text,
            qAttrDims: order[i].qAttrDims,
            referenceNode
          });
          qSubNodes.splice(i, 0, created);
        }
        const node = qSubNodes[i];
        const section = outerSections[i][outerSections[i].length - 1];
        const isFirst = bucket === 0;
        if (isNull(node.qSubNodes[0])) {
          if (!isFirst && (!section.nodes.length || Number.isNaN(section.startValue))) {
            const previous = outerQSubNodes[bucket - 1].qSubNodes[i];
            section.startValue = isNull(previous.qSubNodes[0]) ? NaN : previous.qSubNodes[0].qValue;
          }
          section.nodes.push(node);
        } else if (section.nodes.length) {
          section.endValue = isNull(node.qSubNodes[0]) ? NaN : node.qSubNodes[0].qValue;
          outerSections[i].push({
            startValue: NaN,
            endValue: NaN,
            nodes: []
          });
        }
      }
    });
    outerSections.forEach(outerSection => {
      outerSection.forEach(section => {
        if (!Number.isNaN(section.startValue) && !Number.isNaN(section.endValue)) {
          const difference = section.endValue - section.startValue;
          const step = difference / (section.nodes.length + 1);
          for (let i = 0; i < section.nodes.length; i++) {
            const interpolated = section.startValue + step * (i + 1);
            const m = section.nodes[i];
            m[interpolated < 0 ? 'qMinNeg' : 'qMaxPos'] = interpolated;
            const sub = m.qSubNodes[0];
            sub.qType = 'V';
            sub.qText = `${interpolated}`;
            sub.qValue = interpolated;
            sub.interpolated = true;
          }
        }
      });
    });
  }

  function createTwoDimensionalDiscreteProcessor({
    layoutService
  }) {
    const {
      isZero,
      isStacked,
      isConnect
    } = layoutService.meta;
    const shouldProcess = () => isZero || isStacked && isConnect;
    const process = ({
      dataPage
    }) => {
      var _dataPage$qData;
      if (!(dataPage !== null && dataPage !== void 0 && (_dataPage$qData = dataPage.qData) !== null && _dataPage$qData !== void 0 && _dataPage$qData.length)) {
        return;
      }
      if (isZero) {
        inject$1({
          dataPage
        });
      } else if (isStacked && isConnect) {
        interpolate$2({
          dataPage
        });
      }
    };
    return {
      shouldProcess: () => shouldProcess(),
      shouldProcessInitialPage: () => shouldProcess(),
      getFilteredDataPage: ({
        dataPage
      }) => dataPage,
      processDataPage: ({
        dataPage
      }) => process({
        dataPage
      })
    };
  }

  function createDiscreteProcessor({
    layoutService
  }) {
    const create = layoutService.meta.isOneDimensional ? createOneDimensionalDiscreteProcessor : createTwoDimensionalDiscreteProcessor;
    return create({
      layoutService
    });
  }

  function interpolate$1({
    dataPage
  }) {
    const {
      qMatrix
    } = dataPage;
    const groups = qMatrix.reduce((grouped, item, index) => {
      for (let i = 1; i < item.length; i++) {
        if (index === 0) {
          // eslint-disable-next-line no-param-reassign
          grouped[i] = [];
        }
        grouped[i].push({
          node: item[i],
          num: item[0].qNum
        });
      }
      return grouped;
    }, {});
    const isNull = node => {
      return node.qNum === 'NaN';
    };
    Object.keys(groups).forEach(key => {
      const group = groups[key];
      const sections = [{
        startValue: NaN,
        startNum: NaN,
        endValue: NaN,
        endNum: NaN,
        nodes: []
      }];
      for (let i = 0; i < group.length; i++) {
        const {
          node
        } = group[i];
        const isFirst = i === 0;
        const section = sections[sections.length - 1];
        if (isNull(node)) {
          if (!isFirst && (!section.nodes.length || Number.isNaN(section.startValue))) {
            const previousNode = group[i - 1].node;
            section.startValue = isNull(previousNode) ? NaN : previousNode.qNum;
            section.startNum = isNull(previousNode) ? NaN : group[i - 1].num;
          }
          sections[sections.length - 1].nodes.push(group[i]);
        } else if (section.nodes.length) {
          section.endValue = isNull(node) ? NaN : node.qNum;
          section.endNum = isNull(node) ? NaN : group[i].num;
          sections.push({
            startValue: NaN,
            startNum: NaN,
            endValue: NaN,
            endNum: NaN,
            nodes: []
          });
        }
      }
      sections.forEach(section => {
        if (!Number.isNaN(section.startValue) && !Number.isNaN(section.endValue)) {
          const valueDifference = section.endValue - section.startValue;
          const numDifference = section.endNum - section.startNum;
          for (let i = 0; i < section.nodes.length; i++) {
            const position = (section.nodes[i].num - section.startNum) / numDifference;
            const value = position * valueDifference + section.startValue;
            const {
              node
            } = section.nodes[i];
            node.qText = `${value}`;
            node.qNum = value;
            node.interpolated = true;
          }
        }
      });
    });
  }

  function createOneDimensionalContinuousProcessor({
    layoutService
  }) {
    const {
      isStacked,
      isConnect
    } = layoutService.meta;
    const shouldInterpolate = () => isStacked && isConnect;
    return {
      shouldProcess: () => shouldInterpolate(),
      shouldProcessInitialPage: () => false,
      getFilteredDataPage: ({
        dataPage
      }) => dataPage,
      processDataPage: ({
        dataPage
      }) => interpolate$1({
        dataPage
      })
    };
  }

  /* eslint-disable no-param-reassign */
  function inject({
    dataPage,
    layoutService
  }) {
    var _layoutService$meta;
    const {
      dimensions
    } = (layoutService === null || layoutService === void 0 || (_layoutService$meta = layoutService.meta) === null || _layoutService$meta === void 0 ? void 0 : _layoutService$meta.size) || {};
    if ((dimensions === null || dimensions === void 0 ? void 0 : dimensions.length) === 2 && dataPage.qMatrix.length >= dimensions[0] * dimensions[1]) {
      return;
    }
    const {
      qMatrix
    } = dataPage;
    const dim0 = {
      rows: [],
      headers: [],
      dictionary: {}
    };
    const dim1 = {
      headers: [],
      dictionary: {}
    };
    qMatrix.forEach(point => {
      const id0 = point[0].qElemNumber;
      const id1 = point[1].qElemNumber;
      if (dim0.dictionary[id0] === undefined) {
        dim0.rows.push([]);
        dim0.headers.push(point[0]);
        dim0.dictionary[id0] = {
          index: dim0.headers.length - 1,
          hasAttrExps: false
        };
      }
      const id0Row = dim0.rows[dim0.dictionary[id0].index];
      if (dim1.dictionary[id1] === undefined) {
        dim1.headers.push(point[1]);
        dim1.dictionary[id1] = dim1.headers.length - 1;
      }
      id0Row[dim1.dictionary[id1]] = point;
      dim0.dictionary[id0].hasAttrExps = dim0.dictionary[id0].hasAttrExps || !!point[2].qAttrExps;
    });
    const dim0Len = dim0.headers.length;
    const dim1Len = dim1.headers.length;
    if (qMatrix.length >= dim0Len * dim1Len) {
      return;
    }
    dim1.sortedHeaders = [...dim1.headers];
    dim1.sortedHeaders.sort((a, b) => a.qElemNumber - b.qElemNumber);
    let count = 0;
    for (let rowIdx = 0; rowIdx < dim0Len; rowIdx++) {
      const header0 = dim0.headers[rowIdx];
      const row = dim0.rows[rowIdx];
      const id0 = header0.qElemNumber;
      const {
        hasAttrExps
      } = dim0.dictionary[id0];
      for (let k = 0; k < dim1Len; k++) {
        const header1 = dim1.sortedHeaders[k];
        const id1 = header1.qElemNumber;
        const colIdx = dim1.dictionary[id1];
        const point = row[colIdx];
        if (point) {
          qMatrix[count++] = point;
        } else {
          const item2 = {
            qText: '-',
            qNum: 'NaN',
            injected: true
          };
          if (hasAttrExps) {
            item2.qAttrExps = {
              qValues: [{
                qNum: 'NaN'
              }]
            };
          }
          qMatrix[count++] = [{
            ...header0
          }, {
            ...header1
          }, item2];
        }
      }
    }
  }

  function interpolate({
    dataPage,
    layoutService
  }) {
    inject({
      dataPage,
      layoutService
    });
    const {
      qMatrix
    } = dataPage;
    const groups = qMatrix.reduce((group, item) => {
      if (!group[item[1].qElemNumber]) {
        // eslint-disable-next-line no-param-reassign
        group[item[1].qElemNumber] = [];
      }
      group[item[1].qElemNumber].push(item);
      return group;
    }, {});
    const isNull = bucket => {
      return bucket[2].qNum === 'NaN';
    };
    Object.keys(groups).forEach(key => {
      const group = groups[key];
      const sections = [{
        startValue: NaN,
        startNum: NaN,
        endValue: NaN,
        endNum: NaN,
        nodes: []
      }];
      for (let i = 0; i < group.length; i++) {
        const bucket = group[i];
        const isFirst = i === 0;
        const section = sections[sections.length - 1];
        if (isNull(bucket)) {
          if (!isFirst && (!section.nodes.length || Number.isNaN(section.startValue))) {
            const previousBucket = group[i - 1];
            section.startValue = isNull(previousBucket) ? NaN : previousBucket[2].qNum;
            section.startNum = isNull(previousBucket) ? NaN : previousBucket[0].qNum;
          }
          sections[sections.length - 1].nodes.push(group[i]);
        } else if (section.nodes.length) {
          section.endValue = isNull(bucket) ? NaN : bucket[2].qNum;
          section.endNum = isNull(bucket) ? NaN : bucket[0].qNum;
          sections.push({
            startValue: NaN,
            startNum: NaN,
            endValue: NaN,
            endNum: NaN,
            nodes: []
          });
        }
      }
      sections.forEach(section => {
        if (!Number.isNaN(section.startValue) && !Number.isNaN(section.endValue)) {
          const valueDifference = section.endValue - section.startValue;
          const numDifference = section.endNum - section.startNum;
          for (let i = 0; i < section.nodes.length; i++) {
            const position = (section.nodes[i][0].qNum - section.startNum) / numDifference;
            const value = position * valueDifference + section.startValue;
            const node = section.nodes[i];
            node[2].qText = `${value}`;
            node[2].qNum = value;
            node[2].interpolated = true;
          }
        }
      });
    });
  }

  function eject({
    dataPage
  }) {
    var _dataPage$qMatrix;
    return {
      ...dataPage,
      qMatrix: (dataPage === null || dataPage === void 0 || (_dataPage$qMatrix = dataPage.qMatrix) === null || _dataPage$qMatrix === void 0 ? void 0 : _dataPage$qMatrix.filter(o => {
        var _o$;
        return !((_o$ = o[2]) !== null && _o$ !== void 0 && _o$.injected);
      })) || []
    };
  }

  function createTwoDimensionalContinuousProcessor({
    layoutService
  }) {
    const {
      isGap,
      isZero,
      isStacked,
      isConnect
    } = layoutService.meta;
    const shouldProcess = () => isGap || isZero || isStacked && isConnect;
    const process = ({
      dataPage
    }) => {
      if (isGap || isZero) {
        inject({
          dataPage,
          layoutService
        });
      } else if (isStacked && isConnect) {
        interpolate({
          dataPage,
          layoutService
        });
      }
    };
    return {
      shouldProcess: () => shouldProcess(),
      shouldProcessInitialPage: () => false,
      getFilteredDataPage: ({
        dataPage
      }) => eject({
        dataPage
      }),
      processDataPage: ({
        dataPage
      }) => process({
        dataPage
      })
    };
  }

  function createContinuousProcessor({
    layoutService
  }) {
    const create = layoutService.meta.isOneDimensional ? createOneDimensionalContinuousProcessor : createTwoDimensionalContinuousProcessor;
    return create({
      layoutService
    });
  }

  function createProcessor({
    layoutService
  }) {
    const create = layoutService.meta.isDiscrete ? createDiscreteProcessor : createContinuousProcessor;
    return create({
      layoutService
    });
  }

  function createDataProcessorModel({
    layoutService
  }) {
    const processor = createProcessor({
      layoutService
    });
    const state = {
      shouldProcess: processor.shouldProcess()
    };
    if (processor.shouldProcessInitialPage()) {
      const dataPages = layoutService.getDataPages();
      processor.processDataPage({
        dataPage: dataPages && dataPages.length ? dataPages[0] : []
      });
    }
    return {
      query: {
        getShouldProcess: () => state.shouldProcess,
        getFilteredDataPage: ({
          dataPage
        }) => processor.getFilteredDataPage({
          dataPage
        })
      },
      command: {
        processDataPage: ({
          dataPage
        }) => {
          if (state.shouldProcess) {
            processor.processDataPage({
              dataPage
            });
          }
        }
      }
    };
  }

  var noData = {
    key: 'NoDataExist',
    alignment: 'center',
    condition: ({
      layoutService
    }) => {
      const {
        x,
        y
      } = layoutService.meta.size;
      return x * y === 0;
    }
  };

  var nanDimension = {
    key: 'OnlyNanData',
    alignment: 'center',
    condition: ({
      layoutService
    }) => {
      const {
        isContinuous
      } = layoutService.meta;
      if (!isContinuous) {
        return false;
      }
      const dimension = layoutService.getHyperCubeValue('qDimensionInfo.0');
      return dimension && (dimension.qMax < dimension.qMin || dimension.qMax === 'NaN');
    }
  };

  function measureHasOnlyNullValues(measureInfo) {
    return measureInfo.qMin === 'NaN' && measureInfo.qMax === 'NaN';
  }
  var nanMeasures = {
    key: 'OnlyNanData',
    alignment: 'center',
    condition: ({
      layoutService
    }) => {
      const measures = layoutService.getHyperCubeValue('qMeasureInfo');
      return measures.every(measureHasOnlyNullValues);
    }
  };

  var limitedData = {
    key: 'LimitedData',
    alignment: 'bottom',
    condition: ({
      layoutService,
      largeDataService,
      flags
    }) => {
      if (layoutService.getLayout().showDisclaimer === false && flags.isEnabled('SHOW_DISCLAIMER')) {
        return false;
      }
      const {
        isTwoDimensional,
        isContinuous,
        size
      } = layoutService.meta;
      if (!isTwoDimensional) {
        return false;
      }
      if (isContinuous) {
        var _largeDataService$met;
        return size.y > ((largeDataService === null || largeDataService === void 0 || (_largeDataService$met = largeDataService.meta) === null || _largeDataService$met === void 0 ? void 0 : _largeDataService$met.maxNumPoints) || NUMBERS$1.DEFAULT_NUM_POINTS);
      }
      if (!layoutService.meta.mode.K) {
        return false;
      }
      const [page] = layoutService.getDataPages();
      const [root] = page.qData;
      return root ? root.qSubNodes.some(n => n.qDown > 0) : false;
    }
  };

  var logScaleWithZero = {
    key: 'DataRangeIncludingZero',
    alignment: 'bottom',
    condition: ({
      layoutService,
      extremumModel,
      flags
    }) => {
      if (layoutService.getLayout().showDisclaimer === false && flags.isEnabled('SHOW_DISCLAIMER')) {
        return false;
      }
      const logarithmic = layoutService.getLayoutValue('measureAxis.logarithmic', false);
      const extrema = extremumModel.query.getExtrema();
      return logarithmic && extrema.meta.includesZero;
    }
  };

  var disclaimers = [noData, nanDimension, nanMeasures, limitedData, logScaleWithZero];

  function resolveDisclaimer({
    layoutService,
    largeDataService,
    extremumModel,
    flags
  }) {
    let resolved;
    for (let i = 0; i < disclaimers.length; i++) {
      const disclaimer = disclaimers[i];
      if (disclaimer.condition({
        layoutService,
        largeDataService,
        extremumModel,
        flags
      })) {
        resolved = disclaimer;
        break;
      }
    }
    return resolved;
  }

  function createDisclaimerModel({
    layoutService,
    largeDataService,
    extremumModel,
    flags
  }) {
    const state = {
      disclaimer: undefined
    };
    return {
      query: {
        getHasSuppressingDisclaimer: () => !!(state.disclaimer && state.disclaimer.alignment === 'center'),
        getDisclaimer: () => state.disclaimer
      },
      command: {
        initialize: () => {
          state.disclaimer = resolveDisclaimer({
            layoutService,
            largeDataService,
            extremumModel,
            flags
          });
        }
      }
    };
  }

  const isNumber = v => typeof v === 'number' && !Number.isNaN(v);
  const FORECAST_IDS = ['forecast', 'forecast_lower', 'forecast_upper'];
  function addForecasts(measures) {
    return measures.concat(...measures.map(d => {
      var _d$qAttrExprInfo$filt, _d$qAttrExprInfo;
      return (_d$qAttrExprInfo$filt = (_d$qAttrExprInfo = d.qAttrExprInfo) === null || _d$qAttrExprInfo === void 0 ? void 0 : _d$qAttrExprInfo.filter(e => FORECAST_IDS.indexOf(e.id) !== -1)) !== null && _d$qAttrExprInfo$filt !== void 0 ? _d$qAttrExprInfo$filt : [];
    }));
  }
  function createNonStackedExtractor({
    layoutService
  }) {
    return function extract() {
      let measures = layoutService.getHyperCubeValue('qMeasureInfo');
      measures = addForecasts(measures);
      return {
        min: Math.min(...measures.filter(m => isNumber(m.qMin)).map(m => m.qMin)),
        max: Math.max(...measures.filter(m => isNumber(m.qMax)).map(m => m.qMax))
      };
    };
  }

  function createStackedExtractor() {
    return function extract({
      dataPage,
      count
    }) {
      const {
        qMatrix: matrix
      } = dataPage;
      const extrema = {
        min: NaN,
        max: NaN
      };
      matrix.forEach(row => {
        let rowMin = 0;
        let rowMax = 0;
        row.slice(-count).forEach(cell => {
          if (cell.qNum !== 'NaN') {
            if (cell.qNum >= 0) {
              rowMax += cell.qNum;
            } else {
              rowMin += cell.qNum;
            }
          }
        });
        extrema.min = Number.isNaN(extrema.min) ? rowMin : Math.min(rowMin, extrema.min);
        extrema.max = Number.isNaN(extrema.max) ? rowMax : Math.max(rowMax, extrema.max);
      });
      return extrema;
    };
  }

  function createStacked() {
    return function extract({
      dataPage,
      count
    }) {
      const extrema = {
        min: NaN,
        max: NaN
      };
      if (dataPage.qData) {
        const {
          qData
        } = dataPage;
        extrema.min = Math.min(...qData[0].qSubNodes.map(node => node.qMinNeg));
        extrema.max = Math.max(...qData[0].qSubNodes.map(node => node.qMaxPos));
        return extrema;
      }
      const {
        qMatrix: matrix
      } = dataPage;
      const groups = {};
      matrix.forEach(row => {
        const key = row[0].qElemNumber;
        if (!groups[key]) {
          groups[key] = {
            key,
            min: 0,
            max: 0
          };
        }
        row.slice(count).forEach(cell => {
          if (cell.qNum !== 'NaN') {
            if (cell.qNum >= 0) {
              groups[key].max += cell.qNum;
            } else {
              groups[key].min += cell.qNum;
            }
          }
        });
      });
      Object.keys(groups).forEach(key => {
        extrema.min = Number.isNaN(extrema.min) ? groups[key].min : Math.min(groups[key].min, extrema.min);
        extrema.max = Number.isNaN(extrema.max) ? groups[key].max : Math.max(groups[key].max, extrema.max);
      });
      return extrema;
    };
  }

  function createExtractor({
    layoutService
  }) {
    const {
      isStacked,
      isOneDimensional
    } = layoutService.meta;
    if (!isStacked) {
      return createNonStackedExtractor({
        layoutService
      });
    }
    return isOneDimensional ? createStackedExtractor() : createStacked();
  }

  function resolveExplicits({
    layoutService
  }) {
    const explicits = {
      min: NaN,
      max: NaN
    };
    const {
      getLayoutValue
    } = layoutService;
    if (getLayoutValue('measureAxis.autoMinMax', false)) {
      return explicits;
    }
    const minMax = getLayoutValue('measureAxis.minMax');
    if (minMax === 'min' || minMax === 'minMax') {
      explicits.min = +getLayoutValue('measureAxis.min');
    }
    if (minMax === 'max' || minMax === 'minMax') {
      explicits.max = +getLayoutValue('measureAxis.max');
    }
    return explicits;
  }

  async function resolveData({
    layoutService,
    reducedModel,
    continuousModel
  }) {
    const {
      isDiscrete,
      isStacked,
      measureCount,
      dimensionCount,
      hasMultipleDimensions
    } = layoutService.meta;
    if (isDiscrete) {
      const cube = reducedModel.query.getCube();
      if (!cube.qDataPages.length) {
        return {
          dataPage: cube.qStackedDataPages[0]
        };
      }
      return {
        dataPage: cube.qDataPages[0],
        count: measureCount
      };
    }
    const [dataPage] = await continuousModel.fetchMinMaxData();
    return {
      dataPage,
      count: isStacked && hasMultipleDimensions ? dimensionCount : measureCount
    };
  }

  function createExtremumModel({
    layoutService,
    reducedModel,
    continuousModel,
    trendLineModel
  }) {
    const extrema = {
      min: NaN,
      max: NaN,
      implicit: {
        min: NaN,
        max: NaN
      },
      explicit: {
        min: NaN,
        max: NaN
      },
      meta: {
        hasExplicit: false,
        hasExplicitMin: false,
        hasExplicitMax: false,
        includesZero: false
      }
    };
    const {
      isArea
    } = layoutService.meta;
    const logarithmic = layoutService.getLayoutValue('measureAxis.logarithmic', false);
    const extract = createExtractor({
      layoutService
    });
    return {
      query: {
        getExtrema: () => extrema
      },
      command: {
        initialize: () => {
          const {
            min: explicitMin,
            max: explicitMax
          } = resolveExplicits({
            layoutService
          });
          extrema.explicit.min = explicitMin;
          extrema.explicit.max = explicitMax;
          extrema.meta.hasExplicitMin = !Number.isNaN(explicitMin);
          extrema.meta.hasExplicitMax = !Number.isNaN(explicitMax);
          extrema.meta.hasExplicit = extrema.meta.hasExplicitMin || extrema.meta.hasExplicitMax;
          return resolveData({
            layoutService,
            reducedModel,
            continuousModel
          }).then(({
            dataPage,
            count
          }) => {
            const {
              min: extractedMin,
              max: extractedMax
            } = extract({
              dataPage,
              count
            });
            let dataMin = Number((Number.isFinite(extractedMin) ? extractedMin : 0).toFixed(13));
            let dataMax = Number((Number.isFinite(extractedMax) ? extractedMax : 0).toFixed(13));
            if (trendLineModel.query.hasTrendLines()) {
              const {
                min: trendLineMin,
                max: trendLineMax
              } = trendLineModel.query.getMinMax();
              dataMin = Number.isFinite(trendLineMin) ? Math.min(dataMin, trendLineMin) : dataMin;
              dataMax = Number.isFinite(trendLineMax) ? Math.max(dataMax, trendLineMax) : dataMax;
            }
            extrema.implicit.min = isArea && !logarithmic ? Math.min(0, dataMin) : dataMin;
            extrema.implicit.max = isArea && !logarithmic ? Math.max(0, dataMax) : dataMax;
            extrema.min = Number.isNaN(extrema.explicit.min) ? extrema.implicit.min : extrema.explicit.min;
            extrema.max = Number.isNaN(extrema.explicit.max) ? extrema.implicit.max : extrema.explicit.max;
            if (extrema.meta.hasExplicitMin && !extrema.meta.hasExplicitMax) {
              extrema.max = Math.max(extrema.min, extrema.max);
            }
            if (extrema.meta.hasExplicitMax && !extrema.meta.hasExplicitMin) {
              extrema.min = Math.min(extrema.min, extrema.max);
            }
            extrema.meta.includesZero = !!((0 - extrema.min) * (0 - extrema.max) <= 0);
          });
        }
      }
    };
  }

  function getForecastMeasures(qMeasureInfo) {
    const measures = [];
    qMeasureInfo.forEach((measureInfo, index) => {
      const attrIndex = measureInfo.qAttrExprInfo.findIndex(info => info.id === 'forecast');
      const lowerIndex = measureInfo.qAttrExprInfo.findIndex(info => info.id === 'forecast_lower');
      const upperIndex = measureInfo.qAttrExprInfo.findIndex(info => info.id === 'forecast_upper');
      if (attrIndex === -1) {
        return;
      }
      const item = {
        measureIndex: index,
        field: `qMeasureInfo/${index}/qAttrExprInfo/${attrIndex}`
      };
      if (lowerIndex !== -1 && upperIndex !== -1) {
        item.lower = `qMeasureInfo/${index}/qAttrExprInfo/${lowerIndex}`;
        item.upper = `qMeasureInfo/${index}/qAttrExprInfo/${upperIndex}`;
      }
      measures.push(item);
    });
    return measures;
  }

  function createFieldModel({
    layoutService
  }) {
    const {
      isOneDimensional,
      isContinuous
    } = layoutService.meta;
    const outer = 'qDimensionInfo/0';
    const outerNumeric = `${outer}:numeric`;
    const inner = `qDimensionInfo/${isOneDimensional ? 0 : 1}`;
    const measures = layoutService.getHyperCubeValue('qMeasureInfo');
    const minors = measures.map((d, i) => `qMeasureInfo/${i}`);
    const virtuals = isContinuous ? [{
      key: outerNumeric,
      from: outer,
      override: {
        value: d => d.qNum
      }
    }] : undefined;
    return {
      main: {
        outer,
        inner,
        outerNumeric,
        minors
      },
      reduced: {
        outer,
        inner,
        minors: isOneDimensional ? minors : ['qMeasureInfo/0', 'qMeasureInfo/1']
      },
      forecast: getForecastMeasures(measures),
      virtuals
    };
  }

  const createLayoutServiceMeta = isUnsupportedFeature => ({
    layout,
    meta
  }) => {
    const canBeContinuous = timeUtils.canBeContinuous(layout);
    const {
      hasMultipleDimensions,
      hasMultipleMeasures,
      dimensionCount
    } = meta;
    const isContinuous = !isUnsupportedFeature('continuousData') && isType.continuous(layout, () => timeUtils.isTime(true, layout));
    const isArea = !!(layout.lineType && layout.lineType === 'area');
    const isStacked = isArea && layout.stackedArea && (hasMultipleDimensions || hasMultipleMeasures);
    const nullMode = layout.nullMode || 'gap';
    return {
      canBeContinuous,
      isDiscrete: !isContinuous,
      isArea,
      isStacked,
      isContinuous,
      isTime: timeUtils.isTime(isContinuous, layout),
      isSnapshot: true,
      // isType.snapshot(layout),
      isOneDimensional: dimensionCount === 1,
      isTwoDimensional: dimensionCount === 2,
      isGap: nullMode === 'gap',
      isConnect: nullMode === 'connect',
      isZero: nullMode === 'zero'
    };
  };

  function createLegendModel({
    layoutService
  }) {
    const state = {
      layoutService: undefined
    };
    const {
      isDiscrete,
      hasMultipleDimensions
    } = layoutService.meta;
    const color = layoutService.getLayoutValue('color', {});
    const colorByDataDimension = color.auto ? hasMultipleDimensions : color.mode === 'byDimension' && color.byDimDef && color.byDimDef.activeDimensionIndex > -1;
    if (isDiscrete && colorByDataDimension) {
      state.layoutService = At({
        source: layoutService.getLayout()
      });
    }
    return {
      query: {
        getHasCube: () => !!state.layoutService,
        getCube: () => state.layoutService ? state.layoutService.getHyperCube() : undefined,
        getDataPages: () => state.layoutService ? state.layoutService.getDataPages() : undefined
      },
      command: {
        setDataPages: dataPages => {
          if (state.layoutService) {
            state.layoutService.setDataPages(dataPages);
          }
        }
      }
    };
  }

  function area({
    layoutService
  }) {
    const {
      dimensionCount,
      measureCount,
      isStacked
    } = layoutService.meta;
    const offset = dimensionCount === 2 && isStacked ? 1 : 0;
    return {
      qTop: 0,
      qLeft: offset,
      qWidth: dimensionCount + measureCount + offset,
      qHeight: Math.min(2000, 10000 / (measureCount + 1))
    };
  }

  function createEngineFetcher({
    enigmaModel,
    layoutService
  }) {
    return function fetchFromEngine() {
      return getReducedData(enigmaModel, layoutService, {
        path: '/qHyperCubeDef',
        rect: area({
          layoutService
        }),
        zoomLevel: -1,
        filter: 'D1'
      });
    };
  }

  function createLayoutFetcher({
    layoutService
  }) {
    return function fetchFromLayout() {
      const cube = layoutService.getHyperCube();
      return Promise.resolve({
        reducedCube: {
          ...cube,
          qDataPages: [...cube.qDataPages]
        }
      });
    };
  }

  function createSnapshotFetcher({
    layoutService
  }) {
    return function fetchFromSnapshot() {
      return Promise.resolve({
        reducedCube: layoutService.getLayoutValue('reducedHyperCube') || layoutService.getHyperCube()
      });
    };
  }

  function createFetcher({
    enigmaModel,
    layoutService
  }) {
    const {
      isSnapshot,
      isContinuous
    } = layoutService.meta;
    if (isSnapshot) {
      return createSnapshotFetcher({
        layoutService
      });
    }
    if (isContinuous) {
      return createLayoutFetcher({
        layoutService
      });
    }
    return createEngineFetcher({
      enigmaModel,
      layoutService
    });
  }

  function patcher({
    layoutService
  }) {
    const {
      isSnapshot,
      isTwoDimensional,
      isStacked
    } = layoutService.meta;
    const patch = hyperCube => {
      hyperCube.qDimensionInfo.unshift({
        key: 'dummy-patch-dimension'
      });
    };
    patch.should = hyperCube => !!(isSnapshot && isTwoDimensional && isStacked && hyperCube.qDimensionInfo.length === 1);
    return patch;
  }

  function createReducedModel({
    enigmaModel,
    layoutService,
    dataProcessorModel
  }) {
    const reduced = {
      cube: undefined,
      on: false
    };
    const fetch = createFetcher({
      enigmaModel,
      layoutService
    });
    const patch = patcher({
      layoutService
    });
    return {
      query: {
        getCube: () => reduced.cube,
        getIsReduced: () => reduced.on
      },
      command: {
        initialize: () => fetch().then(result => {
          const {
            reducedCube
          } = result;
          const isSame = reducedCube === layoutService.getHyperCube();
          if (patch.should(reducedCube)) {
            patch(reducedCube);
          }
          reduced.cube = isSame ? At({
            source: layoutService.getLayout()
          }).getHyperCube() : reducedCube;
          reduced.on = !!(reduced.cube && reduced.cube.qDataPages[0] && reduced.cube.qDataPages[0].qIsReduced);
          if (layoutService.meta.isDiscrete && layoutService.meta.isOneDimensional && reduced.cube.qDataPages[0]) {
            dataProcessorModel.command.processDataPage({
              dataPage: reduced.cube.qDataPages[0]
            });
          }
        }),
        setSnapshotData: layout => {
          // eslint-disable-next-line no-param-reassign
          layout.reducedHyperCube = reduced.cube;
        }
      }
    };
  }

  function clear({
    clearMinor,
    clearDiscrete,
    clearLegend,
    chart
  }) {
    clearMinor();
    clearDiscrete();
    clearLegend();
    chart.brush('lazySelection').clear();
  }

  function start({
    setSelectionInfo,
    event,
    components,
    clear
  }) {
    const newComponents = components !== null && components !== void 0 && components.length ? components.map(c => c.key).filter(Boolean) : [];
    setSelectionInfo({
      event,
      components: newComponents,
      // selections meta data
      minorRange: event === 'minorRange',
      legendRange: event === 'legendRange',
      legendTap: event === 'tap' && newComponents[0] === KEYS.COMPONENT.LEGEND_CATEGORICAL
    });
    clear();
  }

  /* eslint-disable no-unused-expressions */
  function createService({
    chart,
    actions,
    selections
  }) {
    const majorScale = chart.scale(KEYS.SCALE.MAIN.MAJOR);
    const service = mo({
      chart,
      actions,
      selections,
      config: {
        allowSimultaneous: true,
        brushRanges: true,
        majorScale,
        selectionActions: {
          reset() {
            chart.brushSelectionIncludeMax = undefined; // eslint-disable-line no-param-reassign
            if (actions.lasso.active()) {
              actions.lasso.action(false);
            }
          },
          clear: ({
            clearMinor,
            clearDiscrete,
            clearLegend
          }) => {
            clear({
              clearMinor,
              clearDiscrete,
              clearLegend,
              chart
            });
          }
        },
        selectionEvents: {
          start
        },
        custom: {
          getShouldIncludeMax: ({
            datum
          }) => chart.brushSelectionIncludeMax && datum === majorScale.max(),
          getIsOuterDimensionLocked: () => service.getIsDimensionLocked(0),
          getIsInnerDimensionLocked: () => service.getIsDimensionLocked(1)
        }
      }
    });
    const lazyBrush = chart.brush('lazySelection');
    const lazySelectionListeners = {
      activate: () => {},
      deactivated: () => lazyBrush.end(),
      cleared: () => lazyBrush.clear(),
      canceled: () => lazyBrush.end()
    };
    const addListeners = (emitter, listeners) => {
      Object.keys(listeners).forEach(type => {
        emitter === null || emitter === void 0 || emitter.on(type, listeners[type]);
      });
    };
    const removeListeners = (emitter, listeners) => {
      Object.keys(listeners).forEach(type => {
        emitter === null || emitter === void 0 || emitter.removeListener(type, listeners[type]);
      });
    };
    addListeners(selections, lazySelectionListeners);
    service.destroyLazySelection = () => {
      removeListeners(selections, lazySelectionListeners);
    };
    return service;
  }

  var STYLES = {
    LINE: {
      CURVE: {
        LINEAR: 'linear',
        MONOTONE: 'monotone',
        STEP: 'step'
      },
      WIDTH: {
        FULL: {
          DEFAULT: 2,
          ACTIVE: 2
        },
        LESS: {
          DEFAULT: 1,
          ACTIVE: 1
        }
      },
      TYPE: {
        SOLID: undefined,
        DASHED: '5, 5'
      }
    },
    POINT: {
      SIZE: {
        DEFAULT: 6,
        ACTIVE: 4
      }
    }
  };

  function createResolver$1({
    layoutService,
    flags
  }) {
    const {
      isOneDimensional
    } = layoutService.meta;
    const isEnabled = flags === null || flags === void 0 ? void 0 : flags.isEnabled('SENSECLIENT_IM_312_STYLINGPANEL_LINECHART');
    const {
      style: global
    } = layoutService.getLayoutValue('components', []).filter(c => c.key === 'line')[0] || {};
    const getPath = index => `qMeasureInfo.${index}.styling`;
    return ({
      property,
      defaultValue,
      index
    }) => {
      const fallback = global && Object.hasOwnProperty.call(global, property) ? global[property] : defaultValue;
      if (index === undefined) {
        return fallback;
      }
      const {
        style: measure
      } = layoutService.getHyperCubeValue(getPath(isOneDimensional ? index : 0), []).filter(c => c.key === 'line' || isEnabled && c.cId)[0] || {};
      return measure && Object.hasOwnProperty.call(measure, property) ? measure[property] : fallback;
    };
  }

  function createStyleModel({
    layoutService,
    dockService,
    themeService,
    flags
  }) {
    const {
      LINE,
      POINT
    } = STYLES;
    const styles = themeService.getStyles();
    const resolve = createResolver$1({
      layoutService,
      flags
    });
    const overrides = key => {
      const isEnabled = flags.isEnabled('CLIENT_IM_3050');
      return isEnabled ? layoutService.getLayoutValue('components', []).find(c => c.key === key) : undefined;
    };
    const query = {
      line: {
        getCurve: () => (context, index) => resolve({
          property: 'lineCurve',
          defaultValue: LINE.CURVE.LINEAR,
          index
        }),
        getStrokeWidth: () => (context, index) => resolve({
          property: 'lineThickness',
          defaultValue: dockService.meta.chart.mode === 'FULL' ? LINE.WIDTH.FULL.DEFAULT : LINE.WIDTH.LESS.DEFAULT,
          index
        }),
        getStrokeDasharray: () => (context, index) => {
          const resolved = resolve({
            property: 'lineType',
            defaultValue: LINE.TYPE.SOLID,
            index
          });
          return resolved && LINE.TYPE[resolved.toUpperCase()];
        }
      },
      forecast: {
        getCurve: () => context => {
          const index = context.datum.line.value;
          return layoutService.getLayoutValue(`qHyperCube.qMeasureInfo.${index}.forecast.lineCurve`, query.line.getCurve()(context, index));
        },
        getStrokeWidth: () => context => {
          const idx = context.datum.line.value;
          return layoutService.getLayoutValue(`qHyperCube.qMeasureInfo.${idx}.forecast.lineThickness`, query.line.getStrokeWidth()(context, idx));
        },
        getStrokeDasharray: () => context => {
          const idx = context.datum.line.value;
          const lineType = layoutService.getLayoutValue(`qHyperCube.qMeasureInfo.${idx}.forecast.lineType`);
          return lineType ? LINE.TYPE[lineType.toUpperCase()] : query.line.getStrokeDasharray()(context, idx);
        }
      },
      point: {
        getSize: index => resolve({
          property: 'dataPointSize',
          defaultValue: POINT.SIZE.DEFAULT,
          index
        })
      },
      axis: {
        title: {
          getStyle: () => {
            var _overrides$axis$title, _overrides, _overrides$axis$title2, _overrides2, _overrides$axis$title3, _overrides3;
            return {
              color: (_overrides$axis$title = (_overrides = overrides('axis')) === null || _overrides === void 0 || (_overrides = _overrides.axis) === null || _overrides === void 0 || (_overrides = _overrides.title) === null || _overrides === void 0 || (_overrides = _overrides.color) === null || _overrides === void 0 ? void 0 : _overrides.color) !== null && _overrides$axis$title !== void 0 ? _overrides$axis$title : styles.axis.title.color,
              fontFamily: (_overrides$axis$title2 = (_overrides2 = overrides('axis')) === null || _overrides2 === void 0 || (_overrides2 = _overrides2.axis) === null || _overrides2 === void 0 || (_overrides2 = _overrides2.title) === null || _overrides2 === void 0 ? void 0 : _overrides2.fontFamily) !== null && _overrides$axis$title2 !== void 0 ? _overrides$axis$title2 : styles.axis.title.fontFamily,
              fontSize: (_overrides$axis$title3 = (_overrides3 = overrides('axis')) === null || _overrides3 === void 0 || (_overrides3 = _overrides3.axis) === null || _overrides3 === void 0 || (_overrides3 = _overrides3.title) === null || _overrides3 === void 0 ? void 0 : _overrides3.fontSize) !== null && _overrides$axis$title3 !== void 0 ? _overrides$axis$title3 : styles.axis.title.fontSize
            };
          }
        },
        label: {
          getStyle: () => {
            var _overrides$axis$label, _overrides4, _overrides$axis$label2, _overrides5, _overrides$axis$label3, _overrides6;
            return {
              fill: (_overrides$axis$label = (_overrides4 = overrides('axis')) === null || _overrides4 === void 0 || (_overrides4 = _overrides4.axis) === null || _overrides4 === void 0 || (_overrides4 = _overrides4.label) === null || _overrides4 === void 0 || (_overrides4 = _overrides4.name) === null || _overrides4 === void 0 || (_overrides4 = _overrides4.color) === null || _overrides4 === void 0 ? void 0 : _overrides4.color) !== null && _overrides$axis$label !== void 0 ? _overrides$axis$label : styles.axis.label.name.color,
              fontFamily: (_overrides$axis$label2 = (_overrides5 = overrides('axis')) === null || _overrides5 === void 0 || (_overrides5 = _overrides5.axis) === null || _overrides5 === void 0 || (_overrides5 = _overrides5.label) === null || _overrides5 === void 0 || (_overrides5 = _overrides5.name) === null || _overrides5 === void 0 ? void 0 : _overrides5.fontFamily) !== null && _overrides$axis$label2 !== void 0 ? _overrides$axis$label2 : styles.axis.label.name.fontFamily,
              fontSize: (_overrides$axis$label3 = (_overrides6 = overrides('axis')) === null || _overrides6 === void 0 || (_overrides6 = _overrides6.axis) === null || _overrides6 === void 0 || (_overrides6 = _overrides6.label) === null || _overrides6 === void 0 || (_overrides6 = _overrides6.name) === null || _overrides6 === void 0 ? void 0 : _overrides6.fontSize) !== null && _overrides$axis$label3 !== void 0 ? _overrides$axis$label3 : styles.axis.label.name.fontSize
            };
          }
        }
      },
      label: {
        getStyle: () => {
          var _overrides$label$valu, _overrides7, _overrides$label$valu2, _overrides8, _overrides$label$valu3, _overrides9;
          return {
            fill: (_overrides$label$valu = (_overrides7 = overrides('label')) === null || _overrides7 === void 0 || (_overrides7 = _overrides7.label) === null || _overrides7 === void 0 || (_overrides7 = _overrides7.value) === null || _overrides7 === void 0 || (_overrides7 = _overrides7.color) === null || _overrides7 === void 0 ? void 0 : _overrides7.color) !== null && _overrides$label$valu !== void 0 ? _overrides$label$valu : styles.label.value.color,
            fontFamily: (_overrides$label$valu2 = (_overrides8 = overrides('label')) === null || _overrides8 === void 0 || (_overrides8 = _overrides8.label) === null || _overrides8 === void 0 || (_overrides8 = _overrides8.value) === null || _overrides8 === void 0 ? void 0 : _overrides8.fontFamily) !== null && _overrides$label$valu2 !== void 0 ? _overrides$label$valu2 : styles.label.value.fontFamily,
            fontSize: (_overrides$label$valu3 = (_overrides9 = overrides('label')) === null || _overrides9 === void 0 || (_overrides9 = _overrides9.label) === null || _overrides9 === void 0 || (_overrides9 = _overrides9.value) === null || _overrides9 === void 0 ? void 0 : _overrides9.fontSize) !== null && _overrides$label$valu3 !== void 0 ? _overrides$label$valu3 : styles.label.value.fontSize
          };
        }
      },
      legend: {
        title: {
          getStyle: () => {
            var _overrides$legend$tit, _overrides10, _overrides$legend$tit2, _overrides11, _overrides$legend$tit3, _overrides12;
            return {
              fontFamily: (_overrides$legend$tit = (_overrides10 = overrides('legend')) === null || _overrides10 === void 0 || (_overrides10 = _overrides10.legend) === null || _overrides10 === void 0 || (_overrides10 = _overrides10.title) === null || _overrides10 === void 0 ? void 0 : _overrides10.fontFamily) !== null && _overrides$legend$tit !== void 0 ? _overrides$legend$tit : styles.legend.title.fontFamily,
              fontSize: (_overrides$legend$tit2 = (_overrides11 = overrides('legend')) === null || _overrides11 === void 0 || (_overrides11 = _overrides11.legend) === null || _overrides11 === void 0 || (_overrides11 = _overrides11.title) === null || _overrides11 === void 0 ? void 0 : _overrides11.fontSize) !== null && _overrides$legend$tit2 !== void 0 ? _overrides$legend$tit2 : styles.legend.title.fontSize,
              color: (_overrides$legend$tit3 = (_overrides12 = overrides('legend')) === null || _overrides12 === void 0 || (_overrides12 = _overrides12.legend) === null || _overrides12 === void 0 || (_overrides12 = _overrides12.title) === null || _overrides12 === void 0 || (_overrides12 = _overrides12.color) === null || _overrides12 === void 0 ? void 0 : _overrides12.color) !== null && _overrides$legend$tit3 !== void 0 ? _overrides$legend$tit3 : styles.legend.title.color
            };
          }
        },
        label: {
          getStyle: () => {
            var _overrides$legend$lab, _overrides13, _overrides$legend$lab2, _overrides14, _overrides$legend$lab3, _overrides15;
            return {
              fontFamily: (_overrides$legend$lab = (_overrides13 = overrides('legend')) === null || _overrides13 === void 0 || (_overrides13 = _overrides13.legend) === null || _overrides13 === void 0 || (_overrides13 = _overrides13.label) === null || _overrides13 === void 0 ? void 0 : _overrides13.fontFamily) !== null && _overrides$legend$lab !== void 0 ? _overrides$legend$lab : styles.legend.label.fontFamily,
              fontSize: (_overrides$legend$lab2 = (_overrides14 = overrides('legend')) === null || _overrides14 === void 0 || (_overrides14 = _overrides14.legend) === null || _overrides14 === void 0 || (_overrides14 = _overrides14.label) === null || _overrides14 === void 0 ? void 0 : _overrides14.fontSize) !== null && _overrides$legend$lab2 !== void 0 ? _overrides$legend$lab2 : styles.legend.label.fontSize,
              color: (_overrides$legend$lab3 = (_overrides15 = overrides('legend')) === null || _overrides15 === void 0 || (_overrides15 = _overrides15.legend) === null || _overrides15 === void 0 || (_overrides15 = _overrides15.label) === null || _overrides15 === void 0 || (_overrides15 = _overrides15.color) === null || _overrides15 === void 0 ? void 0 : _overrides15.color) !== null && _overrides$legend$lab3 !== void 0 ? _overrides$legend$lab3 : styles.legend.label.color
            };
          }
        }
      }
    };
    return {
      query
    };
  }

  const OFFSET = 0.2;
  function getMinMax$1({
    extrema
  }) {
    const {
      min,
      max
    } = extrema;
    if (min !== max) {
      return {
        min,
        max
      };
    }
    if (min === 0 || min === 1) {
      return {
        min: min - 1,
        max: max + 1
      };
    }
    return {
      min: min - min * OFFSET * Math.sign(min),
      max: max + max * OFFSET * Math.sign(max)
    };
  }

  function getIsValid({
    extrema,
    ticks
  }) {
    const minPredicate = tick => !extrema.meta.hasExplicitMin || tick >= extrema.explicit.min;
    const maxPredicate = tick => !extrema.meta.hasExplicitMax || tick <= extrema.explicit.max;
    const minimum = extrema.meta.hasExplicit ? 2 : 3;
    return ticks.filter(tick => minPredicate(tick) && maxPredicate(tick)).length >= minimum;
  }

  function getValidity({
    min,
    max,
    threshold,
    scale,
    disable
  }) {
    const validity = {
      start: true,
      stop: true
    };
    if (disable) {
      return validity;
    }
    const [start, stop] = scale.domain();
    if (min !== 0 && start !== 0) {
      validity.start = scale(min) > threshold;
    }
    if (max !== 0 && stop !== 0) {
      validity.stop = scale(max) < 1 - threshold;
    }
    return validity;
  }

  function getScale({
    min,
    max,
    count,
    threshold,
    disable
  }) {
    const scale = d3Nice(min, max, count);
    const validity = getValidity({
      min,
      max,
      threshold,
      scale,
      disable
    });
    if (!validity.start || !validity.stop) {
      const [start, stop] = scale.domain();
      const ticks = scale.ticks(count);
      const startOffset = ticks.length >= 4 ? ticks[1] - ticks[0] : start * 0.1;
      const stopOffset = ticks.length >= 4 ? ticks[ticks.length - 1] - ticks[ticks.length - 2] : stop * 0.1;
      scale.domain([validity.start ? start : start - startOffset, validity.stop ? stop : stop + stopOffset]);
      scale.nice(count);
    }
    return scale;
  }

  const SPACING$1 = {
    NARROW: 50,
    MEDIUM: 100,
    WIDE: 200,
    FALLBACK: 125
  };
  const getDistance = spacing => {
    switch (spacing) {
      case 0.5:
        return SPACING$1.NARROW;
      case 1:
        return SPACING$1.MEDIUM;
      case 2:
        return SPACING$1.WIDE;
      default:
        return spacing * SPACING$1.FALLBACK;
    }
  };
  function getCount$1({
    layoutService,
    size
  }) {
    const spacing = layoutService.getLayoutValue('measureAxis.spacing', 1);
    const distance = getDistance(spacing);
    return Math.max(1, Math.round(size / distance));
  }

  function getNormalTicks({
    chart,
    layoutService,
    dockService,
    measureText,
    size,
    min,
    max
  }) {
    const count = getCount$1({
      layoutService,
      size
    });
    const scale = getScale({
      min,
      max,
      count,
      threshold: 0.05,
      disable: true
    });
    const domain = scale.domain();
    const normal = {
      roundedMin: domain[0],
      roundedMax: domain[1],
      ticks: scale.ticks(count)
    };
    const dimension = dockService.meta.major.orientation === 'horizontal' ? 'height' : 'width';
    const measure = text => measureText(text)[dimension];
    const formatter = chart.formatter(KEYS.FORMATTER.MINOR);
    const fits = labels => {
      const available = size / normal.ticks.length;
      return Math.max(...labels.map(measure)) <= available;
    };
    const valid = () => {
      const labels = normal.ticks.map(formatter);
      const duplicates = labels.some((tick, i) => labels.indexOf(tick) !== i);
      if (duplicates) {
        return false;
      }
      return fits(labels);
    };
    for (let c = count - 1; c > 0; c--) {
      if (valid()) {
        break;
      }
      scale.domain([min, max]);
      scale.nice(c);
      [normal.roundedMin, normal.roundedMax] = scale.domain();
      normal.ticks = scale.ticks(c);
    }
    return normal;
  }

  const THRESHOLD = 0.3;
  function isZeroNearMiddle({
    ticks
  }) {
    const span = Math.round(ticks.length * THRESHOLD);
    const start = span;
    const end = ticks.length - span;
    return ticks.slice(start, end).some(tick => tick === 0);
  }
  function isFirstOrLastOrZero({
    tick,
    index,
    ticks
  }) {
    return index === 0 || index === ticks.length - 1 || tick === 0;
  }
  function isFirstOrLastOrMiddle({
    index,
    ticks
  }) {
    return index === 0 || index === ticks.length - 1 || index === Math.floor((ticks.length - 1) / 2);
  }

  const COUNT = 10;
  function getSmallTicks({
    chart,
    extrema,
    min,
    max
  }) {
    const small = {
      roundedMin: 0,
      roundedMax: 0,
      ticks: []
    };
    const scale = getScale({
      min,
      max,
      count: COUNT,
      threshold: 0.15,
      disable: true
    });
    [small.roundedMin, small.roundedMax] = scale.domain();
    const ticks = scale.ticks(COUNT);
    const hasZero = isZeroNearMiddle({
      ticks
    });
    const filter = hasZero ? isFirstOrLastOrZero : isFirstOrLastOrMiddle;
    small.ticks = ticks.filter((tick, index, array) => filter({
      tick,
      index,
      ticks: array
    }));
    const isEven = small.ticks.length % 2 === 0;
    if (isEven && !hasZero && !extrema.meta.hasExplicit && ticks.length > 1) {
      small.ticks = [ticks[0], (ticks[0] + ticks[ticks.length - 1]) / 2, ticks[ticks.length - 1]];
    }
    const formatter = chart.formatter(KEYS.FORMATTER.MINOR);
    const labels = small.ticks.map(formatter);
    const duplicates = labels.some((tick, i) => labels.indexOf(tick) !== i);
    if (duplicates) {
      small.ticks = [small.ticks[0], small.ticks[small.ticks.length - 1]];
    }
    return small;
  }

  function getSparkTicks({
    min,
    max
  }) {
    return {
      roundedMin: min,
      roundedMax: max,
      ticks: []
    };
  }

  function getTicks$1({
    chart,
    layoutService,
    dockService,
    extrema,
    measureText,
    size,
    min,
    max
  }) {
    if (dockService.meta.chart.mode === 'SPARK') {
      return getSparkTicks({
        min,
        max
      });
    }
    const normal = getNormalTicks({
      chart,
      layoutService,
      dockService,
      measureText,
      size,
      min,
      max
    });
    const valid = getIsValid({
      extrema,
      ticks: normal.ticks
    });
    return valid ? normal : getSmallTicks({
      chart,
      extrema,
      min,
      max
    });
  }

  function getMinorTicks({
    ticks,
    count
  }) {
    const minor = [];
    for (let i = 0; i < ticks.length - 1; i++) {
      const start = ticks[i];
      const end = ticks[i + 1];
      const step = (end - start) / (count + 1);
      for (let c = 1; c <= count; c++) {
        minor.push(start + step * c);
      }
    }
    return minor;
  }

  function explicify({
    ticks,
    extrema
  }) {
    let explicified = [...ticks];
    if (!extrema.meta.hasExplicit || !ticks.length) {
      return explicified;
    }
    if (extrema.meta.hasExplicitMin && !ticks.some(tick => tick === extrema.explicit.min)) {
      explicified.unshift(extrema.explicit.min);
      explicified = explicified.filter(tick => tick >= extrema.explicit.min);
    }
    if (extrema.meta.hasExplicitMax && !ticks.some(tick => tick === extrema.explicit.max)) {
      explicified.push(extrema.explicit.max);
      explicified = explicified.filter(tick => tick <= extrema.explicit.max);
    }
    return explicified;
  }

  function getTicks({
    chart,
    layoutService,
    dockService,
    extrema,
    measureText,
    size,
    min,
    max
  }) {
    const {
      ticks: majorTicks,
      roundedMin,
      roundedMax
    } = getTicks$1({
      chart,
      layoutService,
      dockService,
      extrema,
      measureText,
      size,
      min,
      max
    });
    const minorTicks = getMinorTicks({
      ticks: majorTicks,
      count: 1
    });
    const values = [...explicify({
      ticks: majorTicks,
      extrema
    }).map(value => ({
      value,
      isMinor: false
    })), ...minorTicks.map(value => ({
      value,
      isMinor: true
    }))].sort((a, b) => a.value - b.value);
    return {
      min: roundedMin,
      max: roundedMax,
      values
    };
  }

  function getLinearTicks({
    chart,
    layoutService,
    dockService,
    measureText,
    extrema,
    size
  }) {
    const {
      min,
      max
    } = getMinMax$1({
      extrema
    });
    const ticks = getTicks({
      chart,
      layoutService,
      dockService,
      extrema,
      measureText,
      size,
      min,
      max
    });
    return ticks;
  }

  function getApproximateLabelWidth({
    min,
    max,
    measureText,
    formatter
  }) {
    if (!formatter) {
      return 0;
    }
    return Math.max(...[min, max, (max - min) / 2].map(value => measureText(formatter(value)).width));
  }

  function getCount({
    chart,
    layoutService,
    dockService,
    measureText,
    extrema,
    size,
    fontHeight
  }) {
    const {
      min,
      max
    } = extrema;
    const formatter = chart.formatter('minor');
    const minTickSpacingInPixel = dockService.meta.minor.orientation === 'vertical' ? fontHeight * 4 : Math.max(96, getApproximateLabelWidth({
      min,
      max,
      measureText,
      formatter
    }));
    const tickMultiplier = layoutService.getLayoutValue('measureAxis.spacing', 1);
    const numTicks = Math.max(2, Math.floor(size / (minTickSpacingInPixel * tickMultiplier)) + 1);
    return numTicks;
  }

  function getMinMax({
    layoutService,
    extrema
  }) {
    const {
      isArea
    } = layoutService.meta;
    const {
      min,
      max
    } = extrema.implicit;
    const result = {
      min,
      max
    };
    if (!isArea) {
      return result;
    }
    if (min >= 1) {
      result.min = 1;
    } else if (min > 0) {
      result.min = 10 ** Math.floor(Math.log(min) / Math.log(10));
    }
    if (max <= -1) {
      result.max = -1;
    } else if (max < 0) {
      result.max = -(10 ** Math.floor(Math.log(Math.abs(max)) / Math.log(10)));
    }
    return result;
  }

  function getLogarithmicTicks({
    chart,
    layoutService,
    dockService,
    measureText,
    extrema,
    size
  }) {
    const fontHeight = measureText('M').height;
    const count = getCount({
      chart,
      layoutService,
      dockService,
      measureText,
      extrema,
      size,
      fontHeight
    });
    const {
      min,
      max
    } = getMinMax({
      layoutService,
      extrema
    });
    const ticks = ScaleLogUtils.calculateTicks({
      size,
      dataMin: min,
      dataMax: max,
      explicitMin: extrema.explicit.min,
      explicitMax: extrema.explicit.max,
      minTickSpacingInPixel: size / (count - 1),
      fontHeight
    });
    return ticks;
  }

  function getSize({
    chart,
    chartModel,
    dockService
  }) {
    const source = chartModel.query.getIsUpdateDataless() ? dockService.meta.chart.size : chart.component(KEYS.COMPONENT.LINE).rect;
    return dockService.meta.major.orientation === 'horizontal' ? source.height : source.width;
  }

  function createResolver({
    chart,
    layoutService,
    chartModel,
    extremumModel,
    dockService,
    themeService
  }) {
    const logarithmic = layoutService.getLayoutValue('measureAxis.logarithmic', false);
    const {
      measureText
    } = p.renderer('svg')();
    return () => {
      const styles = themeService.getStyles();
      const measure = text => measureText({
        text,
        fontFamily: styles.axis.label.name.fontFamily,
        fontSize: styles.axis.label.name.fontSize
      });
      const size = getSize({
        chart,
        chartModel,
        dockService
      });
      const extrema = extremumModel.query.getExtrema();
      const getTicks = logarithmic && !extrema.meta.includesZero ? getLogarithmicTicks : getLinearTicks;
      const ticks = getTicks({
        chart,
        layoutService,
        dockService,
        measureText: measure,
        extrema,
        size
      });
      return ticks;
    };
  }

  function createTickModel({
    chart,
    layoutService,
    chartModel,
    extremumModel,
    dockService,
    themeService
  }) {
    const state = {
      locked: false,
      resolved: undefined
    };
    const {
      getExtrema
    } = extremumModel.query;
    const resolver = createResolver({
      chart,
      layoutService,
      chartModel,
      extremumModel,
      dockService,
      themeService
    });
    const resolve = () => {
      if (!state.locked || !state.resolved) {
        state.resolved = resolver();
      }
      return state.resolved;
    };
    return {
      query: {
        getValues: () => resolve().values,
        getMin: () => getExtrema().meta.hasExplicitMin ? getExtrema().explicit.min : resolve().min,
        getMax: () => getExtrema().meta.hasExplicitMax ? getExtrema().explicit.max : resolve().max
      },
      command: {
        lock: () => {
          state.locked = true;
        },
        unlock: () => {
          state.locked = false;
        }
      }
    };
  }

  function getPlacement({
    tickModel
  }) {
    const {
      POINT,
      OUT_OF_MIN_BOUNDS,
      OUT_OF_MAX_BOUNDS,
      MAJOR_AXIS
    } = KEYS.COMPONENT;
    return [({
      chart,
      hovered,
      meta
    }) => {
      const [node] = hovered;
      const {
        triggerer
      } = meta;
      if (triggerer === POINT) {
        return false;
      }
      if (triggerer === OUT_OF_MIN_BOUNDS || triggerer === OUT_OF_MAX_BOUNDS) {
        return {
          key: node.key,
          bounds: node.bounds
        };
      }
      if (triggerer === MAJOR_AXIS) {
        const maxOOB = chart.findShapes('path').find(s => s.key === OUT_OF_MAX_BOUNDS && s.data.major.value === node.data.value);
        if (maxOOB) {
          return {
            key: maxOOB.key,
            bounds: maxOOB.bounds
          };
        }
        const minOOB = chart.findShapes('path').find(s => s.key === OUT_OF_MIN_BOUNDS && s.data.major.value === node.data.value);
        if (minOOB) {
          const min = tickModel.query.getMin();
          const max = tickModel.query.getMax();
          const point = chart.findShapes('circle').find(s => s.key === POINT && s.data.major.value === node.data.value && s.data.end.value >= min && s.data.end.value <= max);
          if (!point) {
            return {
              key: minOOB.key,
              bounds: minOOB.bounds
            };
          }
        }
      }
      return false;
    }, 'collectible'];
  }

  function getTitle({
    chart,
    layoutService,
    node,
    formatter
  }) {
    var _layoutService$getHyp;
    const {
      isTwoDimensional
    } = layoutService.meta;
    const {
      key,
      data
    } = node;
    if (isTwoDimensional) {
      return `${data.label}, ${data.major.label}`;
    }
    const isUnformatted = ((_layoutService$getHyp = layoutService.getHyperCubeValue('qDimensionInfo.0', {}).qNumFormat) === null || _layoutService$getHyp === void 0 ? void 0 : _layoutService$getHyp.qType) === 'U';
    if (key !== KEYS.COMPONENT.FORECAST_POINT || !isUnformatted) {
      return node.data.label;
    }
    const {
      scale
    } = chart;
    const fallback = formatter({
      data: {
        fields: ['qDimensionInfo/0']
      }
    });
    const majorScale = scale(KEYS.SCALE.MAIN.MAJOR);
    const majorFormatter = majorScale !== null && majorScale !== void 0 && majorScale.formatter ? majorScale.formatter() : fallback;
    const majorInnerScale = scale(KEYS.SCALE.MAIN.MAJOR_INNER);
    const majorInnerFormatter = majorInnerScale !== null && majorInnerScale !== void 0 && majorInnerScale.formatter ? majorInnerScale.formatter() : fallback;
    const {
      value
    } = data.major;
    const majorValue = majorFormatter(value);
    const majorInnerValue = majorInnerFormatter(value);
    return majorValue === majorInnerValue ? majorValue : `${majorValue} ${majorInnerValue}`;
  }

  function createTooltipService({
    chart,
    actions,
    translator,
    rtl,
    viewState,
    layoutService,
    fieldModel,
    colorService,
    themeService,
    trendLineModel,
    tickModel,
    custom
  }) {
    const {
      isTwoDimensional,
      isStacked
    } = layoutService.meta;
    const {
      fontFamily
    } = themeService.getStyles();
    const placement = getPlacement({
      tickModel
    });
    const onTrendline = create$z({
      majorInnerScale: KEYS.SCALE.MAIN.MAJOR_INNER,
      tooltip: KEYS.COMPONENT.TREND_LINES_TOOLTIP,
      tooltipOverlay: KEYS.COMPONENT.TREND_LINES_TOOLTIP_OVERLAY
    }, {
      chart,
      viewState,
      trendLineModel,
      layoutService,
      rtl
    });
    return si({
      chart,
      translator,
      config: {
        rtl,
        enable: () => actions.tooltip.enabled(),
        getColorSettings: () => colorService.getMain().getSettings(),
        style: {
          fontFamily
        },
        main: {
          key: KEYS.COMPONENT.POINT_TOOLTIP,
          suppress: ({
            event
          }) => onTrendline(event),
          getGroupByValue: ({
            data
          }) => isTwoDimensional ? data.line.value : data.major.value,
          collectibles: [{
            key: KEYS.COMPONENT.POINT,
            type: 'point',
            major: ({
              data
            }) => data.major.value
          }, {
            key: KEYS.COMPONENT.FORECAST_POINT,
            type: 'point',
            major: ({
              data
            }) => data.major.value
          }],
          triggers: [{
            keys: [KEYS.COMPONENT.POINT, KEYS.COMPONENT.FORECAST_POINT],
            distance: 3,
            collect: {
              from: 'radius',
              distance: 3,
              filter: ({
                data,
                attrs
              }) => (!data.null || data.null && !data.null.value) && (!data.interpolated || data.interpolated && !data.interpolated.value) && (attrs === null || attrs === void 0 ? void 0 : attrs.opacity) !== 0.01
            },
            placement
          }, {
            keys: [KEYS.COMPONENT.MAJOR_AXIS],
            collect: {
              from: 'dimension',
              by: ({
                data
              }) => data.value
            },
            placement
          }, {
            keys: [KEYS.COMPONENT.OUT_OF_MIN_BOUNDS, KEYS.COMPONENT.OUT_OF_MAX_BOUNDS, KEYS.COMPONENT.FORECAST_OUT_OF_MIN_BOUNDS, KEYS.COMPONENT.FORECAST_OUT_OF_MAX_BOUNDS],
            collect: {
              from: 'dimension',
              by: ({
                data
              }) => data.major.value
            },
            placement
          }],
          placements: {
            collectible: ({
              collected
            }) => {
              const [max] = collected.sort((a, b) => b.data.end.value - a.data.end.value);
              return max.bounds;
            }
          },
          layout: {
            grouping: isTwoDimensional,
            single: () => !!(custom.isEnabled() && custom.hasImages()) || custom.chart.isEnabled()
          },
          section: ({
            h,
            nodes,
            dataset,
            formatter,
            create
          }) => {
            const [first] = nodes;
            const {
              title: customTitle,
              description: customDescription,
              measures: customMeasures
            } = custom.isEnabled() ? custom.getAttributes({
              dataset,
              nodes: [first]
            }) : {};
            const section = [];
            if (customTitle) {
              section.push(create.text({
                value: customTitle,
                style: {
                  bold: true
                }
              }));
            }
            if (customDescription) {
              section.push(create.text({
                value: customDescription
              }));
            }
            const hideBasic = custom.hideBasic();
            if (!hideBasic || customMeasures.length || !customTitle && !customDescription) {
              section.push(create.text({
                value: getTitle({
                  chart,
                  layoutService,
                  node: first,
                  formatter
                }),
                style: {
                  bold: true
                }
              }));
            }
            if (!hideBasic) {
              section.push(create.color({
                nodes,
                property: KEYS.SCALE.MAIN.COLOR
              }));
              section.push(...nodes.map(node => {
                const {
                  data
                } = node;
                const {
                  end,
                  line,
                  point
                } = data;
                const key = isStacked ? data.source.key : end.source.key;
                const index = isTwoDimensional ? 0 : line.value;
                const field = dataset(key).field(isStacked ? fieldModel.main.minors[index] : end.source.field);
                return create.measure({
                  label: field.raw().id === 'forecast' ? translator.get('Forecast') : field.title(),
                  value: isStacked ? point.label : end.label
                });
              }));
            }
            if (customMeasures) {
              section.push(...customMeasures.map(m => create.measure({
                label: m.label,
                value: m.value,
                survive: {
                  color: true,
                  duplicate: true
                }
              })));
            }
            if (custom.chart.isEnabled()) {
              if (custom.chart.hasLimitation()) {
                custom.chart.destroy();
                section.push(create.raw({
                  value: custom.chart.createLimitationRow()
                }));
              } else {
                section.push(create.raw({
                  value: custom.chart.createContainer({
                    h
                  })
                }));
              }
            }
            const {
              customTooltipImages: customImages
            } = first.data;
            if (custom.isEnabled() && customImages) {
              section.push(...customImages.map(i => create.raw({
                value: custom.createImageRow({
                  value: i,
                  h
                })
              })));
            }
            return section;
          },
          events: {
            tooltip: {
              beforeShow: ({
                collectNodes
              }) => {
                if (!custom.isEnabled() || !custom.hasImages()) {
                  return Promise.resolve();
                }
                return custom.addImages({
                  nodes: collectNodes()
                });
              },
              afterShow: ({
                expando,
                nodes
              }) => {
                if (custom.chart.isEnabled() && !custom.chart.hasLimitation()) {
                  custom.chart.show({
                    nodes,
                    properties: expando.get('properties')
                  });
                }
              }
            },
            interaction: {
              mouseleave: () => {
                if (custom.chart.isEnabled() && custom.chart.hasAlternateState()) {
                  custom.chart.hide();
                }
              }
            }
          }
        },
        legend: {
          keys: {
            tooltip: KEYS.COMPONENT.LEGEND_TOOLTIP,
            component: KEYS.COMPONENT.LEGEND_CATEGORICAL
          }
        }
      }
    });
  }

  const {
    DEFAULT_NUM_POINTS: DEFAULT_NUM_POINTS$1,
    DEFAULT_NUM_LINES: DEFAULT_NUM_LINES$1,
    LARGE_NUM_POINTS: LARGE_NUM_POINTS$1
  } = NUMBERS$1;
  const isLargeNumVisiblePoints = ({
    layoutService,
    maxNumPoints,
    maxNumLines
  }) => (maxNumPoints > DEFAULT_NUM_POINTS$1 || maxNumLines > DEFAULT_NUM_LINES$1) && getNumPoints(layoutService) > LARGE_NUM_POINTS$1;

  const shouldUseProgressive = ({
    layoutService,
    isMaxNumPointsEnabled,
    maxNumPoints,
    maxNumLines,
    options
  }) => {
    const {
      isContinuous
    } = layoutService.meta;
    const isProgressiveAllowed = isMaxNumPointsEnabled && isContinuous && options.progressiveRendering !== false;
    return isProgressiveAllowed && isLargeNumVisiblePoints({
      layoutService,
      maxNumPoints,
      maxNumLines
    });
  };

  /* eslint-disable no-param-reassign */
  const calculateLineMedian = line => {
    const values = line.points.map(p => p[2].qNum).sort((a, b) => b - a);
    line.median = Math.abs(values[Math.floor(values.length / 2)]);
  };

  const calculateNumLinesPerRender = ({
    layoutService,
    numLines
  }) => {
    const {
      CHUNK_SIZE
    } = NUMBERS$1;
    const {
      isOneDimensional
    } = layoutService.meta;
    if (!numLines) return 0;
    if (isOneDimensional) return 1;
    const numPoints = getNumPoints(layoutService);
    const numPointsPerLine = numPoints / numLines;
    return Math.max(1, Math.min(numLines, Math.ceil(CHUNK_SIZE / numPointsPerLine)));
  };

  /* eslint-disable no-param-reassign */
  const groupByLine = (layoutService, dataPages, linesData, isStacked, isReduced) => {
    linesData.linesDict = {};
    linesData.lines = [];
    linesData.chunks = [];
    linesData.matrix = [];
    if (!dataPages.length) {
      return;
    }
    const {
      qMatrix
    } = dataPages[0];
    const {
      linesDict,
      lines
    } = linesData;
    qMatrix.forEach(p => {
      const id = p[1].qElemNumber;
      if (linesDict[id] === undefined) {
        linesDict[id] = {
          points: [p]
        };
        lines.push(linesDict[id]);
      } else {
        linesDict[id].points.push(p);
      }
    });
    if (!isReduced) {
      lines.forEach(calculateLineMedian);
      lines.sort((line1, line2) => line2.median - line1.median);
    }
    const numLines = lines.length;
    if (isStacked) {
      const lineSize = lines[0].points.length;
      for (let i = 0; i < lineSize; i++) {
        for (let j = 0; j < numLines; j++) {
          linesData.matrix.push(lines[j].points[i]);
        }
      }
    } else {
      const numLinesPerRender = calculateNumLinesPerRender({
        layoutService,
        numLines
      });
      const nbrOfChunks = Math.ceil(numLines / numLinesPerRender);
      for (let i = 0; i < nbrOfChunks; i++) {
        linesData.chunks[i] = [];
      }
      lines.forEach((line, idx) => {
        const chunkIdx = Math.floor(idx / numLinesPerRender);
        linesData.chunks[chunkIdx].push(...line.points);
      });
    }
  };

  /* eslint-disable no-param-reassign */
  const brushLines = ({
    chart,
    layoutService,
    progressiveRendering,
    meta,
    render,
    nodes,
    timerId,
    progressiveId,
    shouldUseProgressive
  }) => {
    const resetProgressive = id => {
      if (progressiveRendering[id] !== null) {
        cancelAnimationFrame(progressiveRendering[id]);
        progressiveRendering[id] = null;
      }
    };
    resetProgressive('mainTimer');
    resetProgressive(timerId);
    if (!shouldUseProgressive() || !nodes.length) {
      render(nodes);
      return;
    }
    const numLinesPerRender = calculateNumLinesPerRender({
      layoutService,
      numLines: nodes.length
    });
    const nbrOfChunks = Math.ceil(nodes.length / numLinesPerRender);
    if (nbrOfChunks <= 1) {
      render(nodes);
      return;
    }
    let renderCount = 0;
    const renderChunk = () => {
      progressiveRendering[timerId] = requestAnimationFrame(() => {
        if (!(chart !== null && chart !== void 0 && chart.update)) {
          resetProgressive(timerId);
          meta[progressiveId] = false;
          return;
        }
        const start = renderCount * numLinesPerRender;
        const end = Math.min(nodes.length, (renderCount + 1) * numLinesPerRender);
        meta[progressiveId] = {
          start,
          end,
          isFirst: renderCount === 0,
          isLast: renderCount === nbrOfChunks - 1
        };
        render(nodes.slice(start, end));
        renderCount++;
        if (renderCount < nbrOfChunks) {
          renderChunk();
        } else {
          meta[progressiveId] = false;
          progressiveRendering[timerId] = null;
        }
      });
    };
    renderChunk();
  };

  /* eslint-disable no-param-reassign */
  const {
    CHUNK_SIZE: CHUNK_SIZE$1
  } = NUMBERS$1;
  const brushPoints = ({
    chart,
    shouldUseProgressive,
    progressiveRendering,
    meta,
    render,
    nodes
  }) => {
    const resetProgressive = timerId => {
      if (progressiveRendering[timerId] !== null) {
        cancelAnimationFrame(progressiveRendering[timerId]);
        progressiveRendering[timerId] = null;
      }
    };
    resetProgressive('mainTimer');
    resetProgressive('pointTimer');
    if (!shouldUseProgressive()) {
      render(nodes);
      return;
    }
    const nbrOfChunks = Math.ceil(nodes.length / CHUNK_SIZE$1);
    if (nbrOfChunks <= 1) {
      render(nodes);
      return;
    }
    let renderCount = 0;
    const renderChunk = () => {
      progressiveRendering.pointTimer = requestAnimationFrame(() => {
        if (!(chart !== null && chart !== void 0 && chart.update)) {
          resetProgressive('pointTimer');
          meta.pointProgressive = false;
          return;
        }
        const start = renderCount * CHUNK_SIZE$1;
        const end = Math.min(nodes.length, (renderCount + 1) * CHUNK_SIZE$1);
        meta.pointProgressive = {
          start,
          end,
          isFirst: renderCount === 0,
          isLast: renderCount === nbrOfChunks - 1
        };
        render(nodes.slice(start, end));
        renderCount++;
        if (renderCount < nbrOfChunks) {
          renderChunk();
        } else {
          meta.pointProgressive = false;
          progressiveRendering.pointTimer = null;
        }
      });
    };
    renderChunk();
  };

  /* eslint-disable no-unused-expressions */
  /* eslint-disable no-param-reassign */
  const resetProgressive = ({
    progressiveRendering,
    isPartialUpdate,
    meta
  }) => {
    if (progressiveRendering.mainTimer !== null) {
      var _progressiveRendering;
      cancelAnimationFrame(progressiveRendering.mainTimer);
      progressiveRendering.mainTimer = null;
      (_progressiveRendering = progressiveRendering.renderPromise) === null || _progressiveRendering === void 0 || _progressiveRendering.resolve();
      progressiveRendering.renderPromise = null;
    }
    if (progressiveRendering.pointTimer !== null) {
      cancelAnimationFrame(progressiveRendering.pointTimer);
      progressiveRendering.pointTimer = null;
    }
    if (progressiveRendering.lineTimer !== null) {
      cancelAnimationFrame(progressiveRendering.lineTimer);
      progressiveRendering.lineTimer = null;
    }
    if (!isPartialUpdate) {
      if (progressiveRendering.reducedLineTimer !== null) {
        cancelAnimationFrame(progressiveRendering.reducedLineTimer);
        progressiveRendering.reducedLineTimer = null;
      }
    }
    progressiveRendering.setInProgressive(false);
    meta.pointProgressive = false;
    meta.lineProgressive = false;
    meta.reducedLineProgressive = false;
    meta.highlighterProgressive = false;
  };

  const {
    CHUNK_SIZE
  } = NUMBERS$1;
  const calculateLineSegmentSizePerRender = lines => {
    const numLines = lines.length;
    const segmentSize = Math.max(3, Math.ceil(CHUNK_SIZE / numLines));
    return segmentSize;
  };

  /* eslint-disable no-unused-expressions */
  /* eslint-disable no-param-reassign */
  const {
    DEFAULT_NUM_POINTS,
    MAX_NUM_POINTS,
    LARGE_NUM_POINTS,
    DEFAULT_NUM_LINES,
    MAX_NUM_LINES
  } = NUMBERS$1;
  function createLargeDataService({
    chart,
    layoutService,
    progressiveRendering,
    flags,
    options
  }) {
    const {
      POINT,
      LINE,
      BRUSH_HIGHLIGHTER,
      REDUCED_LINE
    } = KEYS.COMPONENT;
    const exclude = {
      partialUpdate: [KEYS.COMPONENT.MINOR_AXIS, KEYS.COMPONENT.GRID_LINE, KEYS.COMPONENT.ZERO_LINE, KEYS.COMPONENT.MAJOR_AXIS_TITLE, KEYS.COMPONENT.MINOR_AXIS_TITLE, KEYS.COMPONENT.MEASURE_REF_LINE_LABEL, KEYS.COMPONENT.LEGEND_CATEGORICAL, REDUCED_LINE],
      duringMainProgressive: [],
      duringReducedLineProgressive: [],
      forClearProgressive: [],
      postUpdate: [],
      all: []
    };
    const {
      dimensionCount,
      measureCount,
      isOneDimensional,
      isContinuous,
      size,
      isStacked,
      isConnect
    } = layoutService.meta;
    const layout = layoutService.getLayout();
    const isMaxNumPointsEnabled = flags === null || flags === void 0 ? void 0 : flags.isEnabled('IM_1620_LINECHART_MORE_POINTS');
    const maxNumPoints = !isMaxNumPointsEnabled || layout.maxNumPoints === undefined || layout.maxNumPoints < DEFAULT_NUM_POINTS ? DEFAULT_NUM_POINTS : Math.min(MAX_NUM_POINTS, Math.ceil(layout.maxNumPoints));
    const largeNumPoints = Math.min(LARGE_NUM_POINTS, maxNumPoints);
    const qcy = bt(layout.qHyperCube, 'qSize.qcy');
    const numPoints = dimensionCount === 1 ? qcy * measureCount : qcy;
    const computeMaxNumLines = () => {
      const numLines = !isMaxNumPointsEnabled || layout.maxNumLines === undefined || layout.maxNumLines <= 0 ? DEFAULT_NUM_LINES : Math.min(MAX_NUM_LINES, Math.ceil(layout.maxNumLines));
      if (dimensionCount === 1) return Math.min(numLines, measureCount);
      if (dimensionCount === 2) return Math.min(numLines, size.dimensions[1] + 1);
      return undefined;
    };
    const maxNumLines = computeMaxNumLines();
    const isLargeNumPoints = isMaxNumPointsEnabled && isContinuous && numPoints > largeNumPoints && maxNumPoints > largeNumPoints && (maxNumPoints > DEFAULT_NUM_POINTS && maxNumLines >= DEFAULT_NUM_LINES || maxNumPoints >= DEFAULT_NUM_POINTS && maxNumLines > DEFAULT_NUM_LINES);
    const storage = {
      mainPages: [],
      reducedCube: undefined,
      reducedPages: []
    };
    const hasInjectedData = !isConnect || isStacked;
    const meta = {
      isMaxNumPointsEnabled,
      isLargeNumPoints,
      maxNumPoints,
      maxNumLines,
      pointProgressive: false,
      lineProgressive: false,
      reducedLineProgressive: false,
      highlighterProgressive: false,
      hasInjectedData
    };
    const mainLines = {
      linesDict: {},
      lines: [],
      chunks: [],
      matrix: []
    };
    const reducedLines = {
      linesDict: {},
      lines: [],
      chunks: [],
      matrix: []
    };
    function extractMainPages() {
      storage.mainPages = layoutService.getDataPages();
      layoutService.setDataPages([]);
    }
    function insertMainPages() {
      layoutService.setDataPages(storage.mainPages);
      storage.mainPages = [];
    }
    function extractReducedPages() {
      if (storage.reducedCube) {
        storage.reducedPages = storage.reducedCube.qDataPages || [];
        storage.reducedCube.qDataPages = [];
      }
    }
    function insertReducedPages() {
      if (storage.reducedCube) {
        storage.reducedCube.qDataPages = storage.reducedPages;
        storage.reducedPages = [];
      }
    }
    const shouldUseProgressive$1 = () => shouldUseProgressive({
      layoutService,
      isMaxNumPointsEnabled,
      maxNumPoints,
      maxNumLines,
      options
    });
    const beforeAllProgressive = isPartialUpdate => {
      const excludeFromUpdate = isPartialUpdate ? [...exclude.partialUpdate, POINT, LINE, BRUSH_HIGHLIGHTER] : [REDUCED_LINE, POINT, LINE, BRUSH_HIGHLIGHTER];
      chart.update({
        partialData: true,
        excludeFromUpdate
      });
    };
    const afterAllProgressive = resolve => {
      requestAnimationFrame(() => {
        if (progressiveRendering.reducedLineTimer === null && progressiveRendering.mainTimer === null) {
          chart.update({
            partialData: true,
            excludeFromUpdate: exclude.postUpdate
          });
          progressiveRendering.setInProgressive(false);
          resolve();
        }
      });
    };
    const afterMainProgressive = resolve => {
      requestAnimationFrame(() => {
        meta.pointProgressive = false;
        meta.lineProgressive = false;
        progressiveRendering.mainTimer = null;
        afterAllProgressive(resolve);
      });
    };
    const afterReducedLinesProgressive = resolve => {
      requestAnimationFrame(() => {
        meta.reducedLineProgressive = false;
        progressiveRendering.reducedLineTimer = null;
        afterAllProgressive(resolve);
      });
    };
    const renderMainProgressive1D = (resolve, onFinishProgressive) => {
      progressiveRendering.setInProgressive(true);
      const dataPages = layoutService.getDataPages();
      if (!dataPages.length) {
        onFinishProgressive(resolve);
        return;
      }
      const dataSize = dataPages[0].qMatrix.length;
      const nbrOfChunks = measureCount;
      let renderCount = 0;
      const renderChunk = () => {
        progressiveRendering.mainTimer = requestAnimationFrame(() => {
          if (!(chart !== null && chart !== void 0 && chart.update)) {
            resetProgressive({
              progressiveRendering,
              meta
            });
            return;
          }
          const start = Math.max(0, renderCount * dataSize);
          const end = Math.min(dataSize * measureCount, (renderCount + 1) * dataSize);
          meta.pointProgressive = {
            start,
            end,
            isFirst: renderCount === 0,
            isLast: renderCount === nbrOfChunks - 1
          };
          meta.lineProgressive = {
            ...meta.pointProgressive
          };
          chart.update({
            partialData: true,
            excludeFromUpdate: exclude.duringMainProgressive
          });
          renderCount++;
          if (renderCount < nbrOfChunks) {
            renderChunk();
          } else {
            onFinishProgressive(resolve);
          }
        });
      };
      renderChunk();
    };
    const renderReducedLinesProgressive1D = (resolve, onFinishProgressive) => {
      progressiveRendering.setInProgressive(true);
      const {
        reducedCube
      } = storage;
      const reducedPages = reducedCube.qDataPages;
      if (!reducedPages.length) {
        onFinishProgressive(resolve);
        return;
      }
      const dataSize = reducedPages[0].qMatrix.length;
      const nbrOfChunks = measureCount;
      let renderCount = 0;
      const renderChunk = () => {
        progressiveRendering.reducedLineTimer = requestAnimationFrame(() => {
          const start = Math.max(0, renderCount * dataSize);
          const end = Math.min(dataSize * measureCount, (renderCount + 1) * dataSize);
          meta.reducedLineProgressive = {
            start,
            end,
            isFirst: renderCount === 0,
            isLast: renderCount === nbrOfChunks - 1
          };
          chart.update({
            partialData: true,
            excludeFromUpdate: exclude.duringReducedLineProgressive
          });
          renderCount++;
          if (renderCount < nbrOfChunks) {
            renderChunk();
          } else {
            onFinishProgressive(resolve);
          }
        });
      };
      renderChunk();
    };
    const renderProgressive1D = (resolve, isPartialUpdate) => {
      beforeAllProgressive(isPartialUpdate);
      progressiveRendering.renderPromise = {
        resolve
      };
      if (isPartialUpdate) {
        renderMainProgressive1D(resolve, afterMainProgressive);
      } else {
        const {
          reducedCube
        } = storage;
        const reducedPages = reducedCube.qDataPages;
        renderMainProgressive1D(resolve, afterMainProgressive);
        if (reducedPages.length && exclude.all.includes(REDUCED_LINE)) {
          renderReducedLinesProgressive1D(resolve, afterReducedLinesProgressive);
        }
      }
    };
    const renderMainProgressive2DStacked = (resolve, onFinishProgressive) => {
      const dataPages = layoutService.getDataPages();
      const dataSize = dataPages[0].qMatrix.length;
      const {
        lines,
        matrix
      } = mainLines;
      const numLines = lines.length;
      const lineSize = lines[0].points.length;
      const lineSegmentSizePerRender = calculateLineSegmentSizePerRender(lines);
      const nbrOfChunks = Math.ceil(lineSize / lineSegmentSizePerRender);
      let renderCount = 0;
      const renderChunk = () => {
        progressiveRendering.mainTimer = requestAnimationFrame(() => {
          if (!(chart !== null && chart !== void 0 && chart.update)) {
            resetProgressive({
              progressiveRendering,
              meta
            });
            return;
          }
          extractMainPages();
          const dataStart = renderCount * numLines * lineSegmentSizePerRender;
          const dataEnd = Math.min(dataSize, (renderCount + 1) * numLines * lineSegmentSizePerRender);
          const start = Math.max(dataStart - numLines, 0);
          const end = dataEnd;
          meta.pointProgressive = {
            start,
            end,
            isFirst: renderCount === 0,
            isLast: end === dataSize
          };
          meta.lineProgressive = {
            ...meta.pointProgressive
          };
          const chunk = [{
            ...storage.mainPages[0],
            qMatrix: matrix.slice(dataStart, dataEnd)
          }];
          layoutService.setDataPages(chunk);
          chart.update({
            partialData: true,
            excludeFromUpdate: exclude.duringMainProgressive
          });
          insertMainPages();
          renderCount++;
          if (renderCount < nbrOfChunks) {
            renderChunk();
          } else {
            onFinishProgressive(resolve);
          }
        });
      };
      renderChunk();
    };
    const renderMainProgressive2DNonStacked = (resolve, onFinishProgressive) => {
      const dataPages = layoutService.getDataPages();
      const dataSize = dataPages[0].qMatrix.length;
      const {
        chunks
      } = mainLines;
      const nbrOfChunks = chunks.length;
      let renderCount = 0;
      let start = 0;
      const renderChunk = () => {
        progressiveRendering.mainTimer = requestAnimationFrame(() => {
          if (!(chart !== null && chart !== void 0 && chart.update)) {
            resetProgressive({
              progressiveRendering,
              meta
            });
            return;
          }
          extractMainPages();
          const end = Math.min(dataSize, start + chunks[renderCount].length);
          meta.pointProgressive = {
            start,
            end,
            isFirst: renderCount === 0,
            isLast: renderCount === nbrOfChunks - 1
          };
          meta.lineProgressive = {
            ...meta.pointProgressive
          };
          start = end;
          const chunk = [{
            ...storage.mainPages[0],
            qMatrix: chunks[renderCount]
          }];
          layoutService.setDataPages(chunk);
          chart.update({
            partialData: true,
            excludeFromUpdate: exclude.duringMainProgressive
          });
          insertMainPages();
          renderCount++;
          if (renderCount < nbrOfChunks) {
            renderChunk();
          } else {
            onFinishProgressive(resolve);
          }
        });
      };
      renderChunk();
    };
    const renderMainProgressive2D = (resolve, onFinishProgressive) => {
      progressiveRendering.setInProgressive(true);
      const dataPages = layoutService.getDataPages();
      if (!dataPages.length) {
        onFinishProgressive(resolve);
        return;
      }
      groupByLine(layoutService, dataPages, mainLines, isStacked, true);
      if (isStacked) {
        renderMainProgressive2DStacked(resolve, onFinishProgressive);
      } else {
        renderMainProgressive2DNonStacked(resolve, onFinishProgressive);
      }
    };
    const renderReducedLinesProgressive2DStacked = (resolve, onFinishProgressive) => {
      const {
        reducedCube
      } = storage;
      const reducedPages = reducedCube.qDataPages;
      const dataSize = reducedPages[0].qMatrix.length;
      const {
        lines,
        matrix
      } = mainLines;
      const numLines = lines.length;
      const lineSize = lines[0].points.length;
      const lineSegmentSizePerRender = calculateLineSegmentSizePerRender(lines);
      const nbrOfChunks = Math.ceil(lineSize / lineSegmentSizePerRender);
      let renderCount = 0;
      const renderChunk = () => {
        progressiveRendering.reducedLineTimer = requestAnimationFrame(() => {
          if (!(chart !== null && chart !== void 0 && chart.update)) {
            resetProgressive({
              progressiveRendering,
              meta
            });
            return;
          }
          extractReducedPages();
          const dataStart = renderCount * numLines * lineSegmentSizePerRender;
          const dataEnd = Math.min(dataSize, (renderCount + 1) * numLines * lineSegmentSizePerRender);
          const start = Math.max(dataStart - numLines, 0);
          const end = dataEnd;
          meta.reducedLineProgressive = {
            start,
            end,
            isFirst: renderCount === 0,
            isLast: end === dataSize
          };
          const chunk = [{
            ...storage.reducedPages[0],
            qMatrix: matrix.slice(dataStart, dataEnd)
          }];
          reducedCube.qDataPages = chunk;
          chart.update({
            partialData: true,
            excludeFromUpdate: exclude.duringReducedLineProgressive
          });
          insertReducedPages();
          renderCount++;
          if (renderCount < nbrOfChunks) {
            renderChunk();
          } else {
            onFinishProgressive(resolve);
          }
        });
      };
      renderChunk();
    };
    const renderReducedLinesProgressive2DNonStacked = (resolve, onFinishProgressive) => {
      const {
        reducedCube
      } = storage;
      const reducedPages = reducedCube.qDataPages;
      const dataSize = reducedPages[0].qMatrix.length;
      const {
        chunks
      } = reducedLines;
      const nbrOfChunks = chunks.length;
      let renderCount = 0;
      let start = 0;
      const renderChunk = () => {
        progressiveRendering.reducedLineTimer = requestAnimationFrame(() => {
          if (!(chart !== null && chart !== void 0 && chart.update)) {
            resetProgressive({
              progressiveRendering,
              meta
            });
            return;
          }
          extractReducedPages();
          const end = Math.min(dataSize, start + chunks[renderCount].length);
          meta.reducedLineProgressive = {
            start,
            end,
            isFirst: renderCount === 0,
            isLast: renderCount === nbrOfChunks - 1
          };
          start = end;
          const chunk = [{
            ...storage.reducedPages[0],
            qMatrix: chunks[renderCount]
          }];
          reducedCube.qDataPages = chunk;
          chart.update({
            partialData: true,
            excludeFromUpdate: exclude.duringReducedLineProgressive
          });
          insertReducedPages();
          renderCount++;
          if (renderCount < nbrOfChunks) {
            renderChunk();
          } else {
            onFinishProgressive(resolve);
          }
        });
      };
      renderChunk();
    };
    const renderReducedLinesProgressive2D = (resolve, onFinishProgressive) => {
      progressiveRendering.setInProgressive(true);
      const {
        reducedCube
      } = storage;
      const reducedPages = reducedCube.qDataPages;
      if (!reducedPages.length) {
        onFinishProgressive(resolve);
        return;
      }
      groupByLine(layoutService, reducedPages, reducedLines, isStacked);
      if (isStacked) {
        renderReducedLinesProgressive2DStacked(resolve, onFinishProgressive);
      } else {
        renderReducedLinesProgressive2DNonStacked(resolve, onFinishProgressive);
      }
    };
    const renderProgressive2D = (resolve, isPartialUpdate) => {
      beforeAllProgressive(isPartialUpdate);
      progressiveRendering.renderPromise = {
        resolve
      };
      if (isPartialUpdate) {
        renderMainProgressive2D(resolve, afterMainProgressive);
      } else {
        const {
          reducedCube
        } = storage;
        const reducedPages = reducedCube.qDataPages;
        renderMainProgressive2D(resolve, afterMainProgressive);
        if (reducedPages.length && exclude.all.includes(REDUCED_LINE)) {
          renderReducedLinesProgressive2D(resolve, afterReducedLinesProgressive);
        }
      }
    };
    const renderProgressive = (resolve, isPartialUpdate) => {
      if (isOneDimensional) {
        renderProgressive1D(resolve, isPartialUpdate);
      } else {
        renderProgressive2D(resolve, isPartialUpdate);
      }
    };
    const highlightLines = ({
      render,
      nodes
    }) => brushLines({
      chart,
      layoutService,
      progressiveRendering,
      meta,
      render,
      nodes,
      timerId: 'highlighterTimer',
      progressiveId: 'highlighterProgressive',
      shouldUseProgressive: shouldUseProgressive$1
    });
    const dimLines = ({
      render,
      nodes
    }) => brushLines({
      chart,
      layoutService,
      progressiveRendering,
      meta,
      render,
      nodes,
      timerId: 'lineTimer',
      progressiveId: 'lineProgressive',
      shouldUseProgressive: shouldUseProgressive$1
    });
    const clear = () => {
      if (progressiveRendering.mainTimer !== null || progressiveRendering.pointTimer !== null || progressiveRendering.lineTimer !== null || progressiveRendering.reducedLineTimer !== null) {
        resetProgressive({
          progressiveRendering,
          meta
        });
        extractMainPages();
        extractReducedPages();
        chart.update({
          partialData: true,
          excludeFromUpdate: exclude.forClearProgressive
        });
        insertMainPages();
        insertReducedPages();
      }
    };
    return {
      meta,
      exclude,
      getSelectionContext: () => isLargeNumPoints ? 'lazySelection' : 'selection',
      shouldUseProgressive: shouldUseProgressive$1,
      isLargeNumVisiblePoints: () => isLargeNumVisiblePoints({
        layoutService,
        maxNumPoints,
        maxNumLines
      }),
      resetProgressive: isPartialUpdate => resetProgressive({
        progressiveRendering,
        isPartialUpdate,
        meta
      }),
      renderProgressive,
      brushPoints: ({
        render,
        nodes
      }) => brushPoints({
        chart,
        shouldUseProgressive: shouldUseProgressive$1,
        progressiveRendering,
        meta,
        render,
        nodes
      }),
      dimLines,
      highlightLines,
      setReducedCube: reducedCube => {
        storage.reducedCube = reducedCube;
      },
      clear
    };
  }

  function getLogicalSize({
    layout,
    options = {}
  }) {
    return layout !== null && layout !== void 0 && layout.snapshotData && !options.freeResize ? {
      width: layout.snapshotData.content.size.w,
      height: layout.snapshotData.content.size.h
    } : false;
  }

  /**
   * The arguments that are passed to the fn function of the plugin definition.
   * @namespace pluginArguments
   * @entry
   */

  /**
   * Prepare important chart internals for the users to build their own plugins
   * @param {object} layoutService
   * @returns {pluginArguments} Chart internals that will be exposed to the users.
   */
  function getPluginArgs(layoutService) {
    /**
     * @lends pluginArguments
     */
    const pluginArgs = {
      /**
       * The layout from the enigma model.
       * @type {object}
       */
      layout: layoutService.getLayout(),
      /**
       * The keys (references) to different types of chart internals
       * @type {object}
       */
      keys: {
        /**
         * The scales associated with the line chart
         * They are useful if you want to, via plugin, add a new component that
         * uses the same scale as one of the measures.
         * @type {object}
         */
        SCALE: {
          /**
           * The main scales
           * @type {object}
           */
          MAIN: {
            /**
             * The main minor scale
             * @type {string}
             */
            MINOR: KEYS.SCALE.MAIN.MINOR,
            /**
             * The main major scale
             * @type {string}
             */
            MAJOR: KEYS.SCALE.MAIN.MAJOR
          }
        },
        /**
         * The unique keys of the existing components available in the chart.
         * They are useful if you want to extend or override the existing components.
         * @type {object}
         */
        COMPONENT: {
          /**
           * The line component
           * @type {string}
           */
          LINE: KEYS.COMPONENT.LINE,
          /**
           * The major axis component
           * @type {string}
           */
          MAJOR_AXIS: KEYS.COMPONENT.MAJOR_AXIS,
          /**
           * The major axis time inner component
           * @type {string}
           */
          MAJOR_AXIS_TIME_INNER: KEYS.COMPONENT.MAJOR_AXIS_TIME_INNER,
          /**
           * The major axis title component
           * @type {string}
           */
          MAJOR_AXIS_TITLE: KEYS.COMPONENT.MAJOR_AXIS_TITLE,
          /**
           * The minor axis component
           * @type {string}
           */
          MINOR_AXIS: KEYS.COMPONENT.MINOR_AXIS,
          /**
           * The minor axis title component
           * @type {string}
           */
          MINOR_AXIS_TITLE: KEYS.COMPONENT.MINOR_AXIS_TITLE
        },
        /**
         * The data collections the users can use to get data from
         * @type {object}
         */
        COLLECTION: {
          /**
           * The main data collection
           * @type {string}
           */
          MAIN: KEYS.COLLECTION.MAIN
        }
      }
    };
    return pluginArgs;
  }

  var LINE_WIDTHS = {
    SPARK: {
      DEFAULT: 7,
      SQUEEZE: 7,
      LABELLESS: 7
    },
    XSMALL: {
      DEFAULT: 28,
      SQUEEZE: 24,
      LABELLESS: 20
    },
    SMALL: {
      DEFAULT: 28,
      SQUEEZE: 24,
      LABELLESS: 20
    },
    MEDIUM: {
      DEFAULT: 28,
      SQUEEZE: 24,
      LABELLESS: 20
    },
    FULL: {
      DEFAULT: 28,
      SQUEEZE: 24,
      LABELLESS: 20
    }
  };

  function useServices({
    core
  }) {
    const app = stardust.useApp();
    const appLayout = stardust.useAppLayout();
    const embed = stardust.useEmbed();
    const model = stardust.useModel();
    const options = stardust.useOptions();
    const plugins = stardust.usePlugins();
    const selections = stardust.useSelections();
    const layout = stardust.useStaleLayout();
    const theme = stardust.useTheme();
    const translator = stardust.useTranslator();
    const [selectionService, setSelectionService] = stardust.useState();
    const [services, setServices] = stardust.useState();
    stardust.useEffect(() => {
      if (!core) {
        return () => {};
      }
      const {
        actions,
        chart
      } = core;
      const ss = createService({
        actions,
        chart,
        selections
      });
      setSelectionService(ss);
      return function destroy() {
        ss.destroy();
        ss.destroyLazySelection();
      };
    }, [core]);
    stardust.useEffect(() => {
      if (!selectionService) {
        return;
      }
      const {
        qLocaleInfo: localeInfo
      } = appLayout;
      const rtl = options.direction === 'rtl';
      const {
        actions,
        chart,
        flags,
        isUnsupportedFeature,
        picasso,
        viewCache,
        viewState,
        progressiveRendering
      } = core;
      const layoutService = At({
        source: layout,
        metaAdditionsFn: createLayoutServiceMeta(isUnsupportedFeature),
        experimental: {
          filter: flags.isEnabled('IM_1869_HIDE_DIM_MEA_LINE')
        }
      });
      selectionService.setFilteredFields(layoutService.meta.filteredFields);
      selectionService.setLayout(layoutService.getLayout());
      const themeService = So({
        theme,
        config: {
          id: 'lineChart'
        }
      });
      const dockService = gt({
        chart,
        layoutService,
        config: {
          logicalSize: getLogicalSize({
            layout: layoutService.getLayout(),
            options
          }),
          rtl
        },
        typeConfig: {
          type: 'major-minor',
          fallback: 'horizontal',
          invert: false
        }
      });
      const largeDataService = createLargeDataService({
        chart,
        layoutService,
        progressiveRendering,
        flags,
        options
      });
      const dataProcessorModel = createDataProcessorModel({
        layoutService
      });
      const legendModel = createLegendModel({
        layoutService
      });
      const fieldModel = createFieldModel({
        layoutService
      });
      const reducedModel = createReducedModel({
        enigmaModel: model,
        layoutService,
        dataProcessorModel
      });
      const continuousModel = layoutService.meta.isContinuous ? continuous$1.model({
        model,
        viewState,
        viewCache,
        layoutService,
        largeDataService,
        dataProcessorModel
      }) : undefined;
      if (continuousModel) {
        continuousModel.update(layoutService.getLayout());
      }
      const colorService = createColorService({
        app,
        model,
        translator,
        picasso,
        localeInfo,
        theme,
        layoutService,
        reducedModel,
        legendModel,
        continuousModel
      });
      const trendLineModel = create$F({
        layoutService,
        viewState,
        colorModel: {
          settings: () => colorService.getMain().getSettings(),
          resolveUIColor: color => colorService.getMain().getPaletteColor(color)
        },
        chart,
        env: {
          translator
        },
        keys: {
          colorScale: KEYS.SCALE.MAIN.COLOR
        },
        isEnabled: () => layoutService.meta.dimensionCount < 2
      });
      trendLineModel.command.update();
      const extremumModel = createExtremumModel({
        layoutService,
        reducedModel,
        continuousModel,
        trendLineModel
      });
      const disclaimerModel = createDisclaimerModel({
        layoutService,
        largeDataService,
        extremumModel,
        flags
      });
      const chartModel = createChartModel({
        picasso,
        chart,
        localeInfo,
        continuousModel,
        layoutService,
        reducedModel,
        legendModel,
        fieldModel,
        trendLineModel,
        colorService,
        largeDataService,
        progressiveRendering,
        options,
        flags,
        viewCache
      });
      const styleModel = createStyleModel({
        layoutService,
        dockService,
        themeService,
        flags
      });
      const tickModel = createTickModel({
        chart,
        layoutService,
        chartModel,
        extremumModel,
        dockService,
        themeService
      });
      const customTooltipService = createCustomTooltipService({
        app,
        chart,
        embed,
        flags,
        layout: layoutService.getLayout(),
        localeInfo,
        model,
        options: {
          direction: options.direction
        },
        picasso,
        translator
      });
      const tooltipService = createTooltipService({
        actions,
        chart,
        colorService,
        custom: customTooltipService,
        fieldModel,
        layoutService,
        rtl,
        themeService,
        tickModel,
        translator,
        trendLineModel,
        viewState
      });
      const discreteModel = layoutService.meta.isDiscrete ? create({
        chart,
        actions,
        componentKey: KEYS.COMPONENT.LINE,
        enigmaModel: model,
        layoutService,
        dockService,
        trendLineModel,
        itemWidths: LINE_WIDTHS,
        viewState,
        rtl,
        reducedModel,
        options: {
          axisKey: KEYS.COMPONENT.MAJOR_AXIS,
          renderer: picasso.renderer('svg')(),
          areaBuffer: layoutService.meta.isTwoDimensional || dataProcessorModel.query.getShouldProcess() ? 40 : 12,
          processDataPage: dataPage => dataProcessorModel.command.processDataPage({
            dataPage
          })
        }
      }) : undefined;
      const refLineModel = createRefLineModel({
        layoutService,
        discreteModel
      });
      const pluginService = Lt({
        picassoInstance: picasso,
        plugins: plugins || [],
        pluginArgs: getPluginArgs(layoutService)
      });
      setServices({
        chartModel,
        colorService,
        continuousModel,
        customTooltipService,
        dataProcessorModel,
        disclaimerModel,
        discreteModel,
        dockService,
        extremumModel,
        fieldModel,
        layoutService,
        legendModel,
        pluginService,
        reducedModel,
        refLineModel,
        selectionService,
        styleModel,
        themeService,
        tickModel,
        tooltipService,
        trendLineModel,
        largeDataService
      });
    }, [layout, options.direction, selectionService, theme.name(), translator.language()]);
    return services;
  }

  function getLabel$1({
    dataset,
    minor
  }) {
    const field = dataset.field(minor);
    const useFormatter = util$2.shouldUseFormat(field.raw());
    if (!useFormatter) {
      return function getText(cell) {
        return cell.qText;
      };
    }
    const formatter = field.formatter();
    return function getFormattedLabel(cell) {
      const {
        qNum,
        qValue,
        interpolated
      } = cell;
      if (qNum !== undefined && qNum !== 'NaN' && !interpolated) {
        return formatter(qNum);
      }
      if (qValue !== undefined && qValue !== 'NaN' && !interpolated) {
        return formatter(qValue);
      }
      return '-';
    };
  }

  function getColoring({
    colorService,
    index
  }) {
    const coloring = {};
    const colorProps = colorService.getMain().getDatumProps(index);
    Object.keys(colorProps).forEach(key => {
      if (colorProps[key] !== undefined) {
        coloring[key] = colorProps[key];
      }
    });
    const color = colorProps[KEYS.SCALE.MAIN.COLOR];
    if (color && color.field) {
      coloring.colorTooltip = {
        field: color.field,
        value: d => {
          if (d.qNum !== undefined && d.qNum !== 'NaN') {
            return d.qNum;
          }
          return d.qText || '-';
        }
      };
    }
    return coloring;
  }

  function createOneDimensional$3({
    layoutService,
    chartModel,
    fieldModel,
    extremumModel,
    tickModel,
    colorService
  }) {
    const {
      isContinuous,
      isStacked,
      isZero
    } = layoutService.meta;
    const {
      minors,
      outer,
      outerNumeric
    } = fieldModel.main;
    const separateStacking = layoutService.getLayoutValue('separateStacking', true);
    const extrema = extremumModel.query.getExtrema();
    const logarithmic = layoutService.getLayoutValue('measureAxis.logarithmic', false) && !extrema.meta.includesZero;
    const excludeForecast = data => !data.fromDynamicScript.value;
    const definition = {
      key: KEYS.COLLECTION.MAIN,
      data: {
        extract: minors.map((minor, index) => ({
          field: outer,
          props: {
            major: {
              field: isContinuous ? outerNumeric : outer
            },
            end: {
              field: minor,
              label: getLabel$1({
                dataset: chartModel.query.getDataset(),
                minor
              })
            },
            selectionDimension: {
              field: outer
            },
            line: index,
            ...getColoring({
              colorService,
              index
            }),
            customTooltipAttrExps: customTooltipNodes.getNode(layoutService.getLayout(), layoutService.meta),
            null: {
              field: minor,
              value: d => d.qNum === 'NaN'
            },
            interpolated: {
              field: minor,
              value: d => !!d.interpolated
            },
            fromDynamicScript: {
              field: outer,
              value: d => d.qInExtRow
            },
            id: {
              value: d => `r${d.qRow}e${d.qElemNumber}m${index}`
            }
          }
        })),
        filter: excludeForecast
      }
    };
    if (isZero) {
      const getBoundary = () => extrema.min < 0 ? tickModel.query.getMax() : tickModel.query.getMin();
      const value = logarithmic ? d => d.qNum !== 'NaN' ? d.qNum : getBoundary() : d => d.qNum !== 'NaN' ? d.qNum : 0;
      minors.forEach((minor, index) => {
        const {
          end
        } = definition.data.extract[index].props;
        end.value = value;
      });
    }
    if (isStacked) {
      definition.data.stack = {
        stackKey: d => d.major.value,
        value: d => d.end.value,
        offset: separateStacking ? 'diverging' : 'none'
      };
      minors.forEach((minor, index) => {
        const {
          props
        } = definition.data.extract[index];
        props.point = {
          field: props.end.field,
          label: props.end.label
        };
        if (props.end.value) {
          props.point.value = props.end.value;
        }
      });
    }
    return definition;
  }

  function createTwoDimensional$2({
    layoutService,
    chartModel,
    fieldModel,
    extremumModel,
    tickModel,
    colorService
  }) {
    const {
      isContinuous,
      isStacked,
      isZero
    } = layoutService.meta;
    const separateStacking = layoutService.getLayoutValue('separateStacking', true);
    const valueProperty = isContinuous ? 'qNum' : 'qValue';
    const extrema = extremumModel.query.getExtrema();
    const logarithmic = layoutService.getLayoutValue('measureAxis.logarithmic', false) && !extrema.meta.includesZero;
    const {
      outer,
      outerNumeric,
      inner,
      minors
    } = fieldModel.main;
    const [minor] = minors;
    const definition = {
      key: KEYS.COLLECTION.MAIN,
      data: {
        extract: {
          field: inner,
          props: {
            major: {
              field: isContinuous ? outerNumeric : outer
            },
            end: {
              field: minor,
              label: getLabel$1({
                dataset: chartModel.query.getDataset(),
                minor
              }),
              reduceLabel: 'first'
            },
            selectionDimension: {
              field: inner
            },
            selectionOuterDimension: {
              field: outer
            },
            line: {
              field: inner
            },
            customTooltipAttrExps: customTooltipNodes.getNode(layoutService.getLayout(), layoutService.meta),
            null: {
              field: minor,
              value: d => d[valueProperty] === 'NaN',
              reduce: 'first'
            },
            interpolated: {
              field: minor,
              value: d => !!d.interpolated,
              reduce: 'first'
            },
            ...getColoring({
              colorService
            })
          }
        }
      }
    };
    if (isZero) {
      const getBoundary = () => extrema.min < 0 ? tickModel.query.getMax() : tickModel.query.getMin();
      definition.data.extract.props.end.value = logarithmic ? d => d[valueProperty] !== 'NaN' ? d[valueProperty] : getBoundary() : d => d[valueProperty] !== 'NaN' ? d[valueProperty] : 0;
    }
    if (isStacked) {
      definition.data.stack = {
        stackKey: d => d.major.value,
        value: d => d.end.value,
        offset: separateStacking ? 'diverging' : 'none'
      };
      const {
        props
      } = definition.data.extract;
      props.point = {
        field: props.end.field,
        label: props.end.label,
        reduceLabel: props.end.reduceLabel
      };
      if (props.end.value) {
        props.point.value = props.end.value;
      }
    }
    return definition;
  }

  function createMainCollection({
    layoutService,
    chartModel,
    fieldModel,
    extremumModel,
    tickModel,
    colorService,
    resources
  }) {
    const create = layoutService.meta.isOneDimensional ? createOneDimensional$3 : createTwoDimensional$2;
    return create({
      layoutService,
      chartModel,
      fieldModel,
      extremumModel,
      tickModel,
      colorService,
      resources
    });
  }

  function createOneDimensional$2({
    layoutService,
    reducedModel,
    fieldModel,
    extremumModel,
    tickModel,
    colorService
  }) {
    const {
      isStacked,
      isZero
    } = layoutService.meta;
    const {
      minors,
      outer
    } = fieldModel.reduced;
    const isReduced = reducedModel.query.getIsReduced();
    const separateStacking = layoutService.getLayoutValue('separateStacking', true);
    const extrema = extremumModel.query.getExtrema();
    const logarithmic = layoutService.getLayoutValue('measureAxis.logarithmic', false) && !extrema.meta.includesZero;
    const definition = {
      key: KEYS.COLLECTION.REDUCED,
      data: {
        extract: minors.map((minor, index) => {
          const color = isReduced ? {} : colorService.getMain().getDatumProps(index);
          return {
            source: KEYS.DATA.REDUCED,
            field: outer,
            props: {
              major: {
                field: outer
              },
              end: {
                field: minor
              },
              line: index,
              ...color
            }
          };
        })
      }
    };
    if (isZero) {
      const getBoundary = () => extrema.min < 0 ? tickModel.query.getMax() : tickModel.query.getMin();
      const value = logarithmic ? d => d.qNum !== 'NaN' ? d.qNum : getBoundary() : d => d.qNum !== 'NaN' ? d.qNum : 0;
      minors.forEach((minor, index) => {
        const {
          end
        } = definition.data.extract[index].props;
        end.value = value;
      });
    }
    if (isStacked) {
      definition.data.stack = {
        stackKey: d => d.major.value,
        value: d => d.end.value,
        offset: separateStacking ? 'diverging' : 'none'
      };
      minors.forEach((minor, index) => {
        const {
          props
        } = definition.data.extract[index];
        props.point = {
          field: props.end.field
        };
      });
    }
    return definition;
  }

  function createTwoDimensional$1({
    layoutService,
    fieldModel
  }) {
    if (!layoutService.meta.isStacked) {
      return false;
    }
    const separateStacking = layoutService.getLayoutValue('separateStacking', true);
    const {
      inner,
      minors
    } = fieldModel.reduced;
    return {
      key: KEYS.COLLECTION.REDUCED,
      data: {
        extract: minors.map(minor => ({
          source: KEYS.DATA.REDUCED,
          field: inner,
          props: {
            major: {
              field: inner
            },
            end: {
              field: minor
            },
            point: {
              field: minor
            }
          }
        })),
        stack: {
          stackKey: d => d.major.value,
          value: d => d.end.value,
          offset: separateStacking ? 'diverging' : 'none'
        }
      }
    };
  }

  function createReducedCollection$2({
    layoutService,
    reducedModel,
    fieldModel,
    extremumModel,
    tickModel,
    colorService
  }) {
    const create = layoutService.meta.isOneDimensional ? createOneDimensional$2 : createTwoDimensional$1;
    return create({
      layoutService,
      reducedModel,
      fieldModel,
      extremumModel,
      tickModel,
      colorService
    });
  }

  function createOneDimensional$1({
    colorService,
    main
  }) {
    const collection = extend$7(true, {}, main);
    collection.key = KEYS.COLLECTION.REDUCED;
    collection.data.extract.forEach((extract, index) => {
      // eslint-disable-next-line no-param-reassign
      extract.source = KEYS.DATA.REDUCED;
      Object.assign(extract.props, colorService.getReduced().getDatumProps(index));
    });
    return collection;
  }

  function createTwoDimensional({
    main
  }) {
    const collection = extend$7(true, {}, main);
    collection.key = KEYS.COLLECTION.REDUCED;
    collection.data.extract.source = KEYS.DATA.REDUCED;
    return collection;
  }

  function createReducedCollection$1({
    layoutService,
    colorService,
    main
  }) {
    const create = layoutService.meta.isOneDimensional ? createOneDimensional$1 : createTwoDimensional;
    return create({
      colorService,
      main
    });
  }

  function createReducedCollection({
    layoutService,
    reducedModel,
    fieldModel,
    extremumModel,
    tickModel,
    colorService,
    main
  }) {
    if (!resolveScrollbar({
      layoutService
    }).miniChart) {
      return false;
    }
    const {
      isDiscrete
    } = layoutService.meta;
    if (isDiscrete) {
      return createReducedCollection$2({
        layoutService,
        reducedModel,
        fieldModel,
        extremumModel,
        tickModel,
        colorService
      });
    }
    return createReducedCollection$1({
      layoutService,
      colorService,
      main
    });
  }

  function getLabel({
    dataset,
    minor
  }) {
    const field = dataset.field(minor);
    const formatter = field.formatter();
    return function getFormattedLabel(cell) {
      const {
        qNum,
        qValue,
        interpolated
      } = cell;
      if (qNum !== undefined && qNum !== 'NaN' && !interpolated) {
        return formatter(qNum);
      }
      if (qValue !== undefined && qValue !== 'NaN' && !interpolated) {
        return formatter(qValue);
      }
      return '-';
    };
  }

  // import { nodes as customTooltipNodes } from '@qlik/custom-tooltips';
  function createOneDimensional({
    chartModel,
    fieldModel,
    colorService
  }) {
    const {
      outer,
      outerNumeric
    } = fieldModel.main;
    const measures = fieldModel.forecast;
    const definition = {
      key: KEYS.COLLECTION.FORECAST,
      data: {
        extract: measures.map(({
          measureIndex: index,
          field: minor,
          lower,
          upper
        }) => ({
          field: outer,
          props: {
            major: {
              field: outerNumeric
            },
            end: {
              field: minor,
              label: getLabel({
                dataset: chartModel.query.getDataset(),
                minor: `qMeasureInfo/${index}`
              })
            },
            lower: {
              field: lower
            },
            upper: {
              field: upper
            },
            // selectionDimension: {
            //   field: outer,
            //   value: (d) => (d.qInExtRow ? -2 : d.qElemNumber),
            // },
            line: index,
            ...getColoring({
              colorService,
              index
            }),
            // customTooltipAttrExps: customTooltipNodes.getNode(layoutService.getLayout(), layoutService.meta),
            null: {
              field: minor,
              value: d => d.qNum === 'NaN'
            },
            interpolated: {
              field: minor,
              value: d => !!d.interpolated
            },
            fromDynamicScript: {
              field: outer,
              value: d => d.qInExtRow
            },
            id: {
              value: d => `r${d.qRow}e${d.qElemNumber}m${index}`
            }
          }
        }))
      }
    };

    // if (isZero) {
    //   const getBoundary = () => (extrema.min < 0 ? tickModel.query.getMax() : tickModel.query.getMin());
    //   const value = logarithmic
    //     ? (d) => (d.qNum !== 'NaN' ? d.qNum : getBoundary())
    //     : (d) => (d.qNum !== 'NaN' ? d.qNum : 0);

    //   minors.forEach((minor, index) => {
    //     const { end } = definition.data.extract[index].props;
    //     end.value = value;
    //   });
    // }

    return definition;
  }

  function createCollections$1({
    chartModel,
    layoutService,
    fieldModel,
    colorService
  }) {
    const {
      isContinuous
    } = layoutService.meta;
    if (!isContinuous || fieldModel.forecast.length === 0) {
      return [];
    }
    const collections = [];
    const main = createOneDimensional({
      chartModel,
      fieldModel,
      colorService
    });
    collections.push(main);
    if (resolveScrollbar({
      layoutService
    }).miniChart) {
      const reduced = extend$7(true, {}, main);
      reduced.key = KEYS.COLLECTION.REDUCED_FORECAST;
      reduced.data.extract.forEach(extract => {
        // eslint-disable-next-line no-param-reassign
        extract.source = KEYS.DATA.REDUCED;
      });
      collections.push(reduced);
    }
    return collections;
  }

  function createCollections({
    layoutService,
    reducedModel,
    fieldModel,
    chartModel,
    extremumModel,
    tickModel,
    colorService,
    resources
  }) {
    const main = createMainCollection({
      layoutService,
      fieldModel,
      chartModel,
      extremumModel,
      tickModel,
      colorService,
      resources
    });
    const collections = [main, createReducedCollection({
      layoutService,
      reducedModel,
      fieldModel,
      extremumModel,
      tickModel,
      colorService,
      main
    }), ...createCollections$1({
      chartModel,
      layoutService,
      fieldModel,
      colorService
    })];
    return collections.filter(Boolean);
  }

  var MODES = {
    AXIS: {
      MAJOR: {
        horizontal: {
          width: 'XSMALL',
          height: 'SMALL'
        },
        vertical: {
          width: 'SMALL',
          height: 'XSMALL'
        }
      },
      MINOR: 'XSMALL'
    },
    AXIS_TITLE: {
      MAJOR: {
        horizontal: {
          width: 'XSMALL',
          height: 'MEDIUM'
        },
        vertical: {
          width: 'MEDIUM',
          height: 'XSMALL'
        }
      },
      MINOR: 'SMALL'
    },
    GRID_LINE: 'XSMALL',
    VALUE_LABEL: 'XSMALL',
    LABEL_SPACE: 'XSMALL',
    OUT_OF_BOUNDS_MARKER: 'XSMALL',
    REDUCED_LINE: 'XSMALL',
    REFERENCE_LINE: 'SPARK'
  };

  function createMinorAxis({
    resources,
    layoutService,
    dockService,
    themeService,
    chartModel,
    styleModel
  }) {
    const axis = layoutService.getLayoutValue('measureAxis');
    const labelStyle = styleModel.query.axis.label.getStyle();
    if (!axis) {
      return false;
    }
    const {
      show
    } = axis;
    if (show === 'none') {
      return false;
    }
    const styles = themeService.getStyles();
    return {
      type: 'axis',
      key: KEYS.COMPONENT.MINOR_AXIS,
      renderer: getTextRenderer(resources.flags),
      scale: KEYS.SCALE.MAIN.MINOR,
      layout: {
        dock: dockService.meta.minor.dock,
        minimumLayoutMode: MODES.AXIS.MINOR
      },
      settings: {
        labels: {
          show: show !== 'title',
          fontSize: labelStyle.fontSize,
          fontFamily: labelStyle.fontFamily,
          fill: labelStyle.fill
        },
        line: {
          stroke: styles.axis.line.major.color
        },
        ticks: {
          stroke: styles.axis.line.major.color
        },
        minorTicks: {
          stroke: styles.axis.line.minor.color
        }
      },
      animations: {
        enabled: chartModel.query.animationsEnabled,
        trackBy: animations.axes.trackBy({
          isMeasure: true
        }),
        compensateForLayoutChanges: animations.axes.compensateForLayoutChanges({
          isMeasure: true,
          dock: dockService.meta.minor.dock
        })
      }
    };
  }

  function getGlyphCount({
    layoutService
  }) {
    const glyphCount = layoutService.getHyperCubeValue('qDimensionInfo.0.qApprMaxGlyphCount');
    const [dataPage] = layoutService.getDataPages();
    const stacked = layoutService.meta.mode.K;
    const data = stacked ? dataPage.qData[0].qSubNodes : dataPage.qMatrix;
    const index = stacked ? undefined : 0;
    const adjusted = stringUtils.getAdjustedMaxGlyphCount(glyphCount, data, index, 'qText');
    return adjusted;
  }

  function createMajorDiscreteAxis({
    context,
    resources,
    layoutService,
    dockService,
    themeService,
    chartModel,
    styleModel
  }) {
    const {
      show,
      label
    } = layoutService.getLayoutValue('dimensionAxis');
    const {
      auto,
      spacing
    } = layoutService.getLayoutValue('gridLine', {});
    const {
      orientation
    } = dockService.meta.major;
    const horizontal = orientation === 'horizontal';
    const styles = themeService.getStyles();
    const labelStyle = styleModel.query.axis.label.getStyle();
    const maxGlyphCount = getGlyphCount({
      layoutService
    });
    const mode = horizontal ? label : 'auto';
    return {
      type: 'axis',
      key: KEYS.COMPONENT.MAJOR_AXIS,
      renderer: getTextRenderer(resources.flags),
      scale: KEYS.SCALE.MAIN.MAJOR,
      layout: {
        dock: dockService.meta.major.dock,
        minimumLayoutMode: MODES.AXIS.MAJOR[orientation]
      },
      settings: {
        labels: {
          show: show !== 'title',
          mode,
          tiltAngle: context.rtl ? -40 : 40,
          maxEdgeBleed: 50,
          maxLengthPx: mode === 'horizontal' ? undefined : dockService.meta.minor.size / 4,
          maxGlyphCount,
          tiltThreshold: maxGlyphCount > 3 && maxGlyphCount < 13 ? 1 : undefined,
          fontSize: labelStyle.fontSize,
          fontFamily: labelStyle.fontFamily,
          fill: labelStyle.fill
        },
        line: {
          show: !auto && spacing === 0,
          stroke: styles.axis.line.major.color
        },
        paddingEnd: 4
      },
      brush: {
        consume: [{
          context: 'selection',
          data: ['selectionDimension', 'selectionInnerDimension'],
          style: {
            inactive: {
              opacity: 0.5
            }
          }
        }]
      },
      animations: {
        enabled: chartModel.query.animationsEnabled,
        trackBy: animations.axes.trackBy({
          isMajor: true
        }),
        compensateForLayoutChanges: animations.axes.compensateForLayoutChanges({
          isHorizontal: horizontal
        })
      }
    };
  }

  function createMajorContinuousAxis({
    resources,
    layoutService,
    dockService,
    themeService,
    chartModel,
    styleModel
  }) {
    const {
      show
    } = layoutService.getLayoutValue('dimensionAxis');
    const {
      auto,
      spacing
    } = layoutService.getLayoutValue('gridLine', {});
    const {
      orientation
    } = dockService.meta.major;
    const styles = themeService.getStyles();
    const labelStyle = styleModel.query.axis.label.getStyle();
    return {
      type: 'axis',
      key: KEYS.COMPONENT.MAJOR_AXIS_CONTINUOUS,
      renderer: getTextRenderer(resources.flags),
      scale: KEYS.SCALE.MAIN.MAJOR,
      layout: {
        dock: dockService.meta.major.dock,
        minimumLayoutMode: MODES.AXIS.MAJOR[orientation]
      },
      settings: {
        labels: {
          show: show !== 'title',
          align: 0,
          offset: 4,
          fontSize: labelStyle.fontSize,
          fontFamily: labelStyle.fontFamily,
          fill: labelStyle.fill
        },
        line: {
          show: !auto && spacing === 0
        },
        ticks: {
          show: true,
          stroke: styles.axis.line.major.color
        },
        minorTicks: {
          show: false
        }
      },
      animations: {
        enabled: chartModel.query.animationsEnabled,
        trackBy: animations.axes.trackBy({
          isContinuous: true
        }),
        compensateForLayoutChanges: animations.axes.compensateForLayoutChanges({
          isContinuous: true
        })
      }
    };
  }

  function createMajorTimeAxes({
    context,
    dockService,
    themeService,
    layoutService,
    chartModel,
    styleModel
  }) {
    const {
      rtl
    } = context;
    const {
      auto,
      spacing
    } = layoutService.getLayoutValue('gridLine', {});
    const {
      orientation
    } = dockService.meta.major;
    const align = dockService.meta.major.dock === 'bottom' ? 0 : 1;
    const styles = themeService.getStyles();
    const labelStyle = styleModel.query.axis.label.getStyle();
    const justify = rtl ? 1 : 0;
    const base = {
      type: 'time-axis',
      renderer: 'svg',
      layout: {
        dock: dockService.meta.major.dock,
        minimumLayoutMode: MODES.AXIS.MAJOR[orientation]
      },
      preferredSize: () => ({
        size: parseFloat(labelStyle.fontSize) * 2,
        edgeBleed: {
          left: 1,
          right: 1
        }
      }),
      settings: {
        anchor: rtl ? 'end' : 'start',
        label: {
          align,
          justify
        },
        guideLine: {
          major: {
            justify
          },
          minor: {
            align
          }
        }
      },
      style: {
        label: labelStyle,
        majorGuideLine: {
          stroke: styles.axis.line.major.color
        },
        minorGuideLine: {
          stroke: styles.axis.line.minor.color
        }
      },
      animations: {
        enabled: chartModel.query.animationsEnabled,
        trackBy: animations.axes.trackBy({
          isTime: true
        }),
        compensateForLayoutChanges: animations.axes.compensateForLayoutChanges({
          isTime: true
        })
      }
    };
    const inner = extend$7(true, {}, base, {
      key: KEYS.COMPONENT.MAJOR_AXIS_TIME_INNER,
      scale: KEYS.SCALE.MAIN.MAJOR_INNER,
      settings: {
        guideLine: {
          minor: {
            show: true
          }
        },
        line: {
          show: !auto && spacing === 0
        }
      },
      style: {
        line: {
          stroke: styles.axis.line.major.color
        },
        majorGuideLine: {
          stroke: styles.axis.line.minor.color // For some unknown reason Sense use minor styling here
        },

        minorGuideLine: {
          stroke: styles.axis.line.major.color // For some unknown reason Sense use major styling here
        }
      }
    });

    const outer = extend$7(true, {}, base, {
      key: KEYS.COMPONENT.MAJOR_AXIS_TIME_OUTER,
      scale: KEYS.SCALE.MAIN.MAJOR,
      settings: {
        guideLine: {
          minor: {
            show: false
          }
        },
        line: {
          show: false
        }
      }
    });
    return [inner, outer];
  }

  function createMajorAxis({
    context,
    resources,
    layoutService,
    dockService,
    themeService,
    chartModel,
    styleModel
  }) {
    const axis = layoutService.getLayoutValue('dimensionAxis');
    if (!axis || axis.show === 'none') {
      return [];
    }
    const {
      isDiscrete,
      isTime
    } = layoutService.meta;
    if (isDiscrete) {
      return [createMajorDiscreteAxis({
        context,
        resources,
        layoutService,
        dockService,
        themeService,
        chartModel,
        styleModel
      })];
    }
    if (isTime) {
      return createMajorTimeAxes({
        context,
        layoutService,
        dockService,
        themeService,
        chartModel,
        styleModel
      });
    }
    return [createMajorContinuousAxis({
      resources,
      layoutService,
      dockService,
      themeService,
      chartModel,
      styleModel
    })];
  }

  function createAxes({
    context,
    resources,
    layoutService,
    dockService,
    themeService,
    chartModel,
    styleModel
  }) {
    return {
      majors: [...createMajorAxis({
        context,
        resources,
        layoutService,
        dockService,
        themeService,
        chartModel,
        styleModel
      })],
      minor: createMinorAxis({
        resources,
        layoutService,
        dockService,
        themeService,
        chartModel,
        styleModel
      })
    };
  }

  function createAxisOverlays({
    layoutService,
    dockService
  }) {
    const {
      isContinuous,
      isTime
    } = layoutService.meta;
    const axis = layoutService.getLayoutValue('dimensionAxis');
    if (!axis || axis.show === 'none' || axis.show === 'title') {
      return [false];
    }
    if (!isContinuous) {
      return [false];
    }
    const minimumLayoutMode = MODES.AXIS.MAJOR[dockService.meta.major.orientation];
    if (isTime) {
      return [{
        type: 'axis-overlay',
        key: KEYS.COMPONENT.MAJOR_AXIS_OVERLAY_TIME_INNER,
        scale: KEYS.SCALE.MAIN.MAJOR_INNER,
        layout: {
          dock: `@${KEYS.COMPONENT.MAJOR_AXIS_TIME_INNER}`,
          minimumLayoutMode
        }
      }, {
        type: 'axis-overlay',
        key: KEYS.COMPONENT.MAJOR_AXIS_OVERLAY_TIME_OUTER,
        scale: KEYS.SCALE.MAIN.MAJOR,
        layout: {
          dock: `@${KEYS.COMPONENT.MAJOR_AXIS_TIME_OUTER}`,
          minimumLayoutMode
        }
      }];
    }
    return [{
      type: 'axis-overlay',
      key: KEYS.COMPONENT.MAJOR_AXIS_OVERLAY_CONTINUOUS,
      scale: KEYS.SCALE.MAIN.MAJOR,
      layout: {
        dock: `@${KEYS.COMPONENT.MAJOR_AXIS_CONTINUOUS}`,
        minimumLayoutMode
      }
    }];
  }

  function createMinorAxisTitle({
    actions,
    model,
    app,
    translator,
    flags,
    rtl,
    properties,
    layoutService,
    dockService,
    styleModel
  }) {
    const axis = layoutService.getLayoutValue('measureAxis');
    const labelStyle = styleModel.query.axis.title.getStyle();
    if (!axis) {
      return false;
    }
    const {
      show
    } = axis;
    if (show !== 'all' && show !== 'title') {
      return false;
    }
    const definition = {
      type: 'data-title',
      key: KEYS.COMPONENT.MINOR_AXIS_TITLE,
      layout: {
        dock: dockService.meta.minor.dock,
        minimumLayoutMode: MODES.AXIS_TITLE.MINOR
      },
      settings: {
        hyperCube: layoutService.getHyperCube(),
        hyperCubeDef: properties && properties.qHyperCubeDef,
        isDimension: false,
        disabled: () => !actions.interact.enabled(),
        model,
        app,
        translator,
        rtl,
        selections: undefined,
        supportConditional: flags.isEnabled('IM_1869_HIDE_DIM_MEA_LINE')
      },
      style: {
        fontSize: labelStyle.fontSize,
        fontFamily: labelStyle.fontFamily,
        color: labelStyle.color
      }
    };
    if (layoutService.meta.hasMultipleMeasures) {
      definition.settings.padding = '0';
      definition.settings.minWidth = 'auto';
    }
    if (layoutService.meta.isOneDimensional) {
      definition.settings.onChangeToAlternative = ({
        newProperties,
        model: enigmaModel
      }) => {
        checkToUpdateProperties({
          enabledForecast: flags.isEnabled('LINECHART_FORECAST'),
          properties: newProperties,
          layout: enigmaModel.layout
        });
      };
    }
    return definition;
  }

  function createMajorAxisTitle({
    actions,
    model,
    app,
    translator,
    flags,
    rtl,
    properties,
    layoutService,
    dockService,
    styleModel
  }) {
    const axis = layoutService.getLayoutValue('dimensionAxis');
    const labelStyle = styleModel.query.axis.title.getStyle();
    if (!axis) {
      return false;
    }
    const {
      show
    } = axis;
    if (show !== 'all' && show !== 'title') {
      return false;
    }
    const {
      orientation
    } = dockService.meta.major;
    const definition = {
      type: 'data-title',
      key: KEYS.COMPONENT.MAJOR_AXIS_TITLE,
      layout: {
        dock: dockService.meta.major.dock,
        minimumLayoutMode: MODES.AXIS_TITLE.MAJOR[orientation]
      },
      settings: {
        hyperCube: layoutService.getHyperCube(),
        hyperCubeDef: properties && properties.qHyperCubeDef,
        isDimension: true,
        disabled: () => !actions.interact.enabled(),
        model,
        app,
        translator,
        rtl,
        selections: undefined,
        supportConditional: flags.isEnabled('IM_1869_HIDE_DIM_MEA_LINE')
      },
      style: {
        fontSize: labelStyle.fontSize,
        fontFamily: labelStyle.fontFamily,
        color: labelStyle.color
      }
    };
    if (layoutService.meta.isOneDimensional) {
      definition.settings.onChangeToAlternative = ({
        newProperties,
        model: enigmaModel
      }) => {
        checkToUpdateProperties({
          enabledForecast: flags.isEnabled('LINECHART_FORECAST'),
          properties: newProperties,
          layout: enigmaModel.layout
        });
      };
    }
    if (layoutService.meta.isTwoDimensional) {
      definition.settings.padding = '0';
      definition.settings.minWidth = 'auto';
    }
    return definition;
  }

  function createAxisTitles({
    actions,
    context,
    resources,
    properties,
    layoutService,
    dockService,
    styleModel
  }) {
    const args = {
      actions,
      model: resources.model,
      app: resources.app,
      translator: resources.translator,
      flags: resources.flags,
      rtl: context.rtl,
      properties,
      layoutService,
      dockService,
      styleModel
    };
    return [createMinorAxisTitle(args), createMajorAxisTitle(args)];
  }

  function createBrushHighlighter({
    context,
    selectionService,
    layoutService,
    dockService,
    colorService,
    largeDataService
  }) {
    const {
      rtl
    } = context;
    const {
      isContinuous,
      isOneDimensional,
      hasMultipleMeasures,
      isStacked
    } = layoutService.meta;
    const color = layoutService.getLayoutValue('color', {});
    return {
      type: 'brush-highlighter',
      key: 'brush-highlighter',
      data: {
        collection: KEYS.COLLECTION.MAIN
      },
      settings: {
        highlightArea: () => !(layoutService.meta.isStacked && largeDataService.shouldUseProgressive()),
        getSelectionInfo: () => selectionService.getSelectionInfo() || {},
        getSelectionContext: largeDataService.getSelectionContext,
        getProgressiveRender: () => largeDataService.highlightLines,
        selectionValues: {
          'qHyperCube/qDimensionInfo/0': isContinuous ? data => isOneDimensional ? data.value : data.selectionOuterDimension.value : data => data.major.value,
          'qHyperCube/qDimensionInfo/0:numeric': data => data.major.value,
          'qHyperCube/qDimensionInfo/1': isOneDimensional ? data => data.major.value : data => data.line.value,
          'qHyperCube/qMeasureInfo/0': data => data.end.value,
          'qHyperCube/qDimensionInfo/0/qAttrExprInfo/0': data => data.end.value
        },
        colorSettings: colorService.getMain().getSettings(),
        colorByData: !color.auto && color.mode === 'byMeasure' && color.byMeasureDef && color.byMeasureDef.activeMeasureIndex !== undefined,
        isColorCode: !color.auto && color.mode === 'byExpression' && color.expressionIsColor,
        hasMultipleMeasures,
        isStacked,
        orientation: dockService.meta.major.orientation,
        rtl
      },
      rendererSettings: {
        progressive: largeDataService.meta.isMaxNumPointsEnabled ? () => largeDataService.meta.highlighterProgressive : undefined
      }
    };
  }

  function createDisclaimer({
    context,
    resources,
    disclaimerModel,
    themeService
  }) {
    const disclaimer = disclaimerModel.query.getDisclaimer();
    if (!disclaimer) {
      return false;
    }
    const {
      rtl
    } = context;
    const {
      translator
    } = resources;
    const {
      fontFamily
    } = themeService.getStyles();
    return {
      key: 'disclaimer',
      type: 'disclaimer',
      layout: {
        dock: disclaimer.alignment
      },
      settings: {
        label: translator.get(`Object.Disclaimer.${disclaimer.key}`),
        rtl
      },
      style: {
        fontFamily
      }
    };
  }

  function createGhostPoint({
    dockService
  }) {
    return {
      type: 'ghost-point',
      key: KEYS.COMPONENT.GHOST_POINT,
      data: {
        collection: KEYS.COLLECTION.MAIN
      },
      layout: {
        dock: `@${KEYS.COMPONENT.POINT}`
      },
      settings: {
        orientation: dockService.meta.major.orientation
      }
    };
  }

  function createContinuousGridLines({
    layoutService,
    themeService,
    chartModel
  }) {
    const {
      isContinuous,
      isTime
    } = layoutService.meta;
    if (!isContinuous) {
      return [false];
    }
    const styles = themeService.getStyles();
    const grid = {
      type: 'grid-line',
      layout: {
        minimumLayoutMode: MODES.GRID_LINE
      },
      ticks: {
        stroke: styles.grid.line.major.color
      },
      minorTicks: {
        show: false,
        stroke: styles.grid.line.minor.color
      },
      animations: {
        enabled: chartModel.query.animationsEnabled,
        trackBy: animations.lines.trackBy,
        compensateForLayoutChanges: animations.lines.compensateForLayoutChanges
      }
    };
    if (isTime) {
      return [extend$7(true, {}, grid, {
        key: 'time-inner-grid',
        x: {
          scale: KEYS.SCALE.MAIN.MAJOR_INNER
        },
        ticks: {
          stroke: styles.grid.line.minor.color // For some unknown reason Sense use minor styling here
        }
      }), extend$7(true, {}, grid, {
        key: 'time-outer-grid',
        x: {
          scale: KEYS.SCALE.MAIN.MAJOR
        }
      })];
    }
    return [extend$7(true, {}, grid, {
      key: 'continuous-grid',
      x: {
        scale: KEYS.SCALE.MAIN.MAJOR
      },
      minorTicks: {
        show: true
      }
    })];
  }

  const SPACING = {
    NONE: 0,
    WIDE: 1,
    MEDIUM: 2,
    NARROW: 3
  };
  function createGrid({
    layoutService,
    dockService,
    themeService,
    chartModel
  }) {
    const {
      auto,
      spacing
    } = layoutService.getLayoutValue('gridLine', {});
    if (!auto && spacing === SPACING.NONE) {
      return false;
    }
    const styles = themeService.getStyles();
    return {
      key: KEYS.COMPONENT.GRID_LINE,
      type: 'grid-line',
      layout: {
        minimumLayoutMode: MODES.GRID_LINE
      },
      preferredSize() {
        return {
          size: 0,
          edgeBleed: {
            left: 1,
            right: 1,
            top: 1,
            bottom: 1
          }
        };
      },
      ticks: {
        show: !auto && spacing === SPACING.WIDE ? (d, i) => i % 2 === 0 : true,
        stroke: styles.grid.line.major.color
      },
      minorTicks: {
        show: !auto && spacing === SPACING.NARROW,
        stroke: styles.grid.line.minor.color
      },
      [dockService.meta.major.orientation === 'horizontal' ? 'y' : 'x']: KEYS.SCALE.MAIN.MINOR,
      animations: {
        enabled: chartModel.query.animationsEnabled,
        trackBy: animations.lines.trackBy,
        compensateForLayoutChanges: animations.lines.compensateForLayoutChanges
      }
    };
  }

  function createZeroLine({
    layoutService,
    extremumModel,
    dockService,
    tickModel,
    themeService,
    gridLine,
    chartModel
  }) {
    const extrema = extremumModel.query.getExtrema();
    if (!gridLine || layoutService.getLayoutValue('measureAxis.logarithmic', false) && !extrema.meta.includesZero) {
      return false;
    }
    const styles = themeService.getStyles();
    return {
      key: KEYS.COMPONENT.ZERO_LINE,
      type: 'ref-line',
      layout: {
        minimumLayoutMode: MODES.GRID_LINE
      },
      show: () => tickModel.query.getMin() <= 0 && tickModel.query.getMax() >= 0,
      scale: KEYS.SCALE.MAIN.MINOR,
      lines: {
        [dockService.meta.minor.orientation === 'horizontal' ? 'x' : 'y']: [{
          value: 0,
          scale: KEYS.SCALE.MAIN.MINOR,
          line: {
            stroke: styles.grid.line.highContrast.color
          }
        }]
      },
      animations: {
        enabled: chartModel.query.animationsEnabled,
        trackBy: animations.lines.trackBy,
        compensateForLayoutChanges: animations.lines.compensateForLayoutChanges
      }
    };
  }

  function createGridLines({
    layoutService,
    extremumModel,
    dockService,
    tickModel,
    themeService,
    chartModel
  }) {
    const gridLine = createGrid({
      layoutService,
      dockService,
      themeService,
      chartModel
    });
    return [gridLine, createZeroLine({
      layoutService,
      extremumModel,
      dockService,
      tickModel,
      themeService,
      gridLine,
      chartModel
    }), ...createContinuousGridLines({
      layoutService,
      themeService,
      chartModel
    })];
  }

  function createLabelSpace({
    chart,
    layoutService,
    extremumModel,
    dockService,
    chartModel
  }) {
    const dataPoint = layoutService.getLayoutValue('dataPoint', {});
    if (!dataPoint.show || dataPoint.showLabels === false || dataPoint.showLabels === 'none') {
      return false;
    }
    const {
      rtl
    } = dockService.config;
    const horizontal = dockService.meta.major.orientation === 'horizontal';
    const {
      show
    } = layoutService.getLayoutValue('dimensionAxis', {});
    if (show !== 'none') {
      const {
        dock
      } = dockService.meta.major;
      if (horizontal && dock === 'top') {
        return false;
      }
      if (!horizontal) {
        if (dock === (rtl ? 'left' : 'right')) {
          return false;
        }
      }
    }
    const horizontalDock = rtl ? 'left' : 'right';
    const size = horizontal ? 21 : 42;
    return {
      type: 'label-space',
      key: KEYS.COMPONENT.LABEL_SPACE,
      layout: {
        minimumLayoutMode: MODES.LABEL_SPACE,
        dock: horizontal ? 'top' : horizontalDock
      },
      settings: {
        size
      },
      preferredSize() {
        const component = chart.component(KEYS.COMPONENT.LINE);
        if (!(component !== null && component !== void 0 && component.rect)) {
          return 0;
        }
        const threshold = (horizontal ? 17 : 34) / component.rect[horizontal ? 'height' : 'width'];
        const extrema = extremumModel.query.getExtrema();
        const scale = chart.scale(KEYS.SCALE.MAIN.MINOR);
        const scaled = scale(extrema.implicit.max);
        const value = horizontal || rtl ? scaled : 1 - scaled;
        const use = value < threshold;
        chartModel.command.setUseLabelSpace(use);
        return use ? size : 0;
      }
    };
  }

  function createSorter() {
    const state = {
      medians: {}
    };
    const median = data => {
      const values = data.map(d => d.end.value).sort((a, b) => b - a);
      return Math.abs(values[Math.floor(values.length / 2)]);
    };
    const getMedian = item => {
      const {
        id: key
      } = item;
      if (state.medians[key] === undefined) {
        state.medians[key] = median(item.data);
      }
      return state.medians[key];
    };
    return (a, b) => getMedian(b) - getMedian(a);
  }

  function createLineColorFn({
    property,
    isHorizontal,
    isColor,
    fallback,
    rtl,
    isContinuous,
    isReduced,
    colorService
  }) {
    return function getLineColor(context) {
      const {
        datum,
        resources: {
          scale
        }
      } = context;

      // Case 1: color by dimension and the context (line) has single color
      if (colorService) {
        const isLineSingleColor = datum.points.every(point => {
          var _point$color, _datum$points$;
          return ((point === null || point === void 0 || (_point$color = point.color) === null || _point$color === void 0 ? void 0 : _point$color.value) || undefined) === (((_datum$points$ = datum.points[0]) === null || _datum$points$ === void 0 || (_datum$points$ = _datum$points$.color) === null || _datum$points$ === void 0 ? void 0 : _datum$points$.value) || undefined);
        });
        if (isLineSingleColor) {
          return colorService.getMain().getColor()(context);
        }
      }

      // Case 2: color by dimension when the line has more than one color, or color by measure
      const majorScale = scale(isReduced ? KEYS.SCALE.REDUCED.MAJOR : KEYS.SCALE.MAIN.MAJOR);
      const colorScale = scale(isContinuous && isReduced ? KEYS.SCALE.REDUCED.COLOR : KEYS.SCALE.MAIN.COLOR);
      const ordered = isHorizontal && rtl ? [...datum.points].reverse() : datum.points;
      const points = ordered.reduce((result, point, index) => {
        const currentMissing = point[property].value === 'NaN' || Number.isNaN(point[property].value);
        const next = ordered[index + 1];
        const nextHas = next && next[property].value !== 'NaN' && !Number.isNaN(next[property].value);
        if (currentMissing) {
          if (result.length && nextHas) {
            result.push(point);
          }
        } else {
          result.push(point);
        }
        return result;
      }, []);
      const values = points.map(p => majorScale(p.major.value));
      const min = Math.min(...values);
      const max = Math.max(...values);
      const difference = max - min;
      const denominator = difference === 0 ? 1 : difference;
      const scaledValues = values.map((value, index) => {
        if (index === 0) {
          return 0;
        }
        if (index === values.length - 1) {
          return 1;
        }
        return (value - min) / denominator;
      });
      const stops = [];
      for (let i = 0; i < points.length; i++) {
        const point = points[i];
        const value = point.color && point.color.value;
        const color = isColor ? value || fallback : colorScale(value) || fallback;
        const first = i === 0;
        const last = i === points.length - 1;
        const currentValue = scaledValues[i];
        const missing = point[property].value === 'NaN' || Number.isNaN(point[property].value);
        if (!missing) {
          const previous = points[i - 1];
          const previousHas = previous && previous[property].value !== 'NaN' && !Number.isNaN(previous[property].value);
          if (previousHas) {
            stops.push({
              color,
              offset: first ? 0 : Math.max(0, parseFloat((currentValue - (currentValue - scaledValues[i - 1]) / 2).toFixed(5)))
            });
          } else {
            stops.push({
              color,
              offset: currentValue
            });
          }
          const next = points[i + 1];
          const nextHas = next && next[property].value !== 'NaN' && !Number.isNaN(next[property].value);
          if (nextHas) {
            stops.push({
              color,
              offset: last ? 1 : Math.max(0, parseFloat((currentValue + (scaledValues[i + 1] - currentValue) / 2).toFixed(5)))
            });
          } else {
            stops.push({
              color,
              offset: currentValue
            });
          }
        } else if (!stops[i - 1].virtual) {
          stops.push({
            virtual: true
          });
        }
      }
      const injected = stops.reduce((result, stop, index) => {
        if (stop.virtual) {
          const previous = stops[index - 1];
          const next = stops[index + 1];
          const offset = previous.offset + (next.offset - previous.offset) / 2;
          result.push({
            color: previous.color,
            offset
          }, {
            color: next.color,
            offset
          });
        } else {
          result.push(stop);
        }
        return result;
      }, []);
      return {
        type: 'gradient',
        x1: 0,
        x2: isHorizontal ? 1 : 0,
        y1: 0,
        y2: isHorizontal ? 0 : 1,
        stops: injected
      };
    };
  }

  function byDataMeasureContinuous({
    isHorizontal,
    isArea,
    isContinuous,
    isReduced,
    rtl
  }) {
    return function createGradient(context) {
      const {
        datum: {
          points
        },
        resources: {
          scale
        }
      } = context;
      const colorScale = scale(isContinuous && isReduced ? KEYS.SCALE.REDUCED.COLOR : KEYS.SCALE.MAIN.COLOR);
      const values = points.map(p => p.end.value).filter(v => v !== 'NaN' && !Number.isNaN(v));
      const minimum = Math.min(...values);
      const maximum = Math.max(...values);
      const min = isArea ? Math.min(0, minimum) : minimum;
      const max = isArea ? Math.max(0, maximum) : maximum;
      const difference = max - min;
      const denominator = difference === 0 ? 1 : difference;
      const domain = colorScale.domain();
      const stops = domain.map(value => ({
        color: colorScale(Math.min(max, Math.max(min, value))),
        offset: Math.min(1, Math.max(0, (value - min) / denominator))
      }));
      return {
        type: 'gradient',
        x1: !isHorizontal && rtl ? 1 : 0,
        x2: isHorizontal || rtl ? 0 : 1,
        y1: isHorizontal ? 1 : 0,
        y2: 0,
        stops
      };
    };
  }

  function byDataMeasureCategorical({
    isHorizontal,
    isArea,
    isContinuous,
    isReduced,
    fallback,
    rtl
  }) {
    return function createGradient(context) {
      const {
        datum: {
          points
        },
        resources: {
          scale
        }
      } = context;
      const colorScale = scale(isContinuous && isReduced ? KEYS.SCALE.REDUCED.COLOR : KEYS.SCALE.MAIN.COLOR);
      const values = points.map(p => p.end.value).filter(v => v !== 'NaN' && !Number.isNaN(v));
      const minimum = Math.min(...values);
      const maximum = Math.max(...values);
      const min = isArea ? Math.min(0, minimum) : minimum;
      const max = isArea ? Math.max(0, maximum) : maximum;
      const difference = max - min;
      const denominator = difference === 0 ? 1 : difference;
      const domain = colorScale.domain();
      const stops = [];
      for (let i = 0; i < domain.length - 1; i++) {
        const value = domain[i];
        const color = colorScale(value) || fallback;
        stops.push({
          color,
          offset: Math.min(1, Math.max(0, (value - min) / denominator))
        });
        const nextValue = domain[i + 1];
        stops.push({
          color,
          offset: Math.min(1, Math.max(0, (nextValue - min) / denominator))
        });
      }
      return {
        type: 'gradient',
        x1: !isHorizontal && rtl ? 1 : 0,
        x2: isHorizontal || rtl ? 0 : 1,
        y1: isHorizontal ? 1 : 0,
        y2: 0,
        stops
      };
    };
  }

  function getColor$1({
    context,
    layoutService,
    dockService,
    colorService,
    isArea,
    isReduced
  }) {
    const {
      rtl
    } = context;
    const {
      isTwoDimensional,
      hasMultipleMeasures,
      isContinuous,
      isStacked
    } = layoutService.meta;
    const property = isStacked && layoutService.getLayoutValue('separateStacking', true) ? 'point' : 'end';
    const {
      mode,
      type,
      nil: fallback
    } = colorService.getMain().getSettings();
    const isHorizontal = dockService.meta.major.orientation === 'horizontal';
    if (!mode || type === 'constant') {
      return colorService.getMain().getColor();
    }
    const color = layoutService.getLayoutValue('color', {});
    const byExpression = !color.auto && color.mode === 'byExpression';
    const hasExpression = !!color.colorExpression;
    if (byExpression && !hasExpression) {
      return fallback;
    }
    if (isTwoDimensional && !byExpression) {
      return createLineColorFn({
        property,
        isHorizontal,
        isColor: false,
        fallback,
        rtl,
        isContinuous,
        isReduced,
        colorService
      });
    }
    const byData = !color.auto && color.mode === 'byMeasure' && color.byMeasureDef && color.byMeasureDef.activeMeasureIndex !== undefined;
    if (hasMultipleMeasures || !byData) {
      return createLineColorFn({
        property,
        isHorizontal,
        isColor: byExpression && color.expressionIsColor,
        fallback,
        rtl,
        isContinuous,
        isReduced
      });
    }
    const createByDataMeasure = type === 'continuous' ? byDataMeasureContinuous : byDataMeasureCategorical;
    return createByDataMeasure({
      isHorizontal,
      isArea,
      isContinuous,
      isReduced,
      fallback,
      rtl
    });
  }

  const getIsArea$2 = node => typeof node.strokeLinejoin === 'undefined';
  function createLine$2({
    context,
    layoutService,
    extremumModel,
    dockService,
    styleModel,
    tickModel,
    colorService,
    largeDataService,
    chartModel
  }) {
    const {
      isStacked,
      isArea,
      isConnect
    } = layoutService.meta;
    const logarithmic = layoutService.getLayoutValue('measureAxis.logarithmic', false);
    const separateStacking = layoutService.getLayoutValue('separateStacking', true);
    const sort = createSorter();
    const {
      fieldType
    } = colorService.getMain().getSettings();
    const definition = {
      key: KEYS.COMPONENT.LINE,
      type: 'line',
      data: {
        collection: KEYS.COLLECTION.MAIN
      },
      settings: {
        coordinates: {
          minor: {
            scale: KEYS.SCALE.MAIN.MINOR,
            fn: d => {
              if (isStacked && separateStacking) {
                const value = d.datum.point.value < 0 ? d.datum.start.value : d.datum.end.value;
                return d.scale(value);
              }
              return d.scale(d.datum.end.value);
            }
          },
          major: {
            scale: KEYS.SCALE.MAIN.MAJOR,
            ref: 'major'
          },
          layerId: {
            ref: 'line'
          }
        },
        orientation: dockService.meta.major.orientation,
        layers: {
          sort,
          curve: styleModel.query.line.getCurve(),
          line: {
            stroke: getColor$1({
              context,
              layoutService,
              dockService,
              colorService
            }),
            strokeWidth: styleModel.query.line.getStrokeWidth(),
            strokeDasharray: styleModel.query.line.getStrokeDasharray(),
            strokeLinejoin: 'round',
            showMinor0: false
          }
        },
        connect: isConnect
      },
      brush: {
        consume: [{
          context: largeDataService.getSelectionContext(),
          data: ['selectionDimension'],
          filter: node => !getIsArea$2(node),
          style: {
            active: {
              opacity: 0.5
            },
            inactive: {
              opacity: 0.5
            }
          }
        }],
        customRender: !largeDataService.meta.isMaxNumPointsEnabled ? undefined : ({
          render,
          nodes
        }) => {
          largeDataService.dimLines({
            render,
            nodes
          });
        }
      },
      rendererSettings: {
        progressive: largeDataService.meta.isMaxNumPointsEnabled ? () => largeDataService.meta.lineProgressive : undefined
      },
      animations: {
        enabled: chartModel.query.animationsEnabled,
        trackBy: animations.lines.trackBy,
        compensateForLayoutChanges: animations.lines.compensateForLayoutChanges,
        isMainComponent: {
          filterFn: node => node.commonPoints.length > 0
        }
      }
    };
    if (logarithmic || isStacked) {
      definition.settings.coordinates.minor0 = {
        scale: KEYS.SCALE.MAIN.MINOR,
        fn: d => {
          if (isStacked) {
            if (separateStacking) {
              const value = d.datum.point.value < 0 ? d.datum.end.value : d.datum.start.value;
              return d.scale(value);
            }
            return d.scale(d.datum.start.value);
          }
          const value = extremumModel.query.getExtrema().meta.includesZero ? 0 : tickModel.query.getMin();
          return d.scale(value);
        }
      };
    }
    if (isArea) {
      definition.settings.layers.area = {
        fill: getColor$1({
          context,
          layoutService,
          dockService,
          colorService,
          isArea: true
        }),
        opacity: fieldType === 'measure' || fieldType === 'expression' ? 0.6 : 0.3
      };
      definition.brush.consume.push({
        context: 'selection',
        data: ['selectionDimension'],
        filter: node => getIsArea$2(node),
        style: {
          active: {
            opacity: 0.15
          },
          inactive: {
            opacity: 0.15
          }
        }
      });
    }
    return definition;
  }

  function createOutOfMinBoundsMarker({
    context,
    layoutService,
    extremumModel,
    dockService,
    themeService,
    tickModel,
    chartModel
  }) {
    const {
      isZero,
      isStacked
    } = layoutService.meta;
    const extrema = extremumModel.query.getExtrema();
    if (!extrema.meta.hasExplicitMin && !isZero) {
      return false;
    }
    const separateStacking = layoutService.getLayoutValue('separateStacking', true);
    const implicit = Number(extrema.implicit.min.toFixed(13));
    const {
      rtl
    } = context;
    const {
      dock,
      orientation
    } = dockService.meta.major;
    const styles = themeService.getStyles();
    const logarithmic = layoutService.getLayoutValue('measureAxis.logarithmic', false) && !extrema.meta.includesZero;
    return {
      type: 'out-of-bounds-marker',
      key: KEYS.COMPONENT.OUT_OF_MIN_BOUNDS,
      layout: {
        dock,
        minimumLayoutMode: MODES.OUT_OF_BOUNDS_MARKER
      },
      data: {
        collection: KEYS.COLLECTION.MAIN
      },
      settings: {
        type: 'min',
        extremum: () => tickModel.query.getMin(),
        separateStacking: isStacked && separateStacking,
        orientation,
        rtl,
        major: {
          scale: KEYS.SCALE.MAIN.MAJOR
        }
      },
      show: () => {
        const min = tickModel.query.getMin();
        if (implicit >= min && !isZero) {
          return false;
        }
        if (isZero && (logarithmic || min <= 0) && implicit >= min) {
          return false;
        }
        return true;
      },
      style: {
        fill: styles.outOfRange.color
      },
      animations: {
        enabled: chartModel.query.animationsEnabled,
        compensateForLayoutChanges: animations.lineOobs.compensateForLayoutChanges
      }
    };
  }

  function createOutOfMaxBoundsMarker({
    context,
    layoutService,
    extremumModel,
    dockService,
    themeService,
    tickModel,
    chartModel
  }) {
    const {
      isZero,
      isStacked
    } = layoutService.meta;
    const extrema = extremumModel.query.getExtrema();
    if (!extrema.meta.hasExplicitMax && !isZero) {
      return false;
    }
    const separateStacking = layoutService.getLayoutValue('separateStacking', true);
    const implicit = Number(extrema.implicit.max.toFixed(13));
    const {
      rtl
    } = context;
    const {
      opposite,
      orientation
    } = dockService.meta.major;
    const styles = themeService.getStyles();
    const logarithmic = layoutService.getLayoutValue('measureAxis.logarithmic', false) && !extrema.meta.includesZero;
    return {
      type: 'out-of-bounds-marker',
      key: KEYS.COMPONENT.OUT_OF_MAX_BOUNDS,
      layout: {
        dock: opposite,
        minimumLayoutMode: MODES.OUT_OF_BOUNDS_MARKER
      },
      data: {
        collection: KEYS.COLLECTION.MAIN
      },
      settings: {
        type: 'max',
        extremum: () => tickModel.query.getMax(),
        separateStacking: isStacked && separateStacking,
        orientation,
        rtl,
        major: {
          scale: KEYS.SCALE.MAIN.MAJOR
        }
      },
      show: () => {
        const max = tickModel.query.getMax();
        if (implicit <= max && !isZero) {
          return false;
        }
        if (isZero && (logarithmic || max >= 0) && implicit <= max) {
          return false;
        }
        return true;
      },
      style: {
        fill: styles.outOfRange.color
      },
      animations: {
        enabled: chartModel.query.animationsEnabled,
        compensateForLayoutChanges: animations.lineOobs.compensateForLayoutChanges
      }
    };
  }

  function createOutOfBoundsMarkers({
    context,
    layoutService,
    extremumModel,
    dockService,
    themeService,
    tickModel,
    chartModel
  }) {
    return [createOutOfMinBoundsMarker({
      context,
      layoutService,
      extremumModel,
      dockService,
      themeService,
      tickModel,
      chartModel
    }), createOutOfMaxBoundsMarker({
      context,
      layoutService,
      extremumModel,
      dockService,
      themeService,
      tickModel,
      chartModel
    })];
  }

  function createReferenceLines({
    chart,
    context,
    layoutService,
    dockService,
    themeService,
    refLineModel,
    colorService,
    chartModel
  }) {
    const {
      rtl,
      theme,
      localeInfo
    } = context;
    const styles = themeService.getStyles();
    const {
      animationsEnabled
    } = chartModel.query;
    return [createRefLines({
      refLineModel,
      layoutService,
      colorModel: {
        resolveUIColor: colorService.getMain().getPaletteColor
      },
      dockService,
      animationsEnabled,
      chart,
      scale: KEYS.SCALE.MAIN.MINOR,
      axis: dockService.meta.major.orientation === 'horizontal' ? 'y' : 'x',
      key: KEYS.COMPONENT.MEASURE_REF_LINE,
      minimumLayoutMode: MODES.REFERENCE_LINE
    }), createRefLines({
      isDimension: true,
      refLineModel,
      layoutService,
      colorModel: {
        resolveUIColor: colorService.getMain().getPaletteColor
      },
      dockService,
      animationsEnabled,
      chart,
      scale: KEYS.SCALE.MAIN.MAJOR,
      axis: dockService.meta.major.orientation === 'horizontal' ? 'x' : 'y',
      rtl,
      key: KEYS.COMPONENT.DIMENSION_REF_LINE,
      mainComponentKey: KEYS.COMPONENT.LINE,
      minimumLayoutMode: MODES.REFERENCE_LINE
    }), ...createRefLineLabels({
      refLineModel,
      layoutService,
      colorModel: {
        resolveUIColor: colorService.getMain().getPaletteColor
      },
      animationsEnabled,
      dock: dockService.meta.minor.opposite,
      scale: KEYS.SCALE.MAIN.MINOR,
      style: styles,
      formatter: KEYS.FORMATTER.MINOR,
      theme,
      localeInfo,
      rtl,
      key: KEYS.COMPONENT.MEASURE_REF_LINE_LABEL
    }), ...createRefLineLabels({
      isDimension: true,
      refLineModel,
      layoutService,
      colorModel: {
        resolveUIColor: colorService.getMain().getPaletteColor
      },
      animationsEnabled,
      dock: dockService.meta.major.opposite,
      scale: KEYS.SCALE.MAIN.MAJOR,
      style: styles,
      theme,
      localeInfo,
      rtl,
      key: KEYS.COMPONENT.DIMENSION_REF_LINE_LABEL
    })];
  }

  function createIsGap({
    layoutService
  }) {
    const {
      isDiscrete
    } = layoutService.meta;
    return ({
      item
    }) => {
      if (item.dummy) {
        return isDiscrete;
      }
      const {
        value
      } = item.end;
      return value === 'NaN' || Number.isNaN(value);
    };
  }

  function createHas({
    layoutService
  }) {
    const {
      isConnect
    } = layoutService.meta;
    const isGap = createIsGap({
      layoutService
    });
    const hasBefore = isConnect ? (index, items) => index !== 0 && items.slice(0, index).reverse().some(item => !isGap({
      item
    })) : (index, items) => index !== 0 && !isGap({
      item: items[index - 1]
    });
    const hasAfter = isConnect ? (index, items) => index !== items.length - 1 && items.slice(index + 1, items.length).some(item => !isGap({
      item
    })) : (index, items) => index !== items.length - 1 && !isGap({
      item: items[index + 1]
    });
    return ({
      index,
      items
    }) => ({
      before: hasBefore(index, items),
      after: hasAfter(index, items)
    });
  }

  function createGroups({
    layoutService,
    items
  }) {
    const {
      isOneDimensional
    } = layoutService.meta;
    const groups = items.reduce((grouped, i) => {
      const {
        value: key
      } = i.line;
      if (!grouped[key]) {
        // eslint-disable-next-line no-param-reassign
        grouped[key] = {
          items: [],
          keys: []
        };
      }
      grouped[key].items.push(i);
      grouped[key].keys.push(`${i.major.value}-${i.line.value}`);
      return grouped;
    }, {});
    if (isOneDimensional || Object.keys(groups).length === 1) {
      return groups;
    }
    const mapped = items.map(i => i.major.value);
    const majors = mapped.filter((value, index) => mapped.indexOf(value) === index);
    const keys = Object.keys(groups);
    const virtual = {};
    majors.forEach(value => {
      keys.forEach(key => {
        if (!virtual[key]) {
          virtual[key] = {
            items: [],
            keys: []
          };
        }
        const group = groups[key];
        const item = group.items.filter(i => i.major.value === value)[0];
        virtual[key].items.push(item || {
          dummy: true
        });
        virtual[key].keys.push(item ? `${item.major.value}-${item.line.value}` : 'dummy');
      });
    });
    return virtual;
  }

  function createIsSingle({
    layoutService
  }) {
    const state = {
      key: undefined,
      map: undefined
    };
    const has = createHas({
      layoutService
    });
    return ({
      item,
      items
    }) => {
      if (state.key !== items) {
        state.key = items;
        state.map = createGroups({
          layoutService,
          items
        });
      }
      const {
        value: mapKey
      } = item.line;
      const group = state.map[mapKey];
      const itemKey = `${item.major.value}-${item.line.value}`;
      const index = group.keys.indexOf(itemKey);
      const {
        before,
        after
      } = has({
        index,
        items: group.items
      });
      return !before && !after;
    };
  }

  const SIZES$1 = {
    MIN: 3,
    MAX: 20
  };
  function createPoint$1({
    selectionService,
    layoutService,
    dockService,
    styleModel,
    tickModel,
    colorService,
    largeDataService,
    chartModel
  }) {
    const {
      isContinuous,
      isStacked
    } = layoutService.meta;
    const separateStacking = layoutService.getLayoutValue('separateStacking', true);
    const preferredShow = layoutService.getLayoutValue('dataPoint.show', false);
    const color = colorService.getMain().getColor();
    const horizontal = dockService.meta.major.orientation === 'horizontal';
    const spark = dockService.meta.chart.mode === 'SPARK';
    const radius = STYLES.POINT.SIZE.DEFAULT / 2;
    const isSingle = createIsSingle({
      layoutService
    });
    return {
      key: KEYS.COMPONENT.POINT,
      type: 'point',
      data: {
        collection: KEYS.COLLECTION.MAIN
      },
      preferredSize: () => {
        return {
          edgeBleed: {
            top: horizontal ? radius : 0,
            right: isContinuous ? radius : 0,
            left: isContinuous ? radius : 0
          }
        };
      },
      settings: {
        [horizontal ? 'y' : 'x']: {
          scale: KEYS.SCALE.MAIN.MINOR,
          fn: d => {
            if (isStacked && separateStacking) {
              const value = d.datum.point.value < 0 ? d.datum.start.value : d.datum.end.value;
              return d.scale(value);
            }
            return d.scale(d.datum.end.value);
          }
        },
        [horizontal ? 'x' : 'y']: {
          scale: KEYS.SCALE.MAIN.MAJOR,
          ref: 'major'
        },
        sizeLimits: {
          minPx: SIZES$1.MIN,
          maxPx: SIZES$1.MAX
        },
        size: context => {
          const {
            value: index
          } = context.datum.line;
          const size = styleModel.query.point.getSize(index);
          return `${size}px`;
        },
        fill: color,
        opacity: context => {
          if (isContinuous) {
            const scale = context.resources.scale(KEYS.SCALE.MAIN.MAJOR);
            const scaled = scale(context.datum.major.value);
            if (scaled < 0 || scaled > 1) {
              return 0.01;
            }
          }
          const min = tickModel.query.getMin();
          const max = tickModel.query.getMax();
          const {
            datum
          } = context;
          const {
            value
          } = isStacked && separateStacking && datum.point && datum.point.value < 0 ? datum.start : datum.end;
          if (datum.null.value || datum.interpolated.value) {
            return 0;
          }
          if (value < min || value > max) {
            return 0.01;
          }
          if (spark) {
            return isSingle({
              item: datum,
              items: context.data.items
            }) ? 1.01 : 0;
          }
          if (preferredShow) {
            return 1;
          }
          if (isSingle({
            item: datum,
            items: context.data.items
          })) {
            return 1.01;
          }
          return 0;
        }
      },
      brush: {
        consume: [{
          context: largeDataService.getSelectionContext(),
          data: ['selectionDimension', 'selectionOuterDimension', 'end', KEYS.SCALE.MAIN.COLOR, 'major'],
          filter: a => !a.data.null.value && !a.data.interpolated.value,
          style: {
            active: {
              r: node => node.r + STYLES.POINT.SIZE.ACTIVE / 2,
              opacity: node => {
                if (node.opacity === 1.01) {
                  return 1;
                }
                if (node.opacity === 0.01) {
                  return 0;
                }
                if (!isContinuous || preferredShow) {
                  return 1;
                }
                const {
                  event,
                  components
                } = selectionService.getSelectionInfo();
                if (event === 'continuousRange') {
                  return 0;
                }
                if (event !== 'tap') {
                  return 1;
                }
                const isContinuousOverlay = [KEYS.COMPONENT.MAJOR_AXIS_OVERLAY_CONTINUOUS, KEYS.COMPONENT.MAJOR_AXIS_OVERLAY_TIME_INNER, KEYS.COMPONENT.MAJOR_AXIS_OVERLAY_TIME_OUTER].some(k => components.indexOf(k) >= 0);
                return isContinuousOverlay ? 0 : 1;
              },
              strokeWidth: 1.5,
              stroke: '#FFFFFF'
            },
            inactive: {
              opacity: node => node.opacity === 1 || node.opacity === 1.01 ? 0.5 : 0
            }
          }
        }],
        customRender: !largeDataService.meta.isMaxNumPointsEnabled ? undefined : ({
          render,
          nodes
        }) => {
          largeDataService.brushPoints({
            render,
            nodes
          });
        }
      },
      rendererSettings: {
        progressive: largeDataService.meta.isMaxNumPointsEnabled ? () => largeDataService.meta.pointProgressive : undefined
      },
      animations: {
        enabled: chartModel.query.animationsEnabled,
        trackBy: animations.nonUpdatingNode.trackBy,
        compensateForLayoutChanges: animations.points.compensateForLayoutChanges
      }
    };
  }

  function createPointLabel({
    resources,
    layoutService,
    dockService,
    chartModel,
    largeDataService,
    styleModel
  }) {
    const dataPoint = layoutService.getLayoutValue('dataPoint');
    if (!dataPoint) {
      return false;
    }
    if (!dataPoint.show) {
      return false;
    }
    if (dataPoint.showLabels === false || dataPoint.showLabels === 'none') {
      return false;
    }
    const {
      rtl
    } = dockService.config;
    const {
      orientation
    } = dockService.meta.major;
    const {
      isDiscrete,
      isStacked,
      isOneDimensional,
      isConnect
    } = layoutService.meta;
    const label = isStacked ? data => data.point.label : data => data.end.label;
    const majorValue = isOneDimensional ? data => data.value : data => data.major.value;
    const labelStyle = styleModel.query.label.getStyle();
    return {
      type: 'point-label',
      key: KEYS.COMPONENT.POINT_LABEL,
      renderer: getTextRenderer(resources.flags),
      layout: {
        minimumLayoutMode: MODES.VALUE_LABEL
      },
      settings: {
        orientation,
        rtl,
        connect: isConnect || !isDiscrete && !isOneDimensional,
        label,
        pointValue: data => data.end.value,
        majorValue,
        all: dataPoint.showLabels === 'all',
        target: {
          allPoints: [KEYS.COMPONENT.POINT, KEYS.COMPONENT.FORECAST_POINT]
        },
        enabled: () => !(largeDataService !== null && largeDataService !== void 0 && largeDataService.isLargeNumVisiblePoints()),
        insideStrategy: isDiscrete ? 'edge' : 'center',
        labelSpace: {
          use: () => chartModel.query.getIsUsingLabelSpace(),
          size: orientation === 'horizontal' ? 21 : 42
        }
      },
      style: {
        fontFamily: labelStyle.fontFamily,
        fontSize: labelStyle.fontSize,
        fill: labelStyle.fill
      },
      animations: {
        enabled: chartModel.query.animationsEnabled,
        trackBy: animations.nonUpdatingNode.trackBy,
        compensateForLayoutChanges: animations.labels.compensateForLayoutChanges
      }
    };
  }

  function createRangeBrushHighlighter({
    layoutService
  }) {
    if (!layoutService.meta.isContinuous || !resolveScrollbar({
      layoutService
    }).miniChart) {
      return false;
    }
    return {
      type: 'range',
      key: 'range-brush-highlighter',
      layout: {
        dock: '@scrollbar'
      },
      settings: {
        scale: KEYS.SCALE.REDUCED.MAJOR,
        brush: 'selection',
        fill: '#6CB33F',
        opacity: 0.2
      }
    };
  }

  function createReducedLine({
    context,
    discreteModel,
    continuousModel,
    layoutService,
    extremumModel,
    dockService,
    styleModel,
    tickModel,
    colorService,
    largeDataService,
    chartModel
  }) {
    if (!resolveScrollbar({
      layoutService
    }).miniChart) {
      return false;
    }
    const {
      isDiscrete,
      isTwoDimensional,
      isStacked,
      isSnapshot,
      isArea,
      isConnect
    } = layoutService.meta;
    if (isDiscrete && isTwoDimensional && !isStacked) {
      return false;
    }
    if (isSnapshot && isStacked && !layoutService.getLayoutValue('reducedHyperCube')) {
      return false;
    }
    const show = isDiscrete ? () => discreteModel.query.getCanScroll() : () => continuousModel.getDimensionCardinality() > 1;
    const logarithmic = layoutService.getLayoutValue('measureAxis.logarithmic', false);
    const separateStacking = layoutService.getLayoutValue('separateStacking', true);
    const {
      fieldType
    } = colorService.getMain().getSettings();
    const {
      orientation
    } = dockService.meta.major;
    const getStrokeDasharray = styleModel.query.line.getStrokeDasharray();
    const definition = {
      key: KEYS.COMPONENT.REDUCED_LINE,
      type: 'line',
      data: {
        collection: KEYS.COLLECTION.REDUCED
      },
      layout: {
        dock: '@scrollbar',
        minimumLayoutMode: MODES.REDUCED_LINE
      },
      show,
      settings: {
        coordinates: {
          minor: {
            scale: KEYS.SCALE.REDUCED.MINOR,
            fn: d => {
              if (isStacked && separateStacking) {
                const value = d.datum.point.value < 0 ? d.datum.start.value : d.datum.end.value;
                return d.scale(value);
              }
              return d.scale(d.datum.end.value);
            }
          },
          major: {
            scale: KEYS.SCALE.REDUCED.MAJOR,
            ref: 'major'
          },
          layerId: {
            ref: 'line'
          }
        },
        orientation,
        layers: {
          curve: styleModel.query.line.getCurve(),
          line: {
            stroke: getColor$1({
              context,
              layoutService,
              dockService,
              colorService,
              isReduced: true
            }),
            strokeWidth: 1,
            strokeDasharray: (...args) => {
              const value = getStrokeDasharray(...args);
              return value === undefined ? undefined : '1, 1';
            },
            strokeLinejoin: 'round',
            showMinor0: false
          }
        },
        connect: !isTwoDimensional && isConnect
      },
      rendererSettings: {
        progressive: largeDataService.meta.isMaxNumPointsEnabled ? () => largeDataService.meta.reducedLineProgressive : undefined
      },
      animations: {
        enabled: chartModel.query.animationsEnabled,
        trackBy: animations.lines.trackBy,
        compensateForLayoutChanges: animations.lines.compensateForLayoutChanges
      }
    };
    if (logarithmic || isStacked) {
      definition.settings.coordinates.minor0 = {
        scale: KEYS.SCALE.REDUCED.MINOR,
        fn: d => {
          if (isStacked) {
            if (separateStacking) {
              const value = d.datum.point.value < 0 ? d.datum.end.value : d.datum.start.value;
              return d.scale(value);
            }
            return d.scale(d.datum.start.value);
          }
          const value = extremumModel.query.getExtrema().meta.includesZero ? 0 : tickModel.query.getMin();
          return d.scale(value);
        }
      };
    }
    if (isArea) {
      definition.settings.layers.area = {
        fill: getColor$1({
          context,
          layoutService,
          dockService,
          colorService,
          isArea: true,
          isReduced: true
        }),
        opacity: fieldType === 'measure' || fieldType === 'expression' ? 0.6 : 0.3
      };
    }
    return definition;
  }

  function createScrollbar({
    context,
    viewState,
    viewCache,
    discreteModel,
    continuousModel,
    layoutService,
    dockService,
    themeService
  }) {
    const {
      deviceType,
      rtl
    } = context;
    const {
      isDiscrete,
      isTwoDimensional,
      isStacked,
      isSnapshot
    } = layoutService.meta;
    if (isSnapshot && isStacked && !layoutService.getLayoutValue('reducedHyperCube')) {
      return false;
    }
    return createScrollbarDefinition({
      viewState,
      viewCache,
      discrete: discreteModel,
      continuousDataModel: continuousModel,
      layoutService,
      dockService,
      themeService,
      deviceType,
      rtl,
      scrollbarOverride: {
        predicate: ({
          scrollbar
        }) => isDiscrete && isTwoDimensional && !isStacked && scrollbar.miniChart,
        value: SCROLLBARS.OPTIONS.BAR.value
      }
    });
  }

  function getColor(layoutService, fn) {
    return args => {
      var _forecast$paletteColo;
      const {
        datum
      } = args;
      const index = datum.line.value;
      const forecast = layoutService.getHyperCubeValue(`qMeasureInfo.${index}.forecast`);
      return forecast !== null && forecast !== void 0 && (_forecast$paletteColo = forecast.paletteColor) !== null && _forecast$paletteColo !== void 0 && _forecast$paletteColo.color && forecast.paletteColor.color !== 'none' ? forecast.paletteColor.color : fn(args);
    };
  }
  function getPointColor({
    layoutService,
    colorService
  }) {
    const fn = colorService.getMain().getColor();
    return getColor(layoutService, fn);
  }
  function isSimpleColor(mode) {
    return mode === 'constant' || mode === 'measure' || mode === 'dimension';
  }
  function getSimpleMeasureColor({
    colorService
  }) {
    const {
      mode,
      nil: fallback
    } = colorService.getMain().getSettings();
    if (isSimpleColor(mode)) {
      return colorService.getMain().getColor();
    }
    return () => fallback;
  }
  function getLineColor({
    layoutService,
    colorService
  }) {
    const fn = getSimpleMeasureColor({
      colorService
    });
    return getColor(layoutService, fn);
  }

  const getIsArea$1 = node => typeof node.strokeLinejoin === 'undefined';
  function createLine$1({
    context,
    discreteModel,
    continuousModel,
    colorService,
    dockService,
    extremumModel,
    layoutService,
    styleModel,
    tickModel,
    chartModel
  }, {
    isReduced
  }) {
    const {
      isConnect,
      isDiscrete
    } = layoutService.meta;
    const logarithmic = layoutService.getLayoutValue('measureAxis.logarithmic', false);
    const show = isDiscrete ? () => discreteModel.query.getCanScroll() : () => continuousModel.getDimensionCardinality() > 1;
    let layout;
    let brush;
    if (isReduced) {
      layout = {
        dock: '@scrollbar',
        minimumLayoutMode: MODES.REDUCED_LINE
      };
    } else {
      brush = {
        consume: [{
          context: 'selection',
          data: ['selectionDimension'],
          filter: node => !getIsArea$1(node),
          style: {
            active: {
              opacity: 0.5
            },
            inactive: {
              opacity: 0.5
            }
          }
        }]
      };
    }
    const definition = {
      key: isReduced ? KEYS.COMPONENT.FORECAST_REDUCED_LINE : KEYS.COMPONENT.FORECAST_LINE,
      type: 'line',
      layout,
      data: {
        collection: isReduced ? KEYS.COLLECTION.REDUCED_FORECAST : KEYS.COLLECTION.FORECAST
      },
      show,
      settings: {
        coordinates: {
          minor: {
            scale: isReduced ? KEYS.SCALE.REDUCED.MINOR : KEYS.SCALE.MAIN.MINOR,
            ref: 'end'
          },
          major: {
            scale: isReduced ? KEYS.SCALE.REDUCED.MAJOR : KEYS.SCALE.MAIN.MAJOR,
            ref: 'major'
          },
          layerId: {
            ref: 'line'
          }
        },
        orientation: dockService.meta.major.orientation,
        layers: {
          curve: styleModel.query.forecast.getCurve(),
          line: {
            stroke: getLineColor({
              context,
              layoutService,
              dockService,
              colorService,
              isReduced
            }),
            strokeWidth: isReduced ? 1 : styleModel.query.forecast.getStrokeWidth(),
            strokeDasharray: styleModel.query.forecast.getStrokeDasharray(),
            strokeLinejoin: 'round',
            showMinor0: false
          }
        },
        connect: isConnect
      },
      brush,
      animations: {
        enabled: chartModel.query.animationsEnabled,
        trackBy: animations.nonUpdatingNode.trackBy,
        compensateForLayoutChanges: animations.lines.compensateForLayoutChanges
      }
    };
    if (logarithmic) {
      definition.settings.coordinates.minor0 = {
        scale: KEYS.SCALE.MAIN.MINOR,
        fn: d => {
          const value = extremumModel.query.getExtrema().meta.includesZero ? 0 : tickModel.query.getMin();
          return d.scale(value);
        }
      };
    }
    return definition;
  }

  const getIsArea = node => typeof node.strokeLinejoin === 'undefined';

  // represent a point infinite distance outside the rendering are in the min direction
  function farOutsideMin(scale) {
    const range = scale.range();
    return range[0] + (range[0] - range[1]) * 100;
  }
  // represent a point infinite distance outside the rendering are in the max direction
  function farOutsideMax(scale) {
    const range = scale.range();
    return range[1] + (range[1] - range[0]) * 100;
  }
  function createLine({
    colorService,
    context,
    dockService,
    layoutService,
    styleModel,
    chartModel
  }, {
    isReduced
  }) {
    const {
      isConnect
    } = layoutService.meta;
    const {
      fieldType
    } = colorService.getMain().getSettings();
    const logarithmic = layoutService.getLayoutValue('measureAxis.logarithmic', false);
    let layout;
    let brush;
    if (isReduced) {
      layout = {
        dock: '@scrollbar',
        minimumLayoutMode: MODES.REDUCED_LINE
      };
    } else {
      brush = {
        consume: [{
          context: 'selection',
          data: ['selectionDimension'],
          filter: node => !getIsArea(node),
          style: {
            active: {
              opacity: 0.5
            },
            inactive: {
              opacity: 0.5
            }
          }
        }, {
          context: 'selection',
          data: ['selectionDimension'],
          filter: node => getIsArea(node),
          style: {
            active: {
              opacity: 0.15
            },
            inactive: {
              opacity: 0.15
            }
          }
        }]
      };
    }
    const definition = {
      key: isReduced ? KEYS.COMPONENT.FORECAST_REDUCED_CONFIDENCE : KEYS.COMPONENT.FORECAST_CONFIDENCE,
      type: 'line',
      layout,
      brush,
      data: {
        collection: isReduced ? KEYS.COLLECTION.REDUCED_FORECAST : KEYS.COLLECTION.FORECAST
      },
      settings: {
        coordinates: {
          minor0: {
            scale: isReduced ? KEYS.SCALE.REDUCED.MINOR : KEYS.SCALE.MAIN.MINOR,
            ref: 'lower'
          },
          minor: {
            scale: isReduced ? KEYS.SCALE.REDUCED.MINOR : KEYS.SCALE.MAIN.MINOR,
            ref: 'upper'
          },
          major: {
            scale: isReduced ? KEYS.SCALE.REDUCED.MAJOR : KEYS.SCALE.MAIN.MAJOR,
            ref: 'major'
          },
          layerId: {
            ref: 'line'
          }
        },
        orientation: dockService.meta.major.orientation,
        layers: {
          curve: styleModel.query.forecast.getCurve(),
          area: {
            show: node => {
              const idx = node.datum.line.value;
              const forecast = layoutService.getLayoutValue(`qHyperCube.qMeasureInfo.${idx}.forecast`);
              return showConfidence(forecast);
            },
            fill: getLineColor({
              context,
              layoutService,
              dockService,
              colorService,
              isArea: true,
              isReduced
            }),
            opacity: fieldType === 'measure' || fieldType === 'expression' ? 0.6 : 0.3
          },
          line: {
            show: false
          }
        },
        connect: isConnect
      },
      animations: {
        enabled: chartModel.query.animationsEnabled,
        trackBy: animations.nonUpdatingNode.trackBy,
        compensateForLayoutChanges: animations.lines.compensateForLayoutChanges
      }
    };
    if (logarithmic) {
      definition.settings.coordinates.minor0.fn = d => {
        let result = d.scale(d.datum.lower.value);
        if (Number.isNaN(result) && !Number.isNaN(+d.datum.lower.value)) {
          if (!Number.isNaN(d.scale(d.datum.upper.value))) {
            result = farOutsideMin(d.scale);
          }
        }
        return result;
      };
      definition.settings.coordinates.minor.fn = d => {
        let result = d.scale(d.datum.upper.value);
        if (Number.isNaN(result) && !Number.isNaN(+d.datum.upper.value)) {
          if (!Number.isNaN(d.scale(d.datum.lower.value))) {
            result = farOutsideMax(d.scale);
          }
        }
        return result;
      };
    }
    return definition;
  }

  const SIZES = {
    MIN: 3,
    MAX: 20
  };
  const filterOnlyNewPoints = data => data.fromDynamicScript.value;
  function createPoint({
    colorService,
    dockService,
    layoutService,
    styleModel,
    tickModel,
    chartModel
  }) {
    const preferredShow = layoutService.getLayoutValue('dataPoint.show', false);
    const horizontal = dockService.meta.major.orientation === 'horizontal';
    const spark = dockService.meta.chart.mode === 'SPARK';
    const limitToNewPoints = true;
    return {
      key: KEYS.COMPONENT.FORECAST_POINT,
      type: 'point',
      data: {
        filter: limitToNewPoints ? filterOnlyNewPoints : undefined,
        collection: KEYS.COLLECTION.FORECAST
      },
      preferredSize: () => ({
        edgeBleed: {
          top: horizontal ? STYLES.POINT.SIZE.DEFAULT / 2 : 0
        }
      }),
      settings: {
        [horizontal ? 'y' : 'x']: {
          scale: KEYS.SCALE.MAIN.MINOR,
          ref: 'end'
        },
        [horizontal ? 'x' : 'y']: {
          scale: KEYS.SCALE.MAIN.MAJOR,
          ref: 'major'
        },
        sizeLimits: {
          minPx: SIZES.MIN,
          maxPx: SIZES.MAX
        },
        size: context => {
          const {
            value: index
          } = context.datum.line;
          const size = styleModel.query.point.getSize(index);
          return `${size}px`;
        },
        fill: getPointColor({
          layoutService,
          colorService
        }),
        opacity: context => {
          const min = tickModel.query.getMin();
          const max = tickModel.query.getMax();
          const {
            datum
          } = context;
          const {
            value
          } = datum.end;
          if (datum.null.value || datum.interpolated.value) {
            return 0;
          }
          if (value < min || value > max) {
            return 0;
          }
          if (spark) {
            return 0;
          }
          return preferredShow ? 1 : 0;
        }
      },
      brush: {
        consume: [{
          context: 'selection',
          data: [],
          style: {
            inactive: {
              opacity: node => node.opacity === 1 ? 0.5 : 0
            }
          }
        }]
      },
      animations: {
        enabled: chartModel.query.animationsEnabled,
        trackBy: animations.nonUpdatingNode.trackBy,
        compensateForLayoutChanges: animations.points.compensateForLayoutChanges
      }
    };
  }

  function createForecastPointLabel(options) {
    const component = createPointLabel(options);
    if (component) {
      component.key = 'forecast-point-label';
      component.settings.target.point = KEYS.COMPONENT.FORECAST_POINT;
    }
    return component;
  }

  function createForecastOutOfBoundsMarkers(options) {
    const components = createOutOfBoundsMarkers(options);
    const min = components.find(c => c.key === KEYS.COMPONENT.OUT_OF_MIN_BOUNDS);
    if (min) {
      min.key = KEYS.COMPONENT.FORECAST_OUT_OF_MIN_BOUNDS;
      min.data.collection = KEYS.COLLECTION.FORECAST;
      min.layout.dock = `@${KEYS.COMPONENT.OUT_OF_MIN_BOUNDS}`;
    }
    const max = components.find(c => c.key === KEYS.COMPONENT.OUT_OF_MAX_BOUNDS);
    if (max) {
      max.key = KEYS.COMPONENT.FORECAST_OUT_OF_MAX_BOUNDS;
      max.data.collection = KEYS.COLLECTION.FORECAST;
      max.layout.dock = `@${KEYS.COMPONENT.OUT_OF_MAX_BOUNDS}`;
    }
    return [min || false, max || false];
  }

  function showMinichart({
    layoutService
  }) {
    if (!resolveScrollbar({
      layoutService
    }).miniChart) {
      return false;
    }
    const {
      isDiscrete,
      isTwoDimensional,
      isStacked,
      isSnapshot
    } = layoutService.meta;
    if (isDiscrete && isTwoDimensional && !isStacked) {
      return false;
    }
    if (isSnapshot && isStacked && !layoutService.getLayoutValue('reducedHyperCube')) {
      return false;
    }
    return true;
  }

  function createForcast(options) {
    const {
      fieldModel
    } = options;
    if (!fieldModel.forecast.length) {
      return [];
    }
    const composition = [createLine$1(options, {
      isReduced: false
    }), createPoint(options), createLine(options, {
      isReduced: false
    }), createForecastPointLabel(options), ...createForecastOutOfBoundsMarkers(options)];
    if (showMinichart(options)) {
      composition.push(createLine$1(options, {
        isReduced: true
      }));
      composition.push(createLine(options, {
        isReduced: true
      }));
    }
    return composition;
  }

  function createComponents({
    actions,
    chart,
    chartModel,
    colorService,
    context,
    continuousModel,
    disclaimerModel,
    discreteModel,
    dockService,
    extremumModel,
    fieldModel,
    layoutService,
    legend,
    properties,
    refLineModel,
    resources,
    selectables,
    selectionService,
    styleModel,
    themeService,
    tickModel,
    tooltipService,
    trendLineModel,
    viewCache,
    viewState,
    largeDataService
  }) {
    const disclaimer = createDisclaimer({
      context,
      resources,
      disclaimerModel,
      themeService
    });
    if (disclaimerModel.query.getHasSuppressingDisclaimer()) {
      return [disclaimer];
    }
    const axes = createAxes({
      context,
      resources,
      layoutService,
      dockService,
      themeService,
      styleModel,
      chartModel
    });
    const components = [...createGridLines({
      layoutService,
      extremumModel,
      dockService,
      themeService,
      tickModel,
      chartModel
    }), ...createOutOfBoundsMarkers({
      context,
      layoutService,
      extremumModel,
      dockService,
      themeService,
      tickModel,
      chartModel
    }), createLine$2({
      context,
      layoutService,
      extremumModel,
      dockService,
      styleModel,
      tickModel,
      colorService,
      largeDataService,
      chartModel
    }), ...createForcast({
      discreteModel,
      continuousModel,
      context,
      resources,
      fieldModel,
      chartModel,
      layoutService,
      extremumModel,
      dockService,
      styleModel,
      tickModel,
      colorService,
      themeService
    }), createBrushHighlighter({
      context,
      selectionService,
      layoutService,
      dockService,
      colorService,
      largeDataService
    }), createLabelSpace({
      chart,
      layoutService,
      extremumModel,
      dockService,
      chartModel
    }), axes.minor, createPoint$1({
      selectionService,
      layoutService,
      dockService,
      styleModel,
      tickModel,
      colorService,
      largeDataService,
      chartModel
    }), ...axes.majors, ...createReferenceLines({
      context,
      refLineModel,
      layoutService,
      dockService,
      themeService,
      colorService,
      chart,
      chartModel
    }), createGhostPoint({
      dockService
    }), ...createAxisOverlays({
      layoutService,
      dockService
    }), ...createAxisTitles({
      actions,
      context,
      resources,
      properties,
      layoutService,
      dockService,
      styleModel
    }), scrollHint({
      viewState,
      viewCache,
      layoutService,
      dockService,
      rtl: context.rtl
    }), createRangeBrushHighlighter({
      layoutService
    }), createPointLabel({
      resources,
      layoutService,
      dockService,
      chartModel,
      largeDataService,
      styleModel
    }), createReducedLine({
      context,
      discreteModel,
      continuousModel,
      layoutService,
      extremumModel,
      dockService,
      styleModel,
      tickModel,
      colorService,
      largeDataService,
      chartModel
    }), createScrollbar({
      context,
      viewState,
      viewCache,
      discreteModel,
      continuousModel,
      layoutService,
      dockService,
      themeService
    }), ...tooltipService.getComponents(), ...trendLines({
      majorScale: KEYS.SCALE.MAIN.MAJOR,
      minorScale: KEYS.SCALE.MAIN.MINOR,
      tooltipOverlay: KEYS.COMPONENT.TREND_LINES_TOOLTIP_OVERLAY
    }, {
      layoutService,
      trendLineModel,
      dockService,
      animationsEnabled: chartModel.query.animationsEnabled
    }), trendLinesTooltip({
      tooltip: KEYS.COMPONENT.TREND_LINES_TOOLTIP,
      formatter: KEYS.FORMATTER.MINOR,
      majorScale: KEYS.SCALE.MAIN.MAJOR
    }, {
      trendLineModel,
      translator: resources.translator
    }, context), disclaimer, ...legend.components, ...selectables.components];
    const filteredComponents = components.filter(Boolean);
    setDisplayOrder(filteredComponents);
    return filteredComponents;
  }

  function createFormatters({
    scales,
    fieldModel
  }) {
    const formatters = {
      [KEYS.FORMATTER.MINOR]: {
        data: {
          fields: fieldModel.main.minors
        }
      }
    };
    const scale = scales[KEYS.SCALE.MAIN.COLOR];
    const field = scale && scale.data && scale.data.field;
    if (field) {
      formatters[KEYS.FORMATTER.COLOR] = {
        data: {
          field
        }
      };
    }
    return formatters;
  }

  const eventName$2 = 'continuousPan';
  const threshold = 10;
  function createContinuousAreaPan({
    chart,
    actions,
    viewState,
    viewCache
  }) {
    return {
      type: 'Pan',
      key: 'continuous:pan',
      options: {
        event: eventName$2,
        pointers: 1,
        threshold,
        enable(r, e) {
          if (this.started === eventName$2 || !e) {
            return true;
          }
          if (!actions.scroll.enabled()) {
            return false;
          }
          return chart.componentsFromPoint({
            x: e.center.x,
            y: e.center.y
          }).some(c => c.key === KEYS.COMPONENT.LINE);
        }
      },
      events: {
        [`${eventName$2}start`](e) {
          e.preventDefault();
          this.started = eventName$2;
          const {
            min,
            max
          } = viewState.get('zoom');
          this[eventName$2] = {
            min,
            max,
            size: chart.component(KEYS.COMPONENT.LINE).rect.computedInner.width,
            span: max - min
          };
        },
        [`${eventName$2}move`](e) {
          e.preventDefault();
          const {
            span,
            min,
            max,
            size
          } = this[eventName$2];
          const relativeDelta = -(e.deltaX / size);
          viewState.set('zoom', {
            min: Math.min(min + relativeDelta * span, viewCache.get('continuousMax') - span),
            max: Math.max(max + relativeDelta * span, viewCache.get('continuousMin') + span)
          });
        },
        [`${eventName$2}end`](e) {
          e.preventDefault();
          this.started = false;
        },
        [`${eventName$2}cancel`](e) {
          e.preventDefault();
          this.started = false;
        }
      }
    };
  }

  const eventName$1 = 'continuousPinchZoom';
  function createContinuousPinchZoom({
    chart,
    actions,
    viewState,
    viewCache,
    rtl
  }) {
    const state = {
      last: 0,
      diff: 0
    };
    const zoom = continuous$1.event.onZoom({
      viewCache,
      viewState,
      chart
    }, {
      threshold: 100,
      rtl,
      targetKey: KEYS.COMPONENT.LINE
    });
    return {
      type: 'Pinch',
      key: 'continuous:pinch-zoom',
      options: {
        event: eventName$1,
        pointers: 2,
        threshold: 0,
        enable(r, e) {
          if (!e) {
            return true;
          }
          if (!actions.scroll.enabled()) {
            return false;
          }
          return chart.componentsFromPoint({
            x: e.center.x,
            y: e.center.y
          }).some(c => c.key === KEYS.COMPONENT.LINE);
        }
      },
      events: {
        [`${eventName$1}start`](e) {
          state.last = e.scale;
          e.preventDefault();
        },
        [`${eventName$1}move`](e) {
          const diff = e.scale - state.last;
          if (Math.abs(diff) > 0.01) {
            zoom(e.center, diff > 0 ? 1 : -1);
          }
          state.last = e.scale;
          e.preventDefault();
        }
      }
    };
  }

  function createNative({
    chart,
    actions,
    viewState,
    viewCache,
    layoutService,
    rtl
  }) {
    const {
      isContinuous
    } = layoutService.meta;
    const zoom = isContinuous ? continuous$1.event.onZoom({
      chart,
      viewState,
      viewCache
    }, {
      rtl,
      threshold: 50,
      targetKey: KEYS.COMPONENT.LINE
    }) : undefined;
    return {
      type: 'native',
      events: {
        wheel(e) {
          const point = {
            x: e.clientX,
            y: e.clientY
          };
          const components = chart.componentsFromPoint(point);
          if (isContinuous && actions.scroll.enabled()) {
            const [target] = components.filter(c => c.key === KEYS.COMPONENT.LINE);
            if (target) {
              zoom(point, Math.sign(-e.deltaY));
              e.preventDefault();
            }
          }
          if (actions.interact.enabled()) {
            const [target] = components.filter(c => c.key === KEYS.COMPONENT.LEGEND_CATEGORICAL);
            if (target) {
              const delta = Math.abs(e.deltaX > Math.abs(e.deltaY)) ? e.deltaX : e.deltaY;
              target.emit(delta >= 0 ? 'next' : 'prev');
              e.preventDefault();
            }
          }
        }
      }
    };
  }

  function createInteractions({
    actions,
    chart,
    discreteModel,
    dockService,
    gestures = [],
    layoutService,
    resources,
    rtl,
    tooltipService,
    trendLineModel,
    viewCache,
    viewState
  }) {
    const {
      isDiscrete,
      isContinuous
    } = layoutService.meta;
    const tooltipInteractions = tooltipService.getInteractions();
    const scrollbar = createScrollbarInteractions({
      componentKey: 'scrollbar',
      chart,
      actions,
      viewState,
      viewCache,
      discrete: discreteModel,
      layoutService,
      dockService,
      rtl
    });
    const hammer = {
      type: 'hammer',
      enable: true,
      gestures: [...[...gestures].sort((a, b) => (b.prio || 0) - (a.prio || 0)), ...scrollbar.gestures, ...tooltipInteractions.gestures]
    };
    const natives = [createNative({
      chart,
      viewState,
      viewCache,
      actions,
      layoutService,
      trendLineModel,
      rtl,
      resources
    }), scrollbar.native, tooltipInteractions.native];
    if (isDiscrete) {
      hammer.gestures.push(...discreteModel.interactions.gestures);
      natives.push(discreteModel.interactions.native);
    }
    if (isContinuous) {
      hammer.gestures.push(createContinuousAreaPan({
        chart,
        actions,
        viewState,
        viewCache
      }), createContinuousPinchZoom({
        chart,
        actions,
        viewState,
        viewCache,
        rtl
      }));
    }
    return [hammer, ...natives];
  }

  function createLegend({
    context,
    chart,
    actions,
    viewState,
    layoutService,
    colorService,
    styleModel
  }) {
    const showPoint = layoutService.getLayoutValue('dataPoint.show', false);
    const config = {
      eventName: 'legend-c',
      key: KEYS.COMPONENT.LEGEND,
      viewState,
      chart,
      styleReference: 'object.lineChart',
      styleOverrides: {
        title: styleModel.query.legend.title.getStyle(),
        label: styleModel.query.legend.label.getStyle()
      },
      rtl: context.rtl
    };
    if (colorService.getMain().getSettings().type === 'categorical') {
      config.settings = {
        item: {
          shape: {
            stroke: {
              scale: KEYS.SCALE.MAIN.COLOR
            }
          }
        }
      };
      config.style = {
        item: {
          shape: {
            type: showPoint ? 'line-point' : 'line',
            size: 12,
            strokeWidth: 2
          }
        }
      };
    }
    const legend = colorService.getMain().getLegend(config, {
      actions,
      navigationDisabled: !actions.interact.enabled()
    });
    return {
      components: [...legend.components],
      gestures: [...legend.interactions]
    };
  }

  function createDiscreteMinorLogarithmicScale({
    context,
    fieldModel,
    dockService,
    tickModel
  }) {
    const {
      rtl
    } = context;
    const {
      minors
    } = fieldModel.main;
    const {
      orientation
    } = dockService.meta.major;
    return {
      type: 'logarithmic',
      data: {
        source: 'qHyperCube',
        fields: minors
      },
      invert: orientation === 'horizontal' || rtl,
      ticks: {
        values: tickModel.query.getValues
      },
      min: tickModel.query.getMin,
      max: tickModel.query.getMax
    };
  }

  function createDiscreteMinorLinearScale({
    context,
    fieldModel,
    dockService,
    tickModel
  }) {
    const {
      rtl
    } = context;
    const {
      minors
    } = fieldModel.main;
    const {
      orientation
    } = dockService.meta.major;
    return {
      data: {
        source: 'qHyperCube',
        fields: minors
      },
      invert: orientation === 'horizontal' || rtl,
      ticks: {
        values: tickModel.query.getValues
      },
      minorTicks: {
        count: 1
      },
      min: tickModel.query.getMin,
      max: tickModel.query.getMax
    };
  }

  function createMainMinorScale({
    context,
    layoutService,
    fieldModel,
    extremumModel,
    dockService,
    tickModel
  }) {
    const logarithmic = layoutService.getLayoutValue('measureAxis.logarithmic', false);
    const extrema = extremumModel.query.getExtrema();
    const create = logarithmic && !extrema.meta.includesZero ? createDiscreteMinorLogarithmicScale : createDiscreteMinorLinearScale;
    return create({
      context,
      fieldModel,
      extremumModel,
      dockService,
      tickModel
    });
  }

  function createMainMajorDiscreteScale({
    context,
    discreteModel,
    fieldModel,
    dockService
  }) {
    const {
      rtl
    } = context;
    const {
      outer,
      inner
    } = fieldModel.main;
    const {
      orientation
    } = dockService.meta.major;
    return {
      [KEYS.SCALE.MAIN.MAJOR]: {
        data: {
          extract: {
            field: outer,
            props: {
              selectionDimension: {
                field: outer
              },
              selectionInnerDimension: {
                field: inner
              }
            }
          }
        },
        invert: orientation === 'horizontal' && rtl,
        range: discreteModel.query.getScaleRange
      }
    };
  }

  function createMainMajorContinuousScale({
    context,
    viewState,
    fieldModel,
    dockService
  }) {
    const {
      rtl
    } = context;
    const {
      orientation
    } = dockService.meta.major;
    return {
      [KEYS.SCALE.MAIN.MAJOR]: {
        type: 'linear',
        invert: orientation === 'horizontal' && rtl,
        data: {
          extract: {
            field: fieldModel.main.outerNumeric
          }
        },
        ticks: {
          forceBounds: true,
          count: viewState.get('zoom').min === viewState.get('zoom').max ? 1 : undefined
        },
        minorTicks: {
          count: 1
        },
        min: () => viewState.get('zoom').min,
        max: () => viewState.get('zoom').max
      }
    };
  }

  function createCache({
    viewState,
    viewCache,
    layoutService
  }) {
    viewCache.set('qTimeAxisCache', []);
    return {
      get: (key, index = 0) => {
        const cache = viewCache.get('qTimeAxisCache');
        return cache[index] && cache[index][0] === key ? cache[index][1] : undefined;
      },
      set: (key, value, index = 0) => {
        const cache = viewCache.get('qTimeAxisCache');
        cache[index] = [key, value];
      },
      key: ({
        distance
      }) => {
        const {
          min,
          max
        } = viewState.get('zoom');
        const zoomLevel = (max - min) / (viewCache.get('continuousMax') - viewCache.get('continuousMin'));
        const qAxisDataStr = layoutService.getHyperCubeValue('qAxisData.qAxis', []).map(q => q.qName);
        return [distance, Number.parseFloat(zoomLevel).toFixed(12), ...qAxisDataStr].toString();
      }
    };
  }

  function createMainMajorTimeScales({
    context,
    picasso,
    viewState,
    viewCache,
    layoutService,
    fieldModel,
    themeService
  }) {
    const {
      localeInfo,
      rtl
    } = context;
    const {
      measureText
    } = picasso.renderer('svg')();
    const {
      outerNumeric
    } = fieldModel.main;
    const styles = themeService.getStyles();
    const base = {
      type: 'time',
      data: {
        field: outerNumeric
      },
      qAxis: () => layoutService.getHyperCubeValue('qAxisData.qAxis', []),
      field: outerNumeric,
      min: () => viewState.get('zoom').min,
      max: () => viewState.get('zoom').max,
      invert: !!rtl,
      formatter: {
        fn: picasso.formatter('q-time'),
        localeInfo,
        qNumFormat: layoutService.getHyperCubeValue('qDimensionInfo.0', {}).qNumFormat,
        measureText: text => measureText({
          text,
          fontFamily: styles.axis.label.name.fontFamily,
          fontSize: styles.axis.label.name.fontSize
        })
      },
      ticks: {
        generator: {
          type: 'd3',
          initialMin: viewState.get('zoom').min
        },
        anchor: 'start',
        clamp: true
      },
      cache: createCache({
        viewState,
        viewCache,
        layoutService
      })
    };
    return {
      [KEYS.SCALE.MAIN.MAJOR]: extend$7(true, {}, base, {
        ticks: {
          level: 'outer'
        }
      }),
      [KEYS.SCALE.MAIN.MAJOR_INNER]: extend$7(true, {}, base, {
        ticks: {
          level: 'inner'
        }
      })
    };
  }

  function createMainMajorScale({
    context,
    picasso,
    viewState,
    viewCache,
    discreteModel,
    layoutService,
    fieldModel,
    dockService,
    themeService
  }) {
    const {
      isDiscrete,
      isTime
    } = layoutService.meta;
    if (isDiscrete) {
      return createMainMajorDiscreteScale({
        context,
        discreteModel,
        fieldModel,
        dockService
      });
    }
    if (isTime) {
      return createMainMajorTimeScales({
        context,
        picasso,
        viewState,
        viewCache,
        layoutService,
        fieldModel,
        themeService
      });
    }
    return createMainMajorContinuousScale({
      context,
      viewState,
      fieldModel,
      dockService
    });
  }

  function createMainScales({
    context,
    picasso,
    viewState,
    viewCache,
    discreteModel,
    layoutService,
    fieldModel,
    extremumModel,
    dockService,
    themeService,
    tickModel
  }) {
    return {
      [KEYS.SCALE.MAIN.MINOR]: createMainMinorScale({
        context,
        layoutService,
        fieldModel,
        extremumModel,
        dockService,
        tickModel
      }),
      ...createMainMajorScale({
        context,
        picasso,
        viewState,
        viewCache,
        discreteModel,
        layoutService,
        fieldModel,
        dockService,
        themeService
      })
    };
  }

  function createReducedMajorDiscreteScale$1({
    layoutService,
    fieldModel,
    major
  }) {
    const {
      isTwoDimensional,
      isStacked
    } = layoutService.meta;
    const {
      outer,
      inner
    } = fieldModel.reduced;
    const {
      invert
    } = major;
    return {
      data: {
        extract: {
          source: KEYS.DATA.REDUCED,
          field: isTwoDimensional && isStacked ? inner : outer
        }
      },
      invert
    };
  }

  function createReducedMajorDiscreteScale({
    viewCache,
    major
  }) {
    return extend$7(true, {}, major, {
      min: () => viewCache.get('continuousMin'),
      max: () => viewCache.get('continuousMax')
    });
  }

  function createReducedMajorScale({
    viewCache,
    layoutService,
    fieldModel,
    major
  }) {
    return layoutService.meta.isDiscrete ? createReducedMajorDiscreteScale$1({
      layoutService,
      fieldModel,
      major
    }) : createReducedMajorDiscreteScale({
      viewCache,
      major
    });
  }

  function createReducedScales({
    viewCache,
    layoutService,
    fieldModel,
    minor,
    major
  }) {
    return {
      [KEYS.SCALE.REDUCED.MINOR]: {
        ...minor,
        data: undefined
      },
      [KEYS.SCALE.REDUCED.MAJOR]: createReducedMajorScale({
        viewCache,
        layoutService,
        fieldModel,
        major
      })
    };
  }

  function createColorScales({
    context,
    layoutService,
    colorService,
    legend
  }) {
    const sources = [colorService.getMain().getScales()];
    if (layoutService.meta.isContinuous) {
      sources.push(colorService.getReduced().getScales());
    }
    const scales = Object.assign({}, ...sources);
    const range = scales[`${KEYS.SCALE.MAIN.COLOR}Range`];
    const [legendComponent] = legend.components;
    const dock = legendComponent && legendComponent.layout.dock;
    if (range && (dock === 'right' || dock === 'left' || context.rtl)) {
      range.invert = true;
    }
    return scales;
  }

  function createScales({
    context,
    picasso,
    viewState,
    viewCache,
    discreteModel,
    layoutService,
    fieldModel,
    extremumModel,
    dockService,
    themeService,
    tickModel,
    colorService,
    legend
  }) {
    const mainScales = createMainScales({
      context,
      picasso,
      viewState,
      viewCache,
      discreteModel,
      layoutService,
      fieldModel,
      extremumModel,
      dockService,
      themeService,
      tickModel
    });
    return {
      ...mainScales,
      ...createReducedScales({
        viewCache,
        layoutService,
        fieldModel,
        minor: mainScales[KEYS.SCALE.MAIN.MINOR],
        major: mainScales[KEYS.SCALE.MAIN.MAJOR]
      }),
      ...createColorScales({
        context,
        layoutService,
        colorService,
        legend
      })
    };
  }

  const lasso$2 = ({
    key,
    components
  }) => ({
    key,
    type: 'brush-lasso',
    layout: {
      displayOrder: 99
    },
    settings: {
      brush: {
        components
      },
      lasso: {
        fill: 'rgba(0, 0, 0, 0)',
        stroke: 'black',
        strokeWidth: 2,
        opacity: 0.7,
        strokeDasharray: []
      },
      snapIndicator: {
        threshold: 75,
        strokeDasharray: '5, 5',
        stroke: 'black',
        strokeWidth: 2,
        opacity: 0.7
      },
      startPoint: {
        r: 10,
        stroke: 'rgba(77, 192, 78, 1)',
        strokeWidth: 0,
        opacity: 1
      }
    }
  });

  const eventName = 'lasso';
  const lasso$1 = ({
    key,
    componentTargetKey,
    requireFailure,
    recognizeWith
  }, opts) => ({
    key: `event:${key}`,
    type: 'Pan',
    requireFailure,
    recognizeWith,
    options: {
      event: eventName,
      enable(r, e) {
        if (this.started === eventName || !e) {
          return true;
        }
        if (!opts.actions.select.enabled() || !opts.actions.lasso.enabled() || !opts.actions.lasso.active()) {
          return false;
        }
        const components = this.chart.componentsFromPoint({
          x: e.center.x,
          y: e.center.y
        });
        return components.filter(c => c.key === componentTargetKey).length > 0;
      }
    },
    events: {
      lassostart(e) {
        e.preventDefault();
        if (this.started !== eventName) {
          opts.actions.select.emit('start', eventName);
          this.chart.component(key).emit('lassoStart', e);
          this.started = eventName;
        }
      },
      lassomove(e) {
        e.preventDefault();
        this.chart.component(key).emit('lassoMove', e);
        if (typeof opts.updateOnMove === 'function') {
          opts.updateOnMove(this.chart);
        }
      },
      lassoend(e) {
        e.preventDefault();
        this.started = false;
        this.chart.component(key).emit('lassoEnd', e);
        opts.actions.select.emit('end', eventName);
        if (typeof opts.updateOnEnd === 'function') {
          opts.updateOnEnd();
        }
      }
    }
  });

  function lasso (cfg, opts) {
    // if (!opts.actions.select.enabled()) {
    //   return {
    //     interactions: [],
    //     components: [],
    //   };
    // }

    if (!cfg.componentTargetKey) {
      throw new Error("Missing 'componentTargetKey' property");
    }
    const config = {
      key: 'lasso',
      ...cfg
    };
    const c = lasso$2(config);
    const e = lasso$1(config, opts);
    return {
      interactions: [e],
      components: [c]
    };
  }

  function eventToLocalPoint(event, chart) {
    const bounds = chart.element.getBoundingClientRect();
    let x;
    let y;
    if (event.center) {
      ({
        x
      } = event.center);
      ({
        y
      } = event.center);
    } else {
      x = event.clientX;
      y = event.clientY;
    }
    return {
      x: x - bounds.left,
      y: y - bounds.top
    };
  }
  const updateLazySelectionOnEnd$1 = ({
    largeDataService,
    chart
  }) => {
    const meta = (largeDataService === null || largeDataService === void 0 ? void 0 : largeDataService.meta) || {};
    if (meta.isLargeNumPoints) {
      // eslint-disable-next-line no-underscore-dangle
      chart.brush('lazySelection')._state(chart.brush('selection')._state());
    }
  };
  const tap$2 = ({
    targets,
    requireFailure,
    recognizeWith,
    components,
    eventName = 'tap'
  }, opts) => {
    let targetComponents;
    const customTooltipUtils = opts.customTooltipModel ? opts.customTooltipModel.utils : undefined;
    const debouncedDisplayCustomTooltip = customTooltipUtils ? opts.debouncer(customTooltipUtils.displayTooltip, customTooltipUtils.DEBOUNCE_THRESHOLD) : undefined;
    return {
      key: 'event:tap',
      type: 'Tap',
      requireFailure,
      recognizeWith,
      options: {
        event: eventName,
        interval: 10,
        pointers: 1,
        enable(r, e) {
          if (!e) {
            return true;
          }
          if (!opts.actions.select.enabled() && !opts.actions.tooltip.enabled()) {
            return false;
          }
          targetComponents = this.chart.componentsFromPoint({
            x: e.center.x,
            y: e.center.y
          }).filter(c => targets.indexOf(c.key) !== -1);
          return targetComponents.length > 0;
        }
      },
      events: {
        [eventName](e) {
          e.preventDefault();
          const localPoint = eventToLocalPoint(e, this.chart);
          const hitRadius = opts.hitRadius ? opts.hitRadius(targetComponents) : 0;
          const shape = hitRadius > 0 ? {
            cx: localPoint.x,
            cy: localPoint.y,
            r: hitRadius
          } : localPoint;
          const shapes = opts.shapesAt ? opts.shapesAt(shape) : this.chart.shapesAt(shape, {
            components: targets.map(c => ({
              key: c,
              propagation: 'stop'
            })),
            propagation: 'stop'
          });
          const tooltip = this.chart.component('tooltip');
          const doTooltip = e.pointerType !== 'mouse' && tooltip && tooltip.show;
          const doSelect = !opts.isLocked(targetComponents) && !opts.tooltipOnly && opts.actions.select.enabled();
          if (doSelect) {
            const compsAtPoint = this.chart.componentsFromPoint({
              x: e.center.x,
              y: e.center.y
            });
            const isLegend = compsAtPoint.some(c => c.type === 'legend-cat');
            if (shapes.length || !isLegend) {
              this.chart.brushSelectionIncludeMax = false;
              opts.actions.select.brushSelectionIncludeMax = false; // eslint-disable-line no-param-reassign
              opts.actions.select.emit('start', eventName, compsAtPoint);
            }
            if (shapes.length && components) {
              this.chart.brushSelectionIncludeMax = false;
              opts.actions.select.brushSelectionIncludeMax = false; // eslint-disable-line no-param-reassign
              const comps = typeof components === 'function' ? components(e, shapes) : components;
              this.chart.brushFromShapes(shapes, {
                components: comps
              });
              opts.actions.select.emit('end', eventName);
              updateLazySelectionOnEnd$1({
                largeDataService: opts.largeDataService,
                chart: this.chart
              });
            }
          }
          if (tooltip && opts.actions.tooltip.enabled()) {
            if (shapes.length) {
              const {
                customTooltipModel
              } = opts;
              if (customTooltipModel !== null && customTooltipModel !== void 0 && customTooltipModel.useCustomTooltip && customTooltipUtils.checkIfPromisesExist({
                customTooltipModel
              })) {
                const nodes = customTooltipUtils.getNodes(e, this.chart);
                debouncedDisplayCustomTooltip(e, tooltip, {
                  nodes,
                  opts,
                  customTooltipModel
                });
              } else {
                tooltip.emit('show', e, {
                  nodes: shapes
                });
              }
            } else if (doTooltip) {
              tooltip.emit('hide');
            }
          }
        }
      }
    };
  };

  function tap$1 (cfg, opts) {
    // if (!opts.actions.select.enabled()) {
    //   return {
    //     interactions: [],
    //     components: [],
    //   };
    // }

    if (!cfg.targets) {
      throw new Error("Missing 'targets' property");
    }
    const e = tap$2(cfg, opts);
    return {
      interactions: [e],
      components: []
    };
  }

  function rangeBrush(config) {
    const {
      key,
      targets,
      fillTargets,
      targetSelector,
      targetFillSelector,
      dock,
      scale,
      bubblesPlacement = 'inside',
      observeBrush = false,
      multiple = false,
      toLabel,
      onEdited
    } = config;
    return {
      key,
      type: 'brush-range',
      layout: {
        dock: targets.map(t => `@${t}`).join(',')
      },
      on: onEdited ? {
        bubbleEnd() {
          onEdited();
        }
      } : {},
      settings: {
        brush: observeBrush ? {
          context: 'selection',
          observe: true
        } : 'selection',
        scale,
        multiple,
        direction: dock === 'left' || dock === 'right' ? 'vertical' : 'horizontal',
        bubbles: {
          align: dock === 'left' || dock === 'top' ? 'end' : 'start',
          placement: bubblesPlacement,
          label: toLabel
        },
        target: {
          components: fillTargets,
          selector: targetSelector,
          fillSelector: targetFillSelector,
          fill: 'rgba(82,204,82,0.2)'
        }
      }
    };
  }

  const tap = ({
    key,
    // targets,
    requireFailure,
    recognizeWith,
    // components,
    eventName = 'tap'
  }, opts) => ({
    prio: 1,
    key: `event:${key}-tap`,
    type: 'Tap',
    requireFailure,
    recognizeWith,
    options: {
      event: `${eventName}-${key}-tap`,
      interval: 10,
      pointers: 1,
      enable(r, e) {
        if (!e) {
          return false;
        }
        if (!opts.actions.select.enabled()) {
          return false;
        }
        if (e.target && e.target.nodeName === 'INPUT') {
          return true; // to block other tap handlers
        }

        if (e.target && e.target.hasAttribute('data-other-value')) {
          return (e.target.getAttribute('data-key') || '').split('-bubble')[0] === key;
        }
        return false;
      }
    },
    events: {
      [`${eventName}-${key}-tap`](e) {
        const k = (e.target.getAttribute('data-key') || '').split('-bubble')[0];
        if (k) {
          e.preventDefault();
          this.chart.component(key).emit('bubbleStart', e);
        }
      }
    }
  });

  function onBubble(e, key) {
    const {
      target
    } = e.srcEvent;
    if (target && (target.getAttribute('data-key') || '').indexOf(`${key}-`) === 0) {
      return true;
    }
    return false;
  }
  const range$1 = ({
    eventName,
    key,
    fillTargets = [],
    requireFailure,
    recognizeWith
  }, opts, emit) => ({
    key: `event:${key}`,
    type: 'Pan',
    requireFailure,
    recognizeWith,
    options: {
      event: eventName,
      enable(r, e) {
        if (this.started === eventName || !e) {
          return true;
        }
        if (!opts.actions.select.enabled()) {
          return false;
        }
        const components = this.chart.componentsFromPoint({
          x: e.center.x,
          y: e.center.y
        }).filter(c => fillTargets.indexOf(c.key) !== -1);
        const bubble = components.length === 0 ? onBubble(e, key) : false;
        if (bubble) {
          this.started = eventName;
          return true;
        }
        return components.length > 0;
      }
    },
    events: {
      [`${eventName}start`](e) {
        if (this.chart.brushSelectionIncludeMax === undefined) {
          this.chart.brushSelectionIncludeMax = true;
          opts.actions.select.brushSelectionIncludeMax = true; // eslint-disable-line no-param-reassign
        }

        e.preventDefault();
        opts.actions.select.emit('start', eventName);
        this.chart.component(key).emit(`${emit}Start`, e);
        this.started = eventName;
      },
      [`${eventName}move`](e) {
        e.preventDefault();
        this.chart.component(key).emit(`${emit}Move`, e);
        if (typeof opts.updateOnMove === 'function') {
          opts.updateOnMove(this.chart);
        }
      },
      [`${eventName}end`](e) {
        if (this.chart.brushSelectionIncludeMax === undefined) {
          this.chart.brushSelectionIncludeMax = true;
          opts.actions.select.brushSelectionIncludeMax = true; // eslint-disable-line no-param-reassign
        }

        e.preventDefault();
        this.chart.component(key).emit(`${emit}End`, e);
        opts.actions.select.emit('end', eventName);
        this.started = false;
        if (typeof opts.updateOnEnd === 'function') {
          opts.updateOnEnd();
        }
      }
    }
  });

  function range (config, opts) {
    const c = rangeBrush(config);
    const e = range$1(config, opts, 'range');
    const t = config.onEdited ? tap(config, opts) : null;
    return {
      interactions: [t, e].filter(Boolean),
      components: [c]
    };
  }

  function rangeDirBrush(config) {
    const {
      key,
      targets,
      components,
      fillTargets,
      dock
    } = config;
    return {
      key,
      type: 'brush-area-dir',
      layout: {
        dock: targets.map(t => `@${t}`).join(',')
      },
      settings: {
        multiple: true,
        brush: {
          components
        },
        direction: dock === 'left' || dock === 'right' ? 'vertical' : 'horizontal',
        bubbles: {
          align: dock === 'left' || dock === 'top' ? 'end' : 'start',
          placement: 'inside'
        },
        target: {
          components: fillTargets,
          fill: 'rgba(82,204,82,0.2)'
        }
      }
    };
  }

  function rangeDir (config, opts) {
    // if (!opts.actions.select.enabled()) {
    //   return {
    //     interactions: [],
    //     components: [],
    //   };
    // }

    const c = rangeDirBrush(config);
    const e = range$1(config, opts, 'area');
    return {
      interactions: [e],
      components: [c]
    };
  }

  function createIsLocked({
    chart,
    selectionService,
    layoutService,
    colorService
  }) {
    const {
      isOneDimensional
    } = layoutService.meta;
    return components => {
      const {
        key
      } = components[0];
      const isOuterLocked = selectionService.custom.getIsOuterDimensionLocked();
      if (key === KEYS.COMPONENT.LEGEND_CATEGORICAL) {
        return colorService.getMain().isSelectionLocked({
          isMeasureSelectionLocked: isOuterLocked
        });
      }
      if (isOneDimensional) {
        return isOuterLocked;
      }
      const isInnerLocked = selectionService.custom.getIsInnerDimensionLocked();
      if (isOuterLocked && isInnerLocked) {
        return true;
      }
      if (isOuterLocked) {
        if (key === KEYS.COMPONENT.MAJOR_AXIS) {
          return true;
        }
        if (key === KEYS.COMPONENT.POINT) {
          const {
            items
          } = chart.component(KEYS.COMPONENT.LINE).data;
          const {
            value: lineKey
          } = items[0].line;
          return items.every(i => i.line.value === lineKey);
        }
      }
      return false;
    };
  }

  function createTap({
    chart,
    actions,
    selectionService,
    layoutService,
    colorService,
    largeDataService,
    resources
  }) {
    const {
      isTwoDimensional
    } = layoutService.meta;
    const isSingleSelection = selectionService.getIsSingleSelect();
    const targets = [KEYS.COMPONENT.MAJOR_AXIS, KEYS.COMPONENT.POINT, KEYS.COMPONENT.MAJOR_AXIS_OVERLAY_CONTINUOUS, KEYS.COMPONENT.MAJOR_AXIS_OVERLAY_TIME_INNER, KEYS.COMPONENT.MAJOR_AXIS_OVERLAY_TIME_OUTER, KEYS.COMPONENT.LEGEND_CATEGORICAL, KEYS.COMPONENT.FORECAST_POINT];
    return tap$1({
      targets,
      components(e, shapes) {
        var _shape$attrs;
        const [shape] = shapes;
        const {
          key
        } = shape;
        const component = {
          key,
          action: e.srcEvent.ctrlKey || isSingleSelection ? 'set' : 'toggle',
          contexts: ['selection']
        };
        const isLegend = key === KEYS.COMPONENT.LEGEND_CATEGORICAL;
        if (isLegend) {
          return [{
            key,
            action: e.srcEvent.ctrlKey ? 'set' : 'toggle',
            contexts: ['selection']
          }];
        }
        const isPoint = key === KEYS.COMPONENT.POINT;
        if (isPoint && (shape.data.null.value || shape.data.interpolated.value || ((_shape$attrs = shape.attrs) === null || _shape$attrs === void 0 ? void 0 : _shape$attrs.opacity) === 0.01)) {
          return false;
        }
        const isInnerLocked = selectionService.custom.getIsInnerDimensionLocked();
        const isContinuousOverlay = [KEYS.COMPONENT.MAJOR_AXIS_OVERLAY_CONTINUOUS, KEYS.COMPONENT.MAJOR_AXIS_OVERLAY_TIME_INNER, KEYS.COMPONENT.MAJOR_AXIS_OVERLAY_TIME_OUTER].indexOf(key) !== -1;
        if (!isContinuousOverlay) {
          component.data = [key === KEYS.COMPONENT.POINT && isInnerLocked ? 'selectionOuterDimension' : 'selectionDimension'];
        }
        if (!isTwoDimensional || !isPoint) {
          return [component];
        }
        const {
          items
        } = chart.component(key).data;
        const {
          value: lineKey
        } = items[0].line;
        const hasOneLine = items.every(i => i.line.value === lineKey);
        if (hasOneLine) {
          component.data = ['selectionOuterDimension'];
        }
        return [component];
      }
    }, {
      debouncer: St,
      flags: resources.flags,
      actions,
      isLocked: createIsLocked({
        chart,
        selectionService,
        layoutService,
        colorService
      }),
      hitRadius: components => components.some(component => component.key === KEYS.COMPONENT.POINT) ? 3 : 0,
      shapesAt: shape => {
        const shapes = chart.shapesAt(shape, {
          components: targets.map(c => ({
            key: c
          }))
        }).filter(s => !s.data.null || !s.data.null.value || !s.data.interpolated || !s.data.interpolated.value);
        return shapes.length ? [shapes[0]] : [];
      },
      largeDataService
    });
  }

  const updateLazySelectionOnEnd = ({
    largeDataService,
    chart
  }) => {
    const meta = (largeDataService === null || largeDataService === void 0 ? void 0 : largeDataService.meta) || {};
    if (meta.isLargeNumPoints) {
      // eslint-disable-next-line no-underscore-dangle
      chart.brush('lazySelection')._state(chart.brush('selection')._state());
    }
  };
  const updateLazySelectionOnMove = ({
    largeDataService,
    chart
  }) => {
    const meta = (largeDataService === null || largeDataService === void 0 ? void 0 : largeDataService.meta) || {};
    if (meta.isLargeNumPoints && !largeDataService.isLargeNumVisiblePoints()) {
      // eslint-disable-next-line no-underscore-dangle
      chart.brush('lazySelection')._state(chart.brush('selection')._state());
    }
  };

  /* eslint-disable no-underscore-dangle */
  function createContinuousRange({
    chart,
    actions,
    selectionService,
    layoutService,
    largeDataService,
    dockService
  }) {
    const {
      isContinuous,
      isTime,
      isTwoDimensional
    } = layoutService.meta;
    if (!isContinuous || isTwoDimensional && selectionService.custom.getIsOuterDimensionLocked()) {
      return false;
    }
    const updateOnMove = () => {
      updateLazySelectionOnMove({
        largeDataService,
        chart
      });
    };
    const updateOnEnd = () => {
      updateLazySelectionOnEnd({
        largeDataService,
        chart
      });
    };
    return range({
      eventName: 'continuousRange',
      key: KEYS.RANGE.CONTINUOUS,
      targets: isTime ? [KEYS.COMPONENT.MAJOR_AXIS_TIME_INNER, KEYS.COMPONENT.MAJOR_AXIS_TIME_OUTER, KEYS.COMPONENT.POINT] : [KEYS.COMPONENT.MAJOR_AXIS_CONTINUOUS, KEYS.COMPONENT.POINT],
      fillTargets: isTime ? [KEYS.COMPONENT.MAJOR_AXIS_TIME_INNER, KEYS.COMPONENT.MAJOR_AXIS_TIME_OUTER] : [KEYS.COMPONENT.MAJOR_AXIS_CONTINUOUS],
      dock: dockService.meta.major.dock,
      scale: isTime ? KEYS.SCALE.MAIN.MAJOR_INNER : KEYS.SCALE.MAIN.MAJOR,
      observeBrush: true,
      multiple: true,
      toLabel({
        datum,
        data,
        scale
      }) {
        const formatter = isTime ? scale.formatter() : chart.formatter(KEYS.FORMATTER.MINOR);
        const includeMax = selectionService.custom.getShouldIncludeMax({
          datum
        });
        return `${datum === Math.max(...data) && !includeMax ? '<' : ''}${formatter(datum)}`;
      }
    }, {
      actions,
      updateOnMove,
      updateOnEnd
    });
  }

  function createDiscreteRange({
    actions,
    selectionService,
    layoutService,
    dockService
  }) {
    const {
      isDiscrete,
      isTwoDimensional
    } = layoutService.meta;
    if (!isDiscrete || selectionService.custom.getIsOuterDimensionLocked()) {
      return false;
    }
    return rangeDir({
      eventName: 'discreteRange',
      key: 'discrete-range-brush',
      components: [{
        key: KEYS.COMPONENT.GHOST_POINT,
        contexts: ['selection'],
        action: 'set',
        data: [isTwoDimensional ? 'selectionOuterDimension' : 'selectionDimension']
      }],
      targets: [KEYS.COMPONENT.MAJOR_AXIS, KEYS.COMPONENT.POINT],
      fillTargets: [KEYS.COMPONENT.MAJOR_AXIS],
      dock: dockService.meta.major.dock
    }, {
      actions
    });
  }

  function createLegendRange({
    actions,
    selectionService,
    layoutService,
    scales,
    legend
  }) {
    const [legendComponent] = legend.components;
    if (!legendComponent) {
      return false;
    }
    const {
      isTwoDimensional
    } = layoutService.meta;
    const {
      type,
      key
    } = legendComponent;
    const {
      colorRange
    } = scales;
    if (isTwoDimensional || selectionService.custom.getIsOuterDimensionLocked() || type !== 'legend-seq' || !colorRange || colorRange.min >= colorRange.max) {
      return false;
    }
    return range({
      eventName: 'legendRange',
      key: 'legend-range-brush',
      targets: [key],
      fillTargets: [key],
      targetSelector: '[id="legend-seq-target"]',
      targetFillSelector: '[id="legend-seq-ticks"]',
      dock: legendComponent.layout.dock,
      scale: 'colorRange',
      bubblesPlacement: 'outside',
      onEdited: () => {
        actions.select.emit('end', 'legendRange');
      }
    }, {
      actions
    });
  }

  function createMinorRange({
    actions,
    selectionService,
    layoutService,
    dockService,
    isUnsupportedFeature
  }) {
    const {
      isOneDimensional,
      isStacked
    } = layoutService.meta;
    if (!isOneDimensional || isStacked || selectionService.custom.getIsOuterDimensionLocked() || isUnsupportedFeature !== null && isUnsupportedFeature !== void 0 && isUnsupportedFeature('rangeSelections')) {
      return false;
    }
    return range({
      eventName: 'minorRange',
      key: 'minor-range-brush',
      targets: [KEYS.COMPONENT.MINOR_AXIS, KEYS.COMPONENT.POINT],
      fillTargets: [KEYS.COMPONENT.MINOR_AXIS],
      dock: dockService.meta.minor.dock,
      scale: KEYS.SCALE.MAIN.MINOR,
      onEdited() {
        actions.select.emit('end', 'minorRange');
      }
    }, {
      actions
    });
  }

  const EMPTY$1 = {
    components: [],
    interactions: []
  };
  function createRange({
    chart,
    actions,
    selectionService,
    layoutService,
    largeDataService,
    dockService,
    scales,
    legend,
    isUnsupportedFeature
  }) {
    const minorRange = createMinorRange({
      actions,
      selectionService,
      layoutService,
      dockService,
      isUnsupportedFeature
    }) || EMPTY$1;
    const discreteRange = createDiscreteRange({
      actions,
      selectionService,
      layoutService,
      dockService
    }) || EMPTY$1;
    const continuousRange = createContinuousRange({
      chart,
      actions,
      selectionService,
      layoutService,
      largeDataService,
      dockService
    }) || EMPTY$1;
    const legendRange = createLegendRange({
      actions,
      selectionService,
      layoutService,
      scales,
      legend
    }) || EMPTY$1;
    return {
      components: [...minorRange.components, ...discreteRange.components, ...continuousRange.components, ...legendRange.components],
      interactions: [...minorRange.interactions, ...discreteRange.interactions, ...continuousRange.interactions, ...legendRange.interactions]
    };
  }

  function getIsSingle({
    layoutService
  }) {
    const {
      isDiscrete
    } = layoutService.meta;
    const [page] = layoutService.getDataPages();
    if (!page) {
      return false;
    }
    return isDiscrete ? page.qData && page.qData.length && page.qData[0].qSubNodes.every(n => n.qSubNodes.length === 1) : page.qMatrix && page.qMatrix.every(n => n[1].qElemNumber === page.qMatrix[0][1].qElemNumber);
  }

  const EMPTY = {
    components: [],
    interactions: []
  };
  function createLasso({
    actions,
    selectionService,
    layoutService,
    largeDataService,
    chart
  }) {
    const {
      isOneDimensional
    } = layoutService.meta;
    const isOuterDimensionLocked = selectionService.custom.getIsOuterDimensionLocked();
    if (isOneDimensional && isOuterDimensionLocked) {
      return EMPTY;
    }
    const isInnerDimensionLocked = selectionService.custom.getIsInnerDimensionLocked();
    if (!isOneDimensional && isOuterDimensionLocked && isInnerDimensionLocked) {
      return EMPTY;
    }
    const isTwoDimensionalSingle = !isOneDimensional && getIsSingle({
      layoutService
    });
    if (isTwoDimensionalSingle && isOuterDimensionLocked) {
      return EMPTY;
    }
    const updateOnMove = () => {
      updateLazySelectionOnMove({
        largeDataService,
        chart
      });
    };
    const updateOnEnd = () => {
      updateLazySelectionOnEnd({
        largeDataService,
        chart
      });
    };
    const component = {
      key: KEYS.COMPONENT.POINT,
      action: 'add',
      contexts: ['selection']
    };
    if (isOneDimensional) {
      component.data = ['selectionDimension'];
    } else {
      component.data = [isInnerDimensionLocked || isTwoDimensionalSingle ? 'selectionOuterDimension' : 'selectionDimension'];
    }
    return lasso({
      key: 'lasso',
      componentTargetKey: KEYS.COMPONENT.POINT,
      components: [component]
    }, {
      actions,
      updateOnMove,
      updateOnEnd
    });
  }

  function createSelectables({
    chart,
    actions,
    selectionService,
    layoutService,
    chartModel,
    dockService,
    colorService,
    largeDataService,
    scales,
    legend,
    resources,
    isUnsupportedFeature
  }) {
    const tap = createTap({
      chart,
      actions,
      selectionService,
      layoutService,
      chartModel,
      colorService,
      largeDataService,
      resources
    });
    const isSingleSelection = selectionService.getIsSingleSelect();
    if (isSingleSelection) {
      return {
        components: [...tap.components],
        gestures: [...tap.interactions]
      };
    }
    const lasso = createLasso({
      actions,
      selectionService,
      layoutService,
      largeDataService,
      chart
    });
    const range = createRange({
      chart,
      actions,
      selectionService,
      layoutService,
      largeDataService,
      dockService,
      scales,
      legend,
      isUnsupportedFeature
    });
    return {
      components: [...tap.components, ...range.components, ...lasso.components],
      gestures: [...tap.interactions, ...range.interactions, ...lasso.interactions]
    };
  }

  function createPicassoDefinition({
    app,
    core,
    localeInfo,
    logicalSize,
    model,
    properties,
    services,
    theme,
    translator
  }) {
    const {
      actions,
      chart,
      deviceType,
      flags,
      isUnsupportedFeature,
      picasso,
      viewCache,
      viewState
    } = core;
    const {
      chartModel,
      colorService,
      continuousModel,
      disclaimerModel,
      discreteModel,
      dockService,
      extremumModel,
      fieldModel,
      layoutService,
      pluginService,
      reducedModel,
      refLineModel,
      selectionService,
      styleModel,
      themeService,
      tickModel,
      tooltipService,
      trendLineModel,
      largeDataService
    } = services;
    const {
      rtl
    } = dockService.config;
    const context = {
      deviceType,
      localeInfo,
      logicalSize,
      rtl,
      theme
    };
    const resources = {
      app,
      flags,
      model,
      translator
    };
    const legend = createLegend({
      actions,
      chart,
      colorService,
      context,
      layoutService,
      viewState,
      styleModel
    });
    const scales = createScales({
      colorService,
      context,
      discreteModel,
      dockService,
      extremumModel,
      fieldModel,
      layoutService,
      legend,
      picasso,
      themeService,
      tickModel,
      viewCache,
      viewState
    });
    const selectables = createSelectables({
      actions,
      chart,
      chartModel,
      colorService,
      dockService,
      isUnsupportedFeature,
      layoutService,
      legend,
      resources,
      scales,
      selectionService,
      largeDataService
    });
    const components = createComponents({
      actions,
      chart,
      chartModel,
      colorService,
      context,
      continuousModel,
      disclaimerModel,
      discreteModel,
      dockService,
      extremumModel,
      fieldModel,
      layoutService,
      legend,
      properties,
      refLineModel,
      resources,
      selectables,
      selectionService,
      styleModel,
      themeService,
      tickModel,
      tooltipService,
      trendLineModel,
      viewCache,
      viewState,
      largeDataService
    });
    return {
      collections: createCollections({
        chartModel,
        colorService,
        extremumModel,
        fieldModel,
        layoutService,
        reducedModel,
        resources,
        tickModel
      }),
      scales,
      components: pluginService.extendComponents(components),
      interactions: createInteractions({
        actions,
        chart,
        discreteModel,
        dockService,
        gestures: [...legend.gestures, ...selectables.gestures],
        layoutService,
        resources,
        rtl,
        tooltipService,
        trendLineModel,
        viewCache,
        viewState
      }),
      palettes: colorService.getMain().getPalettes(),
      formatters: createFormatters({
        fieldModel,
        scales
      }),
      strategy: dockLayout$1(layoutService.getLayout(), {
        logicalSize: context.logicalSize,
        minCenterRatio: 0
      })
    };
  }

  function useThrottle({
    value,
    wait = 100
  }) {
    const ref = stardust.useState({});
    const [throttled, setThrottled] = stardust.useState(value);
    stardust.useEffect(() => {
      if (Date.now() >= ref.lastExecuted + wait) {
        ref.lastExecuted = Date.now();
        setThrottled(value);
        return () => {};
      }
      const timerId = setTimeout(() => {
        ref.lastExecuted = Date.now();
        setThrottled(value);
      }, wait);
      return () => clearTimeout(timerId);
    }, [value]);
    return throttled;
  }

  function useRender({
    core,
    services,
    bootstrapped
  }) {
    const app = stardust.useApp();
    const appLayout = stardust.useAppLayout();
    const model = stardust.useModel();
    const options = stardust.useOptions();
    const rect = stardust.useRect();
    const theme = stardust.useTheme();
    const throttledRect = useThrottle({
      value: rect
    });
    const translator = stardust.useTranslator();
    const render = async () => {
      const {
        chartModel,
        colorService,
        discreteModel,
        layoutService,
        tickModel
      } = services;
      const {
        isDiscrete
      } = layoutService.meta;
      const {
        viewCache
      } = core;
      if (!colorService.isInitialized()) {
        return;
      }
      const settings = createPicassoDefinition({
        app,
        core,
        localeInfo: appLayout.qLocaleInfo,
        logicalSize: getLogicalSize({
          layout: layoutService.getLayout(),
          options
        }),
        model,
        properties: bootstrapped.properties,
        services,
        theme,
        translator
      });
      chartModel.command.updateDataless({
        settings
      });
      await Promise.all(isDiscrete ? [discreteModel.command.initialize()] : []);
      await chartModel.command.update();
      animations.cacheProperties({
        viewCache,
        layout: layoutService.getLayout()
      });
      viewCache.set('hasHiddenMinOobs', settings.components.filter(c => c.key === KEYS.COMPONENT.OUT_OF_MIN_BOUNDS && !c.show()).length > 0);
      tickModel.command.lock();
    };
    const [, renderError] = stardust.usePromise(async () => {
      if (!bootstrapped) {
        return;
      }
      await render();
    }, [bootstrapped]);
    if (renderError) {
      throw renderError;
    }
    const [, resizeError] = stardust.usePromise(async () => {
      if (!bootstrapped) {
        return;
      }
      const {
        dockService,
        tickModel,
        chartModel
      } = services;
      dockService.update({
        width: throttledRect.width,
        height: throttledRect.height
      });
      chartModel.command.setState('isSizeChanging', true);
      tickModel.command.unlock();
      await render();
    }, [throttledRect]);
    if (resizeError) {
      throw resizeError;
    }
  }

  function createSupernova(env) {
    autoRegister(env.translator);
    return {
      ext: createExt(env),
      qae: qae(env),
      component() {
        /**
         * Create things that should only be created once during the chart lifetime,
         * e.g. actions, chart instance, picasso instance, view-cache and view-state.
         */
        const core = useCore({
          env
        });

        /**
         * Create services.
         *
         * Depends on core.
         *
         * Services are recreated when layout, RTL, theme or translation changes.
         */
        const services = useServices({
          core
        });

        /**
         * Bootstraps the chart by hooking up events and running the asynchronous calls
         * and initializations that are needed.
         *
         * Depends on the services.
         */
        const bootstrapped = useBootstrap({
          core,
          services
        });

        /**
         * Renders the chart by creating the picasso definition and calling update on the chart instance.
         *
         * Depends on bootstrap.
         */
        useRender({
          core,
          services,
          bootstrapped
        });
      }
    };
  }

  return createSupernova;

}));
//# sourceMappingURL=sn-line-chart.js.map
